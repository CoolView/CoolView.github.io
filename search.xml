<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MyBatis 10-缓存配置</title>
      <link href="/2019/12/01/MyBatis%2010-%E7%BC%93%E5%AD%98%E9%85%8D%E7%BD%AE/"/>
      <url>/2019/12/01/MyBatis%2010-%E7%BC%93%E5%AD%98%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="http://www.broadview.com.cn/book/3643" target="_blank" rel="noopener">http://www.broadview.com.cn/book/3643</a><br><a href="https://github.com/mybatis-book/book" target="_blank" rel="noopener">https://github.com/mybatis-book/book</a></p></blockquote><p>一般提到 MyBatis 缓存时都是指二级缓存。一级缓存默认会启用，且不能控制。</p><h1 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h1><pre><code class="java">@Testpublic void testL1Cache(){    // 获取 sqlSession    SqlSession sqlSession = getSqlSession();    SysUser user1 = null;    try {        // 获取 UserMapper 接口        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);        // 调用 selectById 方法，查询 id = 1 的用户        user1 = userMapper.selectById(1l);        // 对当前获取的对象重新赋值        user1.setUserName(&quot;New Name&quot;);        // 再次查询获取 id 相同的用户        SysUser user2 = userMapper.selectById(1l);        // 虽然我们没有更新数据库，但是这个用户名和我们 user1 重新赋值的名字相同了        Assert.assertEquals(&quot;New Name&quot;, user2.getUserName());        // 不仅如何，user2 和 user1 完全就是同一个实例        Assert.assertEquals(user1, user2);    } finally {        // 关闭当前的 sqlSession        sqlSession.close();    }    System.out.println(&quot;开启新的 sqlSession&quot;);    // 开始另一个新的 session    sqlSession = getSqlSession();    try {        // 获取 UserMapper 接口        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);        // 调用 selectById 方法，查询 id = 1 的用户        SysUser user2 = userMapper.selectById(1l);        // 第二个 session 获取的用户名仍然是 admin        Assert.assertNotEquals(&quot;New Name&quot;, user2.getUserName());        // 这里的 user2 和 前一个 session 查询的结果是两个不同的实例        Assert.assertNotEquals(user1, user2);        // 执行删除操作        userMapper.deleteById(2L);        // 获取 user3        SysUser user3 = userMapper.selectById(1l);        // 这里的 user2 和 user3 是两个不同的实例        Assert.assertNotEquals(user2, user3);    } finally {        // 关闭 sqlSession        sqlSession.close();    }}</code></pre><p>MyBatis 的一级缓存存在于 SqlSession 的生命周期中，在同一个 SqlSession 中查询时，MyBatis会把执行的方法和参数通过算法生成缓存的键值，将键值和查询结果存入一个 Map 对象中。如果同一个 SqlSession 中执行的方法和参数完全一致，那么通过算法会生成相同的键值，当 Map 缓存对象中已经存在该键值时，则会返回缓存中的对象。</p><p>如果不想让 selectById 方法使用一级缓存，可以加上 <code>flushCach=&quot;true&quot;</code>，会在查询数据前清空当前的一级缓存。</p><pre><code class="xml">&lt;!-- useCache=&quot;false&quot; 可以禁止使用缓存 --&gt;&lt;select id=&quot;selectById&quot; flushCache=&quot;true&quot; resultMap=&quot;userMap&quot;&gt;    select * from sys_user where id=#{id}&lt;/select&gt;</code></pre><p>另外所有的 insert，update、delete 操作都会清空一级缓存。</p><h1 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h1><p>一级缓存只存在于 SqlSession 的生命周期中，而二级缓存可以理解为存在于 SqlSessionFactory 的生命周期中。</p><h2 id="配置二级缓存"><a href="#配置二级缓存" class="headerlink" title="配置二级缓存"></a>配置二级缓存</h2><p>mybatis-config.xml 文件中可以配置二级缓存的全局开关，默认是 true</p><pre><code class="xml">&lt;settings&gt;    &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;&gt;&lt;/settings&gt;</code></pre><p>二级缓存是和命名空间绑定的，所以需要配置在 Mapper.xml 映射文件中（命名空间是 xml 根节点 mapper 的 namespace 属性），或者配置在 Mapper.java 接口中（命令空间就是接口的全限定名称）。</p><h3 id="Mapper-xml-中配置二级缓存"><a href="#Mapper-xml-中配置二级缓存" class="headerlink" title="Mapper.xml 中配置二级缓存"></a>Mapper.xml 中配置二级缓存</h3><p>只需要在你的 SQL 映射文件中添加一行 <code>&lt;cache/&gt;</code></p><p>默认效果：</p><ul><li>映射语句文件中的所有 select 语句的结果将会被缓存。</li><li>映射语句文件中的所有 insert、update 和 delete 语句会刷新缓存。</li><li>缓存会使用最近最少使用算法（LRU, Least Recently Used）算法来清除不需要的缓存。</li><li>缓存不会定时进行刷新（也就是说，没有刷新间隔）。</li><li>缓存会保存列表或对象（无论查询方法返回哪种）的 1024 个引用。</li><li>缓存会被视为读/写缓存，这意味着获取到的对象并不是共享的，可以安全地被调用者修改，而不干扰其他调用者或线程所做的潜在修改。</li></ul><p>这些属性可以通过 cache 元素的属性来修改。比如：</p><pre><code class="xml">&lt;cache    eviction=&quot;FIFO&quot;    flushInterval=&quot;60000&quot;    size=&quot;512&quot;    readOnly=&quot;true&quot;/&gt;</code></pre><p>这个更高级的配置创建了一个 FIFO 缓存，每隔 60 秒刷新，最多可以存储结果对象或列表的 512 个引用，而且返回的对象被认为是只读的，因此对它们进行修改可能会在不同线程中的调用者产生冲突。</p><ol><li><code>eviction</code>（回收策略）：<ul><li>LRU – 最近最少使用：移除最长时间不被使用的对象。默认策略</li><li>FIFO – 先进先出：按对象进入缓存的顺序来移除它们。</li><li>SOFT – 软引用：基于垃圾回收器状态和软引用规则移除对象。</li><li>WEAK – 弱引用：更积极地基于垃圾收集器状态和弱引用规则移除对象。</li></ul></li><li><code>flushInterval</code>（刷新间隔）属性可以被设置为任意的正整数，设置的值应该是一个以毫秒为单位的合理时间量。 默认情况是不设置，也就是没有刷新间隔，缓存仅仅会在调用语句时刷新。</li><li><code>size</code>（引用数目）属性可以被设置为任意正整数，要注意欲缓存对象的大小和运行环境中可用的内存资源。默认值是 1024。</li><li><code>readOnly</code>（只读）属性可以被设置为 true 或 false。只读的缓存会给所有调用者返回缓存对象的相同实例。 因此这些对象不能被修改。这就提供了可观的性能提升。而可读写的缓存会（通过序列化）返回缓存对象的拷贝。 速度上会慢一些，但是更安全，因此默认值是 false。</li></ol><h3 id="Mapper-接口中配置二级缓存"><a href="#Mapper-接口中配置二级缓存" class="headerlink" title="Mapper 接口中配置二级缓存"></a>Mapper 接口中配置二级缓存</h3><pre><code class="java">@CacheNamespace(    eviction=FifoCache.class,    flushInterval=60000,    size=512,    readWrite=true  // true 为读写（默认），false 为只读)public interface RoleMapper {}</code></pre><p>当同时使用注解方式和 xml 映射文件时，如果同时配置了二级缓存，会抛出异常 Caches collection already contains value for tk.mybatis.simple.mapper.RoleMapper</p><p>因为这时是相同的命名空间，这时应该使用<strong>参照缓存</strong></p><pre><code class="java">// 这样就会使用命名空间为 tk.mybatis.simple.mapper.RoleMapper 的缓存配置，即 RoleMapper.xml 中配置的缓存@CacheNamespaceRef(RoleMapper.class)public interface RoleMapper {}</code></pre><p>也可以在 xml 中配置参照缓存</p><pre><code class="xml">&lt;cache-ref namespace=&quot;tk.mybatis.simple.mapper.RoleMapper&quot;/&gt;</code></pre><p>不会同时使用 Mapper 接口注解方式和 xml 映射文件，所以参照缓存不是为解决这个问题设计的，主要作用是解决脏读</p><h2 id="使用二级缓存"><a href="#使用二级缓存" class="headerlink" title="使用二级缓存"></a>使用二级缓存</h2><p>由于配置的是可读写的缓存，而 MyBatis 使用 SerializedCache 序列化缓存来实现可读写缓存类，并通过序列化和反序列化来保证通过缓存获取数据时，得到的是一个新的实例。如果配置为只读缓存，MyBatis 会使用 Map 来存储缓存值。</p><p>使用 SerializedCache 序列化缓存，要求所有被序列化的对象必须实现 Serializable 接口。</p><pre><code class="java">public class SysRole implements Serializable {    private static final long serialVersionUID = 6320941908222932112L;}</code></pre><p>测试</p><pre><code class="java">@Testpublic void testL2Cache(){    SqlSession sqlSession = getSqlSession();    SysRole role1 = null;    try {        // 获取 RoleMapper 接口        RoleMapper roleMapper = sqlSession.getMapper(RoleMapper.class);        // 调用 selectById 方法，查询 id = 1 的用户        role1 = roleMapper.selectById(1l);        // 对当前获取的对象重新赋值        role1.setRoleName(&quot;New Name&quot;);        // 再次查询获取 id 相同的用户        SysRole role2 = roleMapper.selectById(1l);        // 虽然我们没有更新数据库，但是这个用户名和我们 role1 重新赋值的名字相同了        Assert.assertEquals(&quot;New Name&quot;, role2.getRoleName());        // 不仅如何，role2 和 role1 完全就是同一个实例        Assert.assertEquals(role1, role2);    } finally {        sqlSession.close();    }    System.out.println(&quot;开启新的 sqlSession&quot;);    // 开始另一个新的 session    sqlSession = getSqlSession();    try {        // 获取 RoleMapper 接口        RoleMapper roleMapper = sqlSession.getMapper(RoleMapper.class);        // 调用 selectById 方法，查询 id = 1 的用户        SysRole role2 = roleMapper.selectById(1l);        // 第二个 session 获取的用户名仍然是 admin        Assert.assertEquals(&quot;New Name&quot;, role2.getRoleName());        // 这里的 role2 和 前一个 session 查询的结果是两个不同的实例        Assert.assertNotEquals(role1, role2);        // 获取 role3        SysRole role3 = roleMapper.selectById(1l);        // 这里的 role2 和 role3 是两个不同的实例        Assert.assertNotEquals(role2, role3);    } finally {        sqlSession.close();    }}</code></pre><pre><code class="java">// 第一次没有缓存，命中率 0DEBUG [main] - Cache Hit Ratio [tk.mybatis.simple.mapper.RoleMapper]: 0.0DEBUG [main] - ==&gt;  Preparing: select id,role_name roleName, enabled, create_by createBy, create_time createTime from sys_role where id = ?DEBUG [main] - ==&gt; Parameters: 1(Long)TRACE [main] - &lt;==    Columns: id, roleName, enabled, createBy, createTimeTRACE [main] - &lt;==        Row: 1, 管理员, 1, 1, 2016-04-01 17:02:14DEBUG [main] - &lt;==      Total: 1// 使用的一级缓存，所以命中率还是 0DEBUG [main] - Cache Hit Ratio [tk.mybatis.simple.mapper.RoleMapper]: 0.0开启新的 sqlSession// 第三次查询，命中率 1/3DEBUG [main] - Cache Hit Ratio [tk.mybatis.simple.mapper.RoleMapper]: 0.3333333333333333DEBUG [main] - Cache Hit Ratio [tk.mybatis.simple.mapper.RoleMapper]: 0.5</code></pre><p>这个例子中没有真正的读写安全，<code>role1.setRoleName(&quot;New Name&quot;);</code>，第二部分的代码中查询结果 roleName 都是 &quot;New Name&quot;。所以想要安全使用，需要避免无意义的修改。</p><h1 id="集成-EhCache"><a href="#集成-EhCache" class="headerlink" title="集成 EhCache"></a>集成 EhCache</h1><p>EhCache 是一个纯粹的 Java 进程内的缓存框架，具有快速、精干等特点。具体来说，EhCache 主要的特性如下。</p><ul><li>快速。</li><li>简单。</li><li>多种缓存策略。</li><li>缓存数据有内存和磁盘两级，无须担心容量问题。</li><li>存数据会在虚拟机重启的过程中写入磁盘。</li><li>可以通过RMI、可插入 AP I等方式进行分布式缓存。</li><li>具有缓存和缓存管理器的侦昕接口。</li><li>支持多缓存管理器实例以及一个实例的多个缓存区域。</li></ul><h2 id="添加项目依赖"><a href="#添加项目依赖" class="headerlink" title="添加项目依赖"></a>添加项目依赖</h2><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.mybatis.caches&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt;    &lt;version&gt;1.0.3&lt;/version&gt;&lt;/dependency&gt;</code></pre><h2 id="配置-EhCache"><a href="#配置-EhCache" class="headerlink" title="配置 EhCache"></a>配置 EhCache</h2><p>在 src/main/resources 目录下新增 ehcache.xml 文件</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:noNamespaceSchemaLocation=&quot;ehcache.xsd&quot;    updateCheck=&quot;false&quot; monitoring=&quot;autodetect&quot;    dynamicConfig=&quot;true&quot;&gt;    &lt;diskStore path=&quot;D:/cache&quot; /&gt;    &lt;defaultCache        maxElementsInMemory=&quot;3000&quot;        eternal=&quot;false&quot;        copyOnRead=&quot;true&quot;        copyOnWrite=&quot;true&quot;        timeToIdleSeconds=&quot;3600&quot;        timeToLiveSeconds=&quot;3600&quot;        overflowToDisk=&quot;true&quot;        diskPersistent=&quot;true&quot;/&gt;&lt;/ehcache&gt;</code></pre><ul><li><p>maxElementsInMemory：设置基于内存的缓存中可存放的对象最大数目</p></li><li><p>eternal：设置对象是否为永久的，true 表示永不过期，此时将忽略</p></li><li><p>timeToIdleSeconds：设置对象空闲最长时间，以秒为单位，超过这个时间对象过期。当对象过期时，ehCache 会把它从缓存中清除。如果此值为 0，表示对象可以无限期地处于空闲状态。</p></li><li><p>timeToLiveSeconds：设置对象生存最长时间，超过这个时间，对象过期。如果此值为 0，表示对象可以无限期地存在于缓存中，该属性值必须大于或等于 timeToIdleSeconds 属性值</p></li><li><p>overflowToDisk：设置基于内在的缓存中的对象数目达到上限后，是否把溢出的对象写到基于硬盘的缓存中</p></li><li><p>diskPersistent：当 jvm 结束时是否持久化对象 true false 默认是false</p></li><li><p>diskExpiryThreadIntervalSeconds：指定专门用于清除过期对象的监听线程的轮询时间</p></li><li><p>memoryStoreEvictionPolicy：当内存缓存达到最大，有新的 element 加入的时候，移除缓存中 element 的策略，默认是LRU（最近最少使用），可选的有LFU（最不常使用）和 FIFO（先进先出）</p></li><li><p><code>copyOnRead</code> ：判断从缓存中读取数据时是返回对象的引用还是复制一个对象返回。默认情况下是 false，即返回数据的引用，这种情况下返回的都是相同的对象，和 MyBatis 默认缓存中的只读对象是相同的。如果设置为 true，那就是可读写缓存，每次读取缓存时都会复制一个新的实例。</p></li><li><p><code>copyOnWrite</code> ：判断写入缓存时是直接缓存对象的引用还是复制一个对象然后缓存，默认也是 false。如果想使用可读写缓存，就需要将这两个属性配置为 true，如果使用只读缓存，可以不配置这两个属性，使用默认值 false 即可。</p></li></ul><h2 id="修改-RoleMapper-xml-中的缓存配置"><a href="#修改-RoleMapper-xml-中的缓存配置" class="headerlink" title="修改 RoleMapper.xml 中的缓存配置"></a>修改 RoleMapper.xml 中的缓存配置</h2><p>修改 RoleMapper.xml 中的配置如下。</p><pre><code class="xml">&lt;mapper namespace＝&quot;tk.mybatis.simple.mapper.RoleMapper&quot;&gt;    &lt;!-- cache 其他属性不会起到任何作用 --&gt;    &lt;cache type＝&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;/&gt;&lt;/mapper&gt;</code></pre><p>ehcache.xml 只有一个默认的缓存配置，如果想针对某一个命名空间进行配置，需添加</p><pre><code class="xml">&lt;cache    name=&quot;tk.mybatis.simple.mapper.RoleMapper&quot;    maxElementsInMemory=&quot;3000&quot;    eternal=&quot;false&quot;    copyOnRead=&quot;true&quot;    copyOnWrite=&quot;true&quot;    timeToIdleSeconds=&quot;3600&quot;    timeToLiveSeconds=&quot;3600&quot;    overflowToDisk=&quot;true&quot;    diskPersistent=&quot;true&quot;/&gt;</code></pre><h1 id="集成-Redis-缓存"><a href="#集成-Redis-缓存" class="headerlink" title="集成 Redis 缓存"></a>集成 Redis 缓存</h1><h2 id="添加项目依赖-1"><a href="#添加项目依赖-1" class="headerlink" title="添加项目依赖"></a>添加项目依赖</h2><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.mybatis.caches&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-redis&lt;/artifactId&gt;    &lt;version&gt;1.0.0-beta2&lt;/version&gt;&lt;/dependency&gt;</code></pre><h2 id="配置-Redis"><a href="#配置-Redis" class="headerlink" title="配置 Redis"></a>配置 Redis</h2><p>在 src/main/resources 目录下新增 redis.properties 文件</p><pre><code class="ini">host=127.0.0.1port=6379connectionTimeout=5000soTimeout=5000password=database=0clientName=</code></pre><h2 id="修改-RoleMapper-xml-中的缓存配置-1"><a href="#修改-RoleMapper-xml-中的缓存配置-1" class="headerlink" title="修改 RoleMapper.xml 中的缓存配置"></a>修改 RoleMapper.xml 中的缓存配置</h2><pre><code class="xml">&lt;mapper namespace＝&quot;tk.mybatis.simple.mapper.RoleMapper&quot;&gt;    &lt;cache type＝&quot;org.mybatis.caches.redis.RedisCache&quot;/&gt;&lt;/mapper&gt;</code></pre><h1 id="脏数据的产生和避免"><a href="#脏数据的产生和避免" class="headerlink" title="脏数据的产生和避免"></a>脏数据的产生和避免</h1><p>一个多表的查询就会缓存在某命名空间的二级缓存中。涉及这些表的增、删、改操作通常不在一个映射文件中，它们的命名空间不同，因此当有数据变化时，多表查询的缓存未必会被清空，这种情况下就会产生脏数据。</p><p>在 UserMapper.xml 添加二级缓存配置，增加 <code>&lt;cache/&gt;</code> 元素，SysUser 对象实现 Serializable 接口。</p><pre><code class="java">@Testpublic void testDirtyData(){    SqlSession sqlSession = getSqlSession();    try {        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);        SysUser user = userMapper.selectUserAndRoleById(1001L);        Assert.assertEquals(&quot;普通用户&quot;, user.getRole().getRoleName());        System.out.println(&quot;角色名：&quot; + user.getRole().getRoleName());    } finally {        sqlSession.close();    }    // 开始另一个新的 session    sqlSession = getSqlSession();    try {        RoleMapper roleMapper = sqlSession.getMapper(RoleMapper.class);        SysRole role = roleMapper.selectById(2L);        role.setRoleName(&quot;脏数据&quot;);        roleMapper.updateById(role);        sqlSession.commit();    } finally {        sqlSession.close();    }    System.out.println(&quot;开启新的 sqlSession&quot;);    sqlSession = getSqlSession();    try {        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);        RoleMapper roleMapper = sqlSession.getMapper(RoleMapper.class);        SysUser user = userMapper.selectUserAndRoleById(1001L);        SysRole role = roleMapper.selectById(2L);        Assert.assertEquals(&quot;普通用户&quot;, user.getRole().getRoleName());        Assert.assertEquals(&quot;脏数据&quot;, role.getRoleName());        System.out.println(&quot;角色名：&quot; + user.getRole().getRoleName());        // 还原数据        role.setRoleName(&quot;普通用户&quot;);        roleMapper.updateById(role);        sqlSession.commit();    } finally {        sqlSession.close();    }}</code></pre><p>第一个 SqlSession 中获取了用户和关联的角色信息，第二个 SqlSession 中查询角色并修改了角色的信息，第三个 SqlSession 查询用户和关联的角色信息。这时从缓存中直接取出数据，就出现了脏数据，因为角色名称己经修改，但是这里读取到的角色名称仍然是修改前的名字，因此出现了脏读。</p><p>如何避免脏数据的出现？就需要用到参照缓存了。可以让几个会关联的表同时使用同一个二级缓存。修改 UserMapper.xml 的缓存配置。</p><pre><code class="xml">&lt;cache-ref namespace=&quot;tk.mybatis.simple.mapper.RoleMapper&quot;&gt;</code></pre><h1 id="二级缓存适用场景"><a href="#二级缓存适用场景" class="headerlink" title="二级缓存适用场景"></a>二级缓存适用场景</h1><ul><li>查询为主的应用中，只有尽可能少的增、删、改操作。</li><li>绝大多数以单表操作存在时，由于很少存在互相关联的情况，因此不会出现脏数据。</li><li>可以按业务划分对表进行分组时，如关联的表比较少，可以通过参照缓存进行配置。</li></ul><p>除了推荐使用的情况，如果脏读对系统没有影响，也可以考虑使用。在无法保证数据不出现脏读的情况下，建议在业务层使用可控制的缓存代替二级缓存。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis 09-使用枚举或其他对象</title>
      <link href="/2019/12/01/MyBatis%2009-%E4%BD%BF%E7%94%A8%E6%9E%9A%E4%B8%BE%E6%88%96%E5%85%B6%E4%BB%96%E5%AF%B9%E8%B1%A1/"/>
      <url>/2019/12/01/MyBatis%2009-%E4%BD%BF%E7%94%A8%E6%9E%9A%E4%B8%BE%E6%88%96%E5%85%B6%E4%BB%96%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="http://www.broadview.com.cn/book/3643" target="_blank" rel="noopener">http://www.broadview.com.cn/book/3643</a><br><a href="https://github.com/mybatis-book/book" target="_blank" rel="noopener">https://github.com/mybatis-book/book</a></p></blockquote><h1 id="使用-MyBatis-提供的枚举处理器"><a href="#使用-MyBatis-提供的枚举处理器" class="headerlink" title="使用 MyBatis 提供的枚举处理器"></a>使用 MyBatis 提供的枚举处理器</h1><pre><code class="java">public enum Enabled {    enabled,  // 启用    disabled; // 禁用}</code></pre><p>修改 SysRole 中 enabled 的类型</p><pre><code class="java">private Enabled enabled；</code></pre><p>MyBatis 处理枚举类型时默认使用 org.apache.ibatis.type.EnumTypeHandler 处理器，这个处理器会将枚举类型转换为字符串类型的字面值并使用。对于 Enabled 而言便是 &quot;enabled&quot;，&quot;disabled&quot; 字符串。由于数据库中使用的是 int 类型，所以转换时肯定会报错。</p><p>MyBatis 还提供了另一个 org.apache.ibatis.type.EnumOrdinalTypeHandler 处理器，这个处理器使用枚举的索引进行处理，可以解决遇到的问题，在 mybatis-config.xml 中添加配置：</p><pre><code class="xml">&lt;typeHandlers&gt;    &lt;typeHandler        javaType=&quot;tk.mybatis.simple.type.Enabled&quot;        handler=&quot;org.apache.ibatis.type.EnumOrdinalTypeHandler&quot;/&gt;&lt;/typeHandlers&gt;</code></pre><h1 id="使用自定义的类型处理器"><a href="#使用自定义的类型处理器" class="headerlink" title="使用自定义的类型处理器"></a>使用自定义的类型处理器</h1><p>有时候，值既不是枚举的字面值，也不是枚举的索引值，这样就需要自己来实现类型处理器了。</p><pre><code class="java">public enum Enabled {    enabled(1), //启用    disabled(0);//禁用    private final int value;    private Enabled(int value) {        this.value = value;    }    public int getValue() {        return value;    }}</code></pre><pre><code class="java">/** * Enabled 类型处理器 */public class EnabledTypeHandler implements TypeHandler&lt;Enabled&gt; {    private final Map&lt;Integer, Enabled&gt; enabledMap = new HashMap&lt;Integer, Enabled&gt;();    public EnabledTypeHandler() {        for(Enabled enabled : Enabled.values()){            enabledMap.put(enabled.getValue(), enabled);        }    }    public EnabledTypeHandler(Class&lt;?&gt; type) {        this();    }    @Override    public void setParameter(PreparedStatement ps, int i, Enabled parameter, JdbcType jdbcType) throws SQLException {        ps.setInt(i, parameter.getValue());    }    @Override    public Enabled getResult(ResultSet rs, String columnName) throws SQLException {        Integer value = rs.getInt(columnName);        return enabledMap.get(value);    }    @Override    public Enabled getResult(ResultSet rs, int columnIndex) throws SQLException {        Integer value = rs.getInt(columnIndex);        return enabledMap.get(value);    }    @Override    public Enabled getResult(CallableStatement cs, int columnIndex) throws SQLException {        Integer value = cs.getInt(columnIndex);        return enabledMap.get(value);    }}</code></pre><p>在 mybatis-config.xml 中修改配置：</p><pre><code class="xml">&lt;typeHandlers&gt;    &lt;typeHandler        javaType=&quot;tk.mybatis.simple.type.Enabled&quot;        handler=&quot;tk.mybatis.simple.type.EnabledTypeHandler&quot;/&gt;&lt;/typeHandlers&gt;</code></pre><h1 id="对-Java8-日期的支持"><a href="#对-Java8-日期的支持" class="headerlink" title="对 Java8 日期的支持"></a>对 Java8 日期的支持</h1><p><a href="https://github.com/mybatis/typehandlers-jsr310" target="_blank" rel="noopener">https://github.com/mybatis/typehandlers-jsr310</a></p><p>MyBatis 从 3.4.0 版本开始增加对 Java8 日期的支持。如果使用 3.4.0 及以上版本时，只需添加依赖即可。</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-typehandlers-jsr310&lt;/artifactId&gt;    &lt;version&gt;l.0.2&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>如果使用更早的版本，还需要在 mybatis-config.xml 中添加如下配置。</p><pre><code class="xml">&lt;typeHandlers&gt;    &lt;!-- ... --&gt;    &lt;typeHandler handler=&quot;org.apache.ibatis.type.InstantTypeHandler&quot; /&gt;    &lt;typeHandler handler=&quot;org.apache.ibatis.type.LocalDateTimeTypeHandler&quot; /&gt;    &lt;typeHandler handler=&quot;org.apache.ibatis.type.LocalDateTypeHandler&quot; /&gt;    &lt;typeHandler handler=&quot;org.apache.ibatis.type.LocalTimeTypeHandler&quot; /&gt;    &lt;typeHandler handler=&quot;org.apache.ibatis.type.OffsetDateTimeTypeHandler&quot; /&gt;    &lt;typeHandler handler=&quot;org.apache.ibatis.type.OffsetTimeTypeHandler&quot; /&gt;    &lt;typeHandler handler=&quot;org.apache.ibatis.type.ZonedDateTimeTypeHandler&quot; /&gt;    &lt;typeHandler handler=&quot;org.apache.ibatis.type.YearTypeHandler&quot; /&gt;    &lt;typeHandler handler=&quot;org.apache.ibatis.type.MonthTypeHandler&quot; /&gt;    &lt;typeHandler handler=&quot;org.apache.ibatis.type.YearMonthTypeHandler&quot; /&gt;    &lt;typeHandler handler=&quot;org.apache.ibatis.type.JapaneseDateTypeHandler&quot; /&gt;&lt;/typeHandlers&gt;</code></pre><p>为什么这些 typeHandler 都没有配置 javaType 呢？看看 InstantTypeHandler 的源码</p><pre><code class="java">public class InstantTypeHandler extends BaseTypeHandler&lt;Instant&gt; {    // ...}</code></pre><p>InstantTypeHandler 继承了 <code>BaseTypeHandler&lt;T&gt;</code> 类，而 <code>BaseTypeHandler&lt;T&gt;</code> 又继承了 <code>TypeReference&lt;T&gt;</code> 类。MyBatis 会获取这里指定的泛型类型作为 javaType 属性。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis 08-存储过程</title>
      <link href="/2019/12/01/MyBatis%2008-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/"/>
      <url>/2019/12/01/MyBatis%2008-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="http://www.broadview.com.cn/book/3643" target="_blank" rel="noopener">http://www.broadview.com.cn/book/3643</a><br><a href="https://github.com/mybatis-book/book" target="_blank" rel="noopener">https://github.com/mybatis-book/book</a></p></blockquote><h1 id="根据用户-id-查询用户其他信息"><a href="#根据用户-id-查询用户其他信息" class="headerlink" title="根据用户 id 查询用户其他信息"></a>根据用户 id 查询用户其他信息</h1><pre><code class="sql"># 根据用户 id 查询用户其他信息# 方法看着很奇葩，但是展示了多个输出参数DROP PROCEDURE IF EXISTS `select_user_by_id`;DELIMITER ;;CREATE PROCEDURE `select_user_by_id`(IN userId BIGINT,OUT userName VARCHAR(50),OUT userPassword VARCHAR(50),OUT userEmail VARCHAR(50),OUT userInfo TEXT,OUT headImg BLOB,OUT createTime DATETIME)BEGIN# 根据用户 id 查询其他数据select user_name,user_password,user_email,user_info,head_img,create_timeINTO userName,userPassword,userEmail,userInfo,headImg,createTimefrom sys_userWHERE id = userId;END;;DELIMITER ;</code></pre><pre><code class="xml">&lt;select id=&quot;selectUserById&quot; statementType=&quot;CALLABLE&quot; useCache=&quot;false&quot;&gt;    {call select_user_by_id(        #{id, mode=IN},        #{userName, mode=OUT, jdbcType=VARCHAR},        #{userPassword, mode=OUT, jdbcType=VARCHAR},        #{userEmail, mode=OUT, jdbcType=VARCHAR},        #{userInfo, mode=OUT, jdbcType=VARCHAR},        #{headImg, mode=OUT, jdbcType=BLOB, javaType=_byte[]},        #{createTime, mode=OUT, jdbcType=TIMESTAMP}    )}&lt;/select&gt;</code></pre><p>在调用存储过程的方法中，需要把 statementType 设置为 CALLABLE，在使用 select 标签调用存储过程时，由于存储过程不支持二级缓存，因此避免出错将 useCache 设置为 false。</p><p>在存储过程中使用参数时，除了写上必要的属性名，还必须指定参数的 mode，可选值 IN（入参），OUT（出参），INOUT（输入输出）。OUT 模式必须指定 jdbcType。在使用 Oracle 时，如果入参存在 null 的情况，那么入参也必须指定 jdbcType。</p><pre><code class="java">void selectUserById(SysUser user);</code></pre><p>这个存储过程没有返回值（不要和出参混淆）。</p><p>使用出参方式时，使用 JavaBean 对象接收出参时，必须保证所有出参在 JavaBean 中都有对应的属性存在，否则会抛出类似 “Could not set property &#39;xxx&#39;” 这样的错误。使用 Map 类型接收出参时不需要保证所有出参都有对应的属性。</p><h1 id="简单的根据用户名和分页参数进行查询，返回总数和分页数据"><a href="#简单的根据用户名和分页参数进行查询，返回总数和分页数据" class="headerlink" title="简单的根据用户名和分页参数进行查询，返回总数和分页数据"></a>简单的根据用户名和分页参数进行查询，返回总数和分页数据</h1><pre><code class="sql"># 简单的根据用户名和分页参数进行查询，返回总数和分页数据DROP PROCEDURE IF EXISTS `select_user_page`;DELIMITER ;;CREATE PROCEDURE `select_user_page`(IN userName VARCHAR(50),IN _offset BIGINT,IN _limit BIGINT,OUT total BIGINT)BEGIN# 查询数据总数select count(*) INTO totalfrom sys_userwhere user_name like concat(&#39;%&#39;, userName, &#39;%&#39;);# 分页查询数据select *from sys_userwhere user_name like concat(&#39;%&#39;, userName, &#39;%&#39;)limit _offset, _limit;END;;DELIMITER ;</code></pre><pre><code class="xml">&lt;select id=&quot;selectUserPage&quot; statementType=&quot;CALLABLE&quot; useCache=&quot;false&quot; resultMap=&quot;userMap&quot;&gt;    {call select_user_page(        #{userName, mode=IN},        #{offset, mode=IN},        #{limit, mode=IN},        #{total, mode=OUT, jdbcType=BIGINT}    )}&lt;/select&gt;</code></pre><p>select 标签设置了 resultMap，因为该方法通过 total 出参得到了查询的总数，通过存储过程返回了最后的结果集，所以需要设置返回值信息。</p><pre><code class="java">/*** 使用存储过程分页查询** @param userName* @param pageNum* @param pageSize* @param total* @return*/List&lt;SysUser&gt; selectUserPage(Map&lt;String, Object&gt; params);</code></pre><pre><code class="java">@Testpublic void testSelectUserPage(){    // 获取 sqlSession    SqlSession sqlSession = getSqlSession();    try {        // 获取 UserMapper 接口        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);        Map&lt;String, Object&gt; params = new HashMap&lt;String, Object&gt;();        params.put(&quot;userName&quot;, &quot;ad&quot;);        params.put(&quot;offset&quot;, 0);        params.put(&quot;limit&quot;, 10);        List&lt;SysUser&gt; userList = userMapper.selectUserPage(params);  // 也可以使用 JavaBean        Long total = (Long) params.get(&quot;total&quot;);        System.out.println(&quot;总数:&quot; + total);        for(SysUser user : userList){            System.out.println(&quot;用户名：&quot; + user.getUserName());        }    } finally {        // 不要忘记关闭 sqlSession        sqlSession.close();    }}</code></pre><h1 id="添加删除用户"><a href="#添加删除用户" class="headerlink" title="添加删除用户"></a>添加删除用户</h1><pre><code class="sql"># 保存用户信息和角色关联信息DROP PROCEDURE IF EXISTS `insert_user_and_roles`;DELIMITER ;;CREATE PROCEDURE `insert_user_and_roles`(OUT userId BIGINT,IN userName VARCHAR(50),IN userPassword VARCHAR(50),IN userEmail VARCHAR(50),IN userInfo TEXT,IN headImg BLOB,OUT createTime DATETIME,IN roleIds VARCHAR(200))BEGIN# 设置当前时间SET createTime = NOW();# 插入数据INSERT INTO sys_user(user_name, user_password, user_email, user_info, head_img, create_time)VALUES (userName, userPassword, userEmail, userInfo, headImg, createTime);# 获取自增主键SELECT LAST_INSERT_ID() INTO userId;# 保存用户和角色关系数据SET roleIds = CONCAT(&#39;,&#39;,roleIds,&#39;,&#39;);INSERT INTO sys_user_role(user_id, role_id)select userId, id from sys_rolewhere INSTR(roleIds, CONCAT(&#39;,&#39;,id,&#39;,&#39;)) &gt; 0;END;;DELIMITER ;</code></pre><pre><code class="sql"># 删除用户信息和角色关联信息DROP PROCEDURE IF EXISTS `delete_user_by_id`;DELIMITER ;;CREATE PROCEDURE `delete_user_by_id`(IN userId BIGINT)BEGINDELETE FROM sys_user_role where user_id = userId;DELETE FROM sys_user where id = userId;END;;DELIMITER ;</code></pre><pre><code class="xml">&lt;insert id=&quot;insertUserAndRoles&quot; statementType=&quot;CALLABLE&quot;&gt;    {call insert_user_and_roles(        #{user.id, mode=OUT, jdbcType=BIGINT},        #{user.userName, mode=IN},        #{user.userPassword, mode=IN},        #{user.userEmail, mode=IN},        #{user.userInfo, mode=IN},        #{user.headImg, mode=IN, jdbcType=BLOB},        #{user.createTime, mode=OUT, jdbcType=TIMESTAMP},        #{roleIds, mode=IN}    )}&lt;/insert&gt;&lt;delete id=&quot;deleteUserById&quot; statementType=&quot;CALLABLE&quot;&gt;    {call delete_user_by_id(#{id, mode=IN})}&lt;/delete&gt;</code></pre><pre><code class="java">/*** 保存用户信息和角色关联信息*/int insertUserAndRoles(@Param(&quot;user&quot;)SysUser user, @Param(&quot;roleIds&quot;)String roleIds);/*** 根据用户 id 删除用户和用户的角色信息*/int deleteUserById(Long id);</code></pre><h1 id="在-Oracle-中使用游标参数的存储过程"><a href="#在-Oracle-中使用游标参数的存储过程" class="headerlink" title="在 Oracle 中使用游标参数的存储过程"></a>在 Oracle 中使用游标参数的存储过程</h1><pre><code class="sql">create or replace procedure SELECT_COUNTRIES(    ref_cur1 out sys_refcursor,    ref_cur2 out sys_refcursor) isbegin  open ref_cur1 for select * from country where id &lt; 3;  open ref_cur2 for select * from country where id &gt;= 3;end SELECT_COUNTRIES;</code></pre><p>这个存储过程只有两个游标类型的出参，游标对应的值就是两个简单的 SQL。</p><pre><code class="xml">&lt;select id=&quot;selectCountries&quot; statementType=&quot;CALLABLE&quot; useCache=&quot;false&quot;&gt;    {call SELECT_COUNTRIES(        #{list1, mode=OUT, jdbcType=CURSOR, javaType=ResultSet, resultMap=BaseResultMap},        #{list2, mode=OUT, jdbcType=CURSOR, javaType=ResultSet, resultMap=BaseResultMap}    )}&lt;/select&gt;</code></pre><p>使用游标类型时，注意设置 <code>jdbcType=CURSOR</code>, <code>javaType=ResultSet</code></p><pre><code class="java">/*** 执行 Oracle 中的存储过程*/Object selectCountries(Map&lt;String, Object&gt; params);</code></pre><pre><code class="java">@Testpublic void testMapperWithStartPage3() {    SqlSession sqlSession = getSqlSession();    CountryMapper countryMapper = sqlSession.getMapper(CountryMapper.class);    try {        // 获取第1页，10条内容，默认查询总数count        Map&lt;String, Object&gt; params = new HashMap&lt;String, Object&gt;();        countryMapper.selectCountries(params);        List&lt;Country&gt; list1 = (List&lt;Country&gt;) params.get(&quot;list1&quot;);        List&lt;Country&gt; list2 = (List&lt;Country&gt;) params.get(&quot;list2&quot;);        Assert.assertNotNull(list1);        Assert.assertNotNull(list2);    } finally {        sqlSession.close();    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Java 开发手册》记录</title>
      <link href="/2019/11/30/Java%20%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/"/>
      <url>/2019/11/30/Java%20%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="编程规范"><a href="#编程规范" class="headerlink" title="编程规范"></a>编程规范</h1><h2 id="命名风格"><a href="#命名风格" class="headerlink" title="命名风格"></a>命名风格</h2><p>6，抽象类使用 <code>Abstract</code> 或 <code>Base</code> 开头；异常类命名使用 <code>Exception</code> 结尾；测试类命名以他要测试的类名称开始，以 <code>Test</code> 结尾。</p><p>7，类型与中括号紧挨相连来表示数组。<br><strong>正例</strong>：<code>int[] arratDemo</code><br><strong>反例</strong>：<code>String args[]</code></p><p>8，<code>POJO</code> 类中布尔类型变量都不要加 <code>is</code> 前缀</p><p>10，避免在子父类的成员变量之间、或者不同代码块的局部变量之间采用完全相同的命名，使可读性降低。</p><pre><code class="java">// 反例public class ConfusingName {    public int age;    // 非 setter/getter 的参数名称，不允许与本类成员变量同名    public void getData(String alibaba) {        if(true) {            final int money = 531;        // ...        }        for (int i = 0; i &lt; 10; i++) {            // 在同一方法体中，不允许与其它代码块中的 taobao 命名相同            final int money = 615;            // ...        }    }}class Son extends ConfusingName {    // 不允许与父类的成员变量名称相同    public int age;}</code></pre><p>13，在常量与变量的命名时，表示类型的名词放在词尾，以提升辨识度。<br><strong>正例</strong>：<code>startTime</code> / <code>workQueue</code> / <code>nameList</code> / <code>TERMINATED_THREAD_COUNT</code><br><strong>反例</strong>：<code>startedAt</code> / <code>QueueOfWork</code> / <code>listName</code> / <code>COUNT_TERMINATED_THREAD</code></p><p>14，如果模块、接口、类、方法使用了设计模式，在命名时需体现出具体模式。</p><pre><code class="java">// 正例：public class OrderFactory;public class LoginProxy;public class ResourceObserver;</code></pre><p>16，对于 <code>Service</code> 和 <code>DAO</code> 类，基于 <code>SOA</code> 的理念，暴露出来的服务一定是接口，内部的实现类用 <code>Impl</code> 的后缀与接口区别。<br><strong>正例</strong>：<code>CacheServiceImpl</code> 实现 <code>CacheService</code> 接口。</p><p>17，枚举类名带上 <code>Enum</code> 后缀，枚举成员名称需要全大写，单词间用下划线隔开。</p><p>18，各层命名规约：</p><ul><li><code>Service</code>/<code>DAO</code> 层方法命名规约<ul><li>获取单个对象的方法用 <code>get</code> 做前缀。</li><li>获取多个对象的方法用 <code>list</code> 做前缀，复数形式结尾如：<code>listObjects</code>。</li><li>获取统计值的方法用 <code>count</code> 做前缀。</li><li>插入的方法用 <code>save</code>/<code>insert</code> 做前缀。</li><li>删除的方法用 <code>remove</code>/<code>delete</code> 做前缀。</li><li>修改的方法用 <code>update</code> 做前缀。</li></ul></li><li>领域模型命名规约<ul><li>数据对象：<code>xxxDO</code>，xxx 即为数据表名。</li><li>数据传输对象：<code>xxxDTO</code>，xxx 为业务领域相关的名称。</li><li>展示对象：<code>xxxVO</code>，xxx 一般为网页名称。</li><li>POJO 是 <code>DO</code>/<code>DTO</code>/<code>BO</code>/<code>VO</code> 的统称，禁止命名成 xxxPOJO。</li></ul></li></ul><h2 id="常量定义"><a href="#常量定义" class="headerlink" title="常量定义"></a>常量定义</h2><p>1，不允许任何魔法值（即未经预先定义的常量）直接出现在代码中。</p><pre><code class="java">// 反例：String key = &quot;Id#taobao_&quot; + tradeId;cache.put(key, value);// 缓存 get 时，由于在代码复制时，漏掉下划线，导致缓存击穿而出现问题</code></pre><p>3，不要使用一个常量类维护所有常量，要按常量功能进行归类，分开维护。</p><p>4，常量的复用层次有五层：跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量。</p><ul><li>跨应用共享常量：放置在二方库中，通常是 client.jar 中的 <code>constant</code> 目录下。</li><li>应用内共享常量：放置在一方库中，通常是子模块中的 <code>constant</code> 目录下。</li><li>子工程内部共享常量：即在当前子工程的 <code>constant</code> 目录下。</li><li>包内共享常量：即在当前包下单独的 <code>constant</code> 目录下。</li><li>类内共享常量：直接在类内部 <code>private static final</code> 定义。</li></ul><p>5，如果变量值仅在一个固定范围内变化用 <code>enum</code> 类型来定义。<br><strong>说明</strong>：如果存在名称之外的延伸属性应使用 <code>enum</code> 类型，下面正例中的数字就是延伸信息，表示一年中的第几个季节。</p><pre><code class="java">// 正例：public enum SeasonEnum {    SPRING(1), SUMMER(2), AUTUMN(3), WINTER(4);    private int seq;    SeasonEnum(int seq) {        this.seq = seq;    }    public int getSeq() {        return seq;    }}</code></pre><h2 id="代码格式"><a href="#代码格式" class="headerlink" title="代码格式"></a>代码格式</h2><p>8，单行字符数限制不超过 120 个，超出需要换行，换行时遵循如下原则：</p><ul><li>第二行相对第一行缩进 4 个空格，从第三行开始，不再继续缩进，参考示例。</li><li>运算符与下文一起换行。</li><li>方法调用的点符号与下文一起换行。</li><li>方法调用中的多个参数需要换行时，在逗号后进行。</li><li>在括号前不要换行。</li></ul><pre><code class="java">// 正例：StringBuilder sb = new StringBuilder();// 超过 120 个字符的情况下，换行缩进 4 个空格，点号和方法名称一起换行sb.append(&quot;Jack&quot;).append(&quot;Ma&quot;)    .append(&quot;alibaba&quot;)    .append(&quot;alibaba&quot;);</code></pre><h2 id="OOP-规约"><a href="#OOP-规约" class="headerlink" title="OOP 规约"></a>OOP 规约</h2><p>1，避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成本，<strong>直接用类名来访问即可</strong>。</p><p>3，相同参数类型，相同业务含义，才可以使用 Java 的可变参数，避免使用 <code>Object</code>。<br><strong>说明</strong>：可变参数必须放置在参数列表的最后。（提倡同学们尽量不用可变参数编程）<br><strong>正例</strong>：<code>public List&lt;User&gt; listUsers(String type, Long... ids) {...}</code></p><p>6，<code>Object</code> 的 <code>equals</code> 方法容易抛空指针异常，应使用常量或确定有值的对象来调用 <code>equals</code>。<br><strong>正例</strong>：<code>&quot;test&quot;.equals(object);</code><br><strong>反例</strong>：<code>object.equals(&quot;test&quot;);</code><br><strong>说明</strong>：推荐使用 <code>java.util.Objects#equals</code>（JDK7 引入的工具类）。</p><p>7，所有整型包装类对象之间值的比较，全部使用 <code>equals</code> 方法比较。<br><strong>说明</strong>：对于 <code>Integer var = ?</code> 在 <code>-128 至 127</code> 范围内的赋值，<code>Integer</code> 对象是在 <code>IntegerCache.cache</code> 产生，会复用已有对象，这个区间内的 <code>Integer</code> 值可以直接使用 <code>==</code> 进行判断，但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象，这是一个大坑，推荐使用 <code>equals</code> 方法进行判断。</p><p>8，浮点数之间的等值判断，基本数据类型不能用 <code>==</code> 来比较，包装数据类型不能用 <code>equals</code> 来判断。<br><strong>说明</strong>：浮点数采用“尾数+阶码”的编码方式，类似于科学计数法的“有效数字+指数”的表示方式。二进制无法精确表示大部分的十进制小数</p><pre><code class="java">// 反例：float a = 1.0f - 0.9f;float b = 0.9f - 0.8f;if (a == b) {// 预期进入此代码快，执行其它业务逻辑// 但事实上 a==b 的结果为 false}Float x = Float.valueOf(a);Float y = Float.valueOf(b);if (x.equals(y)) {// 预期进入此代码快，执行其它业务逻辑// 但事实上 equals 的结果为 false}// 正例：// (1) 指定一个误差范围，两个浮点数的差值在此范围之内，则认为是相等的。float a = 1.0f - 0.9f;float b = 0.9f - 0.8f;float diff = 1e-6f;if (Math.abs(a - b) &lt; diff) {    System.out.println(&quot;true&quot;);}// (2) 使用 BigDecimal 来定义值，再进行浮点数的运算操作。BigDecimal a = new BigDecimal(&quot;1.0&quot;);BigDecimal b = new BigDecimal(&quot;0.9&quot;);BigDecimal c = new BigDecimal(&quot;0.8&quot;);BigDecimal x = a.subtract(b);BigDecimal y = b.subtract(c);if (x.equals(y)) {    System.out.println(&quot;true&quot;);}</code></pre><p>10，为了防止精度损失，禁止使用构造方法 <code>BigDecimal(double)</code> 的方式把 <code>double</code> 值转化为 <code>BigDecimal</code> 对象。<br><strong>说明</strong>：<code>BigDecimal(double)</code>存在精度损失风险，在精确计算或值比较的场景中可能会导致业务逻辑异常。如：<code>BigDecimal g = new BigDecimal(0.1f);</code> 实际的存储值为：<code>0.10000000149</code><br><strong>正例</strong>：优先推荐入参为 <code>String</code> 的构造方法，或使用 <code>BigDecimal</code> 的 <code>valueOf</code> 方法，此方法内部其实执行了 <code>Double</code> 的 <code>toString</code>，而 <code>Double</code> 的 <code>toString</code> 按 <code>double</code> 的实际能表达的精度对尾数进行了截断。</p><pre><code class="java">BigDecimal recommend1 = new BigDecimal(&quot;0.1&quot;);BigDecimal recommend2 = BigDecimal.valueOf(0.1);</code></pre><p>11，关于基本数据类型与包装数据类型的使用标准如下：</p><ul><li>所有的 POJO 类属性必须使用包装数据类型。</li><li>RPC 方法的返回值和参数必须使用包装数据类型。</li><li>【推荐】所有的局部变量使用基本数据类型。</li></ul><p>12，定义 <code>DO</code>/<code>DTO</code>/<code>VO</code> 等 <code>POJO</code> 类时，<strong>不要设定任何属性默认值</strong>。</p><p>13，序列化类新增属性时，请不要修改 <code>serialVersionUID</code> 字段，避免反序列失败；如果完全不兼容升级，避免反序列化混乱，那么请修改 <code>serialVersionUID</code> 值。</p><p>14，构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在 <code>init</code> 方法中。</p><p>15，<code>POJO</code> 类必须写 <code>toString</code> 方法。使用 IDE 中的工具：<code>source&gt; generate toString</code> 时，如果继承了另一个 <code>POJO</code> 类，注意在前面加一下 <code>super.toString</code>。<br><strong>说明</strong>：在方法执行抛出异常时，可以直接调用 <code>POJO</code> 的 <code>toString()</code> 方法打印其属性值，便于排查问题。</p><p>16，禁止在 POJO 类中，同时存在对应属性 xxx 的 <code>isXxx()</code> 和 <code>getXxx()</code> 方法。<br><strong>说明</strong>：框架在调用属性 xxx 的提取方法时，并不能确定哪个方法一定是被优先调用到。</p><p>20，<code>setter</code> 方法中，参数名称与类成员变量名称一致，<code>this.成员名 = 参数名</code>。在 <code>getter/setter</code> 方法中，不要增加业务逻辑，增加排查问题的难度。</p><pre><code class="java">// 反例：public Integer getData() {    if (condition) {        return this.data + 100;    } else {        return this.data - 100;    }}</code></pre><p>21，循环体内，字符串的连接方式，使用 <code>StringBuilder</code> 的 <code>append</code> 方法进行扩展。<br><strong>说明</strong>：下例中，反编译出的字节码文件显示每次循环都会 <code>new</code> 出一个 <code>StringBuilder</code> 对象，然后进行 <code>append</code> 操作，最后通过 <code>toString</code> 方法返回 <code>String</code> 对象，造成内存资源浪费。</p><pre><code class="java">// 反例：String str = &quot;start&quot;;for (int i = 0; i &lt; 100; i++) {    str = str + &quot;hello&quot;;}</code></pre><p>22，<code>final</code> 可以声明类、成员变量、方法、以及本地变量，下列情况使用 <code>final</code> 关键字：</p><ul><li>不允许被继承的类，如：<code>String</code> 类。</li><li>不允许修改引用的域对象。</li><li>不允许被覆写的方法，如：POJO 类的 <code>setter</code> 方法。</li><li>不允许运行过程中重新赋值的局部变量。</li><li>避免上下文重复使用一个变量，使用 <code>final</code> 可以强制重新定义一个变量，方便更好地进行重构。</li></ul><p>23，慎用 <code>Object</code> 的 <code>clone</code> 方法来拷贝对象。<br><strong>说明</strong>：对象 <code>clone</code> 方法默认是浅拷贝，若想实现深拷贝需覆写 <code>clone</code> 方法实现域对象的深度遍历式拷贝。</p><p>24，类成员与方法访问控制从严：</p><ul><li>如果不允许外部直接通过 <code>new</code> 来创建对象，那么构造方法必须是 <code>private</code>。</li><li>工具类不允许有 <code>public</code> 或 <code>default</code> 构造方法。</li><li>类非 <code>static</code> 成员变量并且与子类共享，必须是 <code>protected</code>。</li><li>类非 <code>static</code> 成员变量并且仅在本类使用，必须是 <code>private</code>。</li><li>类 <code>static</code> 成员变量如果仅在本类使用，必须是 <code>private</code>。</li><li>若是 <code>static</code> 成员变量，考虑是否为 <code>final</code>。</li><li>类成员方法只供类内部调用，必须是 <code>private</code>。</li><li>类成员方法只对继承类公开，那么限制为 <code>protected</code>。</li></ul><h2 id="集合处理"><a href="#集合处理" class="headerlink" title="集合处理"></a>集合处理</h2><p>1，关于 <code>hashCode</code> 和 <code>equals</code> 的处理，遵循如下规则：</p><ul><li>只要覆写 <code>equals</code>，就必须覆写 <code>hashCode</code>。</li><li>因为 <code>Set</code> 存储的是不重复的对象，依据 <code>hashCode</code> 和 <code>equals</code> 进行判断，所以 <code>Set</code> 存储的对象必须覆写这两个方法。</li><li>如果自定义对象作为 <code>Map</code> 的键，那么必须覆写 <code>hashCode</code> 和 <code>equals</code>。</li></ul><p><strong>说明</strong>：<code>String</code> 已覆写 <code>hashCode</code> 和 <code>equals</code> 方法，所以我们可以愉快地使用 <code>String</code> 对象作为 <code>key</code> 来使用。</p><p>2，<code>ArrayList</code> 的 <code>subList</code> 结果不可强转成 <code>ArrayList</code>，否则会抛出 <code>ClassCastException</code> 异常，即 java.util.RandomAccessSubList cannot be cast to java.util.ArrayList。<br><strong>说明</strong>：<code>subLis</code>t 返回的是 <code>ArrayList</code> 的内部类 <code>SubList</code>，并不是 <code>ArrayList</code> 而是 <code>ArrayList</code> 的一个视图，对于 <code>SubList</code> 子列表的所有操作最终会反映到原列表上。</p><p>3，使用 <code>Map</code> 的方法 <code>keySet()</code> / <code>values()</code> / <code>entrySet()</code> 返回集合对象时，不可以对其进行添加元素操作，否则会抛出 <code>UnsupportedOperationException</code> 异常。</p><p>4，<code>Collections</code> 类返回的对象，如：<code>emptyList()</code> / <code>singletonList()</code> 等都是 immutable list，不可对其进行添加或者删除元素的操作。<br><strong>反例</strong>：如果查询无结果，返回 <code>Collections.emptyList()</code> 空集合对象，调用方一旦进行了添加元素的操作，就会触发 <code>UnsupportedOperationException</code> 异常。</p><p>5，在 <code>subList</code> 场景中，高度注意对原集合元素的增加或删除，均会导致子列表的遍历、增加、删除产生 <code>ConcurrentModificationException</code> 异常。</p><p>6，使用集合转数组的方法，必须使用集合的 <code>toArray(T[] array)</code>，传入的是类型完全一致、长度为 0 的空数组。<br><strong>反例</strong>：直接使用 <code>toArray</code> 无参方法存在问题，此方法返回值只能是 <code>Object[]</code> 类，若强转其它类型数组将出现 <code>ClassCastException</code> 错误。</p><pre><code class="java">// 正例：List&lt;String&gt; list = new ArrayList&lt;&gt;(2);list.add(&quot;guan&quot;);list.add(&quot;bao&quot;);String[] array = list.toArray(new String[0]);</code></pre><p>7，在使用 <code>Collection</code> 接口任何实现类的 <code>addAll()</code> 方法时，都要对输入的集合参数进行 <code>NPE</code> 判断。<br><strong>说明</strong>：在 <code>ArrayList#addAll</code> 方法的第一行代码即 <code>Object[] a = c.toArray();</code> 其中 c 为输入集合参数，如果为 null，则直接抛出异常。</p><p>8，使用工具类 <code>Arrays.asList()</code> 把数组转换成集合时，不能使用其修改集合相关的方法，它的 <code>add</code>/<code>remove</code>/<code>clear</code> 方法会抛出 <code>UnsupportedOperationException</code> 异常。<br><strong>说明</strong>：<code>asList</code> 的返回对象是一个 <code>Arrays</code> 内部类，并没有实现集合的修改方法。<code>Arrays.asList</code> 体现的是适配器模式，只是转换接口，后台的数据仍是数组。</p><pre><code class="java">String[] str = new String[] { &quot;yang&quot;, &quot;hao&quot; };List list = Arrays.asList(str);</code></pre><p>第一种情况：<code>list.add(&quot;yangguanbao&quot;);</code> 运行时异常。<br>第二种情况：<code>str[0] = &quot;changed&quot;;</code> 也会随之修改，反之亦然。</p><p>9，泛型通配符 <code>&lt;? extends T&gt;</code> 来接收返回的数据，此写法的泛型集合不能使用 <code>add</code> 方法，而 <code>&lt;? super T&gt;</code> 不能使用 <code>get</code> 方法，作为接口调用赋值时易出错。<br><strong>说明</strong>：扩展说一下 <code>PECS(Producer Extends Consumer Super)</code> 原则：第一、频繁往外读取内容的，适合用<code>&lt;? extends T&gt;</code>。第二、经常往里插入的，适合用<code>&lt;? super T&gt;</code></p><p>10，在无泛型限制定义的集合赋值给泛型限制的集合时，在使用集合元素时，需要进行 <code>instanceof</code> 判断，避免抛出 <code>ClassCastException</code> 异常。</p><p>11，不要在 <code>foreach</code> 循环里进行元素的 <code>remove</code>/<code>add</code> 操作。<code>remove</code> 元素请使用 <code>Iterator</code> 方式，如果并发操作，需要对 <code>Iterator</code> 对象加锁。</p><pre><code class="java">// 正例：List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;1&quot;);list.add(&quot;2&quot;);Iterator&lt;String&gt; iterator = list.iterator();while (iterator.hasNext()) {    String item = iterator.next();    if (删除元素的条件) {        iterator.remove();    }}</code></pre><p>12，在 JDK 7 版本及以上， <code>Comparator</code> 实现类要满足如下三个条件，不然 <code>Arrays.sort</code> ，<code>Collections.sort</code> 会抛 <code>IllegalArgumentException</code> 异常。<br><strong>说明</strong>：三个条件如下</p><ul><li><code>x</code>，<code>y</code> 的比较结果和 <code>y</code>，<code>x</code> 的比较结果相反。</li><li><code>x&gt;y</code>，<code>y&gt;z</code>，则 <code>x&gt;z</code>。</li><li><code>x=y</code>，则 <code>x</code>，<code>z</code> 比较结果和 <code>y</code>，<code>z</code> 比较结果相同。</li></ul><p>14，集合初始化时，指定集合初始值大小。<strong>说明</strong>：HashMap 使用 <code>HashMap(int initialCapacity)</code> 初始化。</p><p>15，使用 <code>entrySet</code> 遍历 <code>Map</code> 类集合 <code>KV</code> ，而不是 <code>keySet</code> 方式进行遍历。<br><strong>说明</strong>：<code>keySet</code> 其实是遍历了 2 次，一次是转为 <code>Iterator</code> 对象，另一次是从 <code>hashMap</code> 中取出 <code>key</code> 所对应的 <code>value</code>。而 <code>entrySet</code> 只是遍历了一次就把 <code>key</code> 和 <code>value</code> 都放到了 <code>entry</code> 中，效率更高。如果是 <code>JDK8</code>，使用 <code>Map.forEach</code> 方法。</p><p>16，高度注意 <code>Map</code> 类集合 <code>K/V</code> 能不能存储 <code>null</code> 值的情况，如下表格：</p><table><thead><tr><th>集合类</th><th>Key</th><th>Value</th><th>Super</th><th>说明</th></tr></thead><tbody><tr><td>Hashtable</td><td>不允许为 null</td><td>不允许为 null</td><td>Dictionary</td><td>线程安全</td></tr><tr><td>ConcurrentHashMap</td><td>不允许为 null</td><td>不允许为 null</td><td>AbstractMap</td><td>锁分段技术（JDK8:CAS）</td></tr><tr><td>TreeMap</td><td>不允许为 null</td><td>允许为 null</td><td>AbstractMap</td><td>线程不安全</td></tr><tr><td>HashMap</td><td>允许为 null</td><td>允许为 null</td><td>AbstractMap</td><td>线程不安全</td></tr></tbody></table><h2 id="并发处理"><a href="#并发处理" class="headerlink" title="并发处理"></a>并发处理</h2><p>1，获取单例对象需要保证线程安全，其中的方法也要保证线程安全。</p><p>2，创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。</p><p>3，线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。</p><p>4，线程池不允许使用 <code>Executors</code> 去创建，而是通过 <code>ThreadPoolExecutor</code> 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</p><p>5，<code>SimpleDateFormat</code> 是线程不安全的类，一般不要定义为 <code>static</code> 变量，如果定义为 <code>static</code>，必须加锁，或者使用 <code>DateUtils</code> 工具类。<br><strong>正例</strong>：注意线程安全，使用 <code>DateUtils</code>。亦推荐如下处理：</p><pre><code class="java">private static final ThreadLocal&lt;DateFormat&gt; df = new ThreadLocal&lt;DateFormat&gt;() {    @Override    protected DateFormat initialValue() {        return new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);    }};</code></pre><p><strong>说明</strong>：如果是 <code>JDK8</code> 的应用，可以使用 <code>Instant</code> 代替 <code>Date</code>，<code>LocalDateTime</code> 代替 <code>Calendar</code>，<code>DateTimeFormatter</code> 代替 <code>SimpleDateFormat</code>，官方给出的解释：simple beautiful strong immutable thread-safe。</p><p>6，必须回收自定义的 <code>ThreadLocal</code> 变量，尤其在线程池场景下，线程经常会被复用，如果不清理自定义的 <code>ThreadLocal</code> 变量，可能会影响后续业务逻辑和造成内存泄露等问题。尽量在代理中使用 <code>try-finally</code> 块进行回收。</p><pre><code class="java">// 正例：objectThreadLocal.set(userInfo);try {// ...} finally {    objectThreadLocal.remove();}</code></pre><p>7，高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。</p><p>8，对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁。<br><strong>说明</strong>：线程一需要对表 A、B、C 依次全部加锁后才可以进行更新操作，那么线程二的加锁顺序也必须是A、B、C，否则可能出现死锁。</p><p>9，在使用阻塞等待获取锁的方式中，必须在 <code>try</code> 代码块之外，并且在加锁方法与 <code>try</code> 代码块之间没有任何可能抛出异常的方法调用，避免加锁成功后，在 <code>finally</code> 中无法解锁。<br><strong>说明一</strong>：如果在 <code>lock</code> 方法与 <code>try</code> 代码块之间的方法调用抛出异常，那么无法解锁，造成其它线程无法成功获取锁。<br><strong>说明二</strong>：如果 <code>lock</code> 方法在 <code>try</code> 代码块之内，可能由于其它方法抛出异常，导致在 <code>finally</code> 代码块中，<code>unlock</code> 对未加锁的对象解锁，它会调用 <code>AQS</code> 的 <code>tryRelease</code> 方法（取决于具体实现类），抛出 <code>IllegalMonitorStateException</code> 异常。<br><strong>说明三</strong>：在 <code>Lock</code> 对象的 <code>lock</code> 方法实现中可能抛出 <code>unchecked</code> 异常，产生的后果与说明二相同。</p><pre><code class="java">// 正例：Lock lock = new XxxLock();// ...lock.lock();try {    doSomething();    doOthers();} finally {    lock.unlock();}</code></pre><p>10，在使用尝试机制来获取锁的方式中，进入业务代码块之前，必须先判断当前线程是否持有锁。锁的释放规则与锁的阻塞等待方式相同。<br><strong>说明</strong>：<code>Lock</code> 对象的 <code>unlock</code> 方法在执行时，它会调用 <code>AQS</code> 的 <code>tryRelease</code> 方法（取决于具体实现类），如果当前线程不持有锁，则抛出 <code>IllegalMonitorStateException</code> 异常。</p><pre><code class="java">// 正例：Lock lock = new XxxLock();// ...boolean isLocked = lock.tryLock();if (isLocked) {    try {        doSomething();        doOthers();    } finally {        lock.unlock();    }}</code></pre><p>11，并发修改同一记录时，避免更新丢失，需要加锁。要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用 <code>version</code> 作为更新依据。<br><strong>说明</strong>：如果每次访问冲突概率小于 20%，推荐使用乐观锁，否则使用悲观锁。乐观锁的重试次数不得小于 3 次。</p><p>12，多线程并行处理定时任务时，<code>Timer</code> 运行多个 <code>TimeTask</code> 时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，如果在处理定时任务时使用 <code>ScheduledExecutorService</code> 则没有这个问题。</p><p>13，资金相关的金融敏感信息，使用<strong>悲观锁策略</strong>。</p><p>14，使用 <code>CountDownLatch</code> 进行异步转同步操作，每个线程退出前必须调用 <code>countDown</code> 方法，线程执行代码注意 <code>catch</code> 异常，确保 <code>countDown</code> 方法被执行到，避免主线程无法执行至 <code>await</code> 方法，直到超时才返回结果。<br><strong>说明</strong>：注意，子线程抛出异常堆栈，不能在主线程 <code>try-catch</code> 到。</p><p>15，避免 <code>Random</code> 实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一 <code>seed</code> 导致的性能下降。<br><strong>说明</strong>：<code>Random</code> 实例包括 <code>java.util.Random</code> 的实例或者 <code>Math.random()</code> 的方式。<br><strong>正例</strong>：在 <code>JDK7</code> 之后，可以直接使用 API <code>ThreadLocalRandom</code>，而在 <code>JDK7</code> 之前，需要编码保证每个线程持有一个实例。</p><p>16，在并发场景下，通过双重检查锁（double checked locking）实现延迟初始化的优化问题隐患，将目标属性声明为 <code>volatile</code> 型 。</p><h2 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h2><p>1，在一个 <code>switch</code> 块内，每个 <code>case</code> 要么通过 <code>continue</code>/<code>break</code>/<code>return</code> 等来终止，要么注释说明程序将继续执行到哪一个 <code>case</code> 为止；在一个 <code>switch</code> 块内，都必须包含一个 <code>default</code> 语句并且放在最后，即使它什么代码也没有。</p><p>2，当 <code>switch</code> 括号内的变量类型为 <code>String</code> 并且此变量为外部参数时，必须先进行 <code>null</code> 判断。</p><p>4，在高并发场景中，避免使用“等于”判断作为中断或退出的条件。反例：判断剩余奖品数量等于 0 时，终止发放奖品，但因为并发处理错误导致奖品数量瞬间变成了负数，这样的话，活动无法终止。</p><p>8，循环体中的语句要考量性能，以下操作尽量移至循环体外处理，如定义对象、变量、获取数据库连接，进行不必要的 <code>try-catch</code> 操作（这个 <code>try-catch</code> 是否可以移至循环体外）。</p><p>11，下列情形，<strong>需要进行参数校验</strong>：</p><ul><li>调用频次低的方法。</li><li>执行时间开销很大的方法。此情形中，参数校验时间几乎可以忽略不计，但如果因为参数错误导致中间执行回退，或者错误，那得不偿失。</li><li>需要极高稳定性和可用性的方法。</li><li>对外提供的开放接口，不管是 RPC/API/HTTP 接口。</li><li>敏感权限入口。</li></ul><p>12，下列情形，<strong>不需要进行参数校验</strong>：</p><ul><li>极有可能被循环调用的方法。但在方法说明里必须注明外部参数检查要求。</li><li>底层调用频度比较高的方法。毕竟是像纯净水过滤的最后一道，参数错误不太可能到底层才会暴露问题。一般 DAO 层与 Service 层都在同一个应用中，部署在同一台服务器中，所以 DAO 的参数校验，可以省略。</li><li>被声明成 private 只会被自己代码所调用的方法，如果能够确定调用方法的代码传入参数已经做过检查或者肯定不会有问题，此时可以不校验参数。</li></ul><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>1，在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度。</p><p>4，注意 <code>Math.random()</code> 这个方法返回是 <code>double</code> 类型，注意取值的范围 <code>0≤x&lt;1</code> （能够取到零值，注意除零异常），如果想获取整数类型的随机数，不要将 x 放大 10 的若干倍然后取整，直接使用 <code>Random</code> 对象的 <code>nextInt</code> 或者 <code>nextLong</code> 方法。</p><p>5，获取当前毫秒数 <code>System.currentTimeMillis();</code> 而不是 <code>new Date().getTime();</code><br><strong>说明</strong>：如果想获取更加精确的纳秒级时间值，使用 <code>System.nanoTime()</code> 的方式。在 <code>JDK8</code> 中，针对统计时间等场景，推荐使用 <code>Instant</code> 类。</p><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>2，异常不要用来做流程控制，条件控制。<strong>说明</strong>：异常设计的初衷是解决程序运行中的各种意外情况，且异常的处理效率比条件判断方式要低很多。</p><p>5，有 <code>try</code> 块放到了事务代码中，<code>catch</code> 异常后，如果需要回滚事务，一定要注意手动回滚事务。</p><p>7，不要在 <code>finally</code> 块中使用 <code>return</code>。<br><strong>说明</strong>：<code>try</code> 块中的 <code>return</code> 语句执行成功后，并不马上返回，而是继续执行 <code>finally</code> 块中的语句，如果此处存在 <code>return</code> 语句，则在此直接返回，无情丢弃掉 <code>try</code> 块中的返回点。</p><p>9，在调用 RPC、二方包、或动态生成类的相关方法时，捕捉异常必须使用 <code>Throwable</code> 类来进行拦截。<br><strong>说明</strong>：通过反射机制来调用方法，如果找不到方法，抛出 <code>NoSuchMethodException</code>。什么情况会抛出 <code>NoSuchMethodError</code> 呢？二方包在类冲突时，仲裁机制可能导致引入非预期的版本使类的方法签名不匹配，或者在字节码修改框架（比如：ASM）动态创建或修改类时，修改了相应的方法签名。这些情况，即使代码编译期是正确的，但在代码运行期时，会抛出 <code>NoSuchMethodError</code>。</p><p>10，方法的返回值可以为 <code>null</code>，不强制返回空集合，或者空对象等，必须添加注释充分说明什么情况下会返回 <code>null</code> 值。</p><p>11，防止 <code>NPE</code> ，是程序员的基本修养，注意 <code>NPE</code> 产生的场景：</p><ul><li>返回类型为基本数据类型，<code>return</code> 包装数据类型的对象时，自动拆箱有可能产生 <code>NPE</code>。</li></ul><p><strong>反例</strong>：<code>public int f() { return Integer 对象}</code>， 如果为 <code>null</code>，自动解箱抛 <code>NPE</code>。</p><ul><li>数据库的查询结果可能为 <code>null</code>。</li><li>集合里的元素即使 <code>isNotEmpty</code>，取出的数据元素也可能为 <code>null</code>。</li><li>远程调用返回对象时，一律要求进行空指针判断，防止 <code>NPE</code>。</li><li>对于 <code>Session</code> 中获取的数据，建议进行 <code>NPE</code> 检查，避免空指针。</li><li>级联调用 <code>obj.getA().getB().getC()；</code>一连串调用，易产生 <code>NPE</code>。</li></ul><p><strong>正例</strong>：使用 <code>JDK8</code> 的 <code>Optional</code> 类来防止 <code>NPE</code> 问题。</p><p>13，对于公司外的 <code>http/api</code> 开放接口必须使用“错误码”；而应用内部推荐异常抛出；跨应用间 <code>RPC</code> 调用优先考虑使用 <code>Result</code> 方式，封装 <code>isSuccess()</code> 方法、“错误码”、“错误简短信息”。<br><strong>说明</strong>：关于 <code>RPC</code> 方法返回方式使用 <code>Result</code> 方式的理由：<br>    1）使用抛异常返回方式，调用方如果没有捕获到就会产生运行时错误。<br>    2）如果不加栈信息，只是 new 自定义异常，加入自己的理解的 error message，对于调用端解决问题的帮助不会太多。如果加了栈信息，在频繁调用出错的情况下，数据序列化和传输的性能损耗也是问题。</p><h1 id="日志规约"><a href="#日志规约" class="headerlink" title="日志规约"></a>日志规约</h1><p>1，应用中不可直接使用日志系统（Log4j、Logback）中的 API ，而应依赖使用日志框架 SLF4J 中的 API ，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。</p><pre><code class="java">import org.slf4j.Logger;import org.slf4j.LoggerFactory;private static final Logger logger = LoggerFactory.getLogger(Test.class);</code></pre><p>2，所有日志文件至少保存 15 天，因为有些异常具备以“周”为频次发生的特点。网络运行状态、安全相关信息、系统监测、管理后台操作、用户敏感操作需要留存相关的网络日志不少于 6 个月。</p><p>3，应用中的扩展日志（如打点、临时监控、访问日志等）命名方式：appName_logType_logName.log。logType：日志类型，如 stats/monitor/access 等；logName：日志描述。这种命名的好处：通过文件名就可知道日志文件属于什么应用，什么类型，什么目的，也有利于归类查找。<br><strong>说明</strong>：推荐对日志进行分类，如将错误日志和业务日志分开存放，便于开发人员查看，也便于通过日志对系统进行及时监控。<br><strong>正例</strong>：force-web 应用中单独监控时区转换异常，如：force_web_timeZoneConvert.log</p><p>4，在日志输出时，字符串变量之间的拼接使用占位符的方式。<br><strong>说明</strong>：因为 String 字符串的拼接会使用 StringBuilder 的 append() 方式，有一定的性能损耗。使用占位符仅是替换动作，可以有效提升性能。<br><strong>正例</strong>： <code>logger.debug(&quot;Processing trade with id: {} and symbol: {}&quot;, id, symbol);</code></p><p>5，对于 trace/debug/info 级别的日志输出，必须进行日志级别的开关判断。<br><strong>说明</strong>：虽然在 debug(参数)的方法体内第一行代码 <code>isDisabled(Level.DEBUG_INT)</code> 为真时（Slf4j 的常见实现 Log4j 和 Logback），就直接 return，但是参数可能会进行字符串拼接运算。此外，如果 <code>debug(getName())</code> 这种参数内有 <code>getName()</code> 方法调用，无谓浪费方法调用的开销。</p><pre><code class="java">// 正例：// 如果判断为真，那么可以输出 trace 和 debug 级别的日志if (logger.isDebugEnabled()) {    logger.debug(&quot;Current ID is: {} and name is: {}&quot;, id, getName());}</code></pre><p>6，避免重复打印日志，浪费磁盘空间，务必在 <code>log4j.xml</code> 中设置 <code>additivity=false</code>。<br><strong>正例</strong>：<code>&lt;logger name=&quot;com.taobao.dubbo.config&quot; additivity=&quot;false&quot;&gt;</code></p><p>7，异常信息应该包括两类信息：案发现场信息和异常堆栈信息。如果不处理，那么通过关键字 <code>throws</code> 往上抛出。<br><strong>正例</strong>：<code>logger.error(各类参数或者对象 toString() + &quot;_&quot; + e.getMessage(), e);</code></p><p>9，可以使用 <code>warn</code> 日志级别来<strong>记录用户输入参数错误的情况</strong>，避免用户投诉时，无所适从。</p><h1 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h1><p>1，好的单元测试必须遵守 <code>AIR</code> 原则。<br><strong>说明</strong>：单元测试在线上运行时，感觉像空气（AIR）一样并不存在，但在测试质量的保障上，却是非常关键的。好的单元测试宏观上来说，具有自动化、独立性、可重复执行的特点。</p><ul><li>A：Automatic（自动化）</li><li>I：Independent（独立性）</li><li>R：Repeatable（可重复）</li></ul><p>2，单元测试应该是全自动执行的，并且非交互式的。测试用例通常是被定期执行的，执行过程必须完全自动化才有意义。输出结果需要人工检查的测试不是一个好的单元测试。单元测试中不准使用 <code>System.out</code> 来进行人肉验证，必须使用 <code>assert</code> 来验证。</p><p>3，保持单元测试的独立性。为了保证单元测试稳定可靠且便于维护，单元测试用例之间决不能互相调用，也不能依赖执行的先后次序。<br><strong>反例</strong>：method2 需要依赖 method1 的执行，将执行结果作为 method2 的输入。</p><p>4，单元测试是可以重复执行的，不能受到外界环境的影响。<br><strong>说明</strong>：单元测试通常会被放到持续集成中，每次有代码 check in 时单元测试都会被执行。如果单测对外部环境（网络、服务、中间件等）有依赖，容易导致持续集成机制的不可用。<br><strong>正例</strong>：为了不受外界环境影响，要求设计代码时就把 SUT 的依赖改成注入，在测试时用 spring 这样的 DI 框架注入一个本地（内存）实现或者 Mock 实现。</p><p>5，对于单元测试，要保证测试粒度足够小，有助于精确定位问题。单测粒度至多是类级别，一般是方法级别。<br><strong>说明</strong>：只有测试粒度小才能在出错时尽快定位到出错位置。单测不负责检查跨类或者跨系统的交互逻辑，那是集成测试的领域。</p><p>9，编写单元测试代码遵守 <code>BCDE</code> 原则，以保证被测试模块的交付质量。</p><ul><li>B：Border，边界值测试，包括循环边界、特殊取值、特殊时间点、数据顺序等。</li><li>C：Correct，正确的输入，并得到预期的结果。</li><li>D：Design，与设计文档相结合，来编写单元测试。</li><li>E：Error，强制错误信息输入（如：非法数据、异常流程、业务允许外等），并得到预期的结果。</li></ul><p>10，对于数据库相关的查询，更新，删除等操作，不能假设数据库里的数据是存在的，或者直接操作数据库把数据插入进去，请使用程序插入或者导入数据的方式来准备数据。</p><p>11，和数据库相关的单元测试，可以设定自动回滚机制，不给数据库造成脏数据。或者对单元测试产生的数据有明确的前后缀标识。</p><p>14，单元测试作为一种质量保障手段，在项目提测前完成单元测试，不建议项目发布后补充单元测试用例。</p><p>15，为了更方便地进行单元测试，业务代码应避免以下情况：</p><ul><li>构造方法中做的事情过多。</li><li>存在过多的全局变量和静态方法。</li><li>存在过多的外部依赖。</li><li>存在过多的条件语句。</li></ul><p>16，不要对单元测试存在如下误解：</p><ul><li>那是测试同学干的事情。本文是开发手册，凡是本文内容都是与开发同学强相关的。</li><li>单元测试代码是多余的。系统的整体功能与各单元部件的测试正常与否是强相关的。</li><li>单元测试代码不需要维护。一年半载后，那么单元测试几乎处于废弃状态。</li><li>单元测试与线上故障没有辩证关系。好的单元测试能够最大限度地规避线上故障。</li></ul><h1 id="安全规约"><a href="#安全规约" class="headerlink" title="安全规约"></a>安全规约</h1><p>1，隶属于用户个人的页面或者功能必须进行权限控制校验。</p><p>2，用户敏感数据禁止直接展示，必须对展示数据进行脱敏。<br><strong>说明</strong>：中国大陆个人手机号码显示为: 137****0969，隐藏中间 4 位，防止隐私泄露。</p><p>3，用户输入的 SQL 参数严格使用参数绑定或者 METADATA 字段值限定，防止 SQL 注入，禁止字符串拼接 SQL 访问数据库。</p><p>4，用户请求传入的任何参数必须做有效性验证。<br><strong>说明</strong>：忽略参数校验可能导致：</p><ul><li>page size 过大导致内存溢出</li><li>恶意 order by 导致数据库慢查询</li><li>任意重定向</li><li>SQL 注入</li><li>反序列化注入</li><li>正则输入源串拒绝服务 ReDoS</li></ul><p><strong>说明</strong>：Java 代码用正则来验证客户端的输入，有些正则写法验证普通用户输入没有问题，但是如果攻击人员使用的是特殊构造的字符串来验证，有可能导致死循环的结果。</p><p>5，禁止向 HTML 页面输出未经安全过滤或未正确转义的用户数据。</p><p>6，表单、 AJAX 提交必须执行 CSRF 安全验证。</p><p>7，在使用平台资源，譬如短信、邮件、电话、下单、支付，必须实现正确的防重放的机制，如数量限制、疲劳度控制、验证码校验，避免被滥刷而导致资损。</p><h1 id="MySQL-数据库"><a href="#MySQL-数据库" class="headerlink" title="MySQL 数据库"></a>MySQL 数据库</h1><h2 id="建表规约"><a href="#建表规约" class="headerlink" title="建表规约"></a>建表规约</h2><p>1，表达是与否概念的字段，必须使用 <code>is_xxx</code> 的方式命名，数据类型是 <code>unsigned tinyint</code>（1 表示是，0 表示否）。<br><strong>说明</strong>：任何字段如果为非负数，必须是 <code>unsigned</code>。<br>注意：POJO 类中的任何布尔类型的变量，都不要加 is 前缀，所以，需要在 <code>&lt;resultMap&gt;</code> 设置从 <code>is_xxx</code> 到 <code>Xxx</code> 的映射关系。数据库表示是与否的值，使用 <code>tinyint</code> 类型，坚持 <code>is_xxx</code> 的命名方式是为了明确其取值含义与取值范围。</p><p>2，表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只出现数字。</p><p>3，表名不使用复数名词。<strong>说明</strong>：表名应该仅仅表示表里面的实体内容，不应该表示实体数量，对应于 DO 类名也是单数形式，符合表达习惯。</p><p>4，禁用保留字，如 desc、range、match、delayed 等，请参考 MySQL 官方保留字。</p><p>5，主键索引名为 <code>pk_字段名</code>；唯一索引名为 <code>uk_字段名</code>；普通索引名则为 <code>idx_字段名</code>。<strong>说明</strong>：<code>pk_</code> 即 primary key；<code>uk_</code> 即 unique key；<code>idx_</code> 即 index 的简称。</p><p>6，小数类型为 <code>decimal</code>，禁止使用 <code>float</code> 和 <code>double</code> 。</p><p>7，如果存储的字符串长度几乎相等，使用 <code>char</code> 定长字符串类型。</p><p>8，<code>varchar</code> 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长度大于此值，定义字段类型为 <code>text</code>，独立出来一张表，用主键来对应，避免影响其它字段索引效率。</p><p>9，表必备三字段：<code>id</code>, <code>create_time</code>, <code>update_time</code>。<br><strong>说明</strong>：其中 <code>id</code> 必为主键，类型为 <code>bigint unsigned</code>、单表时自增、步长为 1。create_time, update_time 的类型均为 datetime 类型。</p><p>13，字段允许适当冗余，以提高查询性能，但必须考虑数据一致。冗余字段应遵循：</p><ul><li>不是频繁修改的字段。</li><li>不是 <code>varchar</code> 超长字段，更不能是 <code>text</code> 字段。</li><li>不是唯一索引的字段。<br>正例：商品类目名称使用频率高，字段长度短，名称基本一不变，可在相关联的表中冗余存储类目名称，避免关联查询。</li></ul><p>14，单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。</p><p>15，合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。<br>正例：如下表，其中无符号值可以避免误存负数，且扩大了表示范围。</p><table><thead><tr><th>对象</th><th>年龄区间</th><th>类型</th><th>字节</th><th>表示范围</th></tr></thead><tbody><tr><td>人</td><td>150 岁之内</td><td>tinyint unsigned</td><td>1</td><td>无符号值：0 到 255</td></tr><tr><td>龟</td><td>数百岁</td><td>smallint unsigned</td><td>2</td><td>无符号值：0 到 65535</td></tr><tr><td>恐龙化石</td><td>数千万年</td><td>int unsigned</td><td>4</td><td>无符号值：0 到约 42.9 亿</td></tr><tr><td>太阳</td><td>约 50 亿年</td><td>bigint unsigned</td><td>8</td><td>无符号值：0 到约 10 的 19 次方</td></tr></tbody></table><h2 id="索引规约"><a href="#索引规约" class="headerlink" title="索引规约"></a>索引规约</h2><p>1，业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。<br><strong>说明</strong>：不要以为唯一索引影响了 <code>insert</code> 速度，这个速度损耗可以忽略，但提高查找速度是明显的；另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生。</p><p>2，超过三个表禁止 <code>join</code> 。需要 <code>join</code> 的字段，数据类型必须绝对一致；多表关联查询时，保证被关联的字段需要有索引。<br><strong>说明</strong>：即使双表 <code>join</code> 也要注意表索引、SQL 性能。</p><p>3，在 <code>varchar</code> 字段上建立索引时，必须指定<strong><em>索引长度</em></strong>，没必要对全字段建立索引，根据实际文本区分度决定索引长度即可。<br><strong>说明</strong>：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会高达 90% 以上，可以使用 <code>count(distinct left(列名, 索引长度))/count(*)</code> 的区分度来确定。<br>Innodb 默认单列索引最大长度 767bytes，一般我们认为是 255 字符。</p><p>4，页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。<br><strong>说明</strong>：索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。</p><p>5，如果有 order by 的场景，请注意利用索引的有序性。order by 最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现 file_sort 的情况，影响查询性能。<br><strong>正例</strong>：<code>where a=? and b=? order by c;</code> 索引：<code>a_b_c</code><br><strong>反例</strong>：索引如果存在范围查询，那么索引有序性无法利用，如：<code>WHERE a&gt;10 ORDER BY b;</code> 索引 <code>a_b</code> 无法排序。</p><p>6，利用<strong><em>覆盖索引</em></strong>来进行查询操作，避免回表。<br><strong>说明</strong>：如果一本书需要知道第 11 章是什么标题，会翻开第 11 章对应的那一页吗？目录浏览一下就好，这个目录就是起到覆盖索引的作用。<br><strong>正例</strong>：能够建立索引的种类分为主键索引、唯一索引、普通索引三种，而覆盖索引只是一种查询的一种效果，用 <code>explain</code> 的结果，<code>extra</code> 列会出现：<code>using index</code>。</p><p>如果一个索引包含所有需要查询的字段的值，称之为“覆盖索引”。</p><p>由于覆盖索引必须要存储索引列的值，哈希索引、空间索引和全文索引都不存储列的值，MySQL 只有 B-Tree 索引可以做覆盖索引。如：对 id,name,title 三个字段建立索引，在索引中会存储这三个列的值，如果查询：<code>select id,name,title from table where id &lt; 10;</code> 通过 explain 会看到 extra 为 using index。<br>如果查询 <code>select * from table where id &lt; 10;</code> 就不会使用覆盖索引，因为索引中没有包含所有的列值。</p><p>7，利用延迟关联或者子查询优化超多分页场景。<br><strong>说明</strong>：MySQL 并不是跳过 <code>offset</code> 行，而是取 <code>offset+N</code> 行，然后返回放弃前 <code>offset</code> 行，返回 N 行，那当 <code>offset</code> 特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行 SQL 改写。<br><strong>正例</strong>：先快速定位需要获取的 id 段，然后再关联：</p><pre><code class="sql">SELECT a.* FROM 表 1 a, (select id from 表 1 where 条件 LIMIT 100000,20 ) b where a.id=b.id</code></pre><p>8，SQL 性能优化的目标：至少要达到 <code>range</code> 级别，要求是 <code>ref</code> 级别，如果可以是 <code>consts</code> 最好。<br><strong>说明</strong>：</p><ul><li><code>consts</code> 单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。</li><li><code>ref</code> 指的是使用普通的索引（normal index）。</li><li><code>range</code> 对索引进行范围检索。</li></ul><p><strong>反例</strong>：<code>explain</code> 表的结果，<code>type=index</code>，索引物理文件全扫描，速度非常慢，这个 <code>index</code> 级别比较 <code>range</code> 还低，与全表扫描是小巫见大巫。</p><p>9，建组合索引的时候，区分度最高的在最左边。<br><strong>正例</strong>：如果 <code>where a=? and b=?</code> ，如果 a 列的几乎接近于唯一值，那么只需要单建 <code>idx_a</code> 索引即可。<br><strong>说明</strong>：存在非等号和等号混合时，在建索引时，请把等号条件的列前置。如：<code>where c&gt;? and d=?</code> 那么即使 c 的区分度更高，也必须把 d 放在索引的最前列，即索引 <code>idx_d_c</code>。</p><p>10，防止因字段类型不同造成的<strong><em>隐式转换</em></strong>，导致索引失效。例如：varchar 条件需要加上 &#39;&#39; ，如果没加就有可能导致索引失效，<code>SELECT code FROM t WHERE code=86</code>，加上 &#39;&#39; 即可使用索引 <code>SELECT code FROM t WHERE code=&#39;86&#39;</code></p><p>11，创建索引时避免有如下极端误解：</p><ul><li>宁滥勿缺。认为一个查询就需要建一个索引。</li><li>宁缺勿滥。认为索引会消耗空间、严重拖慢记录的更新以及行的新增速度。</li><li>抵制惟一索引。认为业务的惟一性一律需要在应用层通过“先查后插”方式解决。</li></ul><h2 id="SQL-语句"><a href="#SQL-语句" class="headerlink" title="SQL 语句"></a>SQL 语句</h2><p>1，不要使用 <code>count(列名)</code> 或 <code>count(常量)</code> 来替代 <code>count(*)</code>，<code>count(*)</code> 是 SQL92 定义的标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。<br><strong>说明</strong>：<code>count(*)</code> 会统计值为 NULL 的行，<strong>而 <code>count(列名)</code> 不会统计此列为 NULL 值的行</strong>。</p><p>2，<code>count(distinct col)</code> 计算该列除 NULL 之外的不重复行数，注意 <code>count(distinct col1, col2)</code> 如果其中一列全为 NULL，那么即使另一列有不同的值，也返回为 0。</p><p>3，当某一列的值全是 NULL 时，<code>count(col)</code> 的返回结果为 0，但 <code>sum(col)</code> 的返回结果为 <code>NULL</code>，因此<strong>使用 <code>sum()</code> 时需注意 <code>NPE</code> 问题</strong>。<br><strong>正例</strong>：使用如下方式来避免 sum 的 NPE 问题：<code>SELECT IFNULL(SUM(column), 0) FROM table;</code></p><p>4，使用 <code>ISNULL()</code> 来判断是否为 <code>NULL</code> 值。<br><strong>说明</strong><code>：NULL</code> 与任何值的直接比较都为 <code>NULL</code>。</p><ul><li><code>NULL&lt;&gt;NULL</code> 的返回结果是 NULL，而不是 false。</li><li><code>NULL=NULL</code> 的返回结果是 NULL，而不是 true。</li><li><code>NULL&lt;&gt;1</code> 的返回结果是 NULL，而不是 true。</li></ul><p>5，代码中写分页查询逻辑时，若 <code>count</code> 为 <code>0</code> 应直接返回，避免执行后面的分页语句。</p><p>6，不得使用外键与级联，一切外键概念必须在应用层解决。<br><strong>说明</strong>：以学生和成绩的关系为例，学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，即为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。</p><p>7，禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。</p><p>8，数据订正（特别是删除、修改记录操作）时，要先 <code>select</code>，避免出现误删除，确认无误才能执行更新语句。</p><p>9，in 操作能避免则避免，若实在避免不了，需要仔细评估 in 后边的集合元素数量，控制在 1000 个之内。</p><p>10，如果有国际化需要，所有的字符存储与表示，均以 utf-8 编码，注意字符统计函数的区别。</p><pre><code class="sql">-- 说明SELECT LENGTH(&quot;轻松工作&quot;)； -- 返回为 12SELECT CHARACTER_LENGTH(&quot;轻松工作&quot;)； -- 返回为 4</code></pre><h2 id="ORM-映射"><a href="#ORM-映射" class="headerlink" title="ORM 映射"></a>ORM 映射</h2><p>1，在表查询中，一律不要使用 * 作为查询的字段列表，需要哪些字段必须明确写明。<br><strong>说明</strong>：</p><ul><li>增加查询分析器解析成本。</li><li>增减字段容易与 <code>resultMap</code> 配置不一致。</li><li>无用字段增加网络消耗，尤其是 text 类型的字段。</li></ul><p>2，POJO 类的布尔属性不能加 is，而数据库字段必须加 <code>is_</code>，要求在 <code>resultMap</code> 中进行字段与属性之间的映射。<br><strong>说明</strong>：参见定义 POJO 类以及数据库字段定义规定，在 <code>&lt;resultMap&gt;</code> 中增加映射，是必须的。在 MyBatis Generator 生成的代码中，需要进行对应的修改。</p><p>3，不要用 <code>resultClass</code> 当返回参数，即使所有类属性名与数据库字段一一对应，也需要定义；反过来，每一个表也必然有一个 POJO 类与之对应。<br><strong>说明</strong>：配置映射关系，使字段与 <code>DO</code> 类解耦，方便维护。</p><p>4，<code>sql.xml</code> 配置参数使用：<code>#{}</code>，<code>#param#</code> 不要使用 <code>${}</code> 此种方式容易出现 SQL 注入。</p><p>6，不允许直接拿 <code>HashMap</code> 与 <code>Hashtable</code> 作为查询结果集的输出。<br><strong>说明</strong>：<code>resultClass=&quot;Hashtable&quot;</code>，会置入字段名和属性值，但是值的类型不可控。</p><p>7，更新数据表记录时，必须同时更新记录对应的 <code>gmt_modified</code> 字段值为当前时间。</p><p>8，不要写一个大而全的数据更新接口。传入为 POJO 类，不管是不是自己的目标更新字段，都进行 <code>update table set c1=value1,c2=value2,c3=value3;</code> 这是不对的。执行 SQL 时，不要更新无改动的字段，一是易出错；二是效率低；三是增加 binlog 存储。</p><p>9，<code>@Transactional</code> 事务不要滥用。事务会影响数据库的 QPS，另外使用事务的地方需要考虑各方面的回滚方案，包括缓存回滚、搜索引擎回滚、消息补偿、统计修正等。</p><h1 id="工程结构"><a href="#工程结构" class="headerlink" title="工程结构"></a>工程结构</h1><h2 id="应用分层"><a href="#应用分层" class="headerlink" title="应用分层"></a>应用分层</h2><p>1，图中默认上层依赖于下层，箭头关系表示可直接依赖，如：开放接口层可以依赖于 Web 层，也可以直接依赖于 Service 层，依此类推：</p><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20191130162652.png" alt=""></p><ul><li>开放接口层：可直接封装 Service 方法暴露成 RPC 接口；通过 Web 封装成 http 接口；进行网关安全控制、流量控制等。</li><li>终端显示层：各个端的模板渲染并执行显示的层。当前主要是 velocity 渲染，JS 渲染，JSP 渲染，移动端展示等。</li><li>Web 层：主要是对访问控制进行转发，各类基本参数校验，或者不复用的业务简单处理等。</li><li>Service 层：相对具体的业务逻辑服务层。</li><li>Manager 层：通用业务处理层，它有如下特征：<br>  1） 对第三方平台封装的层，预处理返回结果及转化异常信息。<br>  2） 对 Service 层通用能力的下沉，如缓存方案、中间件通用处理。<br>  3） 与 DAO 层交互，对多个 DAO 的组合复用。</li><li>DAO 层：数据访问层，与底层 MySQL、Oracle、Hbase 等进行数据交互。</li><li>外部接口或第三方平台：包括其它部门 RPC 开放接口，基础平台，其它公司的 HTTP 接口。</li></ul><p>2，（分层异常处理规约） 在 DAO 层，产生的异常类型有很多，无法用细粒度的异常进行 catch ，使用 catch(Exception e) 方式，并 throw new DAOException(e) ，不需要打印日志，因为日志在 Manager / Service 层一定需要捕获并打印到日志文件中去，如果同台服务器再打日志，浪费性能和存储。在 Service 层出现异常时，必须记录出错日志到磁盘，尽可能带上参数信息，相当于保护案发现场。如果 Manager 层与 Service 同机部署，日志方式与 DAO 层处理一致，如果是单独部署，则采用与 Service 一致的处理方式。 Web 层绝不应该继续往上抛异常，因为已经处于顶层，如果意识到这个异常将导致页面无法正常渲染，那么就应该直接跳转到友好错误页面，加上用户容易理解的错误提示信息。开放接口层要将异常处理成错误码和错误信息方式返回。</p><p>3，分层领域模型规约：</p><ul><li><code>DO</code>（Data Object）：此对象与数据库表结构一一对应，通过 DAO 层向上传输数据源对象。</li><li><code>DTO</code>（Data Transfer Object）：数据传输对象，Service 或 Manager 向外传输的对象。</li><li><code>BO</code>（Business Object）：业务对象，由 Service 层输出的封装业务逻辑的对象。</li><li><code>AO</code>（Application Object）：应用对象，在 Web 层与 Service 层之间抽象的复用对象模型，极为贴近展示层，复用度不高。</li><li><code>VO</code>（View Object）：显示层对象，通常是 Web 向模板渲染引擎层传输的对象。</li><li><code>Query</code>：数据查询对象，各层接收上层的查询请求。注意超过 2 个参数的查询封装，禁止使用 Map 类来传输。</li></ul><h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><p>1，高并发服务器建议调小 TCP 协议的 <code>time_wait</code> 超时时间。<br><strong>说明</strong>：操作系统默认 240 秒后，才会关闭处于 <code>time_wait</code> 状态的连接，在高并发访问下，服务器端会因为处于 <code>time_wait</code> 的连接数太多，可能无法建立新的连接，所以需要在服务器上调小此等待值。<br><strong>正例</strong>：在 linux 服务器上请通过变更 <code>/etc/sysctl.conf</code> 文件去修改该缺省值（秒）：<br><code>net.ipv4.tcp_fin_timeout = 30</code></p><p>2，调大服务器所支持的<code>最大文件句柄数</code>（File Descriptor，简写为 fd）。<br><strong>说明</strong>：主流操作系统的设计是将 TCP/UDP 连接采用与文件一样的方式去管理，即一个连接对应于一个 fd。主流的 linux 服务器默认所支持最大 fd 数量为 <code>1024</code>，当并发连接数很大时很容易因为 fd 不足而出现“open too many files”错误，导致新的连接无法建立。建议将 linux 服务器所支持的最大句柄数调高数倍（与服务器的内存数量相关）。</p><p>3，给 JVM 环境参数设置 <code>-XX:+HeapDumpOnOutOfMemoryError</code> 参数，让 JVM 碰到 OOM 场景时输出 dump 信息。<br><strong>说明</strong>：OOM 的发生是有概率的，甚至相隔数月才出现一例，出错时的堆内信息对解决问题非常有帮助。</p><p>4，在线上生产环境， JVM 的 <code>Xms</code> 和 <code>Xmx</code> 设置一样大小的内存容量，避免在 GC 后调整堆大小带来的压力。</p><p>5，服务器内部重定向使用 <code>forward</code>；外部重定向地址使用 URL 拼装工具类来生成，否则会带来 URL 维护不一致的问题和潜在的安全风险。</p><h1 id="设计规约"><a href="#设计规约" class="headerlink" title="设计规约"></a>设计规约</h1><p>3，如果某个业务对象的状态超过 3 个，使用状态图来表达并且明确状态变化的各个触发条件。<br><strong>说明</strong>：状态图的核心是对象状态，首先明确对象有多少种状态，然后明确两两状态之间是否存在直接转换关系，再明确触发状态转换的条件是什么。<br><strong>正例</strong>：淘宝订单状态有已下单、待付款、已付款、待发货、已发货、已收货等。比如已下单与已收货这两种状态之间是不可能有直接转换关系的。</p><p>4，如果系统中某个功能的调用链路上的涉及对象超过 3 个，使用时序图来表达并且明确各调用环节的输入与输出。<br><strong>说明</strong>：时序图反映了一系列对象间的交互与协作关系，清晰立体地反映系统的调用纵深链路。</p><p>5，如果系统中模型类超过 5 个，并且存在复杂的依赖关系，使用类图来表达并且明确类之间的关系。<br><strong>说明</strong>：类图像建筑领域的施工图，如果搭平房，可能不需要，但如果建造蚂蚁 Z 空间大楼，肯定需要详细的施工图。</p><p>6，如果系统中超过 2 个对象之间存在协作关系，并且需要表示复杂的处理流程，使用活动图来表示。<br><strong>说明</strong>：活动图是流程图的扩展，增加了能够体现协作关系的对象泳道，支持表示并发等。</p><p>7，需求分析与系统设计在考虑主干功能的同时，需要充分评估异常流程与业务边界。<br><strong>反例</strong>：用户在淘宝付款过程中，银行扣款成功，发送给用户扣款成功短信，但是支付宝入款时由于断网演练产生异常，淘宝订单页面依然显示未付款，导致用户投诉。</p><p>8，类在设计与实现时要符合单一原则。<br><strong>说明</strong>：单一原则最易理解却是最难实现的一条规则，随着系统演进，很多时候，忘记了类设计的初衷。</p><p>9，谨慎使用继承的方式来进行扩展，优先使用聚合/组合的方式来实现。<br><strong>说明</strong>：不得已使用继承的话，必须符合里氏代换原则，此原则说父类能够出现的地方子类一定能够出现，比如，“把钱交出来”，钱的子类美元、欧元、人民币等都可以出现。</p><p>10，系统设计时，根据依赖倒置原则，尽量依赖抽象类与接口，有利于扩展与维护。<br><strong>说明</strong>：低层次模块依赖于高层次模块的抽象，方便系统间的解耦。</p><p>11，系统设计时，注意对扩展开放，对修改闭合。<br><strong>说明</strong>：极端情况下，交付线上生产环境的代码都是不可修改的，同一业务域内的需求变化，通过模块或类的扩展来实现。</p><p>12，系统设计阶段，共性业务或公共行为抽取出来公共模块、公共配置、公共类、公共方法等，避免出现重复代码或重复配置的情况。<br><strong>说明</strong>：随着代码的重复次数不断增加，维护成本指数级上升。</p><p>14，系统设计主要目的是明确需求、理顺逻辑、后期维护，次要目的用于指导编码。<br><strong>说明</strong>：避免为了设计而设计，系统设计文档有助于后期的系统维护和重构，所以设计结果需要进行分类归档保存。</p><p>15，设计的本质就是识别和表达系统难点，找到系统的变化点，并隔离变化点。<br><strong>说明</strong>：世间众多设计模式目的是相同的，即隔离系统变化点。</p><p>16，系统架构设计的目的：</p><ul><li>确定系统边界。确定系统在技术层面上的做与不做。</li><li>确定系统内模块之间的关系。确定模块之间的依赖关系及模块的宏观输入与输出。</li><li>确定指导后续设计与演化的原则。使后续的子系统或模块设计在规定的框架内继续演化。</li><li>确定非功能性需求。非功能性需求是指安全性、可用性、可扩展性等。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis 07-高级查询</title>
      <link href="/2019/11/17/MyBatis%2007-%E9%AB%98%E7%BA%A7%E6%9F%A5%E8%AF%A2/"/>
      <url>/2019/11/17/MyBatis%2007-%E9%AB%98%E7%BA%A7%E6%9F%A5%E8%AF%A2/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="http://www.broadview.com.cn/book/3643" target="_blank" rel="noopener">http://www.broadview.com.cn/book/3643</a><br><a href="https://github.com/mybatis-book/book" target="_blank" rel="noopener">https://github.com/mybatis-book/book</a></p></blockquote><h2 id="一对一映射"><a href="#一对一映射" class="headerlink" title="一对一映射"></a>一对一映射</h2><h3 id="使用自动映射处理一对一关系"><a href="#使用自动映射处理一对一关系" class="headerlink" title="使用自动映射处理一对一关系"></a>使用自动映射处理一对一关系</h3><p>假设<strong>一个用户只有一个角色</strong></p><pre><code class="java">public class SysUser {    private Long id;    private String userName;    private String userPassword;    private String userEmail;    /**     * 用户角色     */    private SysRole role;    // ...}</code></pre><p>MyBatis 支持多层嵌套，role.roleName 将会绑定到 role 对象的 roleName 属性上。</p><pre><code class="xml">&lt;select id=&quot;selectUserAndRoleById&quot; resultType=&quot;tk.mybatis.simple.model.SysUser&quot;&gt;    select        u.id,        u.user_name userName,        u.user_password userPassword,        u.user_email userEmail,        r.id &quot;role.id&quot;,        r.role_name &quot;role.roleName&quot;,        r.enabled &quot;role.enabled&quot;,        r.create_by &quot;role.createBy&quot;,        r.create_time &quot;role.createTime&quot;    from sys_user u    inner join sys_user_role ur on u.id = ur.user_id    inner join sys_role r on ur.role_id = r.id    where u.id = #{id}&lt;/select&gt;</code></pre><h3 id="使用-resultMap-配置一对一映射"><a href="#使用-resultMap-配置一对一映射" class="headerlink" title="使用 resultMap 配置一对一映射"></a>使用 resultMap 配置一对一映射</h3><pre><code class="xml">&lt;resultMap id=&quot;userMap&quot; type=&quot;tk.mybatis.simple.model.SysUser&quot;&gt;    &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;    &lt;result property=&quot;userName&quot; column=&quot;user_name&quot;/&gt;    &lt;result property=&quot;userPassword&quot; column=&quot;user_password&quot;/&gt;    &lt;result property=&quot;userEmail&quot; column=&quot;user_email&quot;/&gt;    &lt;!-- role 部分，避免列名重复，可能重复的列名增加了 &quot;role_&quot; 前缀，并在 SQL 中设置别名 --&gt;    &lt;result property=&quot;role.id&quot; column=&quot;role_id&quot;/&gt;    &lt;result property=&quot;role.roleName&quot; column=&quot;role_name&quot;/&gt;    &lt;result property=&quot;role.enabled&quot; column=&quot;enabled&quot;/&gt;    &lt;result property=&quot;role.createBy&quot; column=&quot;create_by&quot;/&gt;    &lt;result property=&quot;role.createTime&quot; column=&quot;role_create_time&quot; jdbcType=&quot;TIMESTAMP&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;selectUserAndRoleById2&quot; resultMap=&quot;userRoleMap&quot;&gt;    select        u.id,        u.user_name,        u.user_password,        u.user_email,        r.id role_id,        r.role_name role_name,        r.enabled enabled,        r.create_by create_by,        r.create_time role_create_time    from sys_user u    inner join sys_user_role ur on u.id = ur.user_id    inner join sys_role r on ur.role_id = r.id    where u.id = #{id}&lt;/select&gt;</code></pre><p>相比自动映射，这样会更麻烦。<br>可简单的部分，MyBatis 支持 resultMap 映射继承的。</p><pre><code class="xml">&lt;resultMap id=&quot;userMap&quot; type=&quot;tk.mybatis.simple.model.SysUser&quot;&gt;    &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;    &lt;result property=&quot;userName&quot; column=&quot;user_name&quot;/&gt;    &lt;result property=&quot;userPassword&quot; column=&quot;user_password&quot;/&gt;    &lt;result property=&quot;userEmail&quot; column=&quot;user_email&quot;/&gt;    &lt;result property=&quot;userInfo&quot; column=&quot;user_info&quot;/&gt;    &lt;result property=&quot;headImg&quot; column=&quot;head_img&quot; jdbcType=&quot;BLOB&quot;/&gt;    &lt;result property=&quot;createTime&quot; column=&quot;create_time&quot; jdbcType=&quot;TIMESTAMP&quot;/&gt;&lt;/resultMap&gt;&lt;resultMap id=&quot;userRoleMap&quot; extends=&quot;userMap&quot; type=&quot;tk.mybatis.simple.model.SysUser&quot;&gt;    &lt;result property=&quot;role.id&quot; column=&quot;role_id&quot;/&gt;    &lt;result property=&quot;role.roleName&quot; column=&quot;role_name&quot;/&gt;    &lt;result property=&quot;role.enabled&quot; column=&quot;enabled&quot;/&gt;    &lt;result property=&quot;role.createBy&quot; column=&quot;create_by&quot;/&gt;    &lt;result property=&quot;role.createTime&quot; column=&quot;role_create_time&quot; jdbcType=&quot;TIMESTAMP&quot;/&gt;&lt;/resultMap&gt;</code></pre><h3 id="使用-resultMap-的-association-标签配置一对一映射"><a href="#使用-resultMap-的-association-标签配置一对一映射" class="headerlink" title="使用 resultMap 的 association 标签配置一对一映射"></a>使用 resultMap 的 association 标签配置一对一映射</h3><p>修改上面的配置</p><pre><code class="xml">&lt;resultMap id=&quot;userRoleMap&quot; extends=&quot;userMap&quot; type=&quot;tk.mybatis.simple.model.SysUser&quot;&gt;    &lt;association property=&quot;role&quot; columnPrefix=&quot;role_&quot; javaType=&quot;tk.mybatis.simple.model.SysRole&quot;/&gt;    &lt;result property=&quot;id&quot; column=&quot;id&quot;/&gt;    &lt;result property=&quot;roleName&quot; column=&quot;role_name&quot;/&gt;    &lt;result property=&quot;enabled&quot; column=&quot;enabled&quot;/&gt;    &lt;result property=&quot;createBy&quot; column=&quot;create_by&quot;/&gt;    &lt;result property=&quot;createTime&quot; column=&quot;create_time&quot; jdbcType=&quot;TIMESTAMP&quot;/&gt;&lt;/resultMap&gt;</code></pre><p>association 标签包含以下属性：</p><ul><li>property：对应实体类中的属性名</li><li>javaType：属性对应的 Java 类型</li><li>resultMap：可以直接使用现有的 resultMap，而不需要在这里配置</li><li>columnPrefix：查询列的前缀，配置前缀后，在子标签配置 result 的 column 时可以省略前缀</li></ul><pre><code class="xml">&lt;!-- 将 sys_role 相关所有列的别名修改为 &quot;role_&quot; 前缀 --&gt;&lt;select id=&quot;selectUserAndRoleById2&quot; resultMap=&quot;userRoleMap&quot;&gt;    select        u.id,        u.user_name,        u.user_password,        u.user_email,        r.id role_id,        r.role_name role_role_name,        r.enabled role_enabled,        r.create_by role_create_by,        r.create_time role_create_time    from sys_user u    inner join sys_user_role ur on u.id = ur.user_id    inner join sys_role r on ur.role_id = r.id    where u.id = #{id}&lt;/select&gt;</code></pre><p>使用 <code>association</code> 配置 resultMap 属性配置一个已经存在的 resultMap 映射。</p><pre><code class="xml">&lt;!-- 这个应该放到 RoleMapper.xml 更合理 --&gt;&lt;resultMap id=&quot;roleMap&quot; type=&quot;tk.mybatis.simple.model.SysRole&quot;&gt;    &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;    &lt;result property=&quot;roleName&quot; column=&quot;role_name&quot;/&gt;    &lt;result property=&quot;enabled&quot; column=&quot;enabled&quot;/&gt;    &lt;result property=&quot;createBy&quot; column=&quot;create_by&quot;/&gt;    &lt;result property=&quot;createTime&quot; column=&quot;create_time&quot; jdbcType=&quot;TIMESTAMP&quot;/&gt;&lt;/resultMap&gt;&lt;!-- 这里还是在 UserMapper.xml 中，所有需要加上 roleMap 的命名空间 --&gt;&lt;resultMap id=&quot;userRoleMap&quot; extends=&quot;userMap&quot; type=&quot;tk.mybatis.simple.model.SysUser&quot;&gt;    &lt;association property=&quot;role&quot; columnPrefix=&quot;role_&quot; resultMap=&quot;tk.mybatis.simple.mapper.RoleMapper.roleMap&quot;/&gt;&lt;/resultMap&gt;</code></pre><h3 id="association-标签的嵌套查询"><a href="#association-标签的嵌套查询" class="headerlink" title="association 标签的嵌套查询"></a>association 标签的嵌套查询</h3><p>association 标签的嵌套查询常用的属性如下：</p><ul><li><code>select</code>：另一个映射查询的 id，MyBatis 会额外执行这个查询获取嵌套对象的结果</li><li><code>column</code>：列名，将主查询中列的结果作为嵌套查询的参数，配置方式：<code>column={prop1=col1, prop2=col2}</code>，prop1，prop2 将作为嵌套查询的参数</li><li><code>fetchType</code>：数据加载方式，可选值为 <code>lazy</code> 和 <code>eager</code>，分别为延迟加载和积极加载，将覆盖全局配置 <code>lazyLoadingEnabled</code></li></ul><pre><code class="xml">&lt;resultMap id=&quot;userRoleMapSelect&quot; extends=&quot;userMap&quot; type=&quot;tk.mybatis.simple.model.SysUser&quot;&gt;    &lt;association property=&quot;role&quot; fetchType=&quot;lazy&quot;                    select=&quot;tk.mybatis.simple.mapper.RoleMapper.selectRoleById&quot;                    column=&quot;{id=role_id}&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;selectUserAndRoleByIdSelect&quot; resultMap=&quot;userRoleMapSelect&quot;&gt;    select        u.id,        u.user_name,        u.user_password,        u.user_email,        u.user_info,        u.head_img,        u.create_time,        ur.role_id    from sys_user u    inner join sys_user_role ur on u.id = ur.user_id    where u.id = #{id}&lt;/select&gt;&lt;!-- RoleMapper.xml --&gt;&lt;select id=&quot;selectRoleById&quot; resultMap=&quot;roleMap&quot;&gt;    select * from sys_role where id = #{id}&lt;/select&gt;</code></pre><p>嵌套查询会多执行 SQL，查询出来的 N 条数据，就会执行 N+1 次查询，设置 <code>fetchType=&quot;lazy&quot;</code>，这样只有调用 getRole() 方法时，才会去执行嵌套查询。</p><p>另外还需设置 <code>aggressiveLazyLoading</code> 才会生效，在 mybatis-config.xml 中添加配置：</p><pre><code class="xml">&lt;settings&gt;    &lt;!-- 当开启时，任何方法的调用都会加载该对象的所有属性。否则，每个属性会按需加载 --&gt;    &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt;&lt;/settings&gt;</code></pre><p>在和 spring 集成时，要确保只能在 Service 层调用延迟加载的属性，因为在 Control 层获取延迟加载的属性值，会因为 SqlSession 已经关闭而报错。</p><p>另外 MyBatis 还提供了 <code>lazyLoadTriggerMethods</code> 参数，指定哪个对象的方法触发一次延迟加载，默认值：<code>equals,clone,hashCode,toString</code>。如执行了 equals 方法就会加载数据。</p><h2 id="一对多映射"><a href="#一对多映射" class="headerlink" title="一对多映射"></a>一对多映射</h2><h3 id="collection-集合的嵌套结果映射"><a href="#collection-集合的嵌套结果映射" class="headerlink" title="collection 集合的嵌套结果映射"></a>collection 集合的嵌套结果映射</h3><p>和 association 类似，集合的嵌套结果映射就是指通过一次 SQL 查询将所有的结果查询出来，然后通过配置的结果映射，将数据映射到不同的对象中去。</p><pre><code class="java">public class SysUser {    // 原有属性    private List&lt;SysRole&gt; roleList;    // setter getter}</code></pre><pre><code class="xml">&lt;resultMap id=&quot;userRoleListMap&quot; extends=&quot;userMap&quot; type=&quot;tk.mybatis.simple.model.SysUser&quot;&gt;    &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;    &lt;result property=&quot;userName&quot; column=&quot;user_name&quot;/&gt;    &lt;result property=&quot;userPassword&quot; column=&quot;user_password&quot;/&gt;    &lt;result property=&quot;userEmail&quot; column=&quot;user_email&quot;/&gt;    &lt;result property=&quot;userInfo&quot; column=&quot;user_info&quot;/&gt;    &lt;result property=&quot;headImg&quot; column=&quot;head_img&quot; jdbcType=&quot;BLOB&quot;/&gt;    &lt;result property=&quot;createTime&quot; column=&quot;create_time&quot; jdbcType=&quot;TIMESTAMP&quot;/&gt;    &lt;collection property=&quot;roleList&quot; columnPrefix=&quot;role_&quot; javaType=&quot;tk.mybatis.simple.model.SysRole&quot;&gt;        &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;        &lt;result property=&quot;roleName&quot; column=&quot;role_name&quot;/&gt;        &lt;result property=&quot;enabled&quot; column=&quot;enabled&quot;/&gt;        &lt;result property=&quot;createBy&quot; column=&quot;create_by&quot;/&gt;        &lt;result property=&quot;createTime&quot; column=&quot;create_time&quot; jdbcType=&quot;TIMESTAMP&quot;/&gt;    &lt;/collection&gt;&lt;/resultMap&gt;</code></pre><p>只是把上文 [使用 resultMap 的 association 标签配置一对一映射] 中 <code>association</code> 改成 <code>collection</code>。</p><p>collection 支持的属性以及属性的作用和 association 完全相同。</p><pre><code class="xml">&lt;!-- 使用 extends，简化 resultMap --&gt;&lt;resultMap id=&quot;userRoleListMap&quot; extends=&quot;userMap&quot; type=&quot;tk.mybatis.simple.model.SysUser&quot;&gt;    &lt;collection property=&quot;roleList&quot; columnPrefix=&quot;role_&quot;                resultMap=&quot;tk.mybatis.simple.mapper.RoleMapper.roleMap&quot;/&gt;&lt;/resultMap&gt;</code></pre><p>仿照 selectUserAndRoleById2 方法，创建 selectAllUserAndRoles</p><pre><code class="xml">&lt;select id=&quot;selectAllUserAndRoles&quot; resultMap=&quot;userRoleListMap&quot;&gt;    select        u.id, u.user_name,        u.user_password, u.user_email,        u.user_info, u.head_img, u.create_time,        r.id role_id,        r.role_name role_role_name,        r.enabled role_enabled,        r.create_by role_create_by,        r.create_time role_create_time    from sys_user u    inner join sys_user_role ur on u.id = ur.user_id    inner join sys_role r on ur.role_id = r.id&lt;/select&gt;</code></pre><p>admin 用户，对应角色：管理员，普通用户<br>test 用户，对应角色：普通用户</p><p>SQL 执行结果数有 3 条，通过 selectAllUserAndRoles 查询出来用户数是 2。</p><p>MyBatis 在处理结果的时候，会判断结果是否相同，如果是相同的结果，则只会保留第一个结果。MyBatis 判断结果是否相同时，最简单的情况就是在映射配置中至少有一个 id 标签，在 userMap 中配置如下：</p><pre><code class="xml">&lt;id property=&#39;id&#39; column=&#39;id&#39;&gt;</code></pre><p>当配置 id 标签时，MyBatis 只需要逐条比较所以数据中 id 标签配置的字段值是否相同即可。在配置嵌套结果查询时，配置 id 标签可以提高处理效率。</p><p>在嵌套结果配置 id 属性时，如果查询语句中没有查询 id 属性配置的列，会导致 id 对应的值未 null，所有值 id 都相同，会使嵌套集合中只有一条数据。所以查询语句中必须包含该列。</p><p>如果将 id 标签改为 result，MyBatis 会对所有字段进行比较，当字段数为 M，查询结果为 N 条时，需要进行 M*N 次比较。</p><p>如果要配置一个相当复杂的映射，一定要从基础映射开始配置，每增加一些配置就进行对应的测试，在循序渐进的过程中更容易发现和解决问题。</p><h3 id="collection-集合的嵌套查询"><a href="#collection-集合的嵌套查询" class="headerlink" title="collection 集合的嵌套查询"></a>collection 集合的嵌套查询</h3><p>和 association 相似</p><p>有一个新的 <code>ofType</code> 属性。这个属性非常重要，它用来将 JavaBean（或字段）属性的类型和集合存储的类型区分开来。</p><pre><code class="xml">&lt;!-- PrivilegeMapper.xml --&gt;&lt;resultMap id=&quot;privilegeMap&quot; type=&quot;tk.mybatis.simple.model.SysPrivilege&quot;&gt;    &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;    &lt;result property=&quot;privilegeName&quot; column=&quot;privilege_name&quot;/&gt;    &lt;result property=&quot;privilegeUrl&quot; column=&quot;privilege_url&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;selectPrivilegeByRoleId&quot; resultMap=&quot;privilegeMap&quot;&gt;    select p.*    from sys_privilege p    inner join sys_role_privilege rp on rp.privilege_id = p.id    where role_id = #{roleId}&lt;/select&gt;</code></pre><pre><code class="xml">&lt;!-- RoleMapper.xml collection 中的 javaType 和 ofType 可以省略--&gt;&lt;resultMap id=&quot;rolePrivilegeListMapSelect&quot; extends=&quot;roleMap&quot; type=&quot;tk.mybatis.simple.model.SysRole&quot;&gt;    &lt;collection property=&quot;privilegeList&quot;                fetchType=&quot;lazy&quot;                ofType=&quot;tk.mybatis.simple.model.SysPrivilege&quot;                javaType=&quot;ArrayList&quot;                select=&quot;tk.mybatis.simple.mapper.PrivilegeMapper.selectPrivilegeByRoleId&quot;                column=&quot;{roleId=id}&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;selectRoleByUserId&quot; resultMap=&quot;rolePrivilegeListMapSelect&quot;&gt;    select        r.id, r.role_name, r.enabled,        r.create_by, r.create_time    from sys_role r    inner join sys_user_role ur on ur.role_id = r.id    where ur.user_id = #{userId}&lt;/select&gt;</code></pre><pre><code class="xml">&lt;!-- UserMapper.xml --&gt;&lt;resultMap id=&quot;userRoleListMapSelect&quot; extends=&quot;userMap&quot; type=&quot;tk.mybatis.simple.model.SysUser&quot;&gt;    &lt;collection property=&quot;roleList&quot;                fetchType=&quot;lazy&quot;                ofType=&quot;tk.mybatis.simple.model.SysRole&quot;                select=&quot;tk.mybatis.simple.mapper.RoleMapper.selectRoleByUserId&quot;                column=&quot;{userId=id}&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;selectAllUserAndRolesSelect&quot; resultMap=&quot;userRoleListMapSelect&quot;&gt;    select        u.id, u.user_name, u.user_password,        u.user_email, u.user_info,        u.head_img, u.create_time    from sys_user u    where u.id = #{id}&lt;/select&gt;</code></pre><h2 id="鉴别器映射"><a href="#鉴别器映射" class="headerlink" title="鉴别器映射"></a>鉴别器映射</h2><p>鉴别器很像 Java 中的 switch 语句</p><p>discriminator 标签常用的两个属性：</p><ul><li>column：该属性用于设置要进行鉴别比较值的列</li><li>javaType：该属性用于指定列的类型，保证使用相同的 Java 类型来比较值。</li></ul><p>discriminator 标签可以有 1 个或者多个 case 标签，case 标签包含以下三个属性：</p><ul><li>value：该值未 discriminator 指定 column 用来匹配的值。</li><li>resultMap：当 column 的值和 value 的值匹配时，可以配置使用 resultMap 指定的映射，resultMap 优先级 高于 resultType。</li><li>resultType：当 column 的值和 value 的值匹配时，用于配置使用 resultType 指定的映射。</li></ul><pre><code class="xml">&lt;resultMap id=&quot;rolePrivilegeListMapChoose&quot; type=&quot;tk.mybatis.simple.model.SysRole&quot;&gt;    &lt;discriminator column=&quot;enabled&quot; javaType=&quot;int&quot;&gt;        &lt;case value=&quot;1&quot; resultMap=&quot;rolePrivilegeListMapSelect&quot;/&gt;        &lt;case value=&quot;0&quot; resultMap=&quot;roleMap&quot;/&gt;    &lt;/discriminator&gt;&lt;/resultMap&gt;</code></pre><p>角色的属性 enable 值为 1 的时候表示状态可用，为 0 不可用。当不可用时，只能获取角色的基本信息，不能获得角色的权限信息。</p><pre><code class="xml">&lt;select id=&quot;selectRoleByUserIdChoose&quot; resultMap=&quot;rolePrivilegeListMapChoose&quot;&gt;    select        r.id, r.role_name, r.enabled,        r.create_by, r.create_time    from sys_role r    inner join sys_user_role ur on ur.role_id = r.id    where ur.user_id = #{userId}&lt;/select&gt;</code></pre><p>鉴别器特殊的地方</p><pre><code class="xml">&lt;resultMap id=&quot;rolePrivilegeListMapChoose&quot; type=&quot;tk.mybatis.simple.model.SysRole&quot;&gt;    &lt;discriminator column=&quot;enabled&quot; javaType=&quot;int&quot;&gt;        &lt;case value=&quot;1&quot; resultMap=&quot;rolePrivilegeListMapSelect&quot;/&gt;        &lt;case value=&quot;0&quot; resultType=&quot;SysRole&quot;&gt;            &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;            &lt;result property=&quot;roleName&quot; column=&quot;role_name&quot;/&gt;        &lt;/case&gt;    &lt;/discriminator&gt;&lt;/resultMap&gt;</code></pre><p>使用 resultType，并在 case 中配置了两个属性的映射，这时 MyBatis 只会对列举出来的配置进行映射，不像使用 resultMap 配置时会自动映射其他的字段。</p><p>鉴别器很少使用，尽可能避免使用。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis 06-代码生成器</title>
      <link href="/2019/11/17/MyBatis%2006-%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/"/>
      <url>/2019/11/17/MyBatis%2006-%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="http://www.broadview.com.cn/book/3643" target="_blank" rel="noopener">http://www.broadview.com.cn/book/3643</a></p></blockquote><p>Mybatis Generator 文档：<a href="http://mybatis.org/generator/" target="_blank" rel="noopener">http://mybatis.org/generator/</a></p><p>这里只讨论 <code>MyBatis3Simple</code></p><h1 id="maven-配置"><a href="#maven-配置" class="headerlink" title="maven 配置"></a>maven 配置</h1><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt;    &lt;version&gt;1.3.3&lt;/version&gt;&lt;/dependency&gt;</code></pre><h1 id="generatorConfig-xml"><a href="#generatorConfig-xml" class="headerlink" title="generatorConfig.xml"></a>generatorConfig.xml</h1><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration        PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt;    &lt;!-- properties 标签用于指定一个需要在配置中解析使用的外部属性文件，之后可以在配置中使用 ${property} 的方式引用，最多配置一个，包含 resource 和 url 两个属性，    resource：指定 classpath 下的属性文件    url：指定文件系统上的特定位置 --&gt;    &lt;!-- &lt;properties resource=&quot;&quot;/&gt; --&gt;    &lt;!-- &lt;classPathEntry location=&quot;F:\.m2\repository\mysql\mysql-connector-java\5.1.38\mysql-connector-java-5.1.38.jar&quot;/&gt; --&gt;    &lt;!-- targetRuntime：MyBatis3Simple 不会生成与 Example 相关的方法；MyBatis3 默认值 --&gt;    &lt;!-- defaultModelType：为每一张表生成一个实体类，包含所有字段 --&gt;    &lt;context id=&quot;MySqlContext&quot; targetRuntime=&quot;MyBatis3Simple&quot; defaultModelType=&quot;flat&quot;&gt;        &lt;!-- 分隔符，MySQL ``，SQLServer []，postgresql &quot;&quot; --&gt;        &lt;!-- &lt;property name=&quot;autoDelimitKeywords&quot; value=&quot;true&quot; /&gt; --&gt;        &lt;property name=&quot;beginningDelimiter&quot; value=&quot;`&quot;/&gt;        &lt;property name=&quot;endingDelimiter&quot; value=&quot;`&quot;/&gt;        &lt;!-- Java 文件编码 --&gt;        &lt;property name=&quot;javaFileEncoding&quot; value=&quot;UTF-8&quot;/&gt;        &lt;commentGenerator&gt;  &lt;!-- 可以自定义实现注释形式， type=&quot;tk.mybatis.generator.MyCommentGenerator&quot; --&gt;            &lt;!-- suppressAllComments：是否阻止生成注释，默认 false --&gt;            &lt;property name=&quot;suppressDate&quot; value=&quot;true&quot;/&gt;  &lt;!-- 注释中是否不生成时间戳，默认 false --&gt;            &lt;property name=&quot;addRemarkComments&quot; value=&quot;true&quot;/&gt;  &lt;!-- 注释是否添加表的备注信息，默认 false --&gt;        &lt;/commentGenerator&gt;        &lt;jdbcConnection driverClass=&quot;com.mysql.cj.jdbc.Driver&quot;                        connectionURL=&quot;jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;amp;characterEncoding=utf8&amp;amp;useSSL=false&amp;amp;serverTimezone=GMT%2B8&quot;                        userId=&quot;root&quot;                        password=&quot;123456&quot;&gt;            &lt;!-- MySQL8 会把所有库中的表都生成出来，添加下面一行即可 http://mybatis.org/generator/usage/mysql.html --&gt;            &lt;property name=&quot;nullCatalogMeansCurrent&quot; value=&quot;true&quot;/&gt;            &lt;!-- Oracle 需添加如下配置，使能够获取到列的注释 --&gt;            &lt;!-- &lt;property name=&quot;remarksReporting&quot; value=&quot;true&quot;/&gt; --&gt;        &lt;/jdbcConnection&gt;        &lt;!-- targetPackage：生成实体类存放的包名             targetProject：指定目标项目路径 --&gt;        &lt;javaModelGenerator targetPackage=&quot;test.model&quot; targetProject=&quot;src\main\java&quot;&gt;            &lt;!-- 是否对数据库查询结果进行 trim 操作 --&gt;            &lt;property name=&quot;trimStrings&quot; value=&quot;false&quot; /&gt;            &lt;!-- 设置所有实体类的基类 --&gt;            &lt;!--&lt;property name=&quot;rootClass&quot; value=&quot;tk.mybatis.simple.model.BaseEntity&quot; /&gt;--&gt;        &lt;/javaModelGenerator&gt;        &lt;!-- 如果未指定该标签，则不生成 xml 的 SQL 映射文件             targetPackage：生成的 xml 文件存放的包名             targetProject：指定目标项目路径 --&gt;        &lt;sqlMapGenerator targetPackage=&quot;test.xml&quot;  targetProject=&quot;src\main\resources&quot;/&gt;        &lt;!-- XMLMAPPER：接口调用依赖 xml 文件 --&gt;        &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;test.dao&quot;  targetProject=&quot;src\main\java&quot;/&gt;        &lt;!-- % 表示全部，要指定多个，可以配置多个 table 标签 --&gt;        &lt;table tableName=&quot;%&quot;&gt;            &lt;!-- 指定自动生成主键的属性 --&gt;            &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;MySql&quot;/&gt;            &lt;!-- Oracle 配置如下 --&gt;            &lt;!-- &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;select SEQ_ID.nextval from dual&quot;/&gt; --&gt;        &lt;/table&gt;    &lt;/context&gt;&lt;/generatorConfiguration&gt;</code></pre><h1 id="自定义实现注释形式"><a href="#自定义实现注释形式" class="headerlink" title="自定义实现注释形式"></a>自定义实现注释形式</h1><pre><code class="java">/** * 自己实现的注释生成器 */public class MyCommentGenerator extends DefaultCommentGenerator {    /**     * 由于默认实现类中的可配参数都没有提供给子类可以访问的方法，这里要定义一遍     */    private boolean suppressAllComments;    private boolean addRemarkComments;    /**     * 设置用户配置的参数     */    @Override    public void addConfigurationProperties(Properties properties) {        // 先调用父类方法保证父类方法可以正常使用        super.addConfigurationProperties(properties);        // 获取 suppressAllComments 参数值        suppressAllComments = isTrue(properties.getProperty(PropertyRegistry.COMMENT_GENERATOR_SUPPRESS_ALL_COMMENTS));        // 获取 addRemarkComments 参数值        addRemarkComments = isTrue(properties.getProperty(PropertyRegistry.COMMENT_GENERATOR_ADD_REMARK_COMMENTS));    }    /**     * 给字段添加注释信息     */    @Override    public void addFieldComment(Field field, IntrospectedTable introspectedTable,            IntrospectedColumn introspectedColumn) {        // 如果阻止生成所有注释，直接返回        if (suppressAllComments) {            return;        }        // 文档注释开始        field.addJavaDocLine(&quot;/**&quot;);        // 获取数据库字段的备注信息        String remarks = introspectedColumn.getRemarks();        // 根据参数和备注信息判断是否添加备注信息        if (addRemarkComments &amp;&amp; StringUtility.stringHasValue(remarks)) {            String[] remarkLines = remarks.split(System.getProperty(&quot;line.separator&quot;));            for (String remarkLine : remarkLines) {                field.addJavaDocLine(&quot; * &quot; + remarkLine);            }        }        // 由于 Java 对象名和数据库字段名可能不一样，注释中保留数据库字段名        field.addJavaDocLine(&quot; * &quot; + introspectedColumn.getActualColumnName());        field.addJavaDocLine(&quot; */&quot;);    }}// 生成的代码中注释如下：/** * 用户名 * user_name */private String userName;</code></pre><h1 id="生成代码"><a href="#生成代码" class="headerlink" title="生成代码"></a>生成代码</h1><pre><code class="java">/** * 读取 MBG 配置生成代码 */public class Generator {    public static void main(String[] args) throws Exception {        // MBG 执行过程中的警告信息        List&lt;String&gt; warnings = new ArrayList&lt;String&gt;();        // 当生成的代码重复时，覆盖原代码        boolean overwrite = true;        // 读取我们的 MBG 配置文件        InputStream is = Generator.class.getResourceAsStream(&quot;/generator/generatorConfig.xml&quot;);        ConfigurationParser cp = new ConfigurationParser(warnings);        Configuration config = cp.parseConfiguration(is);        is.close();        DefaultShellCallback callback = new DefaultShellCallback(overwrite);        // 创建 MBG        MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings);        // 执行生成代码        myBatisGenerator.generate(null);        // 输出警告信息        for(String warning : warnings){            System.out.println(warning);        }    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>aiohttp 简单记录</title>
      <link href="/2019/10/11/aiohttp%20%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/"/>
      <url>/2019/10/11/aiohttp%20%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>aiohttp 中文文档：<a href="https://hubertroy.gitbooks.io/aiohttp-chinese-documentation/content/" target="_blank" rel="noopener">https://hubertroy.gitbooks.io/aiohttp-chinese-documentation/content/</a></p></blockquote><pre><code class="py">loop = asyncio.get_event_loop()app = web.Application()app[&#39;websockets&#39;] = []app.router.add_route(&#39;GET&#39;, &#39;/ws&#39;, websocket_handler)  # WebSockets 控制器app.router.add_route(&#39;POST&#39;, &#39;/sync&#39;, sync)app.router.add_route(&#39;POST&#39;, &#39;/subscribe&#39;, subscribe)  # 需要 POST 和 GET 方法，可以定义两个控制器app.router.add_route(&#39;GET&#39;, &#39;/subscribe&#39;, subscribe)srv = loop.create_server(app.make_handler(), &#39;&#39;, 8080)print(&quot;Server start at at 8080&quot;)loop.run_until_complete(srv)loop.run_forever()</code></pre><h1 id="使用-WebSockets"><a href="#使用-WebSockets" class="headerlink" title="使用 WebSockets"></a>使用 WebSockets</h1><pre><code class="py">async def websocket_handler(request):    ws = web.WebSocketResponse()    await ws.prepare(request)    SerialNo = request.query.get(&#39;SerialNo&#39;)  # 从 url 中获得参数    wsInfo = (ws, cameraid, cameraname)    request.app[&#39;websockets&#39;].append(wsInfo)  # 将连接信息存入 app[&#39;websockets&#39;]    try:        async for msg in ws:            if msg.type == WSMsgType.TEXT:                print(msg.data)                if msg.data == &#39;ping&#39;:                    await ws.send_bytes(&#39;pong&#39;.encode(&#39;utf-8&#39;))  # 向客户端发送数据             elif msg.type == WSMsgType.CLOSE:                await ws.close()                logging.warning(&#39;websocket connection closed, SerialNo: {}&#39;.format(SerialNo))    finally:        request.app[&#39;websockets&#39;].remove(wsInfo)    return ws</code></pre><p>从另一个线程中向客户端发送 <code>WebSocket</code> 数据，注意需要 <code>asyncio.new_event_loop()</code></p><blockquote><p><a href="https://stackoverflow.com/questions/46727787/runtimeerror-there-is-no-current-event-loop-in-thread-in-async-apscheduler/46750562#46750562" target="_blank" rel="noopener">https://stackoverflow.com/questions/46727787/runtimeerror-there-is-no-current-event-loop-in-thread-in-async-apscheduler/46750562#46750562</a></p></blockquote><pre><code class="py">async def employeeSync(ws, cameraid):    await ws.send_bytes(&#39;pong&#39;.encode(&#39;utf-8&#39;))class employeeSyncThread (threading.Thread):    def __init__(self):        threading.Thread.__init__(self)    def run(self):        syncList = []        for webs in app[&#39;websockets&#39;]:            ws, cameraid, cameraname = webs            syncList.append(employeeSync(ws, cameraid))        if syncList:            syncLoop = asyncio.new_event_loop()            asyncio.set_event_loop(syncLoop)            # syncLoop = asyncio.get_event_loop()            syncRes = syncLoop.run_until_complete(asyncio.wait(syncList))            syncLoop.close()</code></pre><h1 id="http-控制器"><a href="#http-控制器" class="headerlink" title="http 控制器"></a>http 控制器</h1><pre><code class="py">async def subscribe(request):    if request.method == &#39;POST&#39;:  # 判断请求方法        data = await request.post()  # 接收表单提交数据        data = await request.json()  # 接收 json 数据        syntype = data.get(&quot;syntype&quot;)        SerialNo = request.query[&#39;SerialNo&#39;]  # url 参数，?SerialNo=111    return web.json_response({&#39;msg&#39;: &#39;ok&#39;})  # 返回 json    text = &#39;测试&#39;    return web.Response(text=text)  # 返回文本</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx 记录</title>
      <link href="/2019/10/11/Nginx%20%E8%AE%B0%E5%BD%95/"/>
      <url>/2019/10/11/Nginx%20%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Nginx-WebSocket-配置"><a href="#Nginx-WebSocket-配置" class="headerlink" title="Nginx WebSocket 配置"></a>Nginx WebSocket 配置</h1><pre><code class="conf">location /ws {    proxy_pass http://127.0.0.1:7270;  // 代理转发地址    proxy_http_version 1.1;  // 使用http版本为1.1    proxy_set_header   Host             $host:$server_port;    proxy_set_header   X-Real-IP        $remote_addr;    proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;    proxy_read_timeout 120s;  // 超时设置，如果 120 秒内没有通讯，会断开    // 启用支持websocket连接    proxy_set_header Upgrade $http_upgrade;    proxy_set_header Connection &quot;upgrade&quot;;}</code></pre><blockquote><p><a href="https://www.cnblogs.com/kevingrace/p/9512287.html" target="_blank" rel="noopener">https://www.cnblogs.com/kevingrace/p/9512287.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis 05-动态 SQL</title>
      <link href="/2019/10/09/MyBatis%2005-%E5%8A%A8%E6%80%81%20SQL/"/>
      <url>/2019/10/09/MyBatis%2005-%E5%8A%A8%E6%80%81%20SQL/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="http://www.broadview.com.cn/book/3643" target="_blank" rel="noopener">http://www.broadview.com.cn/book/3643</a><br><a href="https://mybatis.org/mybatis-3/zh/dynamic-sql.html" target="_blank" rel="noopener">https://mybatis.org/mybatis-3/zh/dynamic-sql.html</a></p></blockquote><h1 id="if"><a href="#if" class="headerlink" title="if"></a>if</h1><pre><code class="xml">&lt;if test=&quot;title != null and title != &#39;&#39;&quot;&gt;    AND title like #{title}&lt;/if&gt;</code></pre><p><code>test</code> 属性值是一个符合 <code>OGNL</code> 要求的判断表达式，表达式的结果可以是 <code>true</code> 或 <code>false</code>，所有非 0 的值都为 true，只有 0 为 false。</p><ul><li>判断条件 <code>property != null</code> 或 <code>property == null</code>，适用于任何类型的字段，用于判断属性值是否为空。</li><li>判断条件 <code>property != &#39;&#39;</code> 或 <code>property == &#39;&#39;</code>，仅适用于 <code>String</code> 类型。</li><li><code>and</code> 和 <code>or</code>，嵌套的判断可以使用小括号分组。</li></ul><h1 id="choose-when-otherwise"><a href="#choose-when-otherwise" class="headerlink" title="choose, when, otherwise"></a>choose, when, otherwise</h1><p>有点像 Java 中的 switch 语句。</p><p>如果提供了 title 就按 title 查找，提供了 author 就按 author 查找的情形，若两者都没有提供，就返回 featured=1 的。</p><pre><code class="xml">&lt;select id=&quot;findActiveBlogLike&quot; resultType=&quot;Blog&quot;&gt;    SELECT * FROM BLOG WHERE state = &#39;ACTIVE&#39;    &lt;choose&gt;        &lt;when test=&quot;title != null&quot;&gt;            AND title like #{title}        &lt;/when&gt;        &lt;when test=&quot;author != null and author.name != null&quot;&gt;            AND author_name like #{author.name}        &lt;/when&gt;        &lt;otherwise&gt;            AND featured = 1        &lt;/otherwise&gt;    &lt;/choose&gt;&lt;/select&gt;</code></pre><h1 id="trim-where-set"><a href="#trim-where-set" class="headerlink" title="trim, where, set"></a>trim, where, set</h1><p><code>where</code> 元素只会在至少有一个子元素的条件返回 SQL 子句的情况下才去插入 <code>WHERE</code> 子句。而且，若语句的开头为 AND 或 OR ，<code>where</code> 元素也会将它们去除。</p><p>我们可以通过自定义 <code>trim</code> 元素来定制 <code>where</code> 元素的功能。比如，和 <code>where</code> 元素等价的自定义 <code>trim</code> 元素为：</p><pre><code class="xml">&lt;!-- 这里的 AND 和 OR 后面的空格不能省略 --&gt;&lt;trim prefix=&quot;WHERE&quot; prefixOverrides=&quot;AND |OR &quot;&gt;    ...&lt;/trim&gt;</code></pre><p><code>set</code> 元素会动态前置 <code>SET</code> 关键字，同时也会删掉无关的逗号，因为用了条件语句之后很可能就会在生成的 SQL 语句的后面留下这些逗号。</p><p>set 元素等价的自定义 trim 元素：</p><pre><code class="xml">&lt;trim prefix=&quot;SET&quot; suffixOverrides=&quot;,&quot;&gt;  ...&lt;/trim&gt;</code></pre><p><code>trim</code> 标签有如下属性：</p><ul><li><code>prefix</code>：当 trim 元素内包含内容时，会给内容增加 <code>prefix</code> 指定的前缀。</li><li><code>prefixOverrides</code>：当 trim 元素内包含内容时，会把内容中匹配的前缀字符串去掉。</li><li><code>suffix</code>：当 trim 元素内包含内容时，会给内容增加 <code>suffix</code> 指定的后缀。</li><li><code>suffixOverrides</code>：当 trim 元素内包含内容时，会把内容中匹配的后缀字符串去掉。</li></ul><h1 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h1><pre><code class="xml">&lt;foreach item=&quot;item&quot; index=&quot;index&quot; collection=&quot;list&quot;    open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt;        #{item}&lt;/foreach&gt;</code></pre><p>foreach 包含以下属性：</p><ul><li><code>collection</code>：必填，为要迭代循环的属性名。</li><li><code>item</code>：变量名，为从迭代对象中取出的每一个值。</li><li><code>index</code>：索引的属性名，在集合数组情况下值为当前索引值，Map 类型时为 Map 的 key。</li><li><code>open</code>：整个循环内容开头的字符串。</li><li><code>close</code>：整个循环内容结尾的字符串。</li><li><code>separator</code>：每次循环的分隔符。</li></ul><p><strong>批量新增并回写主键值</strong>，3.3.1 版本开始，只支持 MySQL。</p><pre><code class="xml">&lt;insert id=&quot;insertList&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;    insert into sys user(        user_name, user_password, user_email,        user_info , head_img , create_time)    values    &lt;foreach collection=&quot;list&quot; item=&quot;user&quot; separator=&quot;,&quot;&gt;        (        #{user.userName}, #{user.userPassword}, #{user.userEmail},        #{user.userlnfo}, #{user.headlmg, jdbcType=BLOB},        #{user.createTime, jdbcType=TIMESTAMP})    &lt;/foreach&gt;&lt;/insert&gt;</code></pre><h1 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h1><p><code>bind</code> 元素可以从 <code>OGNL</code> 表达式中创建一个变量并将其绑定到上下文。比如：</p><pre><code class="xml">&lt;select id=&quot;selectBlogsLike&quot; resultType=&quot;Blog&quot;&gt;    &lt;bind name=&quot;pattern&quot; value=&quot;&#39;%&#39; + _parameter.getTitle() + &#39;%&#39;&quot; /&gt;    SELECT * FROM BLOG    WHERE title LIKE #{pattern}&lt;/select&gt;</code></pre><h1 id="多数据库支持"><a href="#多数据库支持" class="headerlink" title="多数据库支持"></a>多数据库支持</h1><p>一个配置了 <code>_databaseId</code> 变量的 <code>databaseIdProvider</code> 可用于动态代码中，这样就可以根据不同的数据库厂商构建特定的语句。比如下面的例子：</p><pre><code class="xml">&lt;insert id=&quot;insert&quot;&gt;    &lt;selectKey keyProperty=&quot;id&quot; resultType=&quot;int&quot; order=&quot;BEFORE&quot;&gt;        &lt;if test=&quot;_databaseId == &#39;oracle&#39;&quot;&gt;            select seq_users.nextval from dual        &lt;/if&gt;        &lt;if test=&quot;_databaseId == &#39;db2&#39;&quot;&gt;            select nextval for seq_users from sysibm.sysdummy1&quot;        &lt;/if&gt;    &lt;/selectKey&gt;    insert into users values (#{id}, #{name})&lt;/insert&gt;</code></pre><h1 id="OGNL"><a href="#OGNL" class="headerlink" title="OGNL"></a>OGNL</h1><p>MyBatis 的动态 SQL 和 <code>${}</code> 形式的参数中都用到了 OGNL 表达式，常用的表达式如下：</p><ol><li>e1 or e2</li><li>e1 and e2</li><li>e1 == e2 或 e1 eq e2</li><li>e1 != e2 或 e1 neq e2</li><li>e1 lt e2：小于</li><li>e1 lte e2：小于等于，gt（大于），gte（大于等于）</li><li>e1 + e2：+-*/%</li><li>!e 或 not e：非、取反</li><li><code>e.method(args)</code>：调用对象方法，<code>list.size() &gt; 0</code></li><li><code>e.property</code>：对象属性值</li><li><code>e1[e2]</code>：按索引取值（List、数组和 Map）</li><li><code>@class@method(args)</code>：调用类的静态方法</li><li><code>@class@field</code>：调用类的静态字段值</li></ol><p>表达式 12 通常用于简化一些校验，如：</p><pre><code class="xml">&lt;if test=&quot;@tk.mybatis.util.StringUtil@isNotEmpty(userName)&quot;&gt;    and user_name like concat(&#39;%&#39;, #{userName}, &#39;%&#39;)&lt;/if&gt;</code></pre><p>StringUtil 类如下：</p><pre><code class="java">public class StringUtil {    public static boolean isEmpty(String str) {        return str == null || str.length() == 0;    }    public static boolean isNotEmpty(String str) {        return !isEmpty(str);    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis 04-注解方式的基本用法</title>
      <link href="/2019/09/21/MyBatis%2004-%E6%B3%A8%E8%A7%A3%E6%96%B9%E5%BC%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/"/>
      <url>/2019/09/21/MyBatis%2004-%E6%B3%A8%E8%A7%A3%E6%96%B9%E5%BC%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="http://www.broadview.com.cn/book/3643" target="_blank" rel="noopener">http://www.broadview.com.cn/book/3643</a></p></blockquote><p>MyBatis 注解方式就是将 SQL 语句直接写在接口上。优点：对于简单的系统，效率高。缺点：当 SQL 有变化时需重新编译代码。一般不建议使用注解方式。</p><h1 id="Select-注解"><a href="#Select-注解" class="headerlink" title="@Select 注解"></a>@Select 注解</h1><pre><code class="java">@Select({&quot;select id,role_name roleName, enabled, create_by createBy, create_time createTime&quot;,            &quot;from sys_role&quot;,            &quot;where id = #{id}&quot;})SysRole selectById(Long id);</code></pre><h2 id="实现字段映射，使用-resultMap-方式"><a href="#实现字段映射，使用-resultMap-方式" class="headerlink" title="实现字段映射，使用 resultMap 方式"></a>实现字段映射，使用 resultMap 方式</h2><p>可以在配置文件中 <code>&lt;settings&gt;</code> 标签中设置 <code>mapUnderscoreToCamelCase</code> 为 true。MyBatis 会按照“下划线转驼峰”的方式自动映射。</p><p>XML 中的 <code>resultMap</code> 元素对应的 Java 注解 <code>@Results</code></p><pre><code class="java">// 3.3.1 版本，增加了 id 属性，可以通过 id 属性引用同一个 @Results 配置@Results(id = &quot;roleResultMap&quot;, value = {    @Result(property = &quot;id&quot;, column = &quot;id&quot;, id = true),    @Result(property = &quot;roleName&quot;, column = &quot;role_name&quot;),    @Result(property = &quot;enabled&quot;, column = &quot;enabled&quot;),    @Result(property = &quot;createBy&quot;, column = &quot;create_by&quot;),    @Result(property = &quot;createTime&quot;, column = &quot;create_time&quot;)})@Select(&quot;select id,role_name, enabled, create_by, create_time from sys_role where id = #{id}&quot;)SysRole selectById2(Long id);@ResultMap(&quot;roleResultMap&quot;)@Select(&quot;select * from sys_role&quot;)List&lt;SysRole&gt; selectAll();</code></pre><h1 id="Insert-注解"><a href="#Insert-注解" class="headerlink" title="@Insert 注解"></a>@Insert 注解</h1><h2 id="返回自增主键"><a href="#返回自增主键" class="headerlink" title="返回自增主键"></a>返回自增主键</h2><pre><code class="java">@Insert({&quot;insert into sys_role(role_name, enabled, create_by, create_time)&quot;,            &quot;values(#{roleName}, #{enabled}, #{createBy}, #{createTime, jdbcType=TIMESTAMP})&quot;})@Options(useGeneratedKeys = true, keyProperty = &quot;id&quot;)int insert2(SysRole sysRole);</code></pre><h2 id="返回非自增主键"><a href="#返回非自增主键" class="headerlink" title="返回非自增主键"></a>返回非自增主键</h2><pre><code class="java">@Insert({&quot;insert into sys_role(role_name, enabled, create_by, create_time)&quot;,             &quot;values(#{roleName}, #{enabled}, #{createBy}, #{createTime, jdbcType=TIMESTAMP})&quot;})@SelectKey(statement = &quot;SELECT LAST_INSERT_ID()&quot;, keyProperty = &quot;id&quot;, resultType = Long.class, before = false)int insert3(SysRole sysRole);</code></pre><p>使用了 <code>@SelectKey</code> 主键，如果是 XML 中配置的 selectKey</p><pre><code class="xml">&lt;selectKey keyColumn=&quot;id&quot; resultType=&quot;long&quot; keyProperty=&quot;id&quot; order=&quot;AFTER&quot;&gt;    SELECT LAST_INSERT_ID {)&lt;/selectKey&gt;</code></pre><p>before 为 false 时，等同于 <code>order=&quot;AFTER&quot;</code>，before 为 true 时，等同于 <code>order=&quot;BEFORE&quot;</code>，</p><h1 id="Update-和-Delete"><a href="#Update-和-Delete" class="headerlink" title="@Update 和 @Delete"></a>@Update 和 @Delete</h1><h1 id="Provider-注解"><a href="#Provider-注解" class="headerlink" title="Provider 注解"></a>Provider 注解</h1><p>MyBatis 提供了 4 中 Provider 注解，分别是 @SelectProvider、@InsertProvider、@UpdateProvider 和 @DeleteProvider。</p><p>创建 PrivilegeMapper 接口：</p><pre><code class="java">public interface PrivilegeMapper {    // method=&quot;selectById&quot; 方法的参数应该和这个方法一样    @SelectProvider(type=PrivilegeProvider.class, method=&quot;selectById&quot;)    SysPrivilege selectById(Long id);}</code></pre><p>PrivilegeProvider 类：</p><pre><code class="java">public class PrivilegeProvider {    // 必须要有空的构造方法    public String selectById(final Long id){        // 可以直接返回 SQL 字符串        return new SQL(){            {                SELECT(&quot;id, privilege_name, privilege_url&quot;);                FROM(&quot;sys_privilege&quot;);                WHERE(&quot;id = #{id}&quot;);            }        }.toString();    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis 03-XML 映射文件</title>
      <link href="/2019/09/21/MyBatis%2003-XML%20%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6/"/>
      <url>/2019/09/21/MyBatis%2003-XML%20%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://mybatis.org/mybatis-3/zh/sqlmap-xml.html" target="_blank" rel="noopener">https://mybatis.org/mybatis-3/zh/sqlmap-xml.html</a><br><a href="http://www.broadview.com.cn/book/3643" target="_blank" rel="noopener">http://www.broadview.com.cn/book/3643</a></p></blockquote><p>SQL 映射文件只有很少的几个顶级元素（按照应被定义的顺序列出）：</p><ul><li><code>cache</code> – 对给定命名空间的缓存配置。</li><li><code>cache-ref</code> – 对其他命名空间缓存配置的引用。</li><li><code>resultMap</code> – 是最复杂也是最强大的元素，用来描述如何从数据库结果集中来加载对象。</li><li><code>sql</code> – 可被其他语句引用的可重用语句块。</li><li><code>insert</code> – 映射插入语句</li><li><code>update</code> – 映射更新语句</li><li><code>delete</code> – 映射删除语句</li><li><code>select</code> – 映射查询语句</li></ul><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.bin.mapper.CountryMapper&quot;&gt;&lt;/mapper&gt;</code></pre><p><strong>命名空间</strong>的作用有两个，一个是利用更长的完全限定名来将不同的语句隔离开来，同时也实现了你上面见到的接口绑定。就算你觉得暂时用不到接口绑定，你也应该遵循这里的规定，以防哪天你改变了主意。 长远来看，只要将命名空间置于合适的 Java 包命名空间之中，你的代码会变得更加整洁，也有利于你更方便地使用 MyBatis。</p><h1 id="select"><a href="#select" class="headerlink" title="select"></a>select</h1><p>简单查询的 select 元素是非常简单的。比如：</p><pre><code class="xml">&lt;select id=&quot;selectPerson&quot; parameterType=&quot;int&quot; resultType=&quot;hashmap&quot;&gt;    SELECT * FROM PERSON WHERE ID = #{id}&lt;/select&gt;</code></pre><p>这个语句被称作 selectPerson，接受一个 int（或 Integer）类型的参数，并返回一个 HashMap 类型的对象，其中的键是列名，值便是结果行中的对应值。</p><p>如果查询一个 country 下的所有 user，resultType 的类型必须包含 country 和 user 的全部属性。这样不利于扩展，所以可以在 country 中加入 user 属性：<code>private SysUser user; private Integer userid;</code></p><pre><code class="xml">&lt;select id=&quot;selectPerson2&quot; parameterType=&quot;int&quot; resultType=&quot;country&quot;&gt;    select u.id, c.countryname, c.countrycode, u.username as &quot;user.userName&quot;    from sys_user u left join country c on u.id=c.userid    WHERE u.id = #{id}&lt;/select&gt;</code></pre><p>这里设置别名的时候，使用的是 “user.属性名”，可以通过这种方式直接赋值给 country 中的 user 字段的属性。</p><p>select 元素允许你配置很多属性来配置每条语句的作用细节。</p><pre><code class="xml">&lt;select    id=&quot;selectPerson&quot;    parameterType=&quot;int&quot;    parameterMap=&quot;deprecated&quot;    resultType=&quot;hashmap&quot;    resultMap=&quot;personResultMap&quot;    flushCache=&quot;false&quot;    useCache=&quot;true&quot;    timeout=&quot;10&quot;    fetchSize=&quot;256&quot;    statementType=&quot;PREPARED&quot;    resultSetType=&quot;FORWARD_ONLY&quot;&gt;</code></pre><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td><code>id</code></td><td>在命名空间中唯一的标识符，可以被用来引用这条语句。</td></tr><tr><td><code>parameterType</code></td><td>将会传入这条语句的参数类的完全限定名或别名。这个属性是可选的，因为 MyBatis 可以通过类型处理器（TypeHandler） 推断出具体传入语句的参数，默认值为未设置（unset）。</td></tr><tr><td><code>resultType</code></td><td>从这条语句中返回的期望类型的类的完全限定名或别名。 注意如果返回的是集合，那应该设置为集合包含的类型，而不是集合本身。可以使用 resultType 或 resultMap，但不能同时使用。</td></tr><tr><td><code>resultMap</code></td><td>外部 resultMap 的命名引用。结果集的映射是 MyBatis 最强大的特性，如果你对其理解透彻，许多复杂映射的情形都能迎刃而解。可以使用 resultMap 或 resultType，但不能同时使用。</td></tr><tr><td><code>flushCache</code></td><td>将其设置为 true 后，只要语句被调用，都会导致本地缓存和二级缓存被清空，默认值：对 select 元素为 false，对于 insert、update 和 delete 语句为 true。</td></tr><tr><td><code>useCache</code></td><td>将其设置为 true 后，将会导致本条语句的结果被二级缓存缓存起来，默认值：对 select 元素为 true。</td></tr><tr><td><code>timeout</code></td><td>这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为未设置（unset）（依赖驱动）。</td></tr><tr><td><code>fetchSize</code></td><td>这是一个给驱动的提示，尝试让驱动程序每次批量返回的结果行数和这个设置值相等。 默认值为未设置（unset）（依赖驱动）。</td></tr><tr><td><code>statementType</code></td><td>STATEMENT，PREPARED 或 CALLABLE 中的一个。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。</td></tr><tr><td><code>resultSetType</code></td><td>FORWARD_ONLY，SCROLL_SENSITIVE, SCROLL_INSENSITIVE 或 DEFAULT（等价于 unset） 中的一个，默认值为 unset （依赖驱动）。</td></tr><tr><td><code>databaseId</code></td><td>如果配置了数据库厂商标识（databaseIdProvider），MyBatis 会加载所有的不带 databaseId 或匹配当前 databaseId 的语句；如果带或者不带的语句都有，则不带的会被忽略。</td></tr><tr><td><code>resultOrdered</code></td><td>这个设置仅针对嵌套结果 select 语句适用：如果为 true，就是假设包含了嵌套结果集或是分组，这样的话当返回一个主结果行的时候，就不会发生有对前面结果集的引用的情况。 这就使得在获取嵌套的结果集的时候不至于导致内存不够用。默认值：false。</td></tr><tr><td><code>resultSets</code></td><td>这个设置仅对多结果集的情况适用。它将列出语句执行后返回的结果集并给每个结果集一个名称，名称是逗号分隔的。</td></tr></tbody></table><h2 id="多个接口参数的用法"><a href="#多个接口参数的用法" class="headerlink" title="多个接口参数的用法"></a>多个接口参数的用法</h2><ul><li>将多个参数合并到一个 JavaBean 中</li><li>使用 Map 类型</li><li>使用 <code>@Param</code> 注解</li></ul><pre><code class="java">List&lt;SysRole&gt; selectUserAndEnabled(@Param(&quot;userId&quot;)Long userid , @Param(&quot;enabled&quot;)Integer enabled);</code></pre><pre><code class="xml">&lt;select id=&quot;selectUserAndEnabled&quot; resultType =&quot;SysUser&quot;&gt;    select * from sys_user where id = #{userld) and enabled = #{enabled)&lt;/select&gt;</code></pre><p>当只有一个参数时，MyBatis 会不关心参数叫什么名字就直接把这个唯一的参数值拿来使用。</p><pre><code class="java">// @Param 注解，可以将方法的参数换成 JavaBean 类型List&lt;SysRole&gt; selectRolesByUserAndRole(@Param(&quot;user&quot;) SysUser user, @Param(&quot;role&quot;) SysRole role);// 这时，XML 中需要通过点取值方式，#{user.id}</code></pre><h1 id="insert-update-和-delete"><a href="#insert-update-和-delete" class="headerlink" title="insert, update 和 delete"></a>insert, update 和 delete</h1><pre><code class="xml">&lt;insert    id=&quot;insertAuthor&quot;    parameterType=&quot;domain.blog.Author&quot;    flushCache=&quot;true&quot;    statementType=&quot;PREPARED&quot;    keyProperty=&quot;&quot;    keyColumn=&quot;&quot;    useGeneratedKeys=&quot;&quot;    timeout=&quot;20&quot;&gt;&lt;update    id=&quot;updateAuthor&quot;    parameterType=&quot;domain.blog.Author&quot;    flushCache=&quot;true&quot;    statementType=&quot;PREPARED&quot;    timeout=&quot;20&quot;&gt;&lt;delete    id=&quot;deleteAuthor&quot;    parameterType=&quot;domain.blog.Author&quot;    flushCache=&quot;true&quot;    statementType=&quot;PREPARED&quot;    timeout=&quot;20&quot;&gt;</code></pre><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td><code>useGeneratedKeys</code></td><td>（仅对 insert 和 update 有用）这会令 MyBatis 使用 JDBC 的 getGeneratedKeys 方法来取出由数据库内部生成的主键（比如：像 MySQL 和 SQL Server 这样的关系数据库管理系统的自动递增字段），默认值：false。</td></tr><tr><td><code>keyProperty</code></td><td>（仅对 insert 和 update 有用）唯一标记一个属性，MyBatis 会通过 getGeneratedKeys 的返回值或者通过 insert 语句的 selectKey 子元素设置它的键值，默认值：未设置（unset）。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。</td></tr><tr><td><code>keyColumn</code></td><td>（仅对 insert 和 update 有用）通过生成的键值设置表中的列名，这个设置仅在某些数据库（像 PostgreSQL）是必须的，当主键列不是表中的第一列的时候需要设置。如果希望使用多个生成的列，也可以设置为逗号分隔的属性名称列表。</td></tr></tbody></table><pre><code class="xml">&lt;!-- MySQL --&gt;&lt;insert id=&quot;addShop&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot; &gt;    INSERT INTO t_shop(shopname) VALUES(#{shopname})&lt;/insert&gt;&lt;!-- 批量 --&gt;&lt;insert id=&quot;addShops&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;    insert into t_shop (shopname) values    &lt;foreach item=&quot;item&quot; collection=&quot;list&quot; separator=&quot;,&quot;&gt;        (#{item.shopname})    &lt;/foreach&gt;&lt;/insert&gt;</code></pre><h2 id="selectKey"><a href="#selectKey" class="headerlink" title="selectKey"></a>selectKey</h2><p>selectKey 元素描述如下：</p><pre><code class="xml">&lt;selectKey    keyProperty=&quot;id&quot;    resultType=&quot;int&quot;    order=&quot;BEFORE&quot;    statementType=&quot;PREPARED&quot;&gt;</code></pre><p>selectKey 元素的属性</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>keyProperty</td><td>selectKey 语句结果应该被设置的目标属性。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。</td></tr><tr><td>keyColumn</td><td>匹配属性的返回结果集中的列名称。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。</td></tr><tr><td>resultType</td><td>结果的类型。MyBatis 通常可以推断出来，但是为了更加精确，写上也不会有什么问题。MyBatis 允许将任何简单类型用作主键的类型，包括字符串。如果希望作用于多个生成的列，则可以使用一个包含期望属性的 Object 或一个 Map。</td></tr><tr><td>order</td><td>这可以被设置为 BEFORE 或 AFTER。如果设置为 BEFORE，那么它会首先生成主键，设置 keyProperty 然后执行插入语句。如果设置为 AFTER，那么先执行插入语句，然后是 selectKey 中的语句 - 这和 Oracle 数据库的行为相似，在插入语句内部可能有嵌入索引调用。</td></tr><tr><td>statementType</td><td>与前面相同，MyBatis 支持 STATEMENT，PREPARED 和 CALLABLE 语句的映射类型，分别代表 PreparedStatement 和 CallableStatement 类型。</td></tr></tbody></table><pre><code class="xml">&lt;!-- MySQL --&gt;&lt;insert id=&quot;addShop&quot;&gt;    INSERT INTO t_shop(shopname) VALUES(#{shopname})    &lt;selectKey keyColumn=&quot;id&quot; resultType=&quot;long&quot; keyProperty=&quot;id&quot; order=&quot;AFTER&quot;&gt;        SELECT LAST_INSERT_ID()    &lt;/selectKey&gt;&lt;/insert&gt;&lt;!-- Oracle --&gt;&lt;insert id=&quot;insert&quot; &gt;    &lt;selectKey resultType=&quot;int&quot; keyProperty=&quot;id&quot; order=&quot;BEFORE&quot;&gt;        &lt;![CDATA[SELECT T_SHOP_SEQ.NEXTVAL FROM DUAL]]&gt;    &lt;/selectKey&gt;    insert into T_SHOP (id, shopname) values (#{id}, #{shopname})&lt;/insert&gt;</code></pre><h1 id="sql"><a href="#sql" class="headerlink" title="sql"></a>sql</h1><p>这个元素可以被用来定义<strong>可重用的 SQL 代码段</strong>，这些 SQL 代码可以被包含在其他语句中。它可以（在加载的时候）被静态地设置参数。 在不同的包含语句中<strong>可以设置不同的值到参数占位符上</strong>。比如：</p><pre><code class="xml">&lt;sql id=&quot;userColumns&quot;&gt; ${alias}.id,${alias}.username,${alias}.password &lt;/sql&gt;</code></pre><p>这个 SQL 片段可以被包含在其他语句中，例如：</p><pre><code class="xml">&lt;select id=&quot;selectUsers&quot; resultType=&quot;map&quot;&gt;    select        &lt;include refid=&quot;userColumns&quot;&gt;&lt;property name=&quot;alias&quot; value=&quot;t1&quot;/&gt;&lt;/include&gt;,        &lt;include refid=&quot;userColumns&quot;&gt;&lt;property name=&quot;alias&quot; value=&quot;t2&quot;/&gt;&lt;/include&gt;    from some_table t1        cross join some_table t2&lt;/select&gt;</code></pre><p>属性值也可以被用在 include 元素的 refid 属性里或 include 元素的内部语句中，例如：</p><pre><code class="xml">&lt;sql id=&quot;sometable&quot;&gt;    ${prefix}Table&lt;/sql&gt;&lt;sql id=&quot;someinclude&quot;&gt;    from        &lt;include refid=&quot;${include_target}&quot;/&gt;&lt;/sql&gt;&lt;select id=&quot;select&quot; resultType=&quot;map&quot;&gt;    select        field1, field2, field3    &lt;include refid=&quot;someinclude&quot;&gt;        &lt;property name=&quot;prefix&quot; value=&quot;Some&quot;/&gt;        &lt;property name=&quot;include_target&quot; value=&quot;sometable&quot;/&gt;    &lt;/include&gt;&lt;/select&gt;</code></pre><h1 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h1><p>参数也可以指定一个特殊的数据类型。</p><pre><code class="xml">#{property, javaType=int, jdbcType=NUMERIC}</code></pre><p><strong>JDBC 要求，如果一个列允许 null 值，并且会传递值 null 的参数，就必须要指定 JDBC Type。</strong></p><p>数据库中区分 date、time、datetime，但 Java 中一般都使用 java.util.Date 类型。所以需要指定类型，分别对应的 JDBC 类型为 DATE、TIME、TIMESTAMP。</p><h2 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h2><p>默认情况下,使用 #{} 格式的语法会导致 MyBatis 创建 PreparedStatement 参数占位符并安全地设置参数（就像使用 ? 一样）。 这样做更安全，更迅速，通常也是首选做法。不过有时你就是想直接在 SQL 语句中插入一个不转义的字符串。 比如，像 ORDER BY，你可以这样来使用：<code>ORDER BY ${columnName}</code></p><pre><code class="java">@Select(&quot;select * from user where ${column} = #{value}&quot;)User findByColumn(@Param(&quot;column&quot;) String column, @Param(&quot;value&quot;) String value);</code></pre><p>其中 <code>${column}</code> 会被直接替换，而 <code>#{value}</code> 会被使用 <code>?</code> 预处理。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis 02-XML 配置文件</title>
      <link href="/2019/09/18/MyBatis%2002-XML%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
      <url>/2019/09/18/MyBatis%2002-XML%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://mybatis.org/mybatis-3/zh/configuration.html" target="_blank" rel="noopener">https://mybatis.org/mybatis-3/zh/configuration.html</a></p></blockquote><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;!-- 标签顺序必须按以下顺序 --&gt;    &lt;properties&gt;    &lt;settings&gt;    &lt;typeAliases&gt;    &lt;typeHandlers&gt;    &lt;objectFactory&gt;    &lt;objectWrapperFactory&gt;    &lt;reflectorFactory&gt;    &lt;plugins&gt;    &lt;environments&gt;    &lt;databaseIdProvider&gt;    &lt;mappers&gt;&lt;/configuration&gt;</code></pre><p>标签顺序必须符合要求，否则报错：<br>The content of element type &quot;configuration&quot; must match &quot;(properties?,settings?,typeAliases?,typeHandlers?,objectFactory?,objectWrapperFactory?,reflectorFactory?,plugins?,environments?,databaseIdProvider?,mappers?)&quot;.</p><h1 id="属性（properties）"><a href="#属性（properties）" class="headerlink" title="属性（properties）"></a>属性（properties）</h1><p>属性可以在典型的 Java properties 文件中配置，亦可通过 properties 元素的子元素来传递</p><pre><code class="xml">&lt;properties resource=&quot;config.properties&quot;&gt;    &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;    &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;&lt;/properties&gt;</code></pre><p>然后其中的属性就可以在整个配置文件中被用来替换需要动态配置的属性值。比如:</p><pre><code class="xml">&lt;dataSource type=&quot;POOLED&quot;&gt;  &lt;property name=&quot;driver&quot; value=&quot;${driver}&quot;/&gt;  &lt;property name=&quot;url&quot; value=&quot;${url}&quot;/&gt;  &lt;property name=&quot;username&quot; value=&quot;${username}&quot;/&gt;  &lt;property name=&quot;password&quot; value=&quot;${password}&quot;/&gt;&lt;/dataSource&gt;</code></pre><p>属性也可以被传递到 <code>SqlSessionFactoryBuilder.build()</code> 方法中。例如：</p><pre><code class="java">Properties prop = new Properties();prop.setProperty(&quot;driver&quot;, &quot;com.mysql.cj.jdbc.Driver&quot;);prop.setProperty(&quot;url&quot;, &quot;jdbc:mysql://localhost:3306/mybatis?serverTimezone=Asia/Shanghai&amp;characterEncoding=utf8&quot;);prop.setProperty(&quot;username&quot;, &quot;root&quot;);prop.setProperty(&quot;password&quot;, &quot;root&quot;);Reader reader = Resources.getResourceAsReader(&quot;config.xml&quot;);sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader, prop);reader.close();</code></pre><h2 id="加载顺序"><a href="#加载顺序" class="headerlink" title="加载顺序"></a>加载顺序</h2><p>通过方法参数传递的属性具有最高优先级，属性中指定的配置文件次之，最低优先级的是 properties 属性中指定的属性。</p><h2 id="为占位符指定一个默认值"><a href="#为占位符指定一个默认值" class="headerlink" title="为占位符指定一个默认值"></a>为占位符指定一个默认值</h2><p>从 MyBatis 3.4.2 开始</p><pre><code class="xml">&lt;dataSource type=&quot;POOLED&quot;&gt;    &lt;property name=&quot;username&quot; value=&quot;${username:ut_user}&quot;/&gt; &lt;!-- 如果属性 &#39;username&#39; 没有被配置，&#39;username&#39; 属性的值将为 &#39;ut_user&#39; --&gt;&lt;/dataSource&gt;</code></pre><p>需添加一个指定的属性来开启这个特性。例如：</p><pre><code class="xml">&lt;properties resource=&quot;org/mybatis/example/config.properties&quot;&gt;    &lt;property name=&quot;org.apache.ibatis.parsing.PropertyParser.enable-default-value&quot; value=&quot;true&quot;/&gt; &lt;!-- 启用默认值特性 --&gt;&lt;/properties&gt;</code></pre><p>可以修改 <code>value=&quot;?:&quot;</code> 的值，来修改分隔键名和默认值的字符。</p><h1 id="设置（settings）"><a href="#设置（settings）" class="headerlink" title="设置（settings）"></a>设置（settings）</h1><pre><code class="xml">&lt;settings&gt;    &lt;!-- 全局的映射器启用或禁用缓存。 --&gt;    &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;    &lt;!-- 全局启用或禁用延迟加载 --&gt;    &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;    &lt;!-- 允许或不允许多种结果集从一个单独的语句中返回 --&gt;    &lt;setting name=&quot;multipleResultSetsEnabled&quot; value=&quot;true&quot;/&gt;    &lt;setting name=&quot;useColumnLabel&quot; value=&quot;true&quot;/&gt;    &lt;setting name=&quot;useGeneratedKeys&quot; value=&quot;true&quot;/&gt;    &lt;setting name=&quot;defaultExecutorType&quot; value=&quot;SIMPLE&quot;/&gt;    &lt;!-- 设置超时时间（秒） --&gt;    &lt;setting name=&quot;defaultStatementTimeout&quot; value=&quot;200&quot;/&gt;&lt;/settings&gt;</code></pre><table><thead><tr><th>设置名</th><th>描述</th><th>有效值</th><th>默认值</th></tr></thead><tbody><tr><td>cacheEnabled</td><td>全局地开启或关闭配置文件中的所有映射器已经配置的任何缓存。</td><td>true/false</td><td>true</td></tr><tr><td>lazyLoadingEnabled</td><td>延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。特定关联关系中可通过设置 <code>fetchType</code> 属性来覆盖该项的开关状态。</td><td>true/false</td><td>false</td></tr><tr><td>aggressiveLazyLoading</td><td>当开启时，任何方法的调用都会加载该对象的所有属性。否则，每个属性会按需加载（参考 <code>lazyLoadTriggerMethods</code>)。</td><td>true/false</td><td>false （在 3.4.1 及之前的版本默认值为 true）</td></tr><tr><td>lazyLoadTriggerMethods</td><td>指定哪个对象的方法触发一次延迟加载。</td><td>用逗号分隔的方法列表。</td><td>equals,clone,hashCode,toString</td></tr><tr><td>multipleResultSetsEnabled</td><td>是否允许单一语句返回多结果集（需要驱动支持）。</td><td>true/false</td><td>true</td></tr><tr><td>useColumnLabel</td><td>使用列标签代替列名。不同的驱动在这方面会有不同的表现，具体可参考相关驱动文档或通过测试这两种不同的模式来观察所用驱动的结果。</td><td>true/false</td><td>true</td></tr><tr><td>useGeneratedKeys</td><td>允许 JDBC 支持自动生成主键，需要驱动支持。 如果设置为 true 则这个设置强制使用自动生成主键，尽管一些驱动不能支持但仍可正常工作（比如 Derby）。</td><td>true/false</td><td>false</td></tr><tr><td>autoMappingBehavior</td><td>指定 MyBatis 应如何自动映射列到字段或属性。 <code>NONE</code> 表示取消自动映射； <code>PARTIAL</code> 只会自动映射没有定义嵌套结果集映射的结果集。 <code>FULL</code> 会自动映射任意复杂的结果集（无论是否嵌套）。</td><td>NONE, PARTIAL, FULL</td><td>PARTIAL</td></tr><tr><td>autoMappingUnknownColumnBehavior</td><td>指定发现自动映射目标未知列（或者未知属性类型）的行为。 <br/><code>NONE</code>: 不做任何反应 <br/> <code>WARNING</code>: 输出提醒日志 (<code>&#39;org.apache.ibatis.session.AutoMappingUnknownColumnBehavior&#39;</code> 的日志等级必须设置为 <code>WARN</code>)  <br/> <code>FAILING</code>: 映射失败 (抛出 SqlSessionException)</td><td>NONE, WARNING, FAILING</td><td>NONE</td></tr><tr><td>defaultExecutorType</td><td>配置默认的执行器。SIMPLE 就是普通的执行器；REUSE 执行器会重用预处理语句（prepared statements）； BATCH 执行器将重用语句并执行批量更新。</td><td>SIMPLE, REUSE, BATCH</td><td>SIMPLE</td></tr><tr><td>defaultStatementTimeout</td><td>设置超时时间，它决定驱动等待数据库响应的秒数。</td><td>任意正整数</td><td>未设置 (null)</td></tr><tr><td>defaultFetchSize</td><td>为驱动的结果集获取数量（fetchSize）设置一个提示值。此参数只可以在查询设置中被覆盖。</td><td>任意正整数</td><td>未设置 (null)</td></tr><tr><td>safeRowBoundsEnabled</td><td>允许在嵌套语句中使用分页（RowBounds）。如果允许使用则设置为 false。</td><td>true/false</td><td>False</td></tr><tr><td>safeResultHandlerEnabled</td><td>允许在嵌套语句中使用分页（ResultHandler）。如果允许使用则设置为 false。</td><td>true/false</td><td>True</td></tr><tr><td>mapUnderscoreToCamelCase</td><td>是否开启自动驼峰命名规则（camel case）映射，即从经典数据库列名 A_COLUMN 到经典 Java 属性名 aColumn 的类似映射。</td><td>true/false</td><td>False</td></tr><tr><td>localCacheScope</td><td>MyBatis 利用本地缓存机制（Local Cache）防止循环引用（circular references）和加速重复嵌套查询。 默认值为 SESSION，这种情况下会缓存一个会话中执行的所有查询。 若设置值为 STATEMENT，本地会话仅用在语句执行上，对相同 SqlSession 的不同调用将不会共享数据。</td><td>SESSION / STATEMENT</td><td>SESSION</td></tr><tr><td>defaultEnumTypeHandler</td><td>指定 Enum 使用的默认 TypeHandler 。（新增于 3.4.5）</td><td>一个类型别名或完全限定类名。</td><td>org.apache.ibatis.type.EnumTypeHandler</td></tr><tr><td>logPrefix</td><td>指定 MyBatis 增加到日志名称的前缀。</td><td>任何字符串</td><td>未设置</td></tr><tr><td>logImpl</td><td>指定 MyBatis 所用日志的具体实现，未指定时将自动查找。</td><td>SLF4J / LOG4J / LOG4J2 / JDK_LOGGING / COMMONS_LOGGING / STDOUT_LOGGING / NO_LOGGING</td><td>未设置</td></tr></tbody></table><h1 id="类型别名（typeAliases）"><a href="#类型别名（typeAliases）" class="headerlink" title="类型别名（typeAliases）"></a>类型别名（typeAliases）</h1><p>类型别名是为 Java 类型设置一个短的名字。 它只和 XML 配置有关，存在的意义仅在于用来减少类完全限定名的冗余。例如：</p><pre><code class="xml">&lt;typeAliases&gt;    &lt;typeAlias alias=&quot;Country&quot; type=&quot;com.bin.domian.Country&quot;/&gt;&lt;/typeAliases&gt;</code></pre><p>也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean，比如：</p><pre><code class="xml">&lt;typeAliases&gt;    &lt;package name=&quot;com.bin.domian&quot;/&gt;&lt;/typeAliases&gt;</code></pre><p>每一个在包 <code>com.bin.domian</code> 中的 Java Bean，在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名。 比如 <code>com.bin.domian.Country</code> 的别名为 <code>country</code>；若有注解，则别名为其注解值。见下面的例子：</p><pre><code class="java">@Alias(&quot;country&quot;)public class Country {    ...}</code></pre><p>常见的 Java 类型内建的相应的类型别名。它们都是<strong>不区分大小写的</strong>，注意对基本类型名称重复采取的特殊命名风格。</p><table><thead><tr><th>别名</th><th>映射的类型</th></tr></thead><tbody><tr><td>_byte</td><td>byte</td></tr><tr><td>_long</td><td>long</td></tr><tr><td>_short</td><td>short</td></tr><tr><td>_int</td><td>int</td></tr><tr><td>_integer</td><td>int</td></tr><tr><td>_double</td><td>double</td></tr><tr><td>_float</td><td>float</td></tr><tr><td>_boolean</td><td>boolean</td></tr><tr><td>string</td><td>String</td></tr><tr><td>byte</td><td>Byte</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>integer</td><td>Integer</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>boolean</td><td>Boolean</td></tr><tr><td>date</td><td>Date</td></tr><tr><td>decimal</td><td>BigDecimal</td></tr><tr><td>bigdecimal</td><td>BigDecimal</td></tr><tr><td>object</td><td>Object</td></tr><tr><td>map</td><td>Map</td></tr><tr><td>hashmap</td><td>HashMap</td></tr><tr><td>list</td><td>List</td></tr><tr><td>arraylist</td><td>ArrayList</td></tr><tr><td>collection</td><td>Collection</td></tr><tr><td>iterator</td><td>Iterator</td></tr></tbody></table><h1 id="类型处理器（typeHandlers）"><a href="#类型处理器（typeHandlers）" class="headerlink" title="类型处理器（typeHandlers）"></a>类型处理器（typeHandlers）</h1><p>无论是 MyBatis 在预处理语句（PreparedStatement）中设置一个参数时，还是从结果集中取出一个值时， 都会用类型处理器将获取的值以合适的方式转换成 Java 类型。</p><p>可以重写类型处理器或创建你自己的类型处理器来处理不支持的或非标准的类型。 具体做法为：实现 <code>org.apache.ibatis.type.TypeHandler</code> 接口， 或继承一个很便利的类 <code>org.apache.ibatis.type.BaseTypeHandler</code>， 然后可以选择性地将它映射到一个 JDBC 类型。</p><h1 id="处理枚举类型"><a href="#处理枚举类型" class="headerlink" title="处理枚举类型"></a>处理枚举类型</h1><p>若想映射枚举类型 Enum，则需要从 EnumTypeHandler 或者 EnumOrdinalTypeHandler 中选一个来使用。</p><p>默认情况下，MyBatis 会利用 EnumTypeHandler 来把 Enum 值转换成对应的名字。</p><pre><code class="java">public enum CountryCode {    CN(&quot;CN 中国&quot;),    US(&quot;US 美国&quot;),    RU(&quot;RU 俄罗斯&quot;),    GB(&quot;GB 英国&quot;),    FR(&quot;FR 法国&quot;);    private String codename;    private CountryCode(String codename) {        this.codename = codename;    }    public String getCodename() {        return codename;    }}</code></pre><pre><code class="java">// Country 类下 增加属性private CountryCode code;</code></pre><h2 id="EnumTypeHandler"><a href="#EnumTypeHandler" class="headerlink" title="EnumTypeHandler"></a>EnumTypeHandler</h2><pre><code class="xml">&lt;resultMap id=&quot;countryMap&quot; type=&quot;Country&quot;&gt;    &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;    &lt;result column=&quot;countrycode&quot; property=&quot;code&quot; typeHandler=&quot;org.apache.ibatis.type.EnumTypeHandler&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;selectAll2&quot; resultMap=&quot;countryMap&quot;&gt;    select id, countryname, countrycode from country&lt;/select&gt;</code></pre><p>将数据库中 countrycode 映射到 code 字段中。</p><h2 id="EnumOrdinalTypeHandler"><a href="#EnumOrdinalTypeHandler" class="headerlink" title="EnumOrdinalTypeHandler"></a>EnumOrdinalTypeHandler</h2><p>数据库中新增 code 字段，存放整型值</p><pre><code class="xml">&lt;!-- 修改默认的处理器，如果在下方的 resultMap 指定了 typeHandler 这里可以不需要--&gt;&lt;typeHandlers&gt;    &lt;typeHandler handler=&quot;org.apache.ibatis.type.EnumOrdinalTypeHandler&quot; javaType=&quot;com.bin.domian.CountryCode&quot;/&gt;&lt;/typeHandlers&gt;</code></pre><pre><code class="xml">&lt;resultMap id=&quot;countryMap&quot; type=&quot;Country&quot;&gt;    &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;    &lt;!-- 同样如果已经在配置文件中修改了 默认的处理器，这里的 typeHandler 可以不需要 --&gt;    &lt;result column=&quot;code&quot; property=&quot;code&quot; typeHandler=&quot;org.apache.ibatis.type.EnumOrdinalTypeHandler&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;selectAll2&quot; resultMap=&quot;countryMap&quot;&gt;    select id, countryname, countrycode, code from country&lt;/select&gt;</code></pre><h1 id="环境配置（environments）"><a href="#环境配置（environments）" class="headerlink" title="环境配置（environments）"></a>环境配置（environments）</h1><p>可以指定使用哪个环境配置，如果忽略了环境参数，那么默认环境将会被加载</p><pre><code class="java">SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment);SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment, properties);</code></pre><p>环境元素定义了如何配置环境。</p><pre><code class="xml">&lt;environments default=&quot;development&quot;&gt;    &lt;environment id=&quot;development&quot;&gt;        &lt;transactionManager type=&quot;JDBC&quot;&gt;            &lt;property name=&quot;...&quot; value=&quot;...&quot;/&gt;        &lt;/transactionManager&gt;        &lt;dataSource type=&quot;POOLED&quot;&gt;            &lt;property name=&quot;driver&quot; value=&quot;${driver}&quot;/&gt;            &lt;property name=&quot;url&quot; value=&quot;${url}&quot;/&gt;            &lt;property name=&quot;username&quot; value=&quot;${username}&quot;/&gt;            &lt;property name=&quot;password&quot; value=&quot;${password}&quot;/&gt;        &lt;/dataSource&gt;    &lt;/environment&gt;&lt;/environments&gt;</code></pre><ul><li><p>默认使用的环境 ID（比如：default=&quot;development&quot;）。</p></li><li><p>每个 environment 元素定义的环境 ID（比如：id=&quot;development&quot;）。</p></li><li><p>事务管理器的配置（比如：type=&quot;JDBC&quot;）。如果使用 Spring + MyBatis，Spring 模块会使用自带的管理器来覆盖前面的配置。</p></li><li><p>数据源的配置（比如：type=&quot;POOLED&quot;）。</p><pre><code class="xml">  &lt;dataSource type=&quot;POOLED&quot;&gt;      &lt;!-- type=&quot;UNPOOLED&quot;  不使用任何数据库连接池来管理数据库连接 --&gt;      &lt;property name=&quot;driver&quot; value=&quot;${driver}&quot;/&gt;      &lt;property name=&quot;url&quot; value=&quot;${url}&quot;/&gt;      &lt;property name=&quot;username&quot; value=&quot;${username}&quot;/&gt;      &lt;property name=&quot;password&quot; value=&quot;${password}&quot;/&gt;      &lt;!-- defaultTransactionIsolationLevel – 默认的连接事务隔离级别。 --&gt;      &lt;!-- defaultNetworkTimeout 默认网络超时值(以毫秒为单位)，以等待数据库操作完成 --&gt;      &lt;!-- 你也可以传递属性给数据库驱动。只需在属性名加上“driver.”前缀即可，例如： --&gt;          &lt;!-- driver.encoding=UTF8 --&gt;      &lt;!-- type=&quot;POOLED&quot; 使用 Mybatis 自带的数据库连接池来管理数据库连接 --&gt;      &lt;!-- 除了上述提到 UNPOOLED 下的属性外，还有更多属性用来配置 POOLED 的数据源： --&gt;      &lt;!-- 在任意时间可以存在的活动（也就是正在使用）连接数量，默认值：10 --&gt;      &lt;property name=&quot;poolMaximumActiveConnections&quot; value=&quot;10&quot;/&gt;      &lt;!-- 任意时间可能存在的空闲连接数。 --&gt;      &lt;property name=&quot;poolMaximumIdleConnections&quot; value=&quot;10&quot;/&gt;      &lt;!--  在被强制返回之前，池中连接被检出（checked out）时间，默认值：20000 毫秒（即 20 秒） --&gt;      &lt;property name=&quot;poolMaximumCheckoutTime&quot; value=&quot;20000&quot;/&gt;      &lt;!--  这是一个底层设置，如果获取连接花费了相当长的时间，连接池会打印状态日志并重新尝试获取一个连接，默认值：20000 毫秒（即 20 秒）。 --&gt;      &lt;property name=&quot;poolTimeToWait&quot; value=&quot;20000&quot;/&gt;      &lt;!-- 这是一个关于坏连接容忍度的底层设置， 作用于每一个尝试从缓存池获取连接的线程。 如果这个线程获取到的是一个坏的连接，那么这个数据源允许这个线程尝试重新获取一个新的连接，但是这个重新尝试的次数不应该超过 poolMaximumIdleConnections 与 poolMaximumLocalBadConnectionTolerance 之和。 默认值：3 （新增于 3.4.5） --&gt;      &lt;property name=&quot;poolMaximumLocalBadConnectionTolerance&quot; value=&quot;3&quot;/&gt;      &lt;!-- 是否启用侦测查询。若开启，需要设置 poolPingQuery 属性为一个可执行的 SQL 语句（最好是一个速度非常快的 SQL 语句），默认值：false。 --&gt;      &lt;property name=&quot;poolPingEnabled&quot; value=&quot;true&quot;/&gt;      &lt;!-- 发送到数据库的侦测查询，用来检验连接是否正常工作并准备接受请求。默认是“NO PING QUERY SET”，这会导致多数数据库驱动失败时带有一个恰当的错误消息。 --&gt;      &lt;property name=&quot;poolPingQuery&quot; value=&quot;select 1&quot;/&gt;      &lt;!-- 配置 poolPingQuery 的频率。可以被设置为和数据库连接超时时间一样，来避免不必要的侦测，默认值：0（即所有连接每一时刻都被侦测 — 当然仅当 poolPingEnabled 为 true 时适用）。 --&gt;      &lt;property name=&quot;poolPingConnectionsNotUsedFor&quot; value=&quot;20000&quot;/&gt;  &lt;/dataSource&gt;</code></pre></li></ul><h1 id="映射器（mappers）"><a href="#映射器（mappers）" class="headerlink" title="映射器（mappers）"></a>映射器（mappers）</h1><p>可以使用相对于类路径的资源引用， 或完全限定资源定位符（包括 file:/// 的 URL），或类名和包名等。例如：</p><pre><code class="xml">&lt;!-- 使用相对于类路径的资源引用 --&gt;&lt;mappers&gt;    &lt;mapper resource=&quot;org/mybatis/builder/PostMapper.xml&quot;/&gt;&lt;/mappers&gt;&lt;!-- 使用完全限定资源定位符（URL） --&gt;&lt;mappers&gt;    &lt;mapper url=&quot;file:///var/mappers/PostMapper.xml&quot;/&gt;&lt;/mappers&gt;&lt;!-- 使用映射器接口实现类的完全限定类名 --&gt;&lt;mappers&gt;    &lt;mapper class=&quot;org.mybatis.builder.PostMapper&quot;/&gt;&lt;/mappers&gt;&lt;!-- 将包内的映射器接口实现全部注册为映射器 --&gt;&lt;mappers&gt;    &lt;package name=&quot;org.mybatis.builder&quot;/&gt;&lt;/mappers&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis 01-入门</title>
      <link href="/2019/09/18/MyBatis%2001-%E5%85%A5%E9%97%A8/"/>
      <url>/2019/09/18/MyBatis%2001-%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://mybatis.org/mybatis-3/zh/getting-started.html" target="_blank" rel="noopener">https://mybatis.org/mybatis-3/zh/getting-started.html</a><br><a href="http://www.broadview.com.cn/book/3643" target="_blank" rel="noopener">http://www.broadview.com.cn/book/3643</a></p></blockquote><h1 id="引用-jar-包"><a href="#引用-jar-包" class="headerlink" title="引用 jar 包"></a>引用 jar 包</h1><p>可在 <a href="https://github.com/mybatis/mybatis-3/releases" target="_blank" rel="noopener">https://github.com/mybatis/mybatis-3/releases</a> 下载</p><p>或者使用 Maven 来构建项目</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;    &lt;version&gt;3.5.2&lt;/version&gt;&lt;/dependency&gt;</code></pre><h1 id="从-XML-中构建-SqlSessionFactory"><a href="#从-XML-中构建-SqlSessionFactory" class="headerlink" title="从 XML 中构建 SqlSessionFactory"></a>从 XML 中构建 SqlSessionFactory</h1><p>每个基于 <code>MyBatis</code> 的应用都是以一个 <code>SqlSessionFactory</code> 的实例为核心的。<code>SqlSessionFactory</code> 的实例可以通过 <code>SqlSessionFactoryBuilder</code> 获得。而 <code>SqlSessionFactoryBuilder</code> 则可以从 <code>XML</code> 配置文件或一个预先定制的 <code>Configuration</code> 的实例构建出 <code>SqlSessionFactory</code> 的实例。</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;settings&gt;        &lt;!-- logImpl 属性配置指定使用 LOG4J 输出日志 --&gt;        &lt;setting name=&quot;logImpl&quot; value=&quot;LOG4J&quot;/&gt;    &lt;/settings&gt;    &lt;typeAliases&gt;        &lt;!-- 配置了一个包的别名，如：com.bin.model.Country，在使用类时可以使用 Country 即可，或采用如下方式 --&gt;        &lt;!-- &lt;typeAlias alias=&quot;Country&quot; type=&quot;com.bin.model.Country&quot;/&gt; --&gt;        &lt;package name=&quot;com.bin.model&quot;/&gt;    &lt;/typeAliases&gt;    &lt;environments default=&quot;development&quot;&gt;        &lt;environment id=&quot;development&quot;&gt;            &lt;!-- 配置数据库连接  --&gt;            &lt;transactionManager type=&quot;JDBC&quot;/&gt;            &lt;dataSource type=&quot;UNPOOLED&quot;&gt;                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?serverTimezone=Asia/Shanghai&amp;amp;characterEncoding=utf8&quot;/&gt;                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;                &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;    &lt;mappers&gt;        &lt;!-- MyBatis 的 SQL 语句和映射配置文件 --&gt;        &lt;mapper resource=&quot;com/bin/mapper/CountryMapper.xml&quot;/&gt;    &lt;/mappers&gt;&lt;/configuration&gt;</code></pre><p>MyBatis 包含一个名叫 Resources 的工具类，它包含一些实用方法，可使从 classpath 或其他位置加载资源文件更加容易。</p><pre><code class="java">String resource = &quot;mybatis-config.xml&quot;;InputStream inputStream = Resources.getResourceAsStream(resource);SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);</code></pre><h1 id="不使用-XML-构建-SqlSessionFactory"><a href="#不使用-XML-构建-SqlSessionFactory" class="headerlink" title="不使用 XML 构建 SqlSessionFactory"></a>不使用 XML 构建 SqlSessionFactory</h1><p>如果你更愿意直接从 Java 代码而不是 XML 文件中创建配置，或者想要创建你自己的配置构建器，MyBatis 也提供了完整的配置类，提供所有和 XML 文件相同功能的配置项。</p><pre><code class="java">// https://stackoverflow.com/questions/22517318/cant-find-some-mybatis-classes-to-import-in-getting-started-guide/42051489#42051489public interface CountryMapper {    @Select(&quot;select id, countryname, countrycode from country&quot;)  // xml 示例中这行注释    public List&lt;Country&gt; selectAll();}class MyDataSourceFactory implements DataSourceFactory {    private Properties prop;    @Override    public DataSource getDataSource() {        PooledDataSource ds = new PooledDataSource();        ds.setDriver(prop.getProperty(&quot;driver&quot;));        ds.setUrl(prop.getProperty(&quot;url&quot;));        ds.setUsername(prop.getProperty(&quot;user&quot;));        ds.setPassword(prop.getProperty(&quot;password&quot;));        return ds;    }    @Override    public void setProperties(Properties prprts) {        prop = prprts;    }}public class MyBatisJavaConfClient {    private static SqlSessionFactory sesFact = null;    public static void main(String[] args) throws IOException {        Properties prop = new Properties();        prop.setProperty(&quot;driver&quot;, &quot;com.mysql.cj.jdbc.Driver&quot;);        prop.setProperty(&quot;url&quot;, &quot;jdbc:mysql://localhost:3306/mybatis?serverTimezone=Asia/Shanghai&amp;characterEncoding=utf8&quot;);        prop.setProperty(&quot;user&quot;, &quot;root&quot;);        prop.setProperty(&quot;password&quot;, &quot;root&quot;);        MyDataSourceFactory mdsf = new MyDataSourceFactory();        mdsf.setProperties(prop);        DataSource ds = mdsf.getDataSource();        TransactionFactory trFact = new JdbcTransactionFactory();        Environment environment = new Environment(&quot;development&quot;, trFact, ds);        Configuration configuration = new Configuration(environment);        configuration.addMapper(CountryMapper.class);        sesFact = new SqlSessionFactoryBuilder().build(configuration);        try (SqlSession session = sesFact.openSession()) {            List&lt;Country&gt; countryList = session.selectList(&quot;selectAll&quot;);            System.out.println(countryList);        }    }}</code></pre><p>注意该例中，<code>configuration</code> 添加了一个映射器类（mapper class）。映射器类是 Java 类，它们包含 SQL 映射语句的注解从而避免依赖 XML 文件。不过，由于 Java 注解的一些限制以及某些 MyBatis 映射的复杂性，要使用大多数高级映射（比如：嵌套联合映射），仍然需要使用 XML 配置。有鉴于此，如果存在一个同名 XML 配置文件，MyBatis 会自动查找并加载它（在这个例子中，基于类路径和 <code>CountryMapper.class</code> 的类名，会加载 <code>CountryMapper.xml</code>）。</p><h1 id="从-SqlSessionFactory-中获取-SqlSession"><a href="#从-SqlSessionFactory-中获取-SqlSession" class="headerlink" title="从 SqlSessionFactory 中获取 SqlSession"></a>从 SqlSessionFactory 中获取 SqlSession</h1><p>既然有了 SqlSessionFactory，顾名思义，我们就可以从中获得 SqlSession 的实例了。SqlSession 完全包含了面向数据库执行 SQL 命令所需的所有方法。你可以通过 SqlSession 实例来直接执行已映射的 SQL 语句。例如：</p><pre><code class="java">try (SqlSession session = sqlSessionFactory.openSession()) {    List&lt;Country&gt; countryList = sqlSession.selectList(&quot;selectAll&quot;);}</code></pre><p>诚然，这种方式能够正常工作，并且对于使用旧版本 MyBatis 的用户来说也比较熟悉。不过现在有了一种更简洁的方式 ——使用正确描述每个语句的参数和返回值的接口（比如 BlogMapper.class），你现在不仅可以执行更清晰和类型安全的代码，而且还不用担心易错的字符串字面值以及强制类型转换。</p><p>例如：</p><pre><code class="java">try (SqlSession session = sqlSessionFactory.openSession()) {    CountryMapper mapper = sqlSession.getMapper(CountryMapper.class);    List&lt;Country&gt; countryList = mapper.selectAll();}</code></pre><h1 id="CountryMapper-xml"><a href="#CountryMapper-xml" class="headerlink" title="CountryMapper.xml"></a>CountryMapper.xml</h1><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.bin.mapper.CountryMapper&quot;&gt;    &lt;!-- 不能和 接口中的注解同时使用 --&gt;    &lt;select id=&quot;selectAll&quot; resultType=&quot;Country&quot;&gt;        select id, countryname, countrycode from country    &lt;/select&gt;&lt;/mapper&gt;</code></pre><p><strong>命名空间</strong>的作用有两个，一个是利用更长的完全限定名来将不同的语句隔离开来，同时也实现了你上面见到的接口绑定。就算你觉得暂时用不到接口绑定，你也应该遵循这里的规定，以防哪天你改变了主意。 长远来看，只要将命名空间置于合适的 Java 包命名空间之中，你的代码会变得更加整洁，也有利于你更方便地使用 MyBatis。</p><h1 id="作用域（Scope）和生命周期"><a href="#作用域（Scope）和生命周期" class="headerlink" title="作用域（Scope）和生命周期"></a>作用域（Scope）和生命周期</h1><h2 id="SqlSessionFactoryBuilder"><a href="#SqlSessionFactoryBuilder" class="headerlink" title="SqlSessionFactoryBuilder"></a>SqlSessionFactoryBuilder</h2><p>这个类可以被实例化、使用和丢弃，一旦创建了 <code>SqlSessionFactory</code>，就不再需要它了。 因此 <code>SqlSessionFactoryBuilder</code> 实例的最佳作用域是方法作用域（也就是局部方法变量）。 你可以重用 <code>SqlSessionFactoryBuilder</code> 来创建多个 <code>SqlSessionFactory</code> 实例，但是最好还是不要让其一直存在，以保证所有的 XML 解析资源可以被释放给更重要的事情。</p><h2 id="SqlSessionFactory"><a href="#SqlSessionFactory" class="headerlink" title="SqlSessionFactory"></a>SqlSessionFactory</h2><p><code>SqlSessionFactory</code> 一旦被创建就应该在应用的运行期间一直存在，<strong>没有任何理由丢弃它或重新创建另一个实例</strong>。 使用 <code>SqlSessionFactory</code> 的最佳实践是在应用运行期间不要重复创建多次，多次重建 <code>SqlSessionFactory</code> 被视为一种代码“坏味道（bad smell）”。因此 <code>SqlSessionFactory</code> 的最佳作用域是应用作用域。 有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式。</p><h2 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h2><p><strong>每个线程都应该有它自己的 <code>SqlSession</code> 实例</strong>。<code>SqlSession</code> 的实例不是线程安全的，因此是不能被共享的，所以它的<strong>最佳的作用域是请求或方法作用域</strong>。 绝对不能将 <code>SqlSession</code> 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。 也绝不能将 <code>SqlSession</code> 实例的引用放在任何类型的托管作用域中，比如 <code>Servlet</code> 框架中的 <code>HttpSession</code>。 如果你现在正在使用一种 <code>Web</code> 框架，要考虑 <code>SqlSession</code> 放在一个和 <code>HTTP</code> 请求对象相似的作用域中。 换句话说，每次收到的 <code>HTTP</code> 请求，就可以打开一个 <code>SqlSession</code>，返回一个响应，就关闭它。 这个关闭操作是很重要的，你应该把这个关闭操作放到 <code>finally</code> 块中以确保每次都能执行关闭。 下面的示例就是一个确保 <code>SqlSession</code> 关闭的标准模式：</p><pre><code class="java">try (SqlSession session = sqlSessionFactory.openSession()) {  // 你的应用逻辑代码}</code></pre><p>在你的所有的代码中一致地使用这种模式来保证所有数据库资源都能被正确地关闭。</p><h2 id="映射器实例"><a href="#映射器实例" class="headerlink" title="映射器实例"></a>映射器实例</h2><p>映射器是一些由你创建的、绑定你映射的语句的接口。映射器接口的实例是从 <code>SqlSession</code> 中获得的。因此从技术层面讲，任何映射器实例的最大作用域是和请求它们的 <code>SqlSession</code> 相同的。尽管如此，映射器实例的最佳作用域是<strong>方法作用域</strong>。 也就是说，映射器实例应该在调用它们的方法中被请求，用过之后即可丢弃。 并不需要显式地关闭映射器实例，尽管在整个请求作用域保持映射器实例也不会有什么问题，但是你很快会发现，像 <code>SqlSession</code> 一样，在这个作用域上管理太多的资源的话会难于控制。 为了避免这种复杂性，最好把映射器放在方法作用域内。下面的示例就展示了这个实践：</p><pre><code class="java">try (SqlSession session = sqlSessionFactory.openSession()) {  BlogMapper mapper = session.getMapper(BlogMapper.class);  // 你的应用逻辑代码}</code></pre><h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><p>Mybatis 的内置日志工厂提供日志功能，内置日志工厂将日志交给以下其中一种工具作代理：</p><ul><li>SLF4J</li><li>Apache Commons Logging</li><li>Log4j 2</li><li>Log4j</li><li>JDK logging</li></ul><p>MyBatis 内置日志工厂基于运行时自省机制选择合适的日志工具。它会使用第一个查找得到的工具（按上文列举的顺序查找）。如果一个都未找到，日志功能就会被禁用。</p><p>可以通过在 MyBatis 配置文件 <code>mybatis-config.xml</code> 里面添加一项 <code>setting</code> 来选择别的日志工具。</p><pre><code class="xml">&lt;configuration&gt;  &lt;settings&gt;    ...    &lt;setting name=&quot;logImpl&quot; value=&quot;LOG4J&quot;/&gt;    ...  &lt;/settings&gt;&lt;/configuration&gt;</code></pre><p>在应用的类路径中创建一个名称为 <code>log4j.properties</code> 的文件，文件的具体内容如下：</p><pre><code class="ini">; Global logging configurationlog4j.rootLogger=ERROR, stdout; MyBatis logging configuration...log4j.logger.com.bin.mapper.CountryMapper=TRACE; 你也可以将日志的记录方式从接口级别切换到语句级别，从而实现更细粒度的控制。如下配置只对 selectAll 语句记录日志：log4j.logger.com.bin.mapper.CountryMapper.selectAll=TRACE; 可以对一组映射器接口记录日志，只要对映射器接口所在的包开启日志功能即可：log4j.logger.com.bin.mapper=TRACE; 如需对 XML 文件记录日志，只要对命名空间增加日志记录功能即可：log4j.logger.com.bin.mapper.CountryMapper=TRACE; Console output...log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n</code></pre><p>MyBatis 日志的最低级别时 TREAC，这个级别下会输出执行 SQL 过程中的详细信息。</p><pre><code class="log">EBUG [main] - ==&gt;  Preparing: select id, countryname, countrycode from countryDEBUG [main] - ==&gt; Parameters:TRACE [main] - &lt;==    Columns: id, countryname, countrycodeTRACE [main] - &lt;==        Row: 1, 中国, CNTRACE [main] - &lt;==        Row: 2, 美国, USTRACE [main] - &lt;==        Row: 3, 俄罗斯, RUTRACE [main] - &lt;==        Row: 4, 英国, GBTRACE [main] - &lt;==        Row: 5, 法国, FRDEBUG [main] - &lt;==      Total: 5</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven 学习</title>
      <link href="/2019/08/26/Maven%20%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/08/26/Maven%20%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>Maven 是一个项目管理工具，它包含了一个 项目对象模<br>型 (POM：Project Object Model)，一组标准集合，一个项目生命周期(Project Lifecycle)，一个依赖管<br>理系统(Dependency Management System)，和用来运行定义在生命周期阶段(phase)中插件(plugin)目标<br>(goal)的逻辑。</p><h1 id="安装-maven"><a href="#安装-maven" class="headerlink" title="安装 maven"></a>安装 maven</h1><ul><li><p>配置 <code>JAVA_HOME</code> 的环境变量</p></li><li><p>下载地址：<a href="https://maven.apache.org/download.cgi" target="_blank" rel="noopener">https://maven.apache.org/download.cgi</a></p></li><li><p>解压到一个没有中文没有空格的路径下</p><ul><li><code>bin</code>: 存放了 maven 的命令，比如 <code>mvn</code></li><li><code>boot</code>: 存放了一些 maven 本身的引导程序，如类加载器等</li><li><code>conf</code>: 存放了 maven 的一些配置文件，如 <code>setting.xml</code> 文件</li><li><code>lib</code>: 存放了 maven 本身运行所需的一些 jar 包</li></ul></li><li><p>在环境变量增加 <code>M2_HOME</code>，路径是 maven 解压后的根目录</p></li><li><p>在环境变量里的 <code>path</code> 中增加 <code>maven/bin</code> 的目录</p></li><li><p><code>mvn -v</code> 查看 maven 版本</p><pre><code class="cmd">  mvn -v  Apache Maven 3.3.9 (bb52d8502b132ec0a5a3f4c09453c07478323dc5; 2015-11-11T00:41:47+08:00)  Maven home: C:\maven\bin\..  Java version: 1.8.0_171, vendor: Oracle Corporation  Java home: C:\Program Files\Java\jdk1.8.0_171\jre  Default locale: zh_CN, platform encoding: GBK  OS name: &quot;windows 10&quot;, version: &quot;10.0&quot;, arch: &quot;amd64&quot;, family: &quot;dos&quot;</code></pre></li></ul><h1 id="Maven-本地仓库的配置"><a href="#Maven-本地仓库的配置" class="headerlink" title="Maven 本地仓库的配置"></a>Maven 本地仓库的配置</h1><p>在 <code>MAVE_HOME/conf/settings.xml</code> 文件中配置本地仓库位置（maven 的安装目录下）：</p><pre><code class="xml">&lt;!-- settings 标签下 --&gt;&lt;!-- 默认值：${user.home}/.m2/repository --&gt;&lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt;</code></pre><h1 id="Maven-工程的目录结构"><a href="#Maven-工程的目录结构" class="headerlink" title="Maven 工程的目录结构"></a>Maven 工程的目录结构</h1><ul><li><code>src/main/java</code> —— 存放项目的.java 文件</li><li><code>src/main/resources</code> —— 存放项目资源文件，如 spring, hibernate 配置文件</li><li><code>src/main/webapp</code> —— 存放项目页面元素，普通 Java 项目没有这个目录</li><li><code>src/test/java</code> —— 存放所有单元测试 .java 文件，如 JUnit 测试类</li><li><code>src/test/resources</code> —— 测试资源文件</li><li><code>target</code> —— 项目输出位置，编译后的 class 文件会输出到此目录</li><li><code>pom.xml</code> —— maven 项目核心配置文件</li></ul><h1 id="Maven-常用命令"><a href="#Maven-常用命令" class="headerlink" title="Maven 常用命令"></a>Maven 常用命令</h1><ul><li><code>compile</code>：编译，<code>mvn compile</code> 将 src/main/java 下的文件编译为 class 文件输出到 target 目录下</li><li><code>test</code>：测试，<code>mvn test</code> 执行 src/test/java 下的单元测试类</li><li><code>clean</code>：清理，<code>mvn clean</code> 删除 target 目录</li><li><code>package</code>：打包，<code>mvn package</code> 将 Java 工程打成 jar 包，对于 web 工程打成 war 包</li><li><code>install</code>：安装，<code>mvn install</code> 将打成 jar 或 war 包发布到本地仓库中</li></ul><h1 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h1><pre><code class="xml">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;!-- 公司或组织域名倒序+项目名 --&gt;    &lt;groupId&gt;com.bin.test&lt;/groupId&gt;    &lt;!-- 模块名 --&gt;    &lt;artifactId&gt;Demo&lt;/artifactId&gt;    &lt;!-- 打包方式 jar 或 war 或 pom ：用于 maven 工程的继承，通常父工程设置为 pom--&gt;    &lt;packaging&gt;war&lt;/packaging&gt;    &lt;!-- 版本 --&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;    &lt;!-- 项目的显示名称，通常用于 maven 产生的文档中 --&gt;    &lt;name&gt;Demo Maven Webapp&lt;/name&gt;    &lt;!-- 指定项目站点，通常用于maven产生的文档中 --&gt;    &lt;url&gt;http://maven.apache.org&lt;/url&gt;    &lt;!-- 描述此项目，通常用于maven产生的文档中 --&gt;    &lt;description&gt;测试&lt;/description&gt;    &lt;properties&gt;        &lt;!-- 占位符 --&gt;        &lt;spring.version&gt;4.2.9.RELEASE&lt;/spring.version&gt;    &lt;/properties&gt;    &lt;dependencies&gt;    &lt;!-- 依赖的项目 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;            &lt;version&gt;${spring.version}&lt;/version&gt;            &lt;scope&gt;compile&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;repositories&gt;    &lt;!-- 默认的中央仓库设置 --&gt;        &lt;repository&gt;            &lt;id&gt;central&lt;/id&gt;            &lt;name&gt;Central Repository&lt;/name&gt;            &lt;url&gt;https://repo.maven.apache.org/maven2&lt;/url&gt;            &lt;layout&gt;default&lt;/layout&gt;            &lt;snapshots&gt;                &lt;enabled&gt;false&lt;/enabled&gt;            &lt;/snapshots&gt;        &lt;/repository&gt;    &lt;/repositories&gt;    &lt;build&gt;        &lt;!-- 项目的名字 --&gt;    　　&lt;finalName&gt;WebMavenDemo&lt;/finalName&gt;    　　&lt;!-- 描述项目中资源的位置 --&gt;    　　&lt;resources&gt;    　　　　&lt;!-- 自定义资源1 --&gt;    　　　　&lt;resource&gt;    　　　　　　&lt;!-- 资源目录 --&gt;    　　　　　　&lt;directory&gt;src/main/java&lt;/directory&gt;    　　　　　　&lt;!-- 包括哪些文件参与打包 --&gt;    　　　　　　&lt;includes&gt;    　　　　　　　　&lt;include&gt;**/*.xml&lt;/include&gt;    　　　　　　&lt;/includes&gt;    　　　　　　&lt;!-- 排除哪些文件不参与打包 --&gt;    　　　　　　&lt;excludes&gt;    　　　　　　　　&lt;exclude&gt;**/*.txt&lt;/exclude&gt;    　　　　　　　　　　&lt;exclude&gt;**/*.doc&lt;/exclude&gt;    　　　　　　&lt;/excludes&gt;    　　　　&lt;/resource&gt;    　　&lt;/resources&gt;        &lt;plugins&gt;            &lt;!-- 设置 jdk 编译版本 --&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;                &lt;configuration&gt;                    &lt;source&gt;1.8&lt;/source&gt;                    &lt;target&gt;1.8&lt;/target&gt;                    &lt;encoding&gt;UTF-8&lt;/encoding&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;            &lt;!-- 添加 tomcat7 插件，自带 tomcat6， 就算加上 7 了，执行 mvn tomcat:run 也还是 6 --&gt;            &lt;!-- 启动命令：mvn tomcat7:run --&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;                &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;                &lt;version&gt;2.2&lt;/version&gt;                &lt;configuration&gt;                    &lt;uriEncoding&gt;utf-8&lt;/uriEncoding&gt;                    &lt;port&gt;8070&lt;/port&gt;                    &lt;path&gt;/&lt;/path&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;            &lt;!-- 此时点击 idea 最右侧 Maven Projects，就可以看到我们新添加的 tomcat7 插件，双击 tomcat7 插件下 tomcat7:run 命令直接运行项目 --&gt;        &lt;/plugins&gt;    &lt;/build&gt;</code></pre><p>maven坐标和仓库对应的映射关系：<code>[groupId]\[artifactId]\[version]\[artifactId]-[version].jar</code></p><p>去本地仓库看一下此目录：org\springframework\spring-core\4.3.4.RELEASE\spring-core-4.3.4.RELEASE.jar</p><h2 id="依赖范围"><a href="#依赖范围" class="headerlink" title="依赖范围"></a>依赖范围</h2><p>scope就是依赖的范围</p><ol><li><code>compile</code>，默认值，适用于所有阶段（开发、测试、部署、运行）</li><li><code>provided</code>，只在开发、测试阶段使用，目的是不让 Servlet 容器和你本地仓库的 jar 包冲突 。如 servlet.jar。</li><li><code>runtime</code>，只在运行时使用，如 JDBC 驱动，适用运行和测试阶段。</li><li><code>test</code>，只在测试时使用，用于编译和运行测试代码。不会随项目发布。</li><li><code>system</code>，类似 provided，需要显式提供包含依赖的 jar 文件的路径，Maven 不会在 Repository 中查找它，不推荐使用。</li></ol><table><thead><tr><th>依赖范围</th><th>对于编译 classpath 有效</th><th>对于测试 classpath 有效</th><th>对于运行时 classpath 有效</th><th>例子</th></tr></thead><tbody><tr><td>compile</td><td>Y</td><td>Y</td><td>Y</td><td>spring-core</td></tr><tr><td>test</td><td>-</td><td>Y</td><td>-</td><td>Junit</td></tr><tr><td>provided</td><td>Y</td><td>Y</td><td>-</td><td>servlet-api</td></tr><tr><td>runtime</td><td>-</td><td>Y</td><td>Y</td><td>JDBC 驱动</td></tr><tr><td>system</td><td>Y</td><td>Y</td><td>-</td><td>本地的</td></tr></tbody></table><h1 id="idea-开发-maven-项目"><a href="#idea-开发-maven-项目" class="headerlink" title="idea 开发 maven 项目"></a>idea 开发 maven 项目</h1><p>idea 的 的 maven 配置：<code>File --&gt; Settings --&gt; Build, Execution, Deployment --&gt; Build Tools --&gt; Maven</code>。</p><h2 id="创建-Maven-项目速度慢问题"><a href="#创建-Maven-项目速度慢问题" class="headerlink" title="创建 Maven 项目速度慢问题"></a>创建 Maven 项目速度慢问题</h2><blockquote><p><a href="https://www.cnblogs.com/del88/p/6286887.html" target="_blank" rel="noopener">https://www.cnblogs.com/del88/p/6286887.html</a></p></blockquote><p>IDEA 根据 <code>maven archetype</code> 的本质，其实是执行 <code>mvn archetype:generate</code> 命令，该命令执行时，需要指定一个 <code>archetype-catalog.xml</code> 文件。</p><p>该命令的参数 <code>-DarchetypeCatalog</code>，可选值为：<code>remote</code>，<code>internal</code>（内置的，即 <code>maven-archetype-plugin</code> 内置的 <code>archetypeCatalog</code> 文件），<code>local</code>（本地的，即本地 <code>~/.m2/</code> 下的 <code>archetypeCatalog</code> 文件）等，用来指定 <code>archetype-catalog.xml</code> 文件从哪里获取。</p><p>默认为 <code>remote</code>，即从 <a href="http://repo1.maven.org/maven2/archetype-catalog.xml" target="_blank" rel="noopener">http://repo1.maven.org/maven2/archetype-catalog.xml</a> 路径下载 <code>archetype-catalog.xml</code> 文件。</p><p>可以在 <code>Maven --&gt; Runner --&gt; VM Options</code>，增加参数：<code>-DarchetypeCatalog=internal</code></p><h2 id="创建-Maven-项目"><a href="#创建-Maven-项目" class="headerlink" title="创建 Maven 项目"></a>创建 Maven 项目</h2><p>普通 Java 项目，勾选 <code>Create from archetype</code>（可选，最后生成的目录结构不一样），选择 <code>maven-archetype-quickstart</code>。</p><p>web 项目，勾选 <code>Create from archetype</code>），选择 <code>maven-archetype-webapp</code>。</p><p>填写 <code>GroupId</code>（公司名称），<code>ArtifactId</code>（项目名），<code>Version</code>（版本），剩下的默认即可。最后生成的目录不完整，需自己手动补上。</p><blockquote><p><a href="http://yun.itheima.com/course/234.html" target="_blank" rel="noopener">http://yun.itheima.com/course/234.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Spring 实战》笔记7：Spring MVC 的高级技术</title>
      <link href="/2019/08/10/%E3%80%8ASpring%20%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B07%EF%BC%9ASpring%20MVC%20%E7%9A%84%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/"/>
      <url>/2019/08/10/%E3%80%8ASpring%20%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B07%EF%BC%9ASpring%20MVC%20%E7%9A%84%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-MVC-配置的替代方案"><a href="#Spring-MVC-配置的替代方案" class="headerlink" title="Spring MVC 配置的替代方案"></a>Spring MVC 配置的替代方案</h1><p>在第 5 章中，我们通过扩展 <code>AbstractAnnotationConfigDispatcherServletInitializer</code> 快速搭建了 Spring MVC 环境。在这个便利的基础类中，假设我们需要基本的 <code>DispatcherServlet</code> 和 <code>ContextLoaderListener</code> 环境，并且 Spring 配置是使用 Java 的，而不是 XML。</p><p>尽管对很多 Spring 应用来说，这是一种安全的假设，但是并不一定能满足我们的要求。除了 <code>DispatcherServlet</code> 以外，我们还可能需要额外的 <code>Servlet</code> 和 <code>Filter</code>，我们可能还需要对 <code>DispatcherServlet</code> 本身做一些额外的配置；或者，如果我们需要将应用部署到 Servlet3.0 之前的容器中，那么还需要将 <code>DispatcherServlet</code> 配置到传统的 web.xml 中。</p><h2 id="自定义-DispatcherServlet-配置"><a href="#自定义-DispatcherServlet-配置" class="headerlink" title="自定义 DispatcherServlet 配置"></a>自定义 DispatcherServlet 配置</h2><p>在 <code>SpittrWebAppInitializer</code> （第五章）中继承了 <code>AbstractAnnotationConfigDispatcherServletInitializer</code> ，还有其他可重载的方法 <code>customizeRegistration()</code>。</p><p>在 <code>AbstractAnnotationConfigDispatcherServletInitializer</code> 将 <code>DispatcherServlet</code> 注册到 <code>Servlet</code> 容器中之后，就会调用 <code>customizeRegistration()</code>，并将 <code>Servlet</code> 注册后得到的 <code>Registration.Dynamic</code><br>传递进来。通过重载 <code>customizeRegistration()</code> 方法，我们可以对 <code>DispatcherServlet</code> 进行额外的配置。</p><p>如果计划使用 Servlet 3.0 对 multipart 配置的支持，那么需要使用 <code>DispatcherServlet</code> 的 <code>registration</code> 来启用 <code>multipart</code> 请求。我们可以重载 <code>customizeRegistration()</code> 方法来设置 <code>MultipartConfigElement</code>，如下所示：</p><pre><code class="java">@Overrideprotected void customizeRegistration(ServletRegistration.Dynamic registration) {    registration.setMultipartConfig(new MultipartConfigElement(&quot;/tmp/spittr/uploads&quot;));}</code></pre><p>借助 <code>customizeRegistration()</code> 方法中的 <code>ServletRegistration.Dynamic</code>，我们能够完成多项任务，包括通过调用 <code>setLoadOnStartup()</code> 设置 <code>load-on-startup</code> 优先级，通过 <code>setInitParameter()</code> 设置初始化参数，通过调用 <code>setMultipartConfig()</code> 配置 Servlet3.0 对 <code>multipart</code> 的支持。在前面的样例中，我们设置了对 <code>multipart</code> 的支持，将上传文件的临时存储目录设置在 &quot;tmpspittr/uploads&quot; 中。</p><h2 id="添加其他的-Servlet-和-Filter"><a href="#添加其他的-Servlet-和-Filter" class="headerlink" title="添加其他的 Servlet 和 Filter"></a>添加其他的 Servlet 和 Filter</h2><p>按照 <code>AbstractAnnotationConfigDispatcherServletInitializer</code> 的定义，它会创建 <code>DispatcherServlet</code> 和 <code>ContextLoaderListener</code>。</p><p>如果我们想往 Web 容器中注册其他组件的话，只需创建一个新的初始化器就可以了。最简单的方式就是实现 Spring 的 <code>WebApplicationInitializer</code> 接口。</p><pre><code class="java">// 通过实现 WebApplicationInitializer 来注册 Servletpublic class MyServletInitializer implements WebApplicationInitializer {    @Override    public void onStartup(ServletContext servletContext) throws ServletException {        // 注册 Servlet        ServletRegistration.Dynamic myServlet = servletContext.addServlet(&quot;myServlet&quot;, MyServlet.getClass());        // 映射 Servlet        myServlet.addMapping(&quot;/custom/**&quot;);    }}</code></pre><pre><code class="java">// 注册 Filter 的 WebApplicationInitializer@Overridepublic void onStartup(ServletContext servletContext) throws ServletException {    javax.servlet.FilterRegistration.Dynamic filter = servletContext.addFilter(&quot;myFilter&quot;, MyFilter.class);    filter.addMappingForUrlPatterns(null, false, &quot;/custom/*&quot;);}</code></pre><p>如果你只是注册 <code>Filter</code>，并且该 <code>Filter</code> <strong>只会映射到</strong> <code>DispatcherServlet</code> 上的话，只需重<br>载 <code>AbstractAnnotationConfigDispatcherServletInitializer</code> 的 <code>getServletFilters()</code> 方法。</p><pre><code class="java">@Overrideprotected Filter[] getServletFilters() {    return new Filter[] { new MyFilter() };  // 可以返回任意数量的 Filter}</code></pre><h2 id="在-web-xml-中声明-DispatcherServlet"><a href="#在-web-xml-中声明-DispatcherServlet" class="headerlink" title="在 web.xml 中声明 DispatcherServlet"></a>在 web.xml 中声明 DispatcherServlet</h2><h3 id="在-web-xml-中搭建-Spring-MVC"><a href="#在-web-xml-中搭建-Spring-MVC" class="headerlink" title="在 web.xml 中搭建 Spring MVC"></a>在 web.xml 中搭建 Spring MVC</h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app version=&quot;2.5&quot;    xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee        http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;&gt;    &lt;context-param&gt;        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;        &lt;!-- 指定了一个 XML 文件的地址，这个文件定义了根应用上下文，它会被 ContextLoaderListener 加载。从中加载bean定义 --&gt;        &lt;param-value&gt;/WEB-INF/spring/root-context.xml&lt;/param-value&gt;    &lt;/context-param&gt;    &lt;listener&gt;        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;    &lt;/listener&gt;    &lt;servlet&gt;        &lt;servlet-name&gt;appServlet&lt;/servlet-name&gt;        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;        &lt;!-- DispatcherServlet 会根据 Servlet 的名字找到一个文件，并基于该文件加载应用上下文。 --&gt;        &lt;!-- contextConfigLocation 不是必须的，如果不配置默认在：WEB-INF/servletName -servlet.xml --&gt;        &lt;init-param&gt;            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;            &lt;param-value&gt;/WEB-INF/spring/appServlet/servlet-context.xml&lt;/param-value&gt;        &lt;/init-param&gt;        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;    &lt;/servlet&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;appServlet&lt;/servlet-name&gt;        &lt;url-pattern&gt;/&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;&lt;/web-app&gt;</code></pre><h3 id="设置-web-xml-使用基于-Java-的配置"><a href="#设置-web-xml-使用基于-Java-的配置" class="headerlink" title="设置 web.xml 使用基于 Java 的配置"></a>设置 web.xml 使用基于 Java 的配置</h3><p>在本书中的大部分内容中，我们都更倾向于使用 Java 配置而不是 XML 配置。因此，我们需要让 Spring MVC 在启动的时候，从带有 <code>@Configuration</code> 注解的类上加载配置。</p><p>要在 Spring MVC 中使用基于 Java 的配置，我们需要告诉 <code>DispatcherServlet</code> 和 <code>ContextLoaderListener</code> 使用 <code>AnnotationConfigWebApplicationContext</code>，这是一个 <code>WebApplicationContext</code> 的实现类，</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app version=&quot;2.5&quot;         xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee            http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;&gt;    &lt;context-param&gt;        &lt;param-name&gt;contextClass&lt;/param-name&gt;        &lt;!-- 使用 Java 配置 --&gt;        &lt;param-value&gt;            org.springframework.web.context.support.AnnotationConfigWebApplicationContext        &lt;/param-value&gt;    &lt;/context-param&gt;    &lt;context-param&gt;        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;        &lt;!-- 指定根配置类 --&gt;        &lt;param-value&gt;com.habuma.spitter.config.RootConfig&lt;/param-value&gt;    &lt;/context-param&gt;    &lt;listener&gt;        &lt;listener-class&gt;            org.springframework.web.context.ContextLoaderListener        &lt;/listener-class&gt;    &lt;/listener&gt;    &lt;servlet&gt;        &lt;servlet-name&gt;appServlet&lt;/servlet-name&gt;        &lt;servlet-class&gt;            org.springframework.web.servlet.DispatcherServlet        &lt;/servlet-class&gt;        &lt;init-param&gt;            &lt;param-name&gt;contextClass&lt;/param-name&gt;            &lt;!-- 使用 Java 配置 --&gt;            &lt;param-value&gt;                org.springframework.web.context.support.AnnotationConfigWebApplicationContext            &lt;/param-value&gt;        &lt;/init-param&gt;        &lt;init-param&gt;            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;            &lt;!-- 指定 DispatcherServlet 配置类 --&gt;            &lt;param-value&gt;                com.habuma.spitter.config.WebConfigConfig            &lt;/param-value&gt;        &lt;/init-param&gt;        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;    &lt;/servlet&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;appServlet&lt;/servlet-name&gt;        &lt;url-pattern&gt;/&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;&lt;/web-app&gt;</code></pre><h1 id="处理-multipart-形式的数据"><a href="#处理-multipart-形式的数据" class="headerlink" title="处理 multipart 形式的数据"></a>处理 multipart 形式的数据</h1><h2 id="配置-multipart-解析器"><a href="#配置-multipart-解析器" class="headerlink" title="配置 multipart 解析器"></a>配置 multipart 解析器</h2><p><code>DispatcherServlet</code> 并没有实现任何解析 <code>multipart</code> 请求数据的功能。它将该任务委托给了 Spring 中 <code>MultipartResolver</code> 策略接口的实现，通过这个实现类来解析 <code>multipart</code> 请求中的内容。从 Spring 3.1 开始，Spring 内置了两个 <code>MultipartResolver</code> 的实现供我们选择：</p><ul><li><code>CommonsMultipartResolver</code>：使用 <code>Jakarta Commons FileUpload</code> 解析 <code>multipart</code> 请求；</li><li><code>StandardServletMultipartResolver</code>：依赖于 <code>Servlet 3.0</code> 对 <code>multipart</code> 请求的支持<br>（始于Spring 3.1），优选方案，不需要依赖任何其他的项目。</li></ul><h3 id="使用-Servlet-3-0-解析-multipart-请求"><a href="#使用-Servlet-3-0-解析-multipart-请求" class="headerlink" title="使用 Servlet 3.0 解析 multipart 请求"></a>使用 Servlet 3.0 解析 multipart 请求</h3><p>兼容 Servlet 3.0 的 <code>StandardServletMultipartResolver</code> 没有构造器参数，也没有要设置的属性。这样，在 Spring 应用上下文中，将其声明为 bean 就会非常简单，如下所示：</p><pre><code class="java">@Beanpublic MultipartResolver multipartResolver() throws IOException {    return new StandardServletMultipartResolver();}</code></pre><p>我们必须要在 web.xml 或 Servlet 初始化类中，将 multipart 的具体细节作为 DispatcherServlet 配置的一部分。</p><p>如果我们采用 <code>Servlet</code> 初始化类的方式来配置 <code>DispatcherServlet</code> 的话，这个初始化类应该已经实现了 <code>WebApplicationInitializer</code>，那我们可以在 <code>Servlet</code> <code>registration</code> 上调用 <code>setMultipartConfig()</code> 方法，传入一个 <code>MultipartConfigElement</code> 实例。如下是最基本的 <code>DispatcherServlet</code> <code>multipart</code> 配置，它将临时路径设置为 <code>tmp/spittr/uploads</code>：</p><pre><code class="java">DispatcherServlet ds = new DispatcherServlet();Dynamic registration = context.addServlet(&quot;appServlet&quot;, ds);registration.addMapping(&quot;/&quot;);registration.setMultipartConfig(new MultipartConfigElement(&quot;/tmp/spittr/uploads&quot;));</code></pre><p>如果我们配置 <code>DispatcherServlet</code> 的 Servlet 初始化类继承了 <code>AbstractAnnotationConfigDispatcherServletInitializer</code> 或 <code>AbstractDispatcherServletInitializer</code> 的话，那么我们不会直接创建 <code>DispatcherServlet</code> 实例并将其注册到 Servlet 上下文中。这样的话，将不会有对 <code>Dynamic Servlet registration</code> 的引用供我们使用了。但是，我们可以通过重载 <code>customizeRegistration()</code> 方法（它会得到一个 <code>Dynamic</code> 作为参数）来配置 <code>multipart</code> 的具体细节：</p><pre><code class="java">@Overrideprotected void customizeRegistration(Dynamic registration) {    registration.setMultipartConfig(new MultipartConfigElement(&quot;/tmp/spittr/uploads&quot;));}</code></pre><p>到目前为止，我们所使用是只有一个参数的 <code>MultipartConfigElement</code> 构造器，这个参数指定的是文件系统中的一个绝对目录，上传文件将会临时写入该目录中。但是，我们还可以通过其他的构造器来限制上传文件的大小。除了临时路径的位置，其他的构造器所能接受的参数如下：</p><ul><li>上传文件的最大容量（以字节为单位）。默认是没有限制的。</li><li>整个 multipart 请求的最大容量（以字节为单位），不会关心有多少个 part 以及每个 part 的大小。默认是没有限制的。</li><li>在上传的过程中，如果文件大小达到了一个指定最大容量（以字节为单位），将会写入到临时文件路径中。默认值为 0，也就是所有上传的文件都会写入到磁盘上。</li></ul><pre><code class="java">// 限制文件的大小不超过2MB，整个请求不超过4MB，而且所有的文件都要写到磁盘中@Overrideprotected void customizeRegistration(Dynamic registration) {    registration.setMultipartConfig(new MultipartConfigElement(&quot;/tmp/spittr/uploads&quot;, 2097152, 4194304, 0));}</code></pre><pre><code class="xml">&lt;!-- 使用 web.xml 来配置 MultipartConfigElement --&gt;&lt;servlet&gt;    &lt;servlet-name&gt;appServlet&lt;/servlet-name&gt;    &lt;servlet-class&gt;        org.springframework.web.servlet.DispatcherServlet    &lt;/servlet-class&gt;    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;    &lt;multipart-config&gt;        &lt;location&gt;/tmp/spittr/uploads&lt;/location&gt;        &lt;max-file-size&gt;2097152&lt;/max-file-size&gt;        &lt;max-request-size&gt;4194304&lt;/max-request-size&gt;    &lt;/multipart-config&gt;&lt;/servlet&gt;</code></pre><h3 id="配置-Jakarta-Commons-FileUpload-multipart-解析器"><a href="#配置-Jakarta-Commons-FileUpload-multipart-解析器" class="headerlink" title="配置 Jakarta Commons FileUpload multipart 解析器"></a>配置 Jakarta Commons FileUpload multipart 解析器</h3><p><code>通常来讲，StandardServletMultipartResolver</code> 会是最佳的选择</p><p>Spring 内置了 <code>CommonsMultipartResolver</code>，可以作为 <code>StandardServletMultipartResolver</code> 的替代方案。</p><p>将 <code>CommonsMultipartResolver</code> 声明为 Spring bean 的最简单方式如下：</p><pre><code class="java">@Beanpublic MultipartResolver multipartResolver() {    return new CommonsMultipartResolver();}</code></pre><p><code>CommonsMultipartResolver</code> 不会强制要求设置临时文件路径。默认情况下，这个路径就是 Servlet 容器的临时目录。不过，通过设置 <code>uploadTempDir</code> 属性，我们可以将其指定为一个不同的位置，与<code>MultipartConfigElement</code> 有所不同，我们<strong>无法设定 multipart 请求整体的最大容量</strong>。</p><pre><code class="java">@Beanpublic MultipartResolver multipartResolver() throws IOException {    CommonsMultipartResolver multipartResolver = new CommonsMultipartResolver();    multipartResolver.setUploadTempDir(new FileSystemResource(&quot;/tmp/spittr/uploads&quot;));    multipartResolver.setMaxUploadSize(2097152);  // 最大的文件容量设置为2MB    multipartResolver.setMaxInMemorySize(0);  // 最大的内存大小设置为0字节    return multipartResolver;}</code></pre><h2 id="处理-multipart-请求"><a href="#处理-multipart-请求" class="headerlink" title="处理 multipart 请求"></a>处理 multipart 请求</h2><pre><code class="html">&lt;form method=&quot;POST&quot; th:object=&quot;${spitter}&quot; enctype=&quot;multipart/form-data&quot;&gt;...    &lt;label&gt;Profile Picture&lt;/label&gt;:    &lt;input type=&quot;file&quot; name=&quot;profilePicture&quot; accept=&quot;image/jpeg,image/png,image/gif&quot; /&gt;&lt;br/&gt;...&lt;/form&gt;</code></pre><p>修改 <code>processRegistration()</code> 方法，使其能够接受上传的图片。其中一种方式是添加 byte 数组参数，并为其添加 <code>@RequestPart</code> 注解。如下为示例：</p><pre><code class="java">@RequestMapping(value=&quot;/register&quot;, method=POST)public String processRegistration(        // 如果用户提交表单的时候没有选择文件，那么这个数组会是空（而不是null）。        @RequestPart(&quot;profilePicture&quot;) byte[] profilePicture,        @Valid Spitter spitter, Errors errors) {    ...}</code></pre><h3 id="接受-MultipartFile"><a href="#接受-MultipartFile" class="headerlink" title="接受 MultipartFile"></a>接受 MultipartFile</h3><pre><code class="java">// Spring 所提供的 MultipartFile 接口，用来处理上传的文件public interface MultipartFile {    String getName();    String getOriginalFilename();  // 原始的文件名    String getContentType();  // 内容类型    boolean isEmpty();    long getSize();  // 大小    byte[] getBytes() throws IOException;    InputStream getInputStream() throws IOException;  // 将文件数据以流的方式进行读取    void transferTo(File dest) throws IOException;  // 将上传的文件写入到文件系统中    // file.transferTo(new File(&quot;/data/spittr/&quot; + file.getOriginalFilename()));}</code></pre><h3 id="以-Part-的形式接受上传的文件"><a href="#以-Part-的形式接受上传的文件" class="headerlink" title="以 Part 的形式接受上传的文件"></a>以 Part 的形式接受上传的文件</h3><p>如果你需要将应用部署到 Servlet 3.0 的容器中，那么会有 MultipartFile 的一个替代方案。Spring MVC 也能接受 <code>javax.servlet.http.Part</code> 作为控制器方法的参数。</p><pre><code class="java">@RequestMapping(value=&quot;/register&quot;, method=POST)public String processRegistration(        @RequestPart(&quot;profilePicture&quot;) Part profilePicture,        @Valid Spitter spitter, Errors errors) {    ...}</code></pre><p><code>Part</code> 方法的名称与 <code>MultipartFile</code> 方法的名称是完全相同的。有一些比较类似，但是稍有差异，比如 <code>getSubmittedFileName()</code> 对应于 <code>getOriginalFilename()</code>。类似地，<code>write()</code> 对应于 <code>transferTo()</code></p><pre><code class="java">public interface Part {    public InputStream getInputStream() throws IOException;    public String getContentType();    public String getName();    public String getSubmittedFileName();    public long getSize();    public void write(String fileName) throws IOException;    public void delete() throws IOException;    public String getHeader(String name);    public Collection&lt;String&gt; getHeaders(String name);    public Collection&lt;String&gt; getHeaderNames();}</code></pre><p>如果在编写控制器方法的时候，通过 <code>Part</code> 参数的形式接受文件上传，那么就没有必要配置 <code>MultipartResolver</code> 了。只有使用 <code>MultipartFile</code> 的时候，我们才需要 <code>MultipartResolver</code>。</p><h1 id="处理异常"><a href="#处理异常" class="headerlink" title="处理异常"></a>处理异常</h1><p>Spring 提供了多种方式将异常转换为响应：</p><ul><li>特定的 Spring 异常将会自动映射为指定的 HTTP 状态码；</li><li>异常上可以添加 <code>@ResponseStatus</code> 注解，从而将其映射为某一个 HTTP 状态码；</li><li>在方法上可以添加 <code>@ExceptionHandler</code> 注解，使其用来处理异常。</li></ul><h2 id="将异常映射为-HTTP-状态码"><a href="#将异常映射为-HTTP-状态码" class="headerlink" title="将异常映射为 HTTP 状态码"></a>将异常映射为 HTTP 状态码</h2><table><thead><tr><th>Spring 异常</th><th>HTTP 状态码</th></tr></thead><tbody><tr><td>BindException</td><td>400 - Bad Request</td></tr><tr><td>ConversionNotSupportedException</td><td>500 - Internal Server Error</td></tr><tr><td>HttpMediaTypeNotAcceptableException</td><td>406 - Not Acceptable</td></tr><tr><td>HttpMediaTypeNotSupportedException</td><td>415 - Unsupported Media Type</td></tr><tr><td>HttpMessageNotReadableException</td><td>400 - Bad Request</td></tr><tr><td>HttpMessageNotWritableException</td><td>500 - Internal Server Error</td></tr><tr><td>HttpRequestMethodNotSupportedException</td><td>405 - Method Not Allowed</td></tr><tr><td>MethodArgumentNotValidException</td><td>400 - Bad Request</td></tr><tr><td>MissingServletRequestParameterException</td><td>400 - Bad Request</td></tr><tr><td>MissingServletRequestPartException</td><td>400 - Bad Request</td></tr><tr><td>NoSuchRequestHandlingMethodException</td><td>404 - Not Found</td></tr><tr><td>TypeMismatchException</td><td>400 - Bad Request</td></tr></tbody></table><p><code>@ResponseStatus</code> 注解：将异常映射为特定的状态码</p><pre><code class="java">@ResponseStatus(value=HttpStatus.NOT_FOUND, reason=&quot;Spittle Not Found&quot;)public class SpittleNotFoundException extends RuntimeException {}</code></pre><h2 id="编写异常处理的方法"><a href="#编写异常处理的方法" class="headerlink" title="编写异常处理的方法"></a>编写异常处理的方法</h2><p>如果响应中不仅包含状态码，还要包含所产生的错误信息，需要按照请求的方式来处理异常。</p><pre><code class="java">@RequestMapping(method=RequestMethod.POST)public String saveSpittle(SpittleForm form, Model model) {  try {    spittleRepository.save(new Spittle(null, form.getMessage(), new Date(),        form.getLongitude(), form.getLatitude()));    return &quot;redirect:/spittles&quot;;  } catch (DuplicateSpittleException e) {     //捕获异常    return &quot;error/duplicate&quot;;  }}</code></pre><p>运行起来没什么问题，但是这个方法有些复杂。该方法可以有两个路径，每个路径会有不同的输出。如果能让 saveSpittle() 方法只关注正确的路径，而让其他方法处理异常的话，那么它就能简单一些。</p><pre><code class="java">// 首先将 saveSpittle() 方法中的异常处理方法剥离掉@RequestMapping(method=RequestMethod.POST)public String saveSpittle(SpittleForm form, Model model) {    spittleRepository.save(new Spittle(null, form.getMessage(), new Date(),        form.getLongitude(), form.getLatitude()));    return &quot;redirect:/spittles&quot;;    return &quot;error/duplicate&quot;;}</code></pre><p>它只关注成功保存Spittle的情况，所以只需要一个执行路径，很容易理解和测试。</p><pre><code class="java">// 为 SpittleController 添加一个新的方法，它会处理抛出 DuplicateSpittleException 的情况：@ExceptionHandler(DuplicateSpittleException.class)public String handleNotFound() {  return &quot;error/duplicate&quot;;}</code></pre><p>方法上加上 <code>@ExceptionHandler</code> 注解后，当方法抛出异常的时候，将委托该方法来处理，它能够处理<strong>同一个控制器</strong>中所有的方法抛出的异常。</p><h1 id="为控制器添加通知"><a href="#为控制器添加通知" class="headerlink" title="为控制器添加通知"></a>为控制器添加通知</h1><p>如果多个控制器类中都会抛出某个特定的异常，那么你可能会发现要在所有的控制器方法中重复相同的 <code>@ExceptionHandler</code> 方法。或者，为了避免重复，我们会创建一个基础的控制器类，所有控制器类要扩展这个类，从而继承通用的 <code>@ExceptionHandler</code> 方法。</p><p>Spring 3.2 为这类问题引入了一个新的解决方案：控制器通知。控制器通知（controller advice）是任意带有 <code>@ControllerAdvice</code> 注解的类，这个类会包含一个或多个如下类型的方法：</p><ul><li><code>@ExceptionHandler</code> 注解标注的方法；</li><li><code>@InitBinder</code> 注解标注的方法；</li><li><code>@ModelAttribute</code> 注解标注的方法。</li></ul><p>在带有 <code>@ControllerAdvice</code> 注解的类中，以上所述的这些方法会运用到整个应用程序所有控制器中带有 <code>@RequestMapping</code> 注解的方法上。</p><p><code>@ControllerAdvice</code> 注解本身已经使用了 <code>@Component</code>，因此 <code>@ControllerAdvice</code> 注解所标注的类将会自动被组件扫描获取到，就像带有 <code>@Component</code> 注解的类一样。</p><p><code>@ControllerAdvice</code> 最为实用的一个场景就是将所有的 <code>@ExceptionHandler</code> 方法收集到一个类中，这样所有控制器的异常就能在一个地方进行一致的处理。例如，我们想将 <code>DuplicateSpittleException</code> 的处理方法用到整个应用程序的所有控制器上。如下的程序清单展现的 <code>AppWideExceptionHandler</code> 就能完成这一任务，这是一个带有 <code>@ControllerAdvice</code> 注解的类。</p><pre><code class="java">@ControllerAdvicepublic class AppWideExceptionHandler {    @ExceptionHandler(DuplicateSpittleException.class)    public String duplicateSpittleHandler() {        return &quot;error/duplicate&quot;;    }}</code></pre><p>现在，如果任意的控制器方法抛出了 <code>DuplicateSpittleException</code>，不管这个方法位于哪个控制器中，都会调用这个 <code>duplicateSpittleHandler()</code> 方法来处理异常。</p><h1 id="跨重定向请求传递数据"><a href="#跨重定向请求传递数据" class="headerlink" title="跨重定向请求传递数据"></a>跨重定向请求传递数据</h1><h2 id="通过-URL-模板进行重定向"><a href="#通过-URL-模板进行重定向" class="headerlink" title="通过 URL 模板进行重定向"></a>通过 URL 模板进行重定向</h2><pre><code class="java">@RequestMapping(value=&quot;/register&quot;, method=POST)public String processRegistration(Spitter spitter, Model model) {    spitterRepository.save(spitter);    model.addAttribute(&quot;username&quot;, spitter.getUsername());    model.addAttribute(&quot;spitterId&quot;, spitter.getId());    return &quot;redirect:/spitter/{username}&quot;;}</code></pre><p>因为模型中的 <code>spitterId</code> 属性没有匹配重定向 URL 中的任何占位符，所以它<strong>会自动以查询参数的形式附加到重定向 URL 上</strong>。</p><p>如果 username 属性的值是 habuma 并且 spitterId 属性的值是 42，那么结果得到的重定向 URL 路径将会是 <code>spitter/habuma?spitterId=42</code> 。</p><p><strong>只能用来发送简单的值</strong>，如 String 和数字的值。在 URL 中，并没有办法发送更为复杂的值，但这正是 flash 属性能够提供帮助的领域。</p><h1 id="使用-flash-属性"><a href="#使用-flash-属性" class="headerlink" title="使用 flash 属性"></a>使用 flash 属性</h1><p>假设我们不想在重定向中发送 username 或 ID 了，而是要发送实际的 Spitter 对象。</p><p>有个方案是将 Spitter 放到会话中。会话能够长期存在，并且能够跨多个请求。所以我们可以在重定向发生之前将 Spitter 放到会话中，并在重定向后，从会话中将其取出。当然，我们还要负责在重定向后在会话中将其清理掉。</p><p>实际上，Spring 也认为将跨重定向存活的数据放到会话中是一个很不错的方式。Spring 提供了将数据发送为 flash 属性（flash attribute）的功能。按照定义，flash 属性会一直携带这些数据直到下一次请求，然后才会消失。</p><p>Spring 提供了通过 <code>RedirectAttributes</code> 设置 flash 属性的方法，这是Spring 3.1引入的 <code>Model</code> 的一个子接口。<code>RedirectAttributes</code> 提供了 <code>Model</code> 的所有功能，除此之外，还有几个方法是用来设置 flash 属性的。</p><p>具体来讲，<code>RedirectAttributes</code> 提供了一组 <code>addFlashAttribute()</code> 方法来添加 flash 属性。重新看一下 <code>processRegistration()</code> 方法，我们可以使用 <code>addFlashAttribute()</code> 将 Spitter 对象添加到模型中：</p><pre><code class="java">@RequestMapping(value=&quot;/register&quot;, method=POST)public String processRegistration(Spitter spitter, RedirectAttributes model) {    spitterRepository.save(spitter);    model.addAttribute(&quot;username&quot;, spitter.getUsername());    model.addFlashAttribute(&quot;spitter&quot;, spitter);    return &quot;redirect:/spitter/{username}&quot;;}</code></pre><pre><code class="java">@RequestMapping(value=&quot;/{username}&quot;, method=GET)public String showSpitterProfile(@PathVariable String username, Model model) {    检查是否存有 key 为 spitter 的 model 属性。如果有 spitter 属性，那就什么都不用做了。    if (!model.containsAttribute(&quot;spitter&quot;)) {        model.addAttribute(spitterRepository.findByUsername(username));    }    return &quot;profile&quot;;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Spring 实战》笔记6：渲染 Web 视图</title>
      <link href="/2019/08/06/%E3%80%8ASpring%20%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B06%EF%BC%9A%E6%B8%B2%E6%9F%93%20Web%20%E8%A7%86%E5%9B%BE/"/>
      <url>/2019/08/06/%E3%80%8ASpring%20%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B06%EF%BC%9A%E6%B8%B2%E6%9F%93%20Web%20%E8%A7%86%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="理解视图解析"><a href="#理解视图解析" class="headerlink" title="理解视图解析"></a>理解视图解析</h1><p>Spring MVC 定义了一个名为 <code>ViewResolver</code> 的接口，它大致如下所示：</p><pre><code class="java">public interface ViewResolver {    View resolveViewName(String viewName, Locale locale) throws Exception;}</code></pre><p>当给 <code>resolveViewName()</code> 方法传入一个视图名和 <code>Locale</code> 对象时，它会返回一个 <code>View</code> 实例。<code>View</code> 是另外一个接口，如下所示：</p><a id="more"></a><pre><code class="java">public interface View {    String getContentType();    void render(Map&lt;String, ?&gt; model,                HttpServletRequest request,                HttpServletResponse response) throws Exception;}</code></pre><p><code>View</code> 接口的任务就是接受模型以及 <code>Servlet</code> 的 <code>request</code> 和 <code>response</code> 对象，并将输出结果渲染到 <code>response</code> 中。</p><p>Spring 自带了 13 个视图解析器，能够将逻辑视图名转换为物理实现</p><ul><li><code>BeanNameViewResolver</code> 将视图解析为 Spring 应用上下文中的 bean，其中 bean 的 ID 与视图的名字相同</li><li><code>ContentNegotiatingViewResolver</code> 通过考虑客户端需要的内容类型来解析视图，委托给另外一个能够产生对应内容类型的视图解析器</li><li><code>FreeMarkerViewResolver</code> 将视图解析为 <code>FreeMarker</code> 模板</li><li><code>InternalResourceViewResolver</code> 将视图解析为 Web 应用的内部资源（一般为 JSP）</li><li><code>JasperReportsViewResolver</code> 将视图解析为 JasperReports 定义</li><li><code>ResourceBundleViewResolver</code> 将视图解析为资源 bundle（一般为属性文件）</li><li><code>TilesViewResolver</code> 将视图解析为 <code>Apache Tile</code> 定义，其中 tile ID 与视图名称相同。注意有两个不同的 <code>TilesViewResolver</code> 实现，分别对应于 Tiles 2.0 和 Tiles 3.0</li><li><code>UrlBasedViewResolver</code> 直接根据视图的名称解析视图，视图的名称会匹配一个物理视图的定义</li><li><code>VelocityLayoutViewResolver</code> 将视图解析为 <code>Velocity</code> 布局，从不同的 <code>Velocity</code> 模板中组合页面</li><li><code>VelocityViewResolver</code> 将视图解析为 <code>Velocity</code> 模板</li><li><code>XmlViewResolver</code> 将视图解析为特定 XML 文件中的 bean 定义。类似于 <code>BeanNameViewResolver</code></li><li><code>XsltViewResolver</code> 将视图解析为 XSLT 转换后的结果</li></ul><h1 id="创建-JSP-视图"><a href="#创建-JSP-视图" class="headerlink" title="创建 JSP 视图"></a>创建 JSP 视图</h1><p>Spring 提供了两种支持 JSP 视图的方式：</p><ul><li>InternalResourceViewResolver 会将视图名解析为 JSP 文件。另外，如果在你的 JSP 页面中使用了 JSP 标准标签库（JavaServer Pages Standard Tag Library，JSTL）的话，InternalResourceViewResolver 能够将视图名解析为 JstlView 形式的 JSP 文件，从而将 JSTL 本地化和资源 bundle 变量暴露给 JSTL 的格式化（formatting）和信息（message）标签。</li><li>Spring 提供了两个 JSP 标签库，一个用于表单到模型的绑定，另一个提供了通用的工具类特性。</li></ul><h2 id="配置适用于-JSP-的视图解析器"><a href="#配置适用于-JSP-的视图解析器" class="headerlink" title="配置适用于 JSP 的视图解析器"></a>配置适用于 JSP 的视图解析器</h2><p>InternalResourceViewResolver 遵循一种约定，会在视图名上添加前缀和后缀，进而确定一个 Web 应用中视图资源的物理路径。</p><pre><code class="java">@Beanpublic ViewResolver viewResolver() {  InternalResourceVIewResolver resolver = new InternalResourceVIewResolver();  resolver.setPrefix(&quot;WEB-INF/view&quot;);  resolver.setSuffix(&quot;.jsp&quot;)  return resolver;}</code></pre><p>作为替代方法，如果你更喜欢基于 XML 的 Spring 配置，那么可以按照如下方式配置 <code>InternalResourceVIewResolver</code></p><pre><code class="xml">&lt;bean id=&quot;viewResolver&quot;  class=&quot;org.springframework.web.servlet.view.InternalResourceVIewResolver&quot;  p:prefix=&quot;/WEB-INF/view&quot;  p:suffix=&quot;.jsp&quot;</code></pre><p>JSTL 的格式化标签需要一个 <code>Locale</code> 对象，以便于恰当地格式化地域相关的值，如日期和货币。信息标签可以借助 Spring 的信息资源和 Locale，从而选择适当的信息渲染到 HTML 之中。通过解析 <code>JstlView</code>，JSTL 能够获得 Locale 对象以及 Spring 中配置的信息资源。</p><p>如果想让 InternalResourceViewResolver 将视图解析为 JstlView，而不是 InternalResourceView 的话，那么我们只需设置它的 viewClass 属性即可：</p><pre><code class="java">@Beanpublic ViewResolver viewResolver() {  InternalResourceVIewResolver resolver = new InternalResourceVIewResolver();  resolver.setPrefix(&quot;WEB-INF/view&quot;);  resolver.setSuffix(&quot;.jsp&quot;)  resolver.setViewClass(&quot;org.springframework.web.servlet.view.JstlView.class&quot;)  return resolver;}</code></pre><p>同样，我们也可以在 XMl 完成这一任务</p><pre><code class="xml">&lt;bean id=&quot;viewResolver&quot;  class=&quot;org.springframework.web.servlet.view.InternalResourceVIewResolver&quot;  p:prefix=&quot;/WEB-INF/view&quot;  p:suffix=&quot;.jsp&quot;  p:viewClass=&quot;org.springframework.web.servlet.view.JstlView.class&quot;</code></pre><h2 id="使用-Spring-的-JSP-库"><a href="#使用-Spring-的-JSP-库" class="headerlink" title="使用 Spring 的 JSP 库"></a>使用 Spring 的 JSP 库</h2><p>用处不多。</p><h3 id="将表单绑定到模型上"><a href="#将表单绑定到模型上" class="headerlink" title="将表单绑定到模型上"></a>将表单绑定到模型上</h3><p>需要在JSP页面中对其进行声明</p><pre><code class="jsp">&lt;%@ taglib uri=&quot;http://www.springframework.org/tags/form&quot; prefix=&quot;sf&quot; %&gt;</code></pre><ul><li><code>&lt;sf:checkbox&gt;</code></li><li><code>&lt;sf:checkboxes&gt;</code></li><li><code>&lt;sf:errors&gt;</code></li><li><code>&lt;sf:form&gt;</code></li><li><code>&lt;sf:hidden&gt;</code></li><li><code>&lt;sf:input&gt;</code></li><li><code>&lt;sf:lable&gt;</code></li><li><code>&lt;sf:option&gt;</code></li><li><code>&lt;sf:password&gt;</code></li><li><code>&lt;sf:radiobutton&gt;</code></li><li><code>&lt;sf:radiobuttons&gt;</code></li><li><code>&lt;sf:select&gt;</code></li><li><code>&lt;sf:textarea&gt;</code></li><li><code>&lt;sf:radilbutton&gt;</code></li></ul><pre><code class="xml">&lt;sf:form method=&quot;POST&quot; comandName=&quot;spitter&quot;&gt;  First Name: &lt;sf:input path=&quot;firstName&quot; /&gt;&lt;br/&gt;  Last Name: &lt;sf:input path=&quot;lastName&quot; /&gt;&lt;br/&gt;  Email: &lt;sf:input path=&quot;email&quot; /&gt;&lt;br/&gt;  Username: &lt;sf:input path=&quot;username&quot; /&gt;&lt;br/&gt;  Password: &lt;sf:password path=&quot;password&quot; /&gt;&lt;br/&gt;  &lt;sf:input type=&quot;submit&quot; value=&quot;Register&quot; /&gt;&lt;/sf:form&gt;</code></pre><p><code>&lt;sf:form&gt;</code> 会渲染一个 HTMl <code>&lt;form&gt;</code> 标签，<strong>但它也会通过 <code>commandName</code> 属性构建针对某个模型对象的上下文信息，在其他的表单绑定标签中，会引用这个模型对象的属性</strong></p><p>我们将 <code>commandName</code> 属性设置为spitter。因此，在模型中必须要有一个 key 为 spitter 的对象，否则的话，表单不能正常渲染（会出现 JSP 错误）</p><p>从 Spring3.1 开始 <code>&lt;sf:input&gt;</code> 标签能够允许我们指定 type 属性，这样的话，除了其他可选的类型外，还能指定 HTML5 特定类型的文本域，如 date、range、email。我们可以按照如下方式指定 email 域：</p><pre><code class="xml">Email: &lt;sf:input path=&quot;email&quot; type=&quot;email&quot;/&gt; &lt;br/&gt;</code></pre><p>使用 <code>&lt;sf:errors&gt;</code></p><pre><code class="xml">&lt;sf:form method=&quot;POST&quot; commandName=&quot;spitter&quot; &gt;    &lt;sf:input path=&quot;firstName&quot; /&gt;&lt;br/&gt;    &lt;sf:errors path=&quot;firstName&quot; cssErrorClass=&quot;error&quot; /&gt;    ......&lt;/sf:form&gt;</code></pre><pre><code class="java">@NotNull@Size(min=5, max=16, message=&quot;{username.size}&quot;)private String username;.......@NotNull@Size(min=2, max=30, message=&quot;{lastName.size}&quot;)private String lastName;</code></pre><p>我们将其 <code>@Size</code> 注解的 message 设置为一个字符串，用大括号括起来的。没有没有大括号的话，message 中的值将会作为展现给用户的错误信息，使用了就用文件中某个一个属性，该属性包含了实际的信息。</p><p>创建一个 <code>ValidationMessages.properties</code> 的文件，并将其放到根路径之下。</p><pre><code class="ini">firstName.size=First name must be between {min} and {max} characters long.lastName.size=Last name must be between {min} and {max} characters long.</code></pre><h3 id="Spring-通用的标签库"><a href="#Spring-通用的标签库" class="headerlink" title="Spring 通用的标签库"></a>Spring 通用的标签库</h3><p>需要在页面首页对其进行声明</p><pre><code class="xml">&lt;%@ taglib uri=&quot;http://www.springframework.org.tags&quot; prefix=&#39;s&#39;%&gt;</code></pre><ul><li><code>&lt;s:escapeBody&gt;</code> 将标签体中的内容进行 HTML 和 / 或 JavaScript 转义，包裹要转义内容，标签属性加上  <code>htmlEscape=&quot;true&quot;</code>   <code>javaScriptEscape=&quot;true</code></li><li><code>&lt;s:hasBindErrors&gt;</code> 根据指定模型对象（在请求属性中）是否有绑定错误，有条件地渲染内容</li><li><code>&lt;s:htmlEscape&gt;</code> 为当前页面设置默认的 HTML 转义值</li><li><code>&lt;s:message&gt;</code> 根据给定的编码获取信息，然后要么进行渲染（默认行为），要么将其设置为页面作用域、请求作用域、会话作用域或应用作用域的变量（通过使用 var 和 scope 属性实现）</li><li><code>&lt;s:theme&gt;</code> 根据给定的编码获取主题信息，然后要么进行渲染（默认行为），要么将其设置为页面作用域、请求作用域、会话作用域或应用作用域的变量（通过使用 var 和 scope 属性实现）</li><li><code>&lt;s:transform&gt;</code> 使用命令对象的属性编辑器转换命令对象中不包含的属性</li><li><code>&lt;s:url&gt;</code> 创建相对于上下文的 URL，支持 URI 模板变量以及 HTML/XML/JavaScript 转义。可以渲染 URL（默认行为），也可以将其设置为页面作用域、请求作用域、会话作用域或应用作用域的变量（通过使用 var 和 scope 属性实现）</li><li><code>&lt;s:eval&gt;</code> 计算符合 Spring 表达式语言（Spring Expression Language，SpEL）语法的某个表达式的值，然后要么进行渲染（默认行为），要么将其设置为页面作用域、请求作用域、会话作用域或应用作用域的变量（通过使用 var 和 scope 属性实现）</li></ul><h1 id="使用-Apache-Tiles-视图定义布局"><a href="#使用-Apache-Tiles-视图定义布局" class="headerlink" title="使用 Apache Tiles 视图定义布局"></a>使用 Apache Tiles 视图定义布局</h1><h1 id="使用-Thymeleaf"><a href="#使用-Thymeleaf" class="headerlink" title="使用 Thymeleaf"></a>使用 Thymeleaf</h1><p><code>Thymeleaf</code> 模板是原生的，不依赖于标签库。它能在接受原始 HTML 的地方进行编辑和渲染。因为它没有与 Servlet 规范耦合，因此 <code>Thymeleaf</code> 模板能够进入 JSP 所无法涉足的领域。</p><h2 id="配置-Thymeleaf-视图解析器"><a href="#配置-Thymeleaf-视图解析器" class="headerlink" title="配置 Thymeleaf 视图解析器"></a>配置 Thymeleaf 视图解析器</h2><ul><li><code>ThymeleafViewResolver</code>：将逻辑视图名称解析为 Thymeleaf 模板视图；</li><li><code>SpringTemplateEngine</code>：处理模板并渲染结果；</li><li><code>TemplateResolver</code>：加载 Thymeleaf 模板。</li></ul><pre><code class="java">// 声明这些 bean 的 Java 配置@Beanpublic ViewResolver viewResolver(SpringTemplateEngine templateEngine) {    // Thymeleaf 视图解析器    ThymeleafViewResolver viewResolver = new ThymeleafViewResolver();    viewResolver.setTemplateEngine(templateEngine);    return viewResolver;}@Beanpublic TemplateEngine templateEngine(TemplateResolver templateResolver) {    // 模板引擎    SpringTemplateEngine templateEngine = new SpringTemplateEngine();    templateEngine.setTemplateResolver(templateResolver);    return templateEngine;}@Beanpublic TemplateResolver templateResolver() {  // 模板解析器    TemplateResolver templateResolver = new ServletContextTemplateResolver();    templateResolver.setPrefix(&quot;/WEB-INF/templates&quot;);    templateResolver.setSuffix(&quot;.html&quot;);    templateResolver.setTemplateMode(&quot;THML5&quot;);    return templateResolver;}</code></pre><pre><code class="xml">&lt;!-- 使用 XML 的方式，配置 Spring 对 Thymeleaf 的支持 --&gt;&lt;bean id=&quot;viewResolver&quot; class=&quot;org.thymeleaf.spring4.view.ThymeleafViewResolver&quot;        p:templateEngine-ref=&quot;templateEngine&quot; /&gt;&lt;bean id=&quot;templateEngine&quot; class=&quot;org.thymeleaf.spring4.SpringTemplateEngine&quot;        P:templateResolver-ref=&quot;templateResolver&quot; /&gt;&lt;bean id=&quot;templateResolver&quot; class=&quot;org.thymeleaf.templateresolver.ServletContextTemplateResolver&quot;        p:prefix=&quot;WEB-INF/templates/&quot;        p:suffix=&quot;.html&quot;        p:templateMode=&quot;HTML5&quot; /&gt; &lt;!-- 预期要解析的模板会渲染成 HTML5 输出 --&gt;</code></pre><h2 id="定义-Thymeleaf-模板"><a href="#定义-Thymeleaf-模板" class="headerlink" title="定义 Thymeleaf 模板"></a>定义 Thymeleaf 模板</h2><p>Thymeleaf 在很大程度上就是 HTML 文件，与 JSP 不同，它没有什么特殊的标签或标签库。Thymeleaf 之所以能够发挥作用，是因为它通过自定义的命名空间，为标准的 HTML 标签集合添加 Thymeleaf 属性。如下的程序清单展现了 home.html，也就是使用 Thymeleaf 命名空间的首页模板。</p><pre><code class="html">&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;      xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;  &lt;!--声明 Thymeleaf 命名空间--&gt;  &lt;head&gt;    &lt;title&gt;Spitter&lt;/title&gt;    &lt;link rel=&quot;stylesheet&quot;          type=&quot;text/css&quot;          th:href=&quot;@{/resources/style.css}&quot;&gt;&lt;/link&gt;  &lt;!--到样式表的 th:href 链接--&gt;  &lt;/head&gt;  &lt;body&gt;      &lt;h1&gt;Welcome to Spitter&lt;/h1&gt;      &lt;a th:href=&quot;@{/spittles}&quot;&gt;Spittles&lt;/a&gt; |      &lt;!--到页面的 th:herf 链接--&gt;      &lt;a th:href=&quot;@{/spitter/register}&quot;&gt;Register&lt;/a&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><p>使用了 <code>th:href</code> 属性，都用到了 <code>@{}</code> 表达式，用来计算相对于 URL 的路径</p><h3 id="借助-Thymeleaf-实现表单绑定"><a href="#借助-Thymeleaf-实现表单绑定" class="headerlink" title="借助 Thymeleaf 实现表单绑定"></a>借助 Thymeleaf 实现表单绑定</h3><pre><code class="xml">&lt;label th:class=&quot;${#fields.hasErrors(&#39;firstName&#39;)}? &#39;error&#39;&quot;&gt;First Name&lt;/label&gt;:&lt;input type=&quot;text&quot; th:field=&quot;*{firstName}&quot;    th:class=&quot;${#fields.hasErrors(&#39;firstName&#39;)}? &#39;error&#39;&quot; /&gt;&lt;br/&gt;</code></pre><p><code>th:class</code> 属性会渲染为一个 class 属性，它的值是根据给定的表达式计算得到的。在上面的这两个 <code>th:class</code> 属性中，它会直接检查 firstName 域有没有校验错误。如果有的话，class 属性在渲染时的值为 error。如果这个域没有错误的话，将不会渲染 class 属性。</p><p><code>&lt;input&gt;</code> 标签使用了 <code>th:field</code> 属性，用来引用后端对象的 firstName 域。这可能与你的预期有点差别。在 Thymeleaf 模板中，我们在很多情况下所使用的属性都对应于标准的 HTML 属性，因此貌似使用 <code>th:value</code> 属性来设置 <code>&lt;input&gt;</code> 标签的 value 属性才是合理的。</p><p>其实不然，因为我们是在将这个输入域绑定到后端对象的 firstName 属性上，因此使用 <code>th:field</code> 属性引用 firstName 域。通过使用 <code>th:field</code>，我们将 value 属性设置为 firstName 的值，同时还会将 name 属性设置为 firstName。</p><p>完整的注册表单模板</p><pre><code class="xml">&lt;form method=&quot;POST&quot; th:object=&quot;${spitter}&quot;&gt;  &lt;div class=&quot;errors&quot; th:if=&quot;${#fields.hasErrors(&#39;*&#39;)}&quot;&gt;    &lt;ul&gt;      &lt;li th:each=&quot;err : ${#fields.errors(&#39;*&#39;)}&quot;          th:text=&quot;${err}&quot;&gt;Input is incorrect&lt;/li&gt;    &lt;/ul&gt;  &lt;/div&gt;  &lt;label th:class=&quot;${#fields.hasErrors(&#39;firstName&#39;)}? &#39;error&#39;&quot;&gt;First Name&lt;/label&gt;:    &lt;input type=&quot;text&quot; th:field=&quot;*{firstName}&quot;           th:class=&quot;${#fields.hasErrors(&#39;firstName&#39;)}? &#39;error&#39;&quot; /&gt;&lt;br/&gt;  &lt;label th:class=&quot;${#fields.hasErrors(&#39;lastName&#39;)}? &#39;error&#39;&quot;&gt;Last Name&lt;/label&gt;:    &lt;input type=&quot;text&quot; th:field=&quot;*{lastName}&quot;           th:class=&quot;${#fields.hasErrors(&#39;lastName&#39;)}? &#39;error&#39;&quot; /&gt;&lt;br/&gt;  &lt;label th:class=&quot;${#fields.hasErrors(&#39;email&#39;)}? &#39;error&#39;&quot;&gt;Email&lt;/label&gt;:    &lt;input type=&quot;text&quot; th:field=&quot;*{email}&quot;           th:class=&quot;${#fields.hasErrors(&#39;email&#39;)}? &#39;error&#39;&quot; /&gt;&lt;br/&gt;  &lt;label th:class=&quot;${#fields.hasErrors(&#39;username&#39;)}? &#39;error&#39;&quot;&gt;Username&lt;/label&gt;:    &lt;input type=&quot;text&quot; th:field=&quot;*{username}&quot;           th:class=&quot;${#fields.hasErrors(&#39;username&#39;)}? &#39;error&#39;&quot; /&gt;&lt;br/&gt;  &lt;label th:class=&quot;${#fields.hasErrors(&#39;password&#39;)}? &#39;error&#39;&quot;&gt;Password&lt;/label&gt;:    &lt;input type=&quot;password&quot; th:field=&quot;*{password}&quot;           th:class=&quot;${#fields.hasErrors(&#39;password&#39;)}? &#39;error&#39;&quot; /&gt;&lt;br/&gt;  &lt;input type=&quot;submit&quot; value=&quot;Register&quot; /&gt;&lt;/form&gt;</code></pre><p>程序清单使用了相同的 Thymeleaf 属性和 <code>*{}</code> 表达式，为所有的表单域绑定后端对象。</p><p><code>&lt;div&gt;</code> 元素使用 <code>th:if</code> 属性来检查是否有校验错误。如果有的话，会渲染 <code>&lt;div&gt;</code>，否则的话，它将不会渲染。</p><p>在 <code>&lt;div&gt;</code> 中，会使用一个无顺序的列表来展现每项错误。<code>&lt;li&gt;</code> 标签上的 <code>th:each</code> 属性将会通知 <code>Thymeleaf</code> 为每项错误都渲染一个 <code>&lt;li&gt;</code>，在每次迭代中会将当前错误设置到一个名为 <code>err</code> 的变量中。</p><p><code>&lt;li&gt;</code> 标签还有一个 <code>th:text</code> 属性。这个命令会通知 <code>Thymeleaf</code> 计算某一个表达式（在本例中，也就是 err 变量）并将它的值渲染为 <code>&lt;li&gt;</code> 标签的内容体。实际上的效果就是每项错误对应一个 <code>&lt;li&gt;</code> 元素，并展现错误的文本。</p><p> <code>${}</code> 和 <code>*{}</code> 括起来的表达式到底有什么区别。 <code>${}</code> 表达式（如 <code>${spitter}</code>）是变量表达式（variable expression）。一般来讲，它们会是对象图导航语言（Object-Graph Navigation Language，OGNL）表达式<br>（<a href="http://commons.apache.org/proper/commons-ognl/）。但在使用" target="_blank" rel="noopener">http://commons.apache.org/proper/commons-ognl/）。但在使用</a> Spring 的时候，它们是 SpEL 表达式。在 <code>${spitter}</code> 这个例子中，它会解析为 key 为 spitter 的 model 属性。</p><p>而对于 <code>*{}</code> 表达式，它们是选择表达式（selection expression）。变量表达式是基于整个 SpEL 上下文计算的，而选择表达式是基于某一个选中对象计算的。在本例的表单中，选中对象就是 <code>&lt;form&gt;</code> 标签中 <code>th:object</code> 属性所设置的对象：模型中的 Spitter 对象。因此，<code>*{firstName}</code> 表达式就会计算为 Spitter 对象的 firstName 属性。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Spring 实战》笔记5：构建 Spring Web 应用程序</title>
      <link href="/2019/07/13/%E3%80%8ASpring%20%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B05%EF%BC%9A%E6%9E%84%E5%BB%BA%20Spring%20Web%20%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/"/>
      <url>/2019/07/13/%E3%80%8ASpring%20%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B05%EF%BC%9A%E6%9E%84%E5%BB%BA%20Spring%20Web%20%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>Spring MVC 基于模型-视图-控制器（Model-View-Controller，MVC）模式实现，它能够帮你构建像Spring框架那样灵活和松耦合的 Web 应用程序。</p><h1 id="Spring-MVC-起步"><a href="#Spring-MVC-起步" class="headerlink" title="Spring MVC 起步"></a>Spring MVC 起步</h1><p>Spring 将请求在调度 Servlet、处理器映射(Handler Mappering)、控制器以及视图解析器(View resolver)之间移动，每一个 Spring MVC 中的组件都有特定的目的，并且也没那么复杂。</p><p>让我们看一下，请求是如何从客户端发起，经过 Spring MVC 中的组件，最终返回到客户端</p><a id="more"></a><h2 id="跟踪-Spring-MVC-的请求"><a href="#跟踪-Spring-MVC-的请求" class="headerlink" title="跟踪 Spring MVC 的请求"></a>跟踪 Spring MVC 的请求</h2><p>每当用户在 Web 浏览器中点击链接或提交表单的时候，请求就开始工作了。请求是一个十分繁忙的家伙，从离开浏览器开始到获取响应返回，它会经历很多站，在每站都会留下一些信息，同时也会带上一些信息。下图展示了请求使用 Spring MVC 所经历的所有站点。</p><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20190713173157.png" alt="一路上请求会将信息带到很多站点，并生产期望的结果"></p><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/1365825529_4693.png" alt="Spring MVC 流程图"><br><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/1365825551_8302.png" alt="Spring MVC 流程图2"></p><blockquote><p><a href="https://blog.csdn.net/zuoluoboy/article/details/19766131" target="_blank" rel="noopener">Spring MVC 流程图</a></p></blockquote><ol><li>用户向服务器发送请求，请求被 Spring 前端控制 Servelt <code>DispatcherServlet</code> 捕获；</li><li><code>DispatcherServlet</code> 对请求 URL 进行解析，得到请求资源标识符（URI）。然后根据该 URI，调用 <code>HandlerMapping</code> 获得该 <code>Handler</code> 配置的所有相关的对象（包括 <code>Handler</code> 对象以及 <code>Handler</code> 对象对应的拦截器），最后以 <code>HandlerExecutionChain</code> 对象的形式返回；</li><li><code>DispatcherServlet</code> 根据获得的 <code>Handler</code>，选择一个合适的 <code>HandlerAdapter</code>。（附注：如果成功获得 <code>HandlerAdapter</code> 后，此时将开始执行拦截器的 <code>preHandler(...)</code> 方法）</li><li>提取 Request 中的模型数据，填充 <code>Handler</code> 入参，开始执行 <code>Handler（Controller)</code>。 在填充 <code>Handler</code> 的入参过程中，根据你的配置，Spring 将帮你做一些额外的工作：<ul><li><code>HttpMessageConveter</code>：将请求消息（如 JSON、XML 等数据）转换成一个对象，将对象转换为指定的响应信息</li><li><code>数据转换</code>：对请求消息进行数据转换。如 String 转换成 Integer、Double 等</li><li><code>数据根式化</code>：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等</li><li><code>数据验证</code>：验证数据的有效性（长度、格式等），验证结果存储到 BindingResult 或 Error 中</li></ul></li><li><code>Handler</code> 执行完成后，向 <code>DispatcherServlet</code> 返回一个 <code>ModelAndView</code> 对象；</li><li>根据返回的 <code>ModelAndView</code>，选择一个适合的 <code>ViewResolver</code>（必须是已经注册到 Spring 容器中的 <code>ViewResolver</code>)返回给 <code>DispatcherServlet</code> ；</li><li><code>ViewResolver</code> 结合 <code>Model</code> 和 <code>View</code>，来渲染视图</li><li>将渲染结果返回给客户端。</li></ol><h2 id="搭建-Spring-MVC"><a href="#搭建-Spring-MVC" class="headerlink" title="搭建 Spring MVC"></a>搭建 Spring MVC</h2><h3 id="配置-DispatcherServlet"><a href="#配置-DispatcherServlet" class="headerlink" title="配置 DispatcherServlet"></a>配置 DispatcherServlet</h3><p><code>DispatcherServlet</code> 是 Spring MVC 的核心。在这里请求会第一次接触到框架，它要负责将请求路由到其他的组件之中。</p><p>按照传统的方式，像 <code>DispatcherServlet</code> 这样的 Servlet 会配置在 <code>web.xml</code> 文件中</p><pre><code class="xml">&lt;servlet&gt;    &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;    &lt;url-pattern&gt;*.form&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;</code></pre><p>Servlet 3 规范和 Spring 3.1 的功能增强，可以使用 Java 将 DispatcherServlet 配置在 Servlet 容器中</p><pre><code class="java">public class SpittrWebAppInitializer            extends AbstractAnnotationConfigDispatcherServletInitializer {    @Override    protected String[] getServletMappings() {  // 将 DispatcherServlet 映射到 &quot;/&quot;        return new String[] { &quot;/&quot; };    }    @Override    protected Class&lt;?&gt;[] getRootConfigClasses() {        return new Class&lt;?&gt;[] { RootConfig.class };    }    @Override    protected Class&lt;?&gt;[] getServletConfigClasses() {        return new Class&lt;?&gt;[] { WebConfig.class };    }}</code></pre><p>要理解程序是如何工作的，我们可能只需要知道扩展 <code>AbstractAnnotationConfigDispatcherServletInitializer</code> 的任意类都会自动地配置 <code>DispatcherServlet</code> 和 Spring 应用上下文，Spring 的应用上下文会位于应用程序的 Servlet 上下文之中。</p><h3 id="AbstractAnnotationConfigDispatcherServletInitializer-剖析"><a href="#AbstractAnnotationConfigDispatcherServletInitializer-剖析" class="headerlink" title="AbstractAnnotationConfigDispatcherServletInitializer 剖析"></a>AbstractAnnotationConfigDispatcherServletInitializer 剖析</h3><p>在 Servlet 3.0 环境中，容器会在类路径中查找实现 <code>javax.servlet.ServletContainerInitializer</code> 接口的类，如果能发现的话，就会用它来配置 Servlet 容器。</p><p>Spring 提供了这个接口的实现，名为 <code>SpringServletContainerInitializer</code> ，这个类反过来又会查找实现 <code>WebApplicationInitializer</code> 的类并将配置的任务交给它们来完成。Spring 3.2 引入了一个便利的 <code>WebApplicationInitializer</code> 基础实现，也就是 <code>AbstractAnnotationConfigDispatcherServletInitializer</code> 。因为我们的 <code>SpittrWebAppInitializer</code> 扩展了 <code>AbstractAnnotationConfigDispatcherServletInitializer</code> （同时也就实现了 <code>WebApplicationInitializer</code> ），因此当部署到 Servlet 3.0 容器中的时候，容器会自动发现它，并用它来配置 Servlet 上下文。</p><p><code>SpittrWebAppInitializer</code> 重写了三个方法。</p><ul><li>第一个方法是 <code>getServletMappings()</code>，它会将一个或多个路径映射到 DispatcherServlet 上。在本例中，它映射的是 &quot;/&quot; ，这表示它会是应用的默认 Servlet。它会处理进入应用的所有请求。</li></ul><p>为了理解其他的两个方法，我们首先要理解 <code>DispatcherServlet</code> 和一个 Servlet 监听器（也就是 <code>ContextLoaderListener</code> ）的关系。</p><h3 id="两个应用上下文之间的故事"><a href="#两个应用上下文之间的故事" class="headerlink" title="两个应用上下文之间的故事"></a>两个应用上下文之间的故事</h3><p>当 <code>DispatcherServlet</code> 启动的时候，它会创建 Spring 应用上下文，并加载配置文件或配置类中所声明的 bean。在上面程序的 <code>getServletConfigClasses()</code> 方法中，我们要求 <code>DispatcherServlet</code> 加载应用上下文时，使用定义在 <code>WebConfig</code> 配置类（使用 Java 配置）中的 bean。</p><p>但是在 Spring Web 应用中，通常还会有另外一个应用上下文。另外的这个应用上下文是由 <code>ContextLoaderListener</code> 创建的。</p><p>我们希望 <code>DispatcherServlet</code> 加载包含 Web 组件的 bean，如控制器、视图解析器以及处理器映射，而 <code>ContextLoaderListener</code> 要加载应用中的其他 bean。这些 bean 通常是驱动应用后端的中间层和数据层组件。</p><p>实际上， <code>AbstractAnnotationConfigDispatcherServletInitializer</code> 会同时创建 <code>DispatcherServlet</code> 和 <code>ContextLoaderListener</code> 。<code>getServletConfigClasses()</code> 方法返回的带有 <code>@Configuration</code> 注解的类将会用来定义 <code>DispatcherServlet</code> 应用上下文中的 bean。<code>getRootConfigClasses()</code> 方法返回的带有 <code>@Configuration</code> 注解的类将会用来配置 <code>ContextLoaderListener</code> 创建的应用上下文中的 bean。</p><p>在本例中，根配置定义在 <code>RootConfig</code> 中， <code>DispatcherServlet</code> 的配置声明在 <code>WebConfig</code> 中。稍后我们将会看到这两个类的内容。</p><p>需要注意的是，通过 <code>AbstractAnnotationConfigDispatcherServletInitializer</code> 来配置 <code>DispatcherServlet</code> 是传统 <code>web.xml</code> 方式的替代方案。</p><h3 id="启用-Spring-MVC"><a href="#启用-Spring-MVC" class="headerlink" title="启用 Spring MVC"></a>启用 Spring MVC</h3><p>以前，Spring 是使用 XML 进行配置的，你可以使用 <code>&lt;mvc:annotation-driven&gt;</code> 启用注解驱动的 Spring MVC。</p><p>基于 Java 进行配置，我们所能创建的最简单的 Spring MVC 配置就是一个带有 <code>@EnableWebMvc</code> 注解的类：</p><pre><code class="java">@Configuration@EnableWebMvc@ComponentScan(&quot;spittr.web&quot;)public class WebConfig extends WebMvcConfigurerAdapter {    @Bean    public ViewResolver viewResolver() {        InternalResourceViewResolver resolver = new InternalResourceViewResolver();        resolver.setPrefix(&quot;/WEB-INF/views/&quot;);        resolver.setSuffix(&quot;.jsp&quot;);        resolver.setExposeContextBeansAsAttributes(true);        return resolver;    }    @Override    public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {        // 要求 DispatcherServlet 将对静态资源的请求转发到 Servlet 容器中默认的 Servlet 上        configurer.enable();    }}</code></pre><pre><code class="java">@Configuration@ComponentScan(basePackages = {&quot;spittr&quot;},        excludeFilters = {                @ComponentScan.Filter(type = FilterType.ANNOTATION, value = EnableWebMvc.class)        })public class RootConfig {}</code></pre><h1 id="编写基本的控制器"><a href="#编写基本的控制器" class="headerlink" title="编写基本的控制器"></a>编写基本的控制器</h1><pre><code class="java">@Controllerpublic class HomeController {    @RequestMapping(value = &quot;/&quot;, method = RequestMethod.GET)   // 处理对 &quot;/&quot; 的 Get 请求    public String home() {        return &quot;home&quot;;  // 视图名为 home        // DispatcherServlet 会要求视图解析器将这个逻辑名称解析为实际的视图。        // 由于配置 InternalResourceViewResolver 的方式，视图名 &quot;home&quot; 将会解析为 &quot;WEB-INF/views/home.jsp&quot; 路径的 JSP。    }}</code></pre><p><code>@Controller</code> 是一个构造型（stereotype）的注解，它基于 <code>@Component</code> 注解。在这里，它的目的就是辅助实现组件扫描。因为 HomeController 带有 @Controller 注解，因此组件扫描器会自动找到 HomeController，并将其声明为 Spring 应用上下文中的一个 bean。</p><p>带有 <code>@RequestMapping</code> 注解的方法，它的 <code>value</code> 属性指定了这个方法所要处理的请求路径，<code>method</code> 属性细化了它所处理的 HTTP 方法。</p><h2 id="测试控制器"><a href="#测试控制器" class="headerlink" title="测试控制器"></a>测试控制器</h2><pre><code class="java">public class HomeControllerTest {    @Test    public void testHomePage() throws Exception {        HomeController controller = new HomeController();        // 搭建 MockMvc        MockMvc mockMvc = MockMvcBuilders.standaloneSetup(controller).build();        mockMvc.perform(MockMvcRequestBuilders.get(&quot;/&quot;)) // 对 “/” 执行 GET 请求，                .andExpect(MockMvcResultMatchers.view().name(&quot;home&quot;));// 预期得到 home 视图    }}</code></pre><p><a href="/2018/04/01/SpringMVC%20Test/">SpringMVC Test</a></p><h2 id="定义类级别的请求处理"><a href="#定义类级别的请求处理" class="headerlink" title="定义类级别的请求处理"></a>定义类级别的请求处理</h2><h2 id="传递模型数据到视图中"><a href="#传递模型数据到视图中" class="headerlink" title="传递模型数据到视图中"></a>传递模型数据到视图中</h2><pre><code class="java">@RequestMapping(method = RequestMethod.GET)public String spittles(Model model) {    model.addAttribute(spittleRepository.findSpittles(Long.MAX_VALUE, 20)); // 将 spittle 添加到视图    // 和上一行等效    // model.put(&quot;spittleList&quot;, spittleRepository.findSpittles(Long.MAX_VALUE, 20));    return &quot;spittles&quot;;  // 返回视图名}</code></pre><p><code>Model</code> 实际上就是一个 Map（也就是key-value对的集合），它会传递给视图，这样数据就能渲染到客户端了。当调用 <code>addAttribute()</code> 方法并且不指定 <code>key</code> 的时候，那么 <code>key</code> 会根据值的对象类型推断确定。在本例中，因为它是一个 <code>List&lt;Spittle&gt;</code>，因此，键将会推断为 <code>spittleList</code>。</p><pre><code class="java">@RequestMapping(method=RequestMethod.GET)public List&lt;Spittle&gt; spittles() {    return spittleRepository.findSpittles(Long.MAX_VALUE, 20));}</code></pre><p>它并没有返回视图名称，也没有显式地设定模型，这个方法返回的是 Spittle 列表。当处理器方法像这样返回对象或集合时，这个值会放到模型中，模型的 key 会根据其类型推断得出（在本例中，也就是 spittleList）。</p><p>而逻辑视图的名称将会根据请求路径推断得出。因为这个方法处理针对 &quot;/spittles&quot; 的 GET 请求，因此视图的名称将会是 <code>spittles</code>（去掉开头的斜线）。</p><h1 id="接受请求的输入"><a href="#接受请求的输入" class="headerlink" title="接受请求的输入"></a>接受请求的输入</h1><p>Spring MVC 允许以多种方式将客户端中的数据传送到控制器的处理器方法中，包括：</p><ul><li>查询参数（Query Parameter）。</li><li>表单参数（Form Parameter）。</li><li>路径变量（Path Variable）。</li></ul><h2 id="处理查询参数"><a href="#处理查询参数" class="headerlink" title="处理查询参数"></a>处理查询参数</h2><pre><code class="java">// 注：原文中所写的这行是错误的，注解那块会提示 Attribute value must be constant// private static final String MAX_LONG_AS_STRING = Long.toString(Long.MAX_VALUE);private static final String MAX_LONG_AS_STRING = Long.MAX_VALUE + &quot;&quot;;@RequestMapping(method=RequestMethod.GET)public List&lt;Spittle&gt; spittles(        @RequestParam(value=&quot;max&quot;, defaultValue=MAX_LONG_AS_STRING) long max,        @RequestParam(value=&quot;count&quot;, defaultValue=&quot;20&quot;) int count) {    return spittleRepository.findSpittles(max, count);}</code></pre><h2 id="通过路径参数接受输入"><a href="#通过路径参数接受输入" class="headerlink" title="通过路径参数接受输入"></a>通过路径参数接受输入</h2><p>Spring MVC 允许我们在 <code>@RequestMapping</code> 路径中添加占位符。占位符的名称要用大括号（“{”和“}”）括起来。如果对 &quot;/spittles/54321&quot; 发送 GET 请求，那么将会把 &quot;54321&quot; 传递进来，作为 spittleId 的值。</p><pre><code class="Java">@RequestMapping(value=&quot;/{spittleId}&quot;, method=RequestMethod.GET)public String spittle(@PathVariable(&quot;spittleId&quot;) long spittleId, Model model) {    model.addAttribute(spittleRepository.findOne(spittleId));    return &quot;spittle&quot;;}</code></pre><p>需要注意的是，如果你想要重命名参数时，<strong>必须要同时修改占位符的名称</strong>，使其互相匹配。</p><h1 id="处理表单"><a href="#处理表单" class="headerlink" title="处理表单"></a>处理表单</h1><h2 id="编写处理表单的控制器"><a href="#编写处理表单的控制器" class="headerlink" title="编写处理表单的控制器"></a>编写处理表单的控制器</h2><h2 id="校验表单"><a href="#校验表单" class="headerlink" title="校验表单"></a>校验表单</h2><p>在 Spring MVC 中要使用 Java 校验 API 的话，并不需要什么额外的配置。只要保证在类路径下包含这个 Java API 的实现即可，比如 <code>Hibernate Validator</code>。</p><p>Java 校验 API 所提供的校验注解</p><ul><li><code>@AssertFalse</code> 所注解的元素必须是 Boolean 类型，并且值为 false</li><li><code>@AssertTrue</code> 所注解的元素必须是 Boolean 类型，并且值为 true</li><li><code>@DecimalMax</code> 所注解的元素必须是数字，并且它的值要小于或等于给定的 BigDecimalString 值</li><li><code>@DecimalMin</code> 所注解的元素必须是数字，并且它的值要大于或等于给定的 BigDecimalString 值</li><li><code>@Digits</code> 所注解的元素必须是数字，并且它的值必须有指定的位数</li><li><code>@Future</code> 所注解的元素的值必须是一个将来的日期</li><li><code>@Max</code> 所注解的元素必须是数字，并且它的值要小于或等于给定的值</li><li><code>@Min</code> 所注解的元素必须是数字，并且它的值要大于或等于给定的值</li><li><code>@NotNul</code>l 所注解元素的值必须不能为 null</li><li><code>@Null</code> 所注解元素的值必须为 null</li><li><code>@Past</code> 所注解的元素的值必须是一个已过去的日期</li><li><code>@Pattern</code> 所注解的元素的值必须匹配给定的正则表达式</li><li><code>@Size</code> 所注解的元素的值必须是 String 、集合或数组，并且它的长度要符合给定的范围</li></ul><pre><code class="java">public class Spitter {    private Long id;    @NotNull    @Size(min=5, max=16)    private String username;  // 非空，5 到 16 个字符    @NotNull    @Size(min=5, max=25)    private String password;    @NotNull    @Size(min=2, max=30)    private String firstName;    @NotNull    @Size(min=2, max=30)    private String lastName;    ...}</code></pre><p>启用校验功能</p><pre><code class="java">@RequestMapping(value=&quot;/register&quot;, method=POST)public String processRegistration(@Valid Spitter spitter, Errors errors) {    if (errors.hasErrors()) {        return &quot;registerForm&quot;;    }    spitterRepository.save(spitter);    return &quot;redirect:/spitter/&quot; + spitter.getUsername();}</code></pre><p><code>Errors</code> 参数要紧跟在带有 <code>@Valid</code> 注解的参数后面，<code>@Valid</code> 注解所标注的就是要检验的参数</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Spring 实战》笔记4：面向切面的 Spring</title>
      <link href="/2019/07/04/%E3%80%8ASpring%20%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B04%EF%BC%9A%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%9A%84%20Spring/"/>
      <url>/2019/07/04/%E3%80%8ASpring%20%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B04%EF%BC%9A%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%9A%84%20Spring/</url>
      
        <content type="html"><![CDATA[<p>在软件开发中，散布于应用中多处的功能被称为<strong>横切关注点</strong>（cross-cutting concern）。通常来讲，这些横切关注点从概念上是与应用的业务逻辑相分离的（但是往往会直接嵌入到应用的业务逻辑之中）。<strong>把这些横切关注点与业务逻辑相分离正是面向切面编程（AOP）所要解决的问题</strong>。</p><p>在第2章，我们介绍了如何使用<strong>依赖注入</strong>（DI）管理和配置我们的应用对象。DI 有助于应用对象之间的解耦，而 AOP 可以实现横切关注点与它们所影响的对象之间的解耦。</p><p>日志是应用切面的常见范例，但它并不是切面适用的唯一场景。通览本书，我们还会看到切面所适用的多个场景，包括声明式事务、安全和缓存。</p><a id="more"></a><h1 id="什么是面向切面编程"><a href="#什么是面向切面编程" class="headerlink" title="什么是面向切面编程"></a>什么是面向切面编程</h1><p>切面能够帮我们模块化横切关注点。简而言之，横切关注点可以被描述为影响应用多处的功能。例如 安全就是一个横切关注点，应用中的许多方法都会涉及到安全规则。</p><p>如果要重用对象的话，最常见的面向对象技术是继承、委托、组合。但是，如果整个应用中都使用相同的基类，继承往往会导致一个脆弱的对象体系。而使用委托可能需要委托对象进行复杂的调用。</p><p>切面提供了取代继承和委托的另一种可选方案。在使用面向切面编程时，我们仍然在一个地方定义通知功能，而无需修改受影响的类。<strong>横切关注点可以被模块化为特殊的类，这些类被称为切面(aspect)</strong>。 这样做带来两个好处：每个关注点都集中到一个地方，而不是分散到多处代码中；其次，服务模块更简洁，因为它只包含了主要关注点（核心功能）的代码。而次要关注的代码被移到切面中了。</p><h2 id="定义-AOP-术语"><a href="#定义-AOP-术语" class="headerlink" title="定义 AOP 术语"></a>定义 AOP 术语</h2><h3 id="通知（advice）"><a href="#通知（advice）" class="headerlink" title="通知（advice）"></a>通知（advice）</h3><p>切面也有目标——它必须要完成的工作。在 AOP 术语中，<strong>切面的工作被称为通知</strong>。</p><p>通知定义了切面是什么以及何时使用。除了描述切面要完成的工作外，通知还解决了何时执行这个工作问题。它应该在某个方法被调用之前？之后？之前和之后都调用？还是只在方法抛出异常时调用？</p><p>Spring 切面可以应用 5 中类型的通知：</p><ul><li><strong>前置通知(Before)</strong>：在目标方法被调用之前调用通知功能。</li><li><strong>后置通知(After)</strong>：在目标方法完成之后调用通知</li><li><strong>返回通知(After-returning)</strong>：在目标方法成功执行之后调用通知</li><li><strong>异常通知(After-throwing)</strong>：在目标方法抛出异常后调用通知</li><li><strong>环绕通知(Around)</strong>：在被通知方法调用之前和调用之后执行自定义的行为</li></ul><h3 id="连接点（Join-point）"><a href="#连接点（Join-point）" class="headerlink" title="连接点（Join point）"></a>连接点（Join point）</h3><p>我们的应用可能有数以千计的时机应用通知，这些时机被称为连接点。连接点是在应用执行过程中能够插入的一个点。这个点可以是调用方法时，抛出异常时，甚至修改一个字段时。切面可以利用这些点插入到应用的正常流程之中，并添加新的行为。</p><h3 id="切点（Pointcut）"><a href="#切点（Pointcut）" class="headerlink" title="切点（Pointcut）"></a>切点（Pointcut）</h3><p>如果说通知定义了切面的的“什么”和“何时”，那么切点定义了“何处”。切点的定义会匹配通知所要织入的一个或多个连接点。</p><p>我们通常使用明确的类和方法名称，或是利用正则表达式定义所匹配的类和方法名称来指定这些切点。</p><p>有些 AOP 框架允许我们创建动态的切点，可以根据运行时的决策（比如方法的参数值）来决定是否应用通知。</p><h3 id="切面（Aspect）"><a href="#切面（Aspect）" class="headerlink" title="切面（Aspect）"></a>切面（Aspect）</h3><p>切面是通知和切点的结合。通知和切点通过定义了切面的全部内容——它是什么，在什么时候和在哪里完成其功能。</p><h3 id="引入（Introduction）"><a href="#引入（Introduction）" class="headerlink" title="引入（Introduction）"></a>引入（Introduction）</h3><p>引入允许我们向现有的类添加新的方法或者属性。</p><p>例如，我们可以创建一个 Auditable 通知类，该类记录了对象最后一次修改时的状态。这很简单，只需一个方<br>法，setLastModified(Date)，和一个实例变量来保存这个状态。然后，这个新方法和实例变量就可以被引入到现有的类中，从而可以在无需修改这些现有的类的情况下，让它们具有新的行为和状态。</p><h3 id="织入（Weaving）"><a href="#织入（Weaving）" class="headerlink" title="织入（Weaving）"></a>织入（Weaving）</h3><p>织入是把切面应用到目标对象并创建新的代理对象的过程。切面在指定的连接点被织入到目标对象。在目标对象的生命周期里有多个点可以进行织入：</p><ul><li>编译期：切面在目标类编译时被织入。这种方式需要特殊的编译器。<code>AspectJ</code> 的织入编译器就是以这种方式织入切面的。</li><li>类加载期：切面在目标类加载到JVM时被织入。这种方式需要特殊的类加载器（ClassLoader），它可以在目标类被引入应用之前增强该目标类的字节码。<code>AspectJ 5</code> 的加载时织入（load-time weaving，LTW）就支持以这种方式织入切面。</li><li>运行期：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP 容器会为目标对象动态地创建一个代理对象。Spring AOP 就是以这种方式织入切面的。</li></ul><p><strong>通知包含了需要用于多个应用对象的横切行为；连接点是程序执行过程中能够应用通知的所有点；切点定义了通知被应用的具体位置（在哪些连接点）。其中关键的概念是切点定义了哪些连接点会得到通知。</strong></p><h2 id="Spring-对-AOP-的支持"><a href="#Spring-对-AOP-的支持" class="headerlink" title="Spring 对 AOP 的支持"></a>Spring 对 AOP 的支持</h2><p>Spring 提供了 4 种类型的 AOP 支持：</p><ul><li><strong>基于代理的经典 Spring AOP</strong>；非常笨重和过于复杂</li><li><strong>纯 POJO 切面</strong>；需要 XML 配置，但这的确是声明式地将对象转换为切面的简便方式。</li><li><strong><code>@AspectJ</code> 注解驱动的切面</strong>；它依然是 Spring 基于代理的 AOP，但是编程模型几乎与编写成熟的 AspectJ 注解切面完全一致。这种 AOP 风格的好处在于能够不使用 XML 来完成功能。</li><li><strong>注入式 <code>AspectJ</code> 切面</strong>（适用于 Spring 各版本）。如果你的 AOP 需求超过了简单的方法调用（如构造器或属性拦截），那么你需要考虑使用 AspectJ 来实现切面。能够帮助你将值注入到 AspectJ 驱动的切面中。</li></ul><p>前三种都是 Spring AOP 实现的变体，Spring AOP 构建在动态代理基础之上，因此，<strong>Spring 对 AOP 的支持局限于方法拦截</strong>。</p><h3 id="Spring-通知是-Java-编写的"><a href="#Spring-通知是-Java-编写的" class="headerlink" title="Spring 通知是 Java 编写的"></a>Spring 通知是 Java 编写的</h3><p>Spring 所创建的通知都是用标准的 Java 类编写的，定义通知所应用的切点通常会使用注解或在 Spring 配置文件里采用 XML 来编写。</p><p><code>AspectJ</code> 与之相反。虽然 <code>AspectJ</code> 现在支持基于注解的切面，但 <code>AspectJ</code> 最初是以 Java 语言扩展的方式实现的。这种方式有优点也有缺点。通过特有的 AOP 语言，我们可以获得更强大和细粒度的控制，以及更丰富的 AOP 工具集，但是我们需要额外学习新的工具和语法。</p><h3 id="Spring-在运行时通知对象"><a href="#Spring-在运行时通知对象" class="headerlink" title="Spring 在运行时通知对象"></a>Spring 在运行时通知对象</h3><p>通过在代理类中包裹切面，Spring 在运行期把切面织入到 Spring 管理的 bean 中。代理类封装了目标类，并拦截被通知方法的调用，再把调用转发给真正的目标 bean。当代理拦截到方法调用时，在调用目标 bean 方法之前，会执行切面逻辑。</p><p>直到应用需要被代理的 bean 时，Spring 才创建代理对象。如果使用的是 ApplicationContext 的话，在 ApplicationContext 从 BeanFactory 中加载所有 bean 的时候，Spring 才会创建被代理的对象。因为 Spring 运行时才创建代理对象，所以我们不需要特殊的编译器来织入 Spring AOP 的切面。</p><h3 id="Spring-只支持方法级别的连接点"><a href="#Spring-只支持方法级别的连接点" class="headerlink" title="Spring 只支持方法级别的连接点"></a>Spring 只支持方法级别的连接点</h3><p>正如前面所探讨过的，通过使用各种 AOP 方案可以支持多种连接点模型。因为 Spring 基于动态代理，所以 Spring 只支持方法连接点。这与一些其他的 AOP 框架是不同的，例如 <code>AspectJ</code> 和 <code>JBoss</code>，除了方法切点，它们还提供了字段和构造器接入点。Spring 缺少对字段连接点的支持，无法让我们创建细粒度的通知，例如拦截对象字段的修改。而且它不支持构造器连接点，我们就无法在 bean 创建时应用通知。</p><p>但是方法拦截可以满足绝大部分的需求。如果需要方法拦截之外的连接点拦截功能，那么我们可以利用 <code>AspectJ</code> 来补充 Spring AOP 的功能。</p><h1 id="通过切点来选择连接点"><a href="#通过切点来选择连接点" class="headerlink" title="通过切点来选择连接点"></a>通过切点来选择连接点</h1><p>切点用于准确定位应该在什么地方应用切面的通知。通知和切点是切面的最基本元素。</p><p>Spring 仅支持 <code>AspectJ</code> 切点指示器（pointcut designator）的一个子集。Spring 是基于代理的，而某些切点表达式是与基于代理的 AOP 无关的。</p><p>Spring AOP 所支持的 <code>AspectJ</code> 切点指示器</p><table><thead><tr><th>AspectJ指示器</th><th>描　　述</th></tr></thead><tbody><tr><td><code>arg()</code></td><td>限制连接点匹配参数为指定类型的执行方法</td></tr><tr><td><code>@args()</code></td><td>限制连接点匹配参数由指定注解标注的执行方法</td></tr><tr><td><code>execution()</code></td><td>用于匹配是连接点的执行方法</td></tr><tr><td><code>this()</code></td><td>限制连接点匹配 AOP 代理的 bean 引用为指定类型的类</td></tr><tr><td><code>target</code></td><td>限制连接点匹配目标对象为指定类型的类</td></tr><tr><td><code>@target()</code></td><td>限制连接点匹配特定的执行对象，这些对象对应的类要具有指定类型的注解</td></tr><tr><td><code>within()</code></td><td>限制连接点匹配指定的类型</td></tr><tr><td><code>@within()</code></td><td>限制连接点匹配指定注解所标注的类型（当使用 Spring AOP 时，方法定义在由指定的注解所标注的类里）</td></tr><tr><td><code>@annotation</code></td><td>限定匹配带有指定注解的连接点</td></tr></tbody></table><p>注意只有 <code>execution</code> 指示器是实际执行匹配的，而其他的指示器都是用来限制匹配的。这说明 <code>execution</code> 指示器是我们在编写切点定义时最主要使用的指示器。在此基础上，我们使用其他指示器来限制所匹配的切点。</p><h2 id="编写切点"><a href="#编写切点" class="headerlink" title="编写切点"></a>编写切点</h2><p>为了阐述 Spring 中的切面，我们需要有个主题来定义切面的切点。为此，我们定义一个 Performance 接口：</p><pre><code class="java">public interface Performance {    public void perform();}</code></pre><p>下图展现了一个切点表达式，这个表达式能够设置当 perform() 方法执行时触发通知的调用。</p><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20190706151354.png" alt="使用 AspectJ 切点表达式来选择 Performance 的 perform() 方法"></p><p>现在假设我们需要配置的切点仅匹配 concert 包。在此场景下，可以使用 within() 指示器来限制匹配，如图所示。</p><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20190706151943.png" alt="使用 within() 指示器限制切点范围"></p><p>请注意我们使用了 <code>&amp;&amp;</code> 操作符把 <code>execution()</code> 和 <code>within()</code> 指示器连接在一起形成与（and）关系（切点必须匹配所有的指示器）。类似地，我们可以使用 <code>||</code> 操作符来标识或（or）关系，而使用 <code>!</code> 操作符来标识非（not）操作。</p><p>因为 <code>&amp;</code> 在XML中有特殊含义，所以在 Spring 的 XML 配置里面描述切点时，我们可以使用 and<br>来代替 <code>&amp;&amp;</code> 。同样，or 和 not可以分别用来代替 <code>||</code> 和 <code>!</code> 。</p><h2 id="在切点中选择-bean"><a href="#在切点中选择-bean" class="headerlink" title="在切点中选择 bean"></a>在切点中选择 bean</h2><p>Spring 引入了一个新的 <code>bean()</code> 指示器，它允许我们在切点表达式中使用 bean 的ID来标识 bean。<code>bean()</code> 使用 bean ID 或 bean 名称作为参数来限制切点只匹配特定的 bean。</p><pre><code class="java">// 在执行 Performance 的 perform() 方法时应用通知，但限定 bean 的 ID 为 woodstock。execution(* concert.Performance.perform()) and bean(&quot;woodsotck&quot;)</code></pre><pre><code class="java">// 切面的通知会被编织到所有 ID 不为 woodstock 的 bean 中execution(* concert.Performance.perform()) and !bean(&quot;woodsotck&quot;)</code></pre><h1 id="使用注解创建切面"><a href="#使用注解创建切面" class="headerlink" title="使用注解创建切面"></a>使用注解创建切面</h1><p>使用注解来创建切面是 <code>AspectJ 5</code> 所引入的关键特性。</p><p>我们已经定义了 Performance 接口，它是切面中切点的目标对象。现在，让我们使用 AspectJ 注解来定义切面。</p><h2 id="定义切面"><a href="#定义切面" class="headerlink" title="定义切面"></a>定义切面</h2><pre><code class="java">@Aspect  // 使用 @Aspect 注解进行了标注，表明是一个切面public class Audience {    // 表演之前    @Before(&quot;execution(** springaction04.concert.Performance.perform(..))&quot;)    public void silenceCellPhones() {        System.out.println(&quot;Silencing cell phones&quot;);    }    // 表演之前    @Before(&quot;execution(** springaction04.concert.Performance.perform(..))&quot;)    public void takeSeats() {        System.out.println(&quot;Taking seats&quot;);    }    // 表演之后    @AfterReturning(&quot;execution(** springaction04.concert.Performance.perform(..))&quot;)    public void applause() {        System.out.println(&quot;CLAP CLAP CLAP!!!&quot;);    }    // 表演失败之后    @AfterThrowing(&quot;execution(** springaction04.concert.Performance.perform(..))&quot;)    public void demandRefund() {        System.out.println(&quot;Demanding a refund&quot;);    }}</code></pre><p>两个 <code>*</code> 在 IDEA 中会提示 <code>( expected</code>，<a href="https://stackoverflow.com/questions/36717542/why-use-two-stars-in-point-cut-expression-to-match-return-type" target="_blank" rel="noopener">Why use two stars in point cut expression to match return type?</a></p><h3 id="Spring-使用-AspectJ-注解来声明通知方法"><a href="#Spring-使用-AspectJ-注解来声明通知方法" class="headerlink" title="Spring 使用 AspectJ 注解来声明通知方法"></a>Spring 使用 AspectJ 注解来声明通知方法</h3><table><thead><tr><th>注　　解</th><th>通　　知</th></tr></thead><tbody><tr><td><code>@After</code></td><td>通知方法会在目标方法返回或抛出异常后调用</td></tr><tr><td><code>@AfterReturning</code></td><td>通知方法会在目标方法返回后调用</td></tr><tr><td><code>@AfterThrowing</code></td><td>通知方法会在目标方法抛出异常后调用</td></tr><tr><td><code>@Around</code></td><td>通知方法会将目标方法封装起来</td></tr><tr><td><code>@Before</code></td><td>通知方法会在目标方法调用之前执行</td></tr></tbody></table><h3 id="Pointcut"><a href="#Pointcut" class="headerlink" title="@Pointcut"></a>@Pointcut</h3><p><code>@Pointcut</code> 注解能够在一个 <code>@AspectJ</code> 切面内定义可重用的切点。</p><pre><code class="java">@Aspectpublic class Audience {    /**    * 定义命名的切点    * performance() 方法的实际内容并不重要，在这里它实际上应该是空的。    * 其实该方法本身只是一个标识，供 @Pointcut 注解依附。    * 如果方法中存在内容，IDEA 会提示 Pointcut methods should have empty body    */    @Pointcut(&quot;execution(** springaction04.concert.Performance.perform(..))&quot;)    public void performance() {}    @Before(&quot;performance()&quot;)    public void silenceCellPhones() {        System.out.println(&quot;Silencing cell phones&quot;);    }    @Before(&quot;performance()&quot;)    public void takeSeats() {        System.out.println(&quot;Taking seats&quot;);    }    @AfterReturning(&quot;performance()&quot;)    public void applause() {        System.out.println(&quot;CLAP CLAP CLAP!!!&quot;);    }    @AfterThrowing(&quot;performance()&quot;)    public void demandRefund() {        System.out.println(&quot;Demanding a refund&quot;);    }}</code></pre><h3 id="在-JavaConfig-中启用-AspectJ-注解的自动代理"><a href="#在-JavaConfig-中启用-AspectJ-注解的自动代理" class="headerlink" title="在 JavaConfig 中启用 AspectJ 注解的自动代理"></a>在 JavaConfig 中启用 AspectJ 注解的自动代理</h3><pre><code class="java">@Configuration@EnableAspectJAutoProxy  // 启用 AspectJ 自动代理@ComponentScanpublic class ConcertConfig {    @Bean    public Audience audience() {  // 声明 Audience bean        return new Audience();    }}</code></pre><h3 id="在-XML-中启用-AspectJ-自动代理"><a href="#在-XML-中启用-AspectJ-自动代理" class="headerlink" title="在 XML 中启用 AspectJ 自动代理"></a>在 XML 中启用 AspectJ 自动代理</h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop.xsd        http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;context:component-scan base-package=&quot;springaction04.concert&quot; /&gt;    &lt;!-- 启用 AspectJ 自动代理 --&gt;    &lt;aop:aspectj-autoproxy /&gt;    &lt;bean class=&quot;concert.Audience&quot; /&gt;&lt;/beans&gt;</code></pre><p>如果想利用 AspectJ 的所有能力，我们必须在运行时使用 AspectJ 并且不依赖 Spring 来创建基于代理的切面。</p><h2 id="创建环绕通知"><a href="#创建环绕通知" class="headerlink" title="创建环绕通知"></a>创建环绕通知</h2><p>环绕通知是最为强大的通知类型。它能够让你所编写的逻辑将被通知的目标方法完全包装起来。实际上就像在一个通知方法中同时编写前置通知和后置通知。</p><pre><code class="java">// 使用环绕通知重新实现 Audience 切面@Aspectpublic class Audience3 {    @Pointcut(&quot;execution(** concert.Performance.perform(..))&quot;)    public void performance() {}    @Around(&quot;performance()&quot;)    public void watchPerformance(ProceedingJoinPoint jp) {        try {            System.out.println(&quot;Silencing cell phones&quot;);            System.out.println(&quot;Taking seats&quot;);            jp.proceed();            System.out.println(&quot;CLAP CLAP CLAP!!!&quot;);        } catch (Throwable e) {            System.out.println(&quot;Demanding a refund&quot;);        }    }}</code></pre><p>可以看到，这个通知所达到的效果与之前的前置通知和后置通知是一样的。但是，现在它们位于同一个方法中，不像之前那样分散在四个不同的通知方法里面。</p><h2 id="处理通知中的参数"><a href="#处理通知中的参数" class="headerlink" title="处理通知中的参数"></a>处理通知中的参数</h2><pre><code class="java">// 使用参数化的通知来记录磁道播放的次数@Aspectpublic class TrackCounter {    private Map&lt;Integer, Integer&gt; trackCounts = new HashMap&lt;&gt;();    @Pointcut(            &quot;execution(* soundsystem.CompactDisc.playTrack(int)) &quot; +                    &quot;&amp;&amp; args(trackNumber)&quot;)    public void trackPlayed(int trackNumber) {}    // IDEA 提示：argNames attribute isn&#39;t defined，建议修改如下：    // @Before(value = &quot;trackPlayed(trackNumber)&quot;, argNames = &quot;trackNumber&quot;)    @Before(&quot;trackPlayed(trackNumber)&quot;)    public void countTrack(int trackNumber) {        int currentCount = getPlayCount(trackNumber);        trackCounts.put(trackNumber, currentCount + 1);    }    public int getPlayCount(int trackNumber) {        return trackCounts.containsKey(trackNumber)                ? trackCounts.get(trackNumber) : 0;    }}</code></pre><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20190706225055.png" alt="在切点表达式中声明参数，这个参数传入到通知方法中"></p><p>需要关注的是切点表达式中的 <code>args(trackNumber)</code> 限定符。它表明传递给 <code>playTrack()</code> 方法的 int 类型参数也会传递到通知中去。参数的名称 <code>trackNumber</code> 也与切点方法签名中的参数相匹配。</p><h2 id="通过注解引入新功能"><a href="#通过注解引入新功能" class="headerlink" title="通过注解引入新功能"></a>通过注解引入新功能</h2><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20190706234627.png" alt="使用 Spring AOP，我们可以为 bean 引入新的方法。代理拦截调用并委托给实现该方法的其他对象"></p><p>为示例中的所有的 Performance 实现引入下面的 Encoreable 接口：</p><pre><code class="java">public interface Encoreable {    void performEncore();}</code></pre><p>我们需要有一种方式将这个接口应用到 Performance 实现中。我们现在假设你能够访问 Performance 的所有实现，并对其进行修改，让它们都实现 <code>Encoreable</code> 接口。但是，从设计的角度来看，这并不是最好的做法，并不是所有的 Performance 都是具有 Encoreable 特性的。另外一方面，有可能无法修改所有的 Performance 实现，当使用第三方实现并且没有源码的时候更是如此。</p><p>值得庆幸的是，借助于 AOP 的引入功能，我们可以不必在设计上妥协或者侵入性地改变现有的实现。为了实现该功能，我们要创建一个新的切面：</p><pre><code class="java">@Aspectpublic class EncoreableIntroducer {    @DeclareParents(value=&quot;concert.Performance+&quot;, defaultImpl=DefaultEncoreable.class)    public static Encoreable encoreable;}</code></pre><p><code>EncoreableIntroducer</code> 是一个切面。但是，它与我们之前所创建的切面不同，它并没有提供前置、后置或环绕通知，而是通过 <code>@DeclareParents</code> 注解，将 <code>Encoreable</code> 接口引入到 <code>Performance bean</code> 中。</p><p><code>@DeclareParents</code> 注解由三部分组成：</p><ul><li><code>value</code> 属性指定了哪种类型的 bean 要引入该接口。在本例中，也就是所有实现 Performance 的类型。（标记符后面的<code>加号</code>表示是 <code>Performance</code> 的所有子类型，而不是 Performance 本身。）</li><li><code>defaultImpl</code> 属性指定了为引入功能提供实现的类。在这里，我们指定的是 Default`Encoreable 提供实现。</li><li><code>@DeclareParents</code> 注解所标注的静态属性指明了要引入了接口。在这里，我们所引入的是 Encoreable 接口。</li></ul><p>和其他的切面一样，我们需要在 Spring 应用中将 EncoreableIntroducer 声明为一个 bean：</p><pre><code class="xml">&lt;bean class=&quot;concert.EncoreableIntroducer&quot; /&gt;</code></pre><p>在 Spring 中，注解和自动代理提供了一种很便利的方式来创建切面。它非常简单，并且只涉及到最少的Spring配置。但是，面向注解的切面声明有一个明显的劣势：你必须能够为通知类添加注解。为了做到这一点，<strong>必须要有源码</strong>。</p><p>如果你没有源码的话，或者不想将 <code>AspectJ</code> 注解放到你的代码之中，Spring 为切面提供了另外一种可选方案。让我们看一下如何在 Spring XML 配置文件中声明切面。</p><h1 id="在-XML-中声明切面"><a href="#在-XML-中声明切面" class="headerlink" title="在 XML 中声明切面"></a>在 XML 中声明切面</h1><h2 id="Sprin-的-AOP-配置元素能够以非侵入性的方式声明切面"><a href="#Sprin-的-AOP-配置元素能够以非侵入性的方式声明切面" class="headerlink" title="Sprin 的 AOP 配置元素能够以非侵入性的方式声明切面"></a>Sprin 的 AOP 配置元素能够以非侵入性的方式声明切面</h2><table><thead><tr><th>AOP配置元素</th><th>用　　途</th></tr></thead><tbody><tr><td><code>&lt;aop:advisor&gt;</code></td><td>定义 AOP 通知器</td></tr><tr><td><code>&lt;aop:after&gt;</code></td><td>定义 AOP 后置通知（不管被通知的方法是否执行成功）</td></tr><tr><td><code>&lt;aop:after-returning&gt;</code></td><td>定义 AOP 返回通知</td></tr><tr><td><code>&lt;aop:after-throwing&gt;</code></td><td>定义 AOP 异常通知</td></tr><tr><td><code>&lt;aop:around&gt;</code></td><td>定义 AOP 环绕通知</td></tr><tr><td><code>&lt;aop:aspect&gt;</code></td><td>定义一个切面</td></tr><tr><td><code>&lt;aop:aspectj-autoproxy&gt;</code></td><td>启用 <code>@AspectJ</code> 注解驱动的切面</td></tr><tr><td><code>&lt;aop:before&gt;</code></td><td>定义一个 AOP 前置通知</td></tr><tr><td><code>&lt;aop:config&gt;</code></td><td>顶层的 AOP 配置元素。大多数的 <code>&lt;aop:*&gt;</code> 元素必须包含在 <code>&lt;aop:config&gt;</code> 元素内</td></tr><tr><td><code>&lt;aop:declare-parents&gt;</code></td><td>以透明的方式为被通知的对象引入额外的接口</td></tr><tr><td><code>&lt;aop:pointcut&gt;</code></td><td>定义一个切点</td></tr></tbody></table><p>将 Audience 类所有的 <code>AspectJ</code> 注解全部移除掉：</p><pre><code class="java">public class Audience {    public void silenceCellPhones() {        System.out.println(&quot;Silencing cell phones&quot;);    }    public void takeSeats() {        System.out.println(&quot;Taking seats&quot;);    }    public void applause() {        System.out.println(&quot;CLAP CLAP CLAP!!!&quot;);    }    public void demandRefund() {        System.out.println(&quot;Demanding a refund&quot;);    }}</code></pre><h2 id="声明前置和后置通知"><a href="#声明前置和后置通知" class="headerlink" title="声明前置和后置通知"></a>声明前置和后置通知</h2><pre><code class="xml">&lt;aop:config&gt;  &lt;!-- 大多数的 AOP 配置元素必须在 &lt;aop:config&gt; 元素的上下文内使用。 --&gt;    &lt;aop:aspect ref=&quot;audience&quot;&gt;  &lt;!-- 引用 audience bean --&gt;        &lt;aop:before            pointcut=&quot;execution(** concert.Performance.perform(..))&quot;            method=&quot;silenceCellPhones&quot;/&gt;        &lt;aop:before            pointcut=&quot;execution(** concert.Performance.perform(..))&quot;            method=&quot;takeSeats&quot;/&gt;        &lt;aop:after-returning            pointcut=&quot;execution(** concert.Performance.perform(..))&quot;            method=&quot;applause&quot;/&gt;        &lt;aop:after-throwing            pointcut=&quot;execution(** concert.Performance.perform(..))&quot;            method=&quot;demandRefund&quot;/&gt;    &lt;/aop:aspect&gt;&lt;/aop:config&gt;</code></pre><p>使用 <code>&lt;aop:pointcut&gt;</code> 定义命名切点</p><pre><code class="xml">&lt;aop:config&gt;    &lt;aop:aspect ref=&quot;audience&quot;&gt;        &lt;!-- 将通用的切点表达式抽取到一个切点声明中 --&gt;        &lt;aop:pointcut id=&quot;performance&quot;            expression=&quot;execution(** concert.Performance.perform(..))&quot; /&gt;        &lt;aop:before pointcut-ref=&quot;performance&quot; method=&quot;silenceCellPhones&quot;/&gt;        &lt;aop:before pointcut-ref=&quot;performance&quot; method=&quot;takeSeats&quot;/&gt;        &lt;aop:after-returning pointcut-ref=&quot;performance&quot; method=&quot;applause&quot;/&gt;        &lt;aop:after-throwing pointcut-ref=&quot;performance&quot; method=&quot;demandRefund&quot;/&gt;    &lt;/aop:aspect&gt;&lt;/aop:config&gt;</code></pre><p>如果想让定义的切点能够在多个切面使用，我们可以把 <code>&lt;aop:pointcut&gt;</code> 元素放在 <code>&lt;aop:config&gt;</code> 元素的范围内。</p><h2 id="声明环绕通知"><a href="#声明环绕通知" class="headerlink" title="声明环绕通知"></a>声明环绕通知</h2><p>前置通知和后置通知有一些限制。如果不使用成员变量存储信息的话，在前置通知和后置通知之间共享信息非常麻烦。</p><p>使用环绕通知，我们可以完成前置通知和后置通知所实现的相同功能，而且只需要在一个方法中实现。因为整个通知逻辑是在一个方法内实现的，所以不需要使用成员变量保存状态。</p><pre><code class="java">// 新 Audience 类的 watchPerformance() 方法，没有使用任何的注解。public class Audience {    public void watchPerformance(ProceedingJoinPoint jp) {        try {            System.out.println(&quot;Silencing cell phones&quot;);            System.out.println(&quot;Taking seats&quot;);            jp.proceed();            System.out.println(&quot;CLAP CLAP CLAP!!!&quot;);        } catch (Throwable e) {            System.out.println(&quot;Demanding a refund&quot;);        }    }}</code></pre><p>在 XML 中使用 <code>&lt;aop:around&gt;</code> 元素声明环绕通知</p><pre><code class="xml">&lt;aop:config&gt;    &lt;aop:aspect ref=&quot;audience&quot;&gt;        &lt;aop:pointcut            id=&quot;performance&quot;            expression=&quot;execution(** concert.Performance.perform(..))&quot; /&gt;        &lt;aop:around pointcut-ref=&quot;performance&quot; method=&quot;watchPerformance&quot;/&gt;    &lt;/aop:aspect&gt;&lt;/aop:config&gt;</code></pre><h2 id="为通知传递参数"><a href="#为通知传递参数" class="headerlink" title="为通知传递参数"></a>为通知传递参数</h2><pre><code class="java">// 移除掉 TrackCounter 上所有的 @AspectJ 注解public class TrackCounter {    private Map&lt;Integer, Integer&gt; trackCounts = new HashMap&lt;&gt;();    public void countTrack(int trackNumber) {        int currentCount = getPlayCount(trackNumber);        trackCounts.put(trackNumber, currentCount + 1);    }    public int getPlayCount(int trackNumber) {        return trackCounts.containsKey(trackNumber)                ? trackCounts.get(trackNumber) : 0;    }}</code></pre><pre><code class="xml">&lt;bean id=&quot;trackCounter&quot; class=&quot;soundsystem.TrackCounter&quot; /&gt;&lt;bean id=&quot;cd&quot; class=&quot;soundsystem.BlankDisc&quot;&gt;    &lt;property name=&quot;title&quot; value=&quot;Sgt. Pepper&#39;s Lonely Hearts Club Band&quot; /&gt;    &lt;property name=&quot;artist&quot; value=&quot;The Beatles&quot; /&gt;    &lt;property name=&quot;tracks&quot;&gt;        &lt;list&gt;            &lt;value&gt;Sgt. Pepper&#39;s Lonely Hearts Club Band&lt;/value&gt;            &lt;value&gt;With a Little Help from My Friends&lt;/value&gt;            &lt;value&gt;Lucy in the Sky with Diamonds&lt;/value&gt;            &lt;value&gt;Getting Better&lt;/value&gt;            &lt;value&gt;Fixing a Hole&lt;/value&gt;            &lt;!-- ...other tracks omitted for brevity... --&gt;        &lt;/list&gt;    &lt;/property&gt;&lt;/bean&gt;&lt;aop:config&gt;    &lt;aop:aspect ref=&quot;trackCounter&quot;&gt;        &lt;aop:pointcut id=&quot;trackPlayed&quot; expression=            &quot;execution(* soundsystem.CompactDisc.playTrack(int)) and args(trackNumber)&quot; /&gt;        &lt;aop:before pointcut-ref=&quot;trackPlayed&quot; method=&quot;countTrack&quot;/&gt;    &lt;/aop:aspect&gt;&lt;/aop:config&gt;</code></pre><p>我们使用了和前面相同的 aop 命名空间 XML 元素，它们会将 POJO 声明为切面。唯一明显的差别在于切点表达式中包含了一个参数，这个参数会传递到通知方法中。</p><h2 id="通过切面引入新的功能"><a href="#通过切面引入新的功能" class="headerlink" title="通过切面引入新的功能"></a>通过切面引入新的功能</h2><p>借助 <code>AspectJ</code> 的 <code>@DeclareParents</code> 注解为被通知的方法神奇地引入新的方法。但是 AOP 引入并不是 AspectJ 特有的。使用 Spring aop 命名空间中的 <code>&lt;aop:declare-parents&gt;</code> 元素，我们可以实现相同的功能。</p><pre><code class="xml">&lt;aop:aspect&gt;    &lt;aop:declare-parents        types-matching=&quot;concert.Performance+&quot;        implement-interface=&quot;concert.Encoreable&quot;        default-impl=&quot;concert.DefaultEncoreable&quot;        /&gt;&lt;/aop:aspect&gt;</code></pre><p>这里有两种方式标识所引入接口的实现。在本例中，我们使用 <code>default-impl</code> 属性用全限定类名来显式指定 <code>Encoreable</code> 的实现。或者，我们还可以使用 <code>delegate-ref</code> 属性来标识。</p><pre><code class="xml">&lt;bean id=&quot;encoreableDelegate&quot; class=&quot;concert.DefaultEncoreable&quot; /&gt;&lt;aop:aspect&gt;    &lt;aop:declare-parents        types-matching=&quot;concert.Performance+&quot;        implement-interface=&quot;concert.Encoreable&quot;        delegate-ref=&quot;encoreableDelegate&quot;        /&gt;&lt;/aop:aspect&gt;</code></pre><p>使用 <code>default-impl</code> 来直接标识委托和间接使用 <code>delegate-ref</code> 的区别在于后者是 Spring bean，它本身可以被注入、通知或使用其他的 Spring 配置。</p><h1 id="注入-AspectJ-切面"><a href="#注入-AspectJ-切面" class="headerlink" title="注入 AspectJ 切面"></a>注入 AspectJ 切面</h1><p>虽然 Spring AOP 能够满足许多应用的切面需求，但是与 <code>AspectJ</code> 相比，Spring AOP 是一个功能比较弱的 AOP 解决方案。<code>AspectJ</code> 提供了 Spring AOP 所不能支持的许多类型的切点。例如，构造器切点。</p><p>我们可以借助 Spring 的依赖注入把 bean 装配进 <code>AspectJ</code> 切面中。</p><p>我们为上面的演出创建一个新切面。具体来讲，我们以切面的方式创建一个评论员的角色，他会观看演出并且会在演出之后提供一些批评意见。下面的 <code>CriticAspect</code> 就是一个这样的切面。</p><pre><code class="java">// 使用 AspectJ 实现表演的评论员public aspect CriticAspect {    public CriticAspect() {}    pointcut performance() : execution(* perform(..));    afterReturning() : performance() {        System.out.println(criticismEngine.getCriticism());    }    private CriticismEngine criticismEngine;    public void setCriticismEngine(CriticismEngine criticismEngine) {        this.criticismEngine = criticismEngine;    }}</code></pre><p><code>CriticAspect</code> 的主要职责是在表演结束后为表演发表评论。程序中的 <code>performance()</code> 切点匹配 <code>perform()</code> 方法。当它与 <code>afterReturning()</code> 通知一起配合使用时，我们可以让该切面在表演结束时起作用。</p><p><code>CriticAspect</code> 与一个 <code>CriticismEngine</code> 对象相协作，在表演结束时，调用该对象的 <code>getCriticism()</code> 方法来发表一个苛刻的评论。下图展示了此关系。</p><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20190707172016.png" alt="切面也需要注入。像其他的 bean 一样，Spring 可以为 AspectJ 切面注入依赖"></p><pre><code class="java">public interface CriticismEngine {    public String getCriticism();}public class CriticismEngineImpl implements CriticismEngine {    public CriticismEngineImpl() {}    public String getCriticism() {        int i = (int) (Math.random() * criticismPool.length);        return criticismPool[i];    }    // injected    private String[] criticismPool;    public void setCriticismPool(String[] criticismPool) {        this.criticismPool = criticismPool;    }}</code></pre><p>CriticismEngineImpl 可以使用如下的 XML 声明为一个 Spring bean</p><pre><code class="xml">&lt;bean id=&quot;criticismEngine&quot;        class=&quot;com.springinaction.springidol.CriticismEngineImpl&quot;&gt;    &lt;property name=&quot;criticisms&quot;&gt;        &lt;list&gt;            &lt;value&gt;Worst performance ever!&lt;/value&gt;            &lt;value&gt;I laughed, I cried, then I realized I was at the wrong show.&lt;/value&gt;            &lt;value&gt;A must see show!&lt;/value&gt;        &lt;/list&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre><p>把 <code>criticismEngine bean</code> 注入到 <code>CriticAspect</code> 中：</p><pre><code class="xml">&lt;bean class=&quot;com.springinaction.springidol.CriticAspect&quot;        factory-method=&quot;aspectOf&quot;&gt;    &lt;property name=&quot;criticismEngine&quot; ref=&quot;criticismEngine&quot; /&gt;&lt;/bean&gt;</code></pre><p>使用了 <code>factory-method</code> 属性。通常情况下，<code>AspectJ</code> 切面是由 <code>AspectJ</code> 在运行期创建的。</p><p>Spring 不能负责创建 <code>CriticAspect</code>，但所有的 <code>AspectJ</code> 切面都提供了一个静态的 <strong><code>aspectOf()</code></strong> 方法，该方法返回切面的一个单例。所以为了获得切面的实例，我们必须使用 <code>factory-method</code> 来调用 <code>asepctOf()</code> 方法而不是调用 CriticAspect 的构造器方法。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Spring 实战》笔记3：高级装配2</title>
      <link href="/2019/07/02/%E3%80%8ASpring%20%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B03%EF%BC%9A%E9%AB%98%E7%BA%A7%E8%A3%85%E9%85%8D2/"/>
      <url>/2019/07/02/%E3%80%8ASpring%20%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B03%EF%BC%9A%E9%AB%98%E7%BA%A7%E8%A3%85%E9%85%8D2/</url>
      
        <content type="html"><![CDATA[<h1 id="bean-的作用域"><a href="#bean-的作用域" class="headerlink" title="bean 的作用域"></a>bean 的作用域</h1><p>在默认情况下，Spring 应用上下文中所有 bean 都是作为以单例（singleton）的形式创建的。</p><p>Spring 定义了多种作用域，可以基于这些作用域创建 bean，包括：</p><ul><li>单例（Singleton）：在整个应用中，只创建 bean 的一个实例。</li><li>原型（Prototype）：每次注入或者通过 Spring 应用上下文获取的时候，都会创建一个新的 bean 实例。</li><li>会话（Session）：在 Web 应用中，为每个会话创建一个 bean 实例。</li><li>请求（Request）：在 Web 应用中，为每个请求创建一个 bean 实例。</li></ul><a id="more"></a><p>单例是默认的作用域，对于易变的类型，这并不适合。如果要选择其他作用域，要使用 <code>@Scope</code> 注解，它可以与 <code>@Component</code> 或 <code>@Bean</code> 一起使用。</p><p>如果你使用组件扫描来发现 bean 和声明 bean，那么你可以在 bean 的类上使用 <code>@Scope</code> 注解，并将其声明为原型 bean</p><pre><code class="java">@Component@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)// @Scope(&quot;prototype&quot;)  // 使用 SCOPE_PROTOTYPE 常量更加安全并且不易出错public class NotePad {}</code></pre><p>在 JavaConfig 中将 NotePad 声明为原型 bean，那么可以组合使用 <code>@Scope</code> 和 <code>@Bean</code> 来指定所需的作用域</p><pre><code class="java">@Bean@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)public NotePad notepad {    return new NotePad();}</code></pre><p>使用 XMl 来配置 bean，可以使用 bean 元素的 <code>scope</code> 属性来设置作用域：</p><pre><code class="xml">&lt;bean id=&quot;notepad&quot;    class=&quot;com.myapp.NotePad&quot;    scope=&quot;prototype&quot;</code></pre><h2 id="使用会话和请求作用域"><a href="#使用会话和请求作用域" class="headerlink" title="使用会话和请求作用域"></a>使用会话和请求作用域</h2><p>在 Web 应用中，如果能够实例化在会话和请求范围内共享的 bean，那将是非常有价值的事。例如：在典型的电子商务中，可能会有一个 bean 代表用户的购物车，如果这个购物车是单例的话，那么 将导致所有的用户都会像同一个购物车中添加商品。另一方面，如果购物车是原型作用域，那么在应用中某一个地方往购物车添加商品，在应用的另外一个地方可能就不可用了。因为这里注入的是另外一个原型作用域的购物车。</p><p>就购物车 bean 来说，会话作用域是最为合适的，因为它与给定的用户关联性最大，要指定会话作用域，我们可以使用 <code>@Scope</code> 注解，它的使用方式和原型作用域是相同的。</p><pre><code class="java">@Component@Scope(value=WebApplicationContext.SCOPE_SESSION,        proxyMode=ScopedProxyMode.INTERFACES)public ShoppingCart cart() {...}</code></pre><p>这里我们将 value 设置成 <code>WebapplicationConext.SCOPE_SESSION</code>。这会告诉 Spring 为 Web 应用中的每个会话创建一个 ShoppingCart。</p><p><code>@Scope</code> 同时还有另外一个 <code>ProxyMode</code> 属性，它被设置成了 <code>ScopeProxyMode.INTERFACES</code>。这个属性解决了将会话或请求作用域的 bean 注入到单例 bean 中所遇到的问题。在描述 <code>ProxyMode</code> 属性之前，我们先来看下 <code>proxyMode</code> 所解决问题的场景。</p><p>假设我们要将 ShoppingCart bean 注入到单例 StoreService bean 的 Setter 方法中：</p><pre><code class="java">@Componentpublic class StoreService {    @Autowired    public void setShoppingCart(ShoppingCart shoppingCart) {        this.shoppingCart = shoppingCart;    }}</code></pre><p>因为 StoreService 是一个单例 bean，会在 Spring 应用上下文加载的时候创建，当它创建的时候，Spring 会试图将 ShoppingCart 注入到 setShoppingCart 方法中，但是 ShoppingCart 是会话作用域的，此时并不存在。直到用户进入系统，创建了会话之后，才会出现 ShoppingCart 实例。</p><p>另外，系统中将会有多个实例：每个用户一个。我们并不想让 Spirng 注入到某个固定的 ShoppingCart 实例到 StoreService 中，我们希望的是当 StoreService 处理购物车的时候，他所用使用的 ShoppingCart 实例恰好是当前会话所对应的一个。</p><p>Spring 并不会将实例的 ShoppingCart bean 注入到 StoreService，<strong>Spring 会注入一个到 ShoppingCart 的代理</strong>。这个代理会暴露于 ShoppingCart 相同的方法。所以 StoreService 就会认为他是一个购物车。<strong>但是当 StoreService 调用 ShoppingCart 的方法方法时，代理会对其进行解析，并将调用委托给会话作用域内真正的 ShoppingCart。</strong></p><p>现在我们带着这个作用域的理解，讨论一下 <code>ProxyMode</code> 属性，如配置所示，<code>proxyMode</code> 属性被设置成了 <code>ScopedProxyMode.INTERFACES</code>，这表明这个代理要实现 ShoppingCart 接口，并将调用委托给实现 bean。</p><p>如果 ShoppingCart 是接口，而不是类的话，这是可以的，但<strong>如果 ShoppingCart 是一个具体的类的话，Spring 就没有办法创建基于接口的代理了，此时，它必须使用 <code>CGLIB</code> 来生成基于类的代理。所以，如果 bean 类型是具体的类的话，我们必须要将 ProxyMode 属性设置为 <code>ScopedProxyMOde.TARGET_CLASS</code> ，以此来表明要以生成目标类扩展的方法创建代理</strong>。</p><p>尽管我主要关注了会话作用域，但是请求作用域的 bean 会面临相同的装配问题。因此，请求作用域的 bean 应该也以作用域代理的方式进行注入。</p><h2 id="在XML中声明作用域代理"><a href="#在XML中声明作用域代理" class="headerlink" title="在XML中声明作用域代理"></a>在XML中声明作用域代理</h2><p>如果你需要使用 XML 来声明会话或请求作用域的 bean，那么就不能使用 <code>@Scope</code> 注解及其 <code>ProxyMode</code> 属性了 <code>&lt;bean&gt;</code> 元素能够设置 bean 的作用域，但是该怎样设置代理模式呢？</p><p>要使用代理模式，我们需要使用 <code>Spring aop</code> 命名空间的一个新元素：</p><pre><code class="xml">&lt;bean id=&quot;cart&quot;    class=&quot;com.myapp.ShoppingCart&quot;    scope=&quot;session&quot;&gt;    &lt;aop:scoped-proxy/&gt;&lt;/bean&gt;</code></pre><p><code>&lt;aop:scoped-proxy&gt;</code> 是与 <code>@Scope</code> 注解的 <code>proxyMode</code> 属性功能相同的 Spring XML 配置元素，它会告诉 Spring 为 bean 创建一个作用域代理。默认情况下，它会使用 <code>CGLIB</code> 创建目标的代理。但是我们可以将 <code>proxy-target-class</code> 的属性设置为 false，进而要求它生成基于接口的代理。</p><pre><code class="xml">&lt;bean id=&quot;cart&quot;    class=&quot;com.myapp.ShoppingCart&quot;    scope=&quot;session&quot;&gt;    &lt;aop:scoped-proxy proxy-target-class = &quot;false&quot;/&gt;&lt;/bean&gt;</code></pre><p>为了使用 <code>&lt;aop:scoped-proxy&gt;</code> 元素，必须在 XML 配置中声明 Spring 的 aop 命名空间：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;&lt;/beans&gt;</code></pre><h1 id="运行时值注入"><a href="#运行时值注入" class="headerlink" title="运行时值注入"></a>运行时值注入</h1><p>当讨论依赖注入的时候，我们通常讨论的是将一个 bean 引入到另一个 bean 的属性或构造器参数中。它通常来讲指的是将一个对象与另一个对象关联起来</p><p>但 bean 装配的另一个方面指的是将一个值注入到 bean 的属性或构造器参数中。例如将专辑的名字装配到 BlankDisc bean 的构造器活 title 属性中：</p><pre><code class="java">@Beanpublic CompactDisc sgtPeppers() {    return new BlankDisc(&quot;Sgt, Pepper&#39;s Lonely Hearts Club Band&quot;, &quot;The Beatles&quot;);}</code></pre><p>为 BlankDisc bean 设置 title 和 artist，但它在实现的时候是将值硬编码在配置类中的。与之类似，如果使用 XML 的话，那么值也会是硬编码的：</p><pre><code class="xml">&lt;bean id=&quot;sgtPeppers&quot;    class=&quot;soundsystem.BlankDisc&quot;    c:_tilte=&quot;Sgt, Pepper&#39;s Lonely Hearts Club Band&quot;    c:_artist=&quot;The Beatles&quot; /&gt;</code></pre><p>有时候硬编码是可行的，但有时候我们可能会希望避免硬编码。而是让这些值在运行时在确定，为了实现这些功能，Spring 提供了运行时求值的方式：</p><ul><li>属性占位符(Property placeholder)</li><li>Spring表达式语言(SpEL)</li></ul><p>这两种技术的用法是类似的，不过它们的目的和行为是有所差别的。</p><h2 id="注入外部的值"><a href="#注入外部的值" class="headerlink" title="注入外部的值"></a>注入外部的值</h2><p>在 Spring 中，处理外部值的最简单方式就是声明属性源，并通过 Spring 的 <code>Enviroment</code> 来检索属性。</p><pre><code class="java">// 一个基本的 Spring 配置类，它使用外部的属性来装配 BlankDisc bean。@Configuration@PropertySource(&quot;classpath:/com/soundsystem/app.properties&quot;)public class EnvironmentConfig {    @Autowired    private Environment env;    @Bean    public BlankDisc blankDisc() {        return new BlankDisc(                env.getProperty(&quot;disc.title&quot;),                env.getProperty(&quot;disc.artist&quot;));    }}// app.properties// disc.tilte=Sgt, Pepper&#39;s Lonely Hearts Club Band// disc.artist=The Beatles</code></pre><h3 id="PropertyResolver"><a href="#PropertyResolver" class="headerlink" title="PropertyResolver"></a>PropertyResolver</h3><p><code>getProperty()</code> 方法并不是获取属性值的唯一方法，<code>getProperty()</code> 方法有四个重载的变种形式</p><pre><code class="java">package org.springframework.core.env;public interface PropertyResolver {    // 获取属性值，不存在为 null    String getProperty(String key);    // 指定属性不存在的时候，会使用一个默认值    String getProperty(String key, String defaultValue);    // 与前面的两种非常类似，但是它们不会将所有的值都视为 String 类型    &lt;T&gt; T getProperty(String key, Class&lt;T&gt; targetType);    &lt;T&gt; T getProperty(String key, Class&lt;T&gt; targetType, T defaultValue);    // 检查一下某个属性是否存在    boolean containsProperty(String key);    // 如果属性不存在，则抛出异常    String getRequiredProperty(String key) throws IllegalStateException;    /**     * Return the property value associated with the given key, converted to the given targetType (never {@code null}).     * @throws IllegalStateException if the given key cannot be resolved     */    &lt;T&gt; T getRequiredProperty(String key, Class&lt;T&gt; targetType) throws IllegalStateException;    /**     * 解析给定文本中的 $ {...} 占位符，将其替换为 {@link #getProperty} 解析的相应属性值。     * 没有默认值的无法解决的占位符将被忽略并传递不变     */    String resolvePlaceholders(String text);    // 同上，如果占位符解析不存在，则抛出异常    String resolveRequiredPlaceholders(String text) throws IllegalArgumentException;}</code></pre><h3 id="Environment"><a href="#Environment" class="headerlink" title="Environment"></a>Environment</h3><pre><code class="java">public interface Environment extends PropertyResolver {    // 返回激活 profile 名称的数组    String[] getActiveProfiles();    // 返回默认 profile 名称的数组    String[] getDefaultProfiles();    // 如果 environment 支持给定 profile 的话，就返回 true。    boolean acceptsProfiles(String... profiles);}</code></pre><p>直接从 Environment 中检索属性是非常方便的，尤其是在 Java 配置中装配 bean 的时候。但是，Spring 也提供了通过占位符装配属性的方法，这些占位符的值会来源于一个属性源。</p><h3 id="解析属性占位符"><a href="#解析属性占位符" class="headerlink" title="解析属性占位符"></a>解析属性占位符</h3><p>Spring 一直支持将属性定义到外部的属性配置文件中，并使用占位符值将其插入到 Spring bean 中，占位符的形式为使用 <code>${ ... }</code> 包装的属性名称</p><pre><code class="xml">&lt;bean class=&quot;com.soundsystem.BlankDisc&quot;      c:_title=&quot;${disc.title}&quot;      c:_artist=&quot;${disc.artist}&quot;/&gt;</code></pre><p>按照这种方式，XML 配置没有使用任何硬编码的值，它的值是从配置文件以外的一个源中解析得到的。</p><p>如果我们依赖于组件扫描和自动装配来创建和初始化应用组件的话，那么就没有占位符的配置文件了，在这种情况下，我们可以使用 <code>@Value</code> 注解，它的使用方式与 <code>@Autowired</code> 注解非常类似。在 BlankDisc 类中，构造器可以改成如下显示：</p><pre><code class="java">public BlankDisc(        @Value(&quot;${disc.title}&quot;) String title,        @Value(&quot;${disc.artist}&quot;) String artist) {    this.title = title;    this.artist = artist;}</code></pre><p>为了使用占位符，我们必须要配置一个 <code>PropertyPlaceholderConfigurer</code> bean， 从 Spring3.1 开始，推荐使用 <code>PropertySourcesPlaceholderConfigurer</code> ，因为它能够基于 Spirnig Environment 及其属性源来加载占位符。</p><pre><code class="java">@Beanpublic static PropertySourcesPlaceholderConfigurer placeholderConfigurer() {    return new PropertySourcesPlaceholderConfigurer();}</code></pre><p>如果使用 XML 配置，Spring Context 命名空间中的 <code>&lt;context:propertyplaceholder&gt;</code> 元素会为你生成 PropertySourcesPlaceholderConfigurer bean：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd&quot;&gt;    &lt;context:property-placeholder            location=&quot;com/soundsystem/app.properties&quot; /&gt;&lt;/beans&gt;</code></pre><p>解析外部属性能够将值的处理推迟到运行时，但是它的关注点在于根据名称解析来自于 Spring Environment 和属性源的属性。</p><h2 id="使用Spring表达式语言进行装配"><a href="#使用Spring表达式语言进行装配" class="headerlink" title="使用Spring表达式语言进行装配"></a>使用Spring表达式语言进行装配</h2><p>Spring 3 引入了 Spring 表达式语言(SpringExpression Langguage, SpEL)，它能够以一种强大和简洁的方式将值装配到 bean 的属性和构造器参数中，在这个过程中所使用的表达式会在运行时计算到值。</p><p>SpEL 拥有的特性：</p><ul><li>使用 bean 的 ID 来引用 bean</li><li>调用方法和访问对象的属性</li><li>对值进行算术、关系、逻辑运算</li><li>正则表达式匹配</li><li>集合操作</li></ul><p>SpEL 表达式要放要 <code>#{...}</code> 之中这与属性占位符有些类似，属性占位符需要放到 <code>${...}</code> 之中</p><h3 id="装配-bean-时使用-SpEL"><a href="#装配-bean-时使用-SpEL" class="headerlink" title="装配 bean 时使用 SpEL"></a>装配 bean 时使用 SpEL</h3><pre><code class="java">public BlankDisc(        @Value(&quot;#{systemProperties[&#39;disc.title&#39;]}&quot;) String title,        @Value(&quot;#{systemProperties[&#39;disc.artist&#39;]}&quot;) String artist) {    this.title = title;    this.artist = artist;}</code></pre><p>在 XML 配置中，可以将 SpEL 表达式传入 <code>&lt;property&gt;</code> 或 <code>&lt;constructor-arg&gt;</code> 的 <code>value</code> 属性中，或者将其作为 <code>p-</code> 命名空间或 <code>c-</code> 命名空间条目的值。</p><pre><code class="xml">&lt;bean id=&quot;sgtPeppers&quot;    class=&quot;soundsystem.BlankDisc&quot;    c:_tilte=&quot;#{systemProperties[&#39;disc.title&#39;]}&quot;    c:_artist=&quot;#{systemProperties[&#39;disc.artist&#39;]}&quot; /&gt;</code></pre><h3 id="表示字面值"><a href="#表示字面值" class="headerlink" title="表示字面值"></a>表示字面值</h3><pre><code class="java">#{3.1415}#{9.87E4}#{&#39;Hello&#39;}#{false}</code></pre><h3 id="引用-bean、属性和方法"><a href="#引用-bean、属性和方法" class="headerlink" title="引用 bean、属性和方法"></a>引用 bean、属性和方法</h3><pre><code class="java">#{sgtPeppers} // 通过 ID 引用其他的 bean#{sgtPeppers.artist}  // 引用 sgtPeppers 的 artist 属性#{artistSelector.selectArtist()} // 调用 bean 的 selectArtist() 方法#{artistSelector.selectArtist().toUpperCase()}#{artistSelector.selectArtist()?.toUpperCase()}  // 避免空指针// 如果 selectArtist() 的返回值是 null 的话，// 那么 SpEL 将不会调用 toUpperCase() 方法。表达式的返回值会是 null。</code></pre><h3 id="在表达式中使用类型"><a href="#在表达式中使用类型" class="headerlink" title="在表达式中使用类型"></a>在表达式中使用类型</h3><p>如果要在 SpEL 中访问类作用域的方法和常量的话，要依赖 <code>T()</code> 这个关键的运算符。</p><pre><code class="java">T(java.lang.Math)  // 一个 Class 对象T(java.lang.Math).PI  // 访问目标类型的常量T(java.lang.Math).random()  // 访问目标类型的静态方法</code></pre><h3 id="SpEL-运算符"><a href="#SpEL-运算符" class="headerlink" title="SpEL 运算符"></a>SpEL 运算符</h3><table><thead><tr><th>运算符类型</th><th>运　算　符</th></tr></thead><tbody><tr><td>算术运算</td><td>+ 、 - 、 * 、 / 、 % 、 ^</td></tr><tr><td>比较运算</td><td>&lt; 、 &gt; 、 == 、 &lt;= 、 &gt;= 、 lt 、 gt 、 eq 、 le 、 ge</td></tr><tr><td>逻辑运算</td><td>and 、 or 、 not 、 `</td></tr><tr><td>条件运算</td><td>?:(ternary) 、 ?:(Elvis)</td></tr><tr><td>正则表达式</td><td>matches</td></tr></tbody></table><pre><code class="java">#{2 * T(java.lang.Math).PI * circle.radius}  // 计算 circle bean 中所定义圆的周长#{T(java.lang.Math).PI * circle.radius ^ 2}  // ^ 用于乘方计算的运算符// 三元运算符（ternary）#{scoreboard.score &gt; 1000 ? &quot;Winner！&quot; : &quot;Loser&quot;}// 三元运算符的一个常见场景就是检查 null 值#{disc.title ?: &quot;Rattle and Hum&quot;}  // 如果是 null 的话，那么表达式的计算结果就会是 Rattle and Hum// 正则表达式// matches 运算符对 String 类型的文本（作为左边参数）应用正则表达式（作为右边参数）。// matches 的运算结果会返回一个 Boolean 类型的值：如果与正则表达式相匹配，则返回 true；否则返回 false。#{admin.email matches &#39;[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.com&#39;}</code></pre><h3 id="计算集合"><a href="#计算集合" class="headerlink" title="计算集合"></a>计算集合</h3><pre><code class="java">#{jukebox.songs[4].title}  // 计算 songs 集合中第五个元素的 title 属性#{jukebox.songs[T(java.long.Math).random() * jukebox.songs.size()].title}  // 随机选择一首歌#{&#39;This is a test&#39;[3]}  // s// 查询运算符 .?[]#{jukebox.songs.?[artist eq &#39;Aerosmith&#39;]  // artist 属性为 Aerosmith 的所有歌曲// .^[]  在集合中查询第一个匹配项// .$[]  在集合中查询最后一个匹配项#{jukebox.songs.^[artist eq &#39;Aerosmith&#39;]// 投影运算符 .![]，从集合的每个成员中选择特定的属性放到另外一个集合中#{jukebox.songs.![title]  // 将 title 属性投影到一个新的 String 类型的集合中// 投影操作可以与其他任意的 SpEL 运算符一起使用#{jukebox.songs.?[artist eq &#39;Aerosmith&#39;].![title]</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Effective Java》笔记57-65：异常</title>
      <link href="/2019/06/20/%E3%80%8AEffective%20Java%E3%80%8B%E7%AC%94%E8%AE%B057-65%EF%BC%9A%E5%BC%82%E5%B8%B8/"/>
      <url>/2019/06/20/%E3%80%8AEffective%20Java%E3%80%8B%E7%AC%94%E8%AE%B057-65%EF%BC%9A%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<h1 id="第57条：只针对异常的情况才使用异常"><a href="#第57条：只针对异常的情况才使用异常" class="headerlink" title="第57条：只针对异常的情况才使用异常"></a>第57条：只针对异常的情况才使用异常</h1><p>也许你在将来会碰到下面这样的代码，它是基本异常模式的循环：</p><pre><code class="java">try {    int i = 0;    while(true)        range[i++].climb();} catch (ArrayIndexOutOfBoundsException e) {}</code></pre><p>实例上，在现代的JVM实例上，基本异常的模式比标准模式要慢得多。</p><p>异常应该只用于异常的情况下，它们永远不应该用于正常的控制流。</p><a id="more"></a><h1 id="第58条：对可恢复的情况使用受检异常，对编程错误使用运用时异常"><a href="#第58条：对可恢复的情况使用受检异常，对编程错误使用运用时异常" class="headerlink" title="第58条：对可恢复的情况使用受检异常，对编程错误使用运用时异常"></a>第58条：对可恢复的情况使用受检异常，对编程错误使用运用时异常</h1><p>Java程序设计语言提供了三种异常：受检的异常（checked exception）、运行时异常（run-time exception）和错误（error）。关于什么时候适合使用哪种异常，虽然没有明确的规定，但还是有些一般性的原则的。</p><ol><li>如果期望调用者能够适当地恢复，对于这种情况就应该使用受检异常，如某人打算网上购物，结果余额不足，此时可以抛出自定义的受检异常。通过抛出受检异常，将强迫调用者在 catch 子句中处理该异常，或继续向上传播。因此，在方法中声明受检异常，是对 API 用户的一种潜在提示。</li><li>用运行时异常来表明编程错误。大多数的运行时异常都表示&quot;前提违例&quot;，即 API 的使用者没有遵守 API 设计者建立的使用约定。如数组访问越界等问题。</li><li>对于错误而言，通常是被 JVM 保留用于表示资源不足、约束失败，或者其他使程序无法继续执行的条件。</li></ol><p>针对自定义的受检异常，该条目还给出一个非常实用的技巧，当调用者捕获到该异常时，可以通过调用该自定义异常提供的接口方法，获取更为具体的错误信息，如当前余额等信息。</p><h1 id="第59条：避免不必要地使用受检的异常"><a href="#第59条：避免不必要地使用受检的异常" class="headerlink" title="第59条：避免不必要地使用受检的异常"></a>第59条：避免不必要地使用受检的异常</h1><p>受检异常是 Java 提供的一个很好的特征。与返回值不同，它们强迫程序员必须处理异常的条件，从而大大增强了程序的可靠性。也就是说，过分使用受检的异常，调用该方法的代码就必须在 catch 中处理这些异常，或者抛出。</p><p>如果正确的使用 API 不能阻止这种异常条件的产生，并且一旦产生异常，使用 API 的程序员可以立即采用有用的动作，这种负担就被认为是正当的。除非这两个条件都成立，否则更适合使用未受检异常。</p><p>如果方法只抛出单个受检异常，也会导致该方法不得在 try 块中，在这种情况下，应该问自己，是否有别的途径来避免 API 调用者使用受检的异常。这里提供这样的参考，我们可以把抛出的单个异常的方法分成两个方法，其中一个方法返回一个 boolean，表明是否该抛出异常。这种 API 重构：</p><pre><code class="java">try { // 调用时检查异常    obj.action(args); // 调用检查异常方法} catch (TheCheckedExcption e) {    // 处理异常条件    ...}//重构为：if (obj.actionPermitted(args)) { // 使用状态测试方法消除catch    obj.action(args);} else {    // 处理异常条件    ...}</code></pre><p>这种重构并不总是合适的，但在合适的地方，它会使用 API 用起来更加舒服。虽然没有前者漂亮，但更加灵活——如果程序员知道调用肯定会成功，或不介意由调用失败而导致的线程终止，则下面为理为简单的调用形式：</p><pre><code class="java">obj.action(args);</code></pre><h1 id="第60条：优先使用标准的异常"><a href="#第60条：优先使用标准的异常" class="headerlink" title="第60条：优先使用标准的异常"></a>第60条：优先使用标准的异常</h1><table><thead><tr><th>异常</th><th>使用场景</th></tr></thead><tbody><tr><td>IllegalArgumentException</td><td>非 null 的参数值不正确。如：收款金额传递负数</td></tr><tr><td>IllegalStateException</td><td>对于方法调用而言，对象状态不合适。如：正在初始化中，就被调用了</td></tr><tr><td>NullPointerException</td><td>在禁止使用 null 的情况下参数值为 null。</td></tr><tr><td>IndexOutOfBoundsException</td><td>下标参数值越界</td></tr><tr><td>ConcurrentModificationException</td><td>在禁止并发修改的情况下，检测到对象的并发修改。</td></tr><tr><td>UnsupportedOperationException</td><td>对象不支持用户请求的方法。如：只读 List 进行删除操作</td></tr></tbody></table><h1 id="第61条：抛出与抽象相对应的异常"><a href="#第61条：抛出与抽象相对应的异常" class="headerlink" title="第61条：抛出与抽象相对应的异常"></a>第61条：抛出与抽象相对应的异常</h1><p>更高层的实现应该捕获低层的异常，同时抛出可以按照高层抽象进行解释的异常。这种做法称为<strong>异常转译</strong> （exception translation），如下代码所示：</p><pre><code class="java">// AbstractSequentialList/** * Returns the element at the specified position in this list. * @throws IndexOutOfBoundsException if the index is out of range * ({@code index &lt; 0 || index &gt;= size()}). */public E get(int index) {    ListIterator&lt;E&gt; i = listIterator(index);    try {        return(i.next() );    } catch (NoSuchElementException e) {        throw new IndexOutOfBoundsException(&quot;Index: &quot; + index);    }}</code></pre><p>一种特殊的异常转译形式称为<strong>异常链</strong>（exception chaining），如果低层的异常对于调试导致高层异常的问题非常有帮助，使用异常链就很合适。低层的异常（原因）被传到高层的异常，高层的异常提供访问方法 (Throwable 的 getCause 方法）来获得低层的异常：</p><pre><code class="java">try {... // Use lower-level abstraction to do our bidding} catch (LowerLevelException cause) {    throw new HigherLevelException(cause);}</code></pre><p>高层异常的构造器将原因传到<strong>支持链</strong>（chaining-aware）的超级构造器，因此它最终将被传给 Throwable 的其中一个运行异常链的构造器，例如 Throwable(Throwable) :</p><pre><code class="java">/* Exception with chaining-aware constructor */class HigherLevelException extends Exception {    HigherLevelException( Throwable cause ) {        super(cause);    }}</code></pre><p>大多数标准的异常都有支持链的构造器。对于没有支持链的异常，可以利用 Throwable 的 <code>initCause</code> 方法设置原因。异常链不仅让你可以通过程序（用 getCause）访问原因，还可以将原因的堆战轨迹集成到更高层的异常中。</p><p>尽管异常转译与不加选择地从低层传递异常的做法相比有所改进，但是也不能滥用它。</p><p>总而言之，如果不能阻止或者处理来自更低层的异常，一般的做法是使用异常转译，只有在低层方法的规范碰巧可以保证“它所抛出的所有异常对于更高层也是合适的”情况下，才可以将异常从低层传播到高层。异常链对高层和低层异常都提供了最佳的功能：它允许抛出适当的高层异常，同时又能捕获低层的原因进行失败分析。</p><h1 id="第62条：每个方法抛出的异常都要有文档"><a href="#第62条：每个方法抛出的异常都要有文档" class="headerlink" title="第62条：每个方法抛出的异常都要有文档"></a>第62条：每个方法抛出的异常都要有文档</h1><p>如果一个方法可能抛出多个异常类，则不要使用“快捷方式”声明它会抛出这此异常类的某个超类。永远不要声明一个方法<code>throws Exception</code>，或者更糟的是声明 <code>throws Throwable</code> ，这是极端的例子，因为它掩盖了该方法可能抛出的其他异常。</p><p>对于方法可能抛出的运行时异常，如果将这些异常信息很好地组织成列表文档，就可以有效地描述出这个方法被成功执行的<strong>前提条件</strong>。</p><p>对于接口的方法，在文档中描述出它可能抛出的运行时异常显得尤其重要。这份文档成了该接口的通用约定的一部分，它指定了该接口的多个实现必须遵循的公共行为。</p><p>运行时异常也要在 <code>@throws</code> 标签中进行描述。</p><p>应该注意的是，为每个方法可能抛出的所有运行时异常建立文档是一种很理想的好的想法，但在实践中并非总能做到这一点。比如在后面的版本中如果修改代码，有可能抛出另外一个运行时异常，这不算违反源代码或者二进制兼容性。</p><p>如果某类所有方法抛出同一个异常，那么这个异常的文档可以描述在类文档中。</p><p>总之，要为你编写的每个方法所能摆好出的每个异常建立文档，对于未受检和受检异常，以及对于抽象的和具体的方法也都一样。</p><h1 id="第63条：在细节消息中包含能捕获失败的信息"><a href="#第63条：在细节消息中包含能捕获失败的信息" class="headerlink" title="第63条：在细节消息中包含能捕获失败的信息"></a>第63条：在细节消息中包含能捕获失败的信息</h1><p>为了捕获失败，异常的细节信息应该包含“对该异常有贡献”的所有参数和字段的值。 例如， IndexOutOfBoundsException 异常的细节消息应该包含下界、上界以及没有落在界内的下标值。该细节消息提供了许多关于失败的信息。这三个值中任何一个或者全部都有可能是错的。实际的下标值可能小于下界或等于上界（「越界错误」），或者它可能是个无效值，太小或太大。下界也有可能大于上界（严重违反内部约束条件的一种情况） 。每一种情形都代表了不同的问题，如果程序员知道应该去查找哪种错误，就可以极大地加速诊断过程。</p><p>为了确保在异常的细节消息中包含足够的失败信息，一种办法是在异常的构造器而不是字符串细节消息中引人这些信息。然后，有了这些信息，只要把它们放到消息描述中，就可以自动产生细节消息。例如  <code>IndexOutOfBoundsException</code> 使用如下构造器代替 String 构造器：</p><pre><code class="java">/** * Constructs an IndexOutOfBoundsException. * * @param lowerBound the lowest legal index value * @param upperBound the highest legal index value plus one * @param index the actual index value */public IndexOutOfBoundsException( int lowerBound, int upperBound,                  int index ) {    // Generate a detail message that captures the failure    super(String.format(              &quot;Lower bound: %d, Upper bound: %d, Index: %d&quot;,              lowerBound, upperBound, index ) );    // Save failure information for programmatic access    this.lowerBound = lowerBound;    this.upperBound = upperBound;    this.index = index;}</code></pre><p>从 Java 9 开始， IndexOutOfBoundsException 终于获得了一个构造器，它可以带一个类型为 int 的 index 参数值。更通俗地说， Java 平台类库并没有广泛地使用这种做法，但是，这种做法仍然值得大力推荐。</p><h1 id="第64条：努力使失败保持原子性"><a href="#第64条：努力使失败保持原子性" class="headerlink" title="第64条：努力使失败保持原子性"></a>第64条：努力使失败保持原子性</h1><p>一般而言，失败的方法调用应该使对象保持在被调用之前的状态。 具有这种属性的方法被称为具有失败原子性。<br>有以下几种途径可以保持这种原子性。</p><ol><li><p>最简单的方法是设计不可变对象。因为失败的操作只会导致新对象的创建失败，而不会影响已有的对象。对于可变对象，一般方法是在操作该对象之前先进行参数的有效性验证，这可以使对象在被修改之前，抛出更为有意义的异常，如：</p><pre><code class="java"> public Object pop() {     if (size == 0)         throw new EmptyStackException();     Object result = elements[--size];     elements[size] = null;     return result; }</code></pre><p> 如果取消对初始大小（size）的检查，当这个方法企图从一个空栈中弹出元素时，它仍然会抛出异常。然而，这将会导致 size 字段保持在不一致的状态（负数）之中，从而导致将来对该对象的任何方法调用都会失败。此外，那时， pop 方法抛出的 ArrayIndexOutOfBoundsException 异常对于该抽象来说也是不恰当的。</p></li><li><p>一种类似的获得失败原子性的办法是，调整计算处理过程的顺序，使得任何可能会失败的计算部分都在对象状态被修改之前发生。如果对参数的检查只有在执行了部分计算之后才能进行，这种办法实际上就是上一种办法的自然扩展。比如，以 TreeMap 的情形为例，它的元素被按照某种特定的顺序做了排序。为了向 TreeMap 中添加元素，该元素的类型就必须是可以利用 TreeMap 的排序准则与其他元素进行比较的。如果企图增加类型不正确的元素，在 tree 以任何方式被修改之前，自然会导致 ClassCastException 异常。</p></li><li><p>第三种获得失败原子性的办法是，在对象的一份临时拷贝上执行操作，当操作完成之后再用临时拷贝中的结果代替对象的内容。如果数据保存在临时的数据结构中，计算过程会更加迅速，使用这种办法就是件很自然的事。例如，有些排序函数会在执行排序之前，先把它的输入列表备份到一个数组中，以便降低在排序的内循环中访问元素所需要的开销。这是出于性能考虑的做法，但是，它增加了一项优势：即使排序失败，它也能保证输入列表保持原样。</p></li><li><p>最后一种获得失败原子性的办法远远没有那么常用，做法是编写一段恢复代码 （recovery code），由它来拦截操作过程中发生的失败，以及便对象回滚到操作开始之前的状态上。这种办法主要用于永久性的（基于磁盘的） 数据结构。</p></li></ol><p>虽然一般情况下都希望实现失败原子性，但并非总是可以做到。举个例子，如果两个线程企图在没有适当的同步机制的情况下，并发地修改同一个对象，这个对象就有可能被留在不一致的状态之中。因此，在捕获了  ConcurrentModificationException 异常之后再假设对象仍然是可用的，这就是不正确的。错误通常是不可恢复的，因此，当方法抛出 AssertionError 时，不需要努力去保持失败原子性。</p><h1 id="第65条：不要忽略异常"><a href="#第65条：不要忽略异常" class="headerlink" title="第65条：不要忽略异常"></a>第65条：不要忽略异常</h1><p>空的 catch 块会使异常达不到应用的目的。忽略异常就如同火警信号器关掉了。至少，catch 块也应该包含一条说明，解释为什么可以忽略这个异常。</p><p>有一种情况可以忽略异常，即关闭 FileInputStream 的时候，因为你还没有改变文件的状态，因此不必执行任何恢复动作，并且已经从文件中读取到所需要的信息了，因此不必终止正在进行的操作，即使在这种情况下，也得要把异常记录下来。</p><p>本条目中的建议同样适用于受检异常和未受检异常。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Effective Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Effective Java》笔记45-56：通用程序设计</title>
      <link href="/2019/06/19/%E3%80%8AEffective%20Java%E3%80%8B%E7%AC%94%E8%AE%B045-56%EF%BC%9A%E9%80%9A%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
      <url>/2019/06/19/%E3%80%8AEffective%20Java%E3%80%8B%E7%AC%94%E8%AE%B045-56%EF%BC%9A%E9%80%9A%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="第45条：将局部变量的作用域最小化"><a href="#第45条：将局部变量的作用域最小化" class="headerlink" title="第45条：将局部变量的作用域最小化"></a>第45条：将局部变量的作用域最小化</h1><p>将局部变量的作用域最小化，可以增强代码的可读性和可维护性，并降低出错的可能性。</p><p>要使用局部变量的作用域最小化，最有力的方法就是在第一次使用它的地方才声明，不要过早的声明。</p><p>局部变量的作用域从它被声明的点开始扩展，一直到外围块的结束外。如果变量是在“使用它的块”之外被声明有，当程序退出该块之后，该变量仍是可见的，如果它在目标使用区之前或之后意外使用，将可能引发意外错误。</p><p>几乎每个局部变量的声明都应该包含一个初始化表达式，如果你还没有足够信息来对象一个变量进行有意义的初始化，就应该推迟这个声明，直到可初始化为止。</p><a id="more"></a><p>循环中提供了特殊的机会来将变量的作用域最小化。如果在循环终止之后不再需要使用循环变量的内容，for 循环就优先于 while 循环。for 循环也增强了可读性。</p><pre><code class="java">Iterator&lt;Element&gt; i = c.iterator();while (i.hasNext()) {    doSomething(i.next());}for (Iterator&lt;Element&gt; i = c.iterator(); i.hasNext(); ) {    doSomething(i.next());}</code></pre><p>最后一种“将局部变量的作用域最小化”的方法是使方法小而集中。如果两个操作合并在一个方法中，与其中的一个操作相关的局部变量就有可能出现在另一个操作的代码范围之内。为了防止这种情况发生，需将这两个操作分成两个方法。</p><h1 id="第46条：for-each-循环优先于传统的-for-循环"><a href="#第46条：for-each-循环优先于传统的-for-循环" class="headerlink" title="第46条：for-each 循环优先于传统的 for 循环"></a>第46条：for-each 循环优先于传统的 for 循环</h1><p>传统的 for 循环</p><pre><code class="java">for (Iterator&lt;Element&gt; i = c.iterator(); i.hasNext(); ) {    Element e = i.next();    ... // Do something with e}for (int i = 0; i &lt; a.length; i++) {    ... // Do something with a[i]}</code></pre><p>这些习惯用法比 while 循环更好，但是它们并不完美。迭代器和索引变量都很混乱——你只需要元素而已。此外，它们也代表了出错的机会。迭代器在每个循环中出现三次，索引变量出现四次，这使你有很多机会使用错误的变量。如果这样做，就不能保证编译器会发现到问题。</p><p>for-each 循环，完全隐藏迭代器或者索引变量，避免了混乱和出错的可能，下面这种模式同样适合于集合与数组：</p><pre><code class="java">for(Element e : elements){    doSomething(e);}</code></pre><p>当涉及到嵌套迭代时，for-each 循环相对于传统 for 循环的优势甚至更大。下面是人们在进行嵌套迭代时经常犯的一个错误:</p><pre><code class="java">enum Suit { CLUB, DIAMOND, HEART, SPADE }enum Rank { ACE, DEUCE, THREE, FOUR, FIVE, SIX, SEVEN, EIGHT,            NINE, TEN, JACK, QUEEN, KING }...static Collection&lt;Suit&gt; suits = Arrays.asList(Suit.values());static Collection&lt;Rank&gt; ranks = Arrays.asList(Rank.values());List&lt;Card&gt; deck = new ArrayList&lt;&gt;();for (Iterator&lt;Suit&gt; i = suits.iterator(); i.hasNext(); )    for (Iterator&lt;Rank&gt; j = ranks.iterator(); j.hasNext(); )        // next 方法，多次被调用，在 suit 用完之后，循环抛出 NoSuchElementException 异常        deck.add(new Card(i.next(), j.next()));// 要修复例子中的错误，必须在外部循环的作用域内添加一个变量来保存外部元素:for (Iterator&lt;Suit&gt; i = suits.iterator(); i.hasNext(); ) {    Suit suit = i.next();    for (Iterator&lt;Rank&gt; j = ranks.iterator(); j.hasNext(); )        deck.add(new Card(suit, j.next()));}// 如果使用嵌套 for-each 循环，问题就会消失。生成的代码也尽可能地简洁:for (Suit suit : suits)    for (Rank rank : ranks)        deck.add(new Card(suit, rank));</code></pre><h2 id="三种常见的情况不能使用-for-each-循环"><a href="#三种常见的情况不能使用-for-each-循环" class="headerlink" title="三种常见的情况不能使用 for-each 循环"></a>三种常见的情况不能使用 for-each 循环</h2><ul><li><strong>有损过滤</strong>：如果需要遍历集合，并删除指定选元素，则需要使用显式迭代器，以便可以调用其 remove 方法。通常可以使用在 Java 8 中添加的 Collection 类中的 <code>removeIf</code> 方法，来避免显式遍历。</li><li><strong>转换</strong>：如果需要遍历一个列表或数组并替换其元素的部分或全部值（<strong>不可赋值，可以对元素进行操作 setter</strong>），那么需要列表迭代器或数组索引来替换元素的值。</li><li><strong>并行迭代</strong>：如果需要并行地遍历多个集合，那么需要显式地控制迭代器或索引变量，以便所有迭代器或索引变量都可以同步进行 (正如上面错误的示例中无意中演示的那样)。</li></ul><h1 id="第47条：了解和使用类库"><a href="#第47条：了解和使用类库" class="headerlink" title="第47条：了解和使用类库"></a>第47条：了解和使用类库</h1><p>通过使用标准类库，可以充分利用这些编写标准类库的专家的知识，以及在你之前的其他人的使用经验。</p><p>使用标准类库中的第二个好处是，不必关心底层细节上，把时间应花在应用程序上。</p><p>使用标准类库中的第三个好处是，它们的性能往往会随着时间的推移而不断提高，无需你做任何努力。</p><p>总之，不要重新发明轮子，已存在的我们就直接使用，只有不能满足我们需求时，才需自己开发，总的来说，多了解类库是有好处的，特别是为库中的工具包。</p><h1 id="第48条：如果需要精确的答案，请避免使用-float-和-double"><a href="#第48条：如果需要精确的答案，请避免使用-float-和-double" class="headerlink" title="第48条：如果需要精确的答案，请避免使用 float 和 double"></a>第48条：如果需要精确的答案，请避免使用 float 和 double</h1><p><a href="/2018/03/17/Java大数操作（BigInteger，BigDecimal）/">Java大数操作（BigInteger，BigDecimal）</a></p><p>float 和 double 类型主要是用来为科学计算和工程计算而设计的。它们执行二进制浮点运算，这是为了在广泛的数值满园上提供较为精确的快速近似计算而精心设计的，然而，它们并没有提供完全精确的结果，所以不应该被用于需要精确结果的场合。float 和 double 类型尤其不适合用于货币的计算，因为要让一个 float 和 double 精确地表示0.1（或者 10 的任何其他负数次方值）是不可能的。</p><pre><code class="java">System.out.println(1.0-.9);// 0.09999999999999998</code></pre><p>请使用BigDecimal、int 或 long（int 与 long 以货币最小单位计算）进行货币计算。</p><p>使用 BigDecimal 时还请使用 BigDecimal(String)，而不要使用 BigDecimal(float 或 double)，因为后者在传递的过程中会丢失精度：</p><pre><code class="java">new BigDecimal(0.1)// 0.1000000000000000055511151231257827021181583404541015625new BigDecimal(&quot;0.1&quot;)//0.1</code></pre><p>使用 BigDecimal 有两个缺点：与使用基本运算类型相比，这样做很不方便，而且很慢。</p><p>如果性能非常关键，请使用 int 和 long，如果数值范围没有超过 9 位十进制数字，就可以使用 int；如果不超过 18 位数字，就可以使用 long，如果数字可能超过 18 位数字，就必须使用 BigDecimal。</p><h1 id="第49条：基本类型优先于装箱基本类型"><a href="#第49条：基本类型优先于装箱基本类型" class="headerlink" title="第49条：基本类型优先于装箱基本类型"></a>第49条：基本类型优先于装箱基本类型</h1><p>主要区别：</p><ol><li>基本类型只有值，在进行比较时可以直接基于值进行比较，而装箱类型在进行同一性比较时和基本类型相比有着不同的逻辑，毕竟他们是对象，是 Object 的子类，它们需要遵守 Java 中类对象比较的默认规则。</li><li>基本类型只有功能完备的值，而每个装箱类型除了它对应基本类型的所有功能之外，还有一个非功能值：null。记住，它毕竟是对象。</li><li>基本类型通常比装箱类型更节省时间和空间。</li></ol><pre><code class="java">public class MyTest {    private static int compare(Integer first,Integer second) {        return first &lt; second ? -1 : (first == second ? 0 : 1);    }    public static void main(String[] args) {        Integer first = new Integer(42);        Integer second = new Integer(42);        System.out.println(&quot;Result of compare first and second is &quot; + compare(first,second));    }}// Result of compare first and second is 1</code></pre><p>这段代码看起来非常简单，它的运行结果也非常容易得出，然而当我们真正运行它的时候却发现，实际输出的结果和我们的期望是完全不同的，这是为什么呢？见如下分析：</p><ol><li>compare 方法中的第一次比较(first &lt; second，自动拆箱)将能够正常工作并得到正确的结果，即 first &lt; second 为 false；</li><li>在进行相等性比较的时候问题出现了，如前所述，Integer 毕竟是对象，在进行对象之间的同一性比较时它将遵守对象的同一性比较规则，由于这两个参数对象的地址是不同的，因为我们是通过两次不同的 new 方法构建出的这两个参数对象。结果可想而知，first == second 返回 false；</li><li>现在最后的输出结果已经很清楚了：Result of compare first and second is 1</li></ol><p>对于装箱基本类型运用 == 操作符几乎总是错的。</p><pre><code class="java">// 修正问题private static int compare(Integer first,Integer second) {    int f = first;    int s = second;    return f &lt; s ? -1 : (f == s ? 0 : 1);}</code></pre><pre><code class="java">// 错误示例1：public class Unbelievable {    static Integer i;    public static void main(String[] args) {        if (i == 42)  // NullPointerException，需声明 i 为 int            System.out.println(&quot;Unbelievable&quot;);    }}// 错误示例2：public static void main(String[] args) {    Long sum = 0L;    for (long i = 0; i &lt; Integer.MAX_VALUE; ++i) {        sum += i;    }    System.out.println(sum);}// 没有错误，但反复的装箱拆箱导致性能下降</code></pre><p>在以下三种情况下我们将需要使用装箱基本类型：</p><ol><li>作为集合中的元素、建和值。</li><li>泛型</li><li>在使用反射进行方法调用时。</li></ol><p>总之，当可以选择的时候，基本类型要优先于包装类型，基本类型更加简单，也更加快速。自动装箱减少了使用包装基本类型的繁琐，但是并没有减少它的风险。另外，对于装箱基本类型运用 == 操作符几乎总是错的。</p><h1 id="第50条：如果其他类型更适合，则尽量避免使用字符串"><a href="#第50条：如果其他类型更适合，则尽量避免使用字符串" class="headerlink" title="第50条：如果其他类型更适合，则尽量避免使用字符串"></a>第50条：如果其他类型更适合，则尽量避免使用字符串</h1><p>字符串不适合代替其他的值类型。数组经过文件、网络，或键盘输出设置进入到程序中之后，它通常是以字符形式存在，但我们应该尽量将他们转换为确切的类型。</p><p>如果可以使用更加合适的数据类型，或者可以编写更加适当的数据类型，就应该避免用字符串来表示对象。若使用不当，字符串会比其他类型更加笨拙、更不灵活、速度慢，也更容易出错。经常被错误地用字符串来代替的类型包括基本类型、枚举类型和聚集类型。</p><h1 id="第51条：当心字符串连接的性能"><a href="#第51条：当心字符串连接的性能" class="headerlink" title="第51条：当心字符串连接的性能"></a>第51条：当心字符串连接的性能</h1><p>循环中不要使用字符串连接操作符 <code>+</code> 来合并多个字符串，除非性能无关紧要。相反，应该使用 StringBuilder 的 append 方法。</p><h1 id="第52条：通过接口引用对象"><a href="#第52条：通过接口引用对象" class="headerlink" title="第52条：通过接口引用对象"></a>第52条：通过接口引用对象</h1><p>一般来讲，在函数参数、返回值、域变量等声明中，应该尽量使用接口而不是类作为它们的类型。只有当你利用构造器创建某个对象的时候，才真正需要引用这个对象的类，如：</p><pre><code class="java">List&lt;Subscriber&gt; subscribers = new Vector&lt;Subscriber&gt;();// 而不是像下面这样的声明：Vector&lt;Subscriber&gt; subscribers = new Vector&lt;Subscriber&gt;();</code></pre><p>如果你养成了用接口作为类型的习惯，你的程序将更加灵活。对于上面的例子，在今后的改进中，如果不想使用 Vector 作为实例化对象，我们只需在如下一出进行修改即可：</p><pre><code class="java">List&lt;Subscriber&gt; subscribers = new ArrayList&lt;Subscriber&gt;();</code></pre><p>如果之前该变量的类型不是接口类型，而是它实际类型的本身，那么在做如此修改之前，则需要确认在所有使用该变量的代码行是否用到了 Vector 的特性（同步），从而导致不行直接进行替换。如果该变量的接口为接口，我们将不受此问题的限制。</p><p>那么在哪些情况下不是使用接口<strong>而是使用实际类</strong>呢？见如下情况：</p><ol><li>没有合适的接口存在，如 String 和 BigInteger 等值对象，通常它们都是 final 的，也没有提供任何接口。</li><li>对象属于一个框架，而框架的基本类型是类，不是接口。如果对象属于这种基于类的框架，就应使用基类来引用该对象，如 TimerTask。</li><li>类实现了接口，但是它提供了接口中不存在的额外方法。如果程序此时依赖于这些额外的方法，这种类就应该只被用来引用他的实例。例如依赖 Vector 的同步（只是假设）。</li></ol><p>简而言之，如果类实现了接口，就应该尽量使用其接口引用该类的引用对象，这样可以使程序更加灵活，如果不是，则使用类层次结构中提供了必要功能的最基础的类。</p><h1 id="第53条：接口优先于反射机制"><a href="#第53条：接口优先于反射机制" class="headerlink" title="第53条：接口优先于反射机制"></a>第53条：接口优先于反射机制</h1><p>Java 中提供了反射的机制，如给定一个 Class 实例，你可以获取 Constructor、Method 和 Field 等实例，分别代表了该 Class 实例所表示的类的 Constructor(构造器)、Method(方法) 和 Field(域)。与此同时，这些实例可以使你通过反射机制操作它们的底层对等体。然后这种灵活是需要付出一定代价的，如下：</p><ol><li>丧失了编译时类型检查的好处，包括异常检查和类型检查等。</li><li>执行反射访问所需要的代码往往非常笨拙和冗长，阅读起来也非常困难，通常而言，一个基于普通方式的函数调用大约 1,2 行，而基于反射方式，则可能需要十几行。</li><li>性能损失，反射方法的调用比普通方法调用慢了许多。</li></ol><p>核心反射机制最初是为了基于组件的应用创建工具而设计的。它们通常需要动态装载类，并且用反射功能找出它们支持哪些方法和构造器，如类浏览器、对象监视器、代码分析工具、解释性的嵌入式系统等。</p><p>在通常情况下，如果只是以非常有限的形式使用反射机制，虽然也要付出少许代价，但是可以获得许多好处。对于有些程序，它们必须用到编译时无法获取的类，但是在编译时却存在适当的接口或超类，通过它们可以引用这个类。如果是这样，可以先通过反射创建实例，然后再通过它们的接口或超类，以正常的方式访问这些实例。见如下代码片段：</p><pre><code class="java">public static void main(String[] args) {    Class&lt;?&gt; cl = null;    try {        c1 = Class.forName(args[0]);    } catch (ClassNotFoundException e) {        System.err.println(&quot;Class not found.&quot;);        System.exit(1);    }    Set&lt;String&gt; s = null;    try {        s = (Set&lt;String&gt;)c1.newInstance();    } catch (IllegalAccessException e) {        System.err.println(&quot;Class not accessible&quot;);        System.exit(1);    } catch (InstantiationException e) {        System.err.println(&quot;Class not instantiation.&quot;);        System.exit(1);    }    s.addAll(Arrays.asList(args).subList(1,args.length));    System.out.println(s);}</code></pre><p>上面的代码中体现出了反射的两个缺点：</p><ol><li>这个例子有 3 个运行时异常的错误，如果不使用反射方式实例化，这 3 个错误都会成为编译时错误。</li><li>根据类名生成它的实例需要 20 行冗长的代码，而调用构造器可以非常简洁的只使用一行代码。</li></ol><p>简而言之，反射机制是一种功能强大的机制，对于特定的复杂系统编程任务，它是非常必要的。如果你编写的程序必须要与编译时未知的类一起工作，如有可能，就应该仅仅使用反射机制来实例化对象，而访问对象时则使用编译时已知的某个接口或者超类。</p><h1 id="第54条：谨慎地使用本地方法"><a href="#第54条：谨慎地使用本地方法" class="headerlink" title="第54条：谨慎地使用本地方法"></a>第54条：谨慎地使用本地方法</h1><p>Java Native Interface（JNI）允许 Java 应用程序可以调用本地方法，所谓本地方法是指用本地程序设计的语言（如 C 或者 C++）来编写的特殊的方法。它可以在本地语言中执行任意的计算任务后返回到 Java 语言。</p><p>本地方法主要有三种用途。它们提供了“访问特定于平台的机制”的能力，比如访问注册表和文件锁。它们还提供了访问遗留代码库的能力，从而可以访问遗留数据。最后，本地方法可以通过本地语言，编写应用程序中注重性能的部分，以提高系统的性能。</p><p>使用本地方法来访问特定于平台的机制与访问遗留代码是合法的。但使用本地方法来提高性能的做法不值得提倡，因为 VM 在逐渐的更优更快了，如 1.1 中 BigInteger 是在一个用 C 编写的快速多精度运行库的基础上实现的，但在 1.3 中，则完全用 Java 重写了，并进行了精心的性能调优，比原来的版本甚至更快一些。</p><p>使用本地方法有一些严重的缺点。因为本地语言不是安全的、不可移植、难调试，而且在进行本地代码时，需要相关的固定开销，所以如果本地代码只是做少量的工作，本地方法就可能降低性能。</p><p>总之，本地方法极少数情况下会需要使用本地方法来提高性能。如果你必须要使用本地方法访问底层的资源，或者遗留代码，也要尽可能少的使用本地代码。</p><h1 id="第55条：谨慎地进行优化"><a href="#第55条：谨慎地进行优化" class="headerlink" title="第55条：谨慎地进行优化"></a>第55条：谨慎地进行优化</h1><p>有三条与优化有关的格言是每个人都应该知道的：</p><ol><li>很多计算上的过失都被归咎于效率（没有必要达到的效率），而不是任何其他原因——甚至包括盲目地做傻事。</li><li>不要去计较效率上的一些小小的得失，在97%的情况下，不成熟的优化才是一切问题的根源。</li><li>在优化方面，我们应该两条规则：规则1：不要进行优化。规则2（仅针对专家）：还是不要进行优化——也就是说，在你还没有绝对清晰的未优化方案之前，请不要进行优化。</li></ol><p>所有这些格言都比Java程序设计语言的出现早了20年，它们讲述了一个关于优化的深刻真理：优化的弊小于利，特别是不成熟的优化。在优化过程中，产生软件可能既不快速，也不正确，而且还不容易修正。</p><p>总之，不要费力去编写快速的程序——应该努力编写好的程序，速度自然会随之而来。在设计系统的时候，特别是在设计 API、线路层协议和永久数据库格式的时候（模块之间的交互与模块与外界的交互一旦定下来后是不可能更改的），一定要考虑性能的因素。当构建完系统之后，要测量它的性能。如果它足够快，你的任务就完了。如果不够快，则可以在性能剖析器的帮助下，找到问题的根源，然后设法优化系统中相关的部分。第一个步骤是检查所选择的算法：再多的低层优化也无法弥补算法的选择不当。</p><h1 id="第56条：遵守普遍接受的命名惯例"><a href="#第56条：遵守普遍接受的命名惯例" class="headerlink" title="第56条：遵守普遍接受的命名惯例"></a>第56条：遵守普遍接受的命名惯例</h1>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Effective Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Effective Java》笔记09：使用 try-with-resources 语句替代 try-finally 语句</title>
      <link href="/2019/06/17/%E3%80%8AEffective%20Java%E3%80%8B%E7%AC%94%E8%AE%B009%EF%BC%9A%E4%BD%BF%E7%94%A8%20try-with-resources%20%E8%AF%AD%E5%8F%A5%E6%9B%BF%E4%BB%A3%20try-finally%20%E8%AF%AD%E5%8F%A5/"/>
      <url>/2019/06/17/%E3%80%8AEffective%20Java%E3%80%8B%E7%AC%94%E8%AE%B009%EF%BC%9A%E4%BD%BF%E7%94%A8%20try-with-resources%20%E8%AF%AD%E5%8F%A5%E6%9B%BF%E4%BB%A3%20try-finally%20%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<p>Java 类库中包含许多必须通过调用 close 方法手动关闭的资源。 比如 InputStream，OutputStream 和 java.sql.Connection。 客户经常忽视关闭资源，其性能结果可想而知。 尽管这些资源中有很多使用 finalizer 机制作为安全网，但 finalizer 机制却不能很好地工作（详见第 8 条）。</p><a id="more"></a><p>从以往来看，try-finally 语句是保证资源正确关闭的最佳方式，即使是在程序抛出异常或返回的情况下：</p><pre><code class="java">static String firstLineOfFile(String path) throws IOException {    BufferedReader br = new BufferedReader(new FileReader(path));    try {        return br.readLine();    } finally {        br.close();    }}// 添加第二个资源时，情况会变得更糟static void copy(String src, String dst) throws IOException {    InputStream in = new FileInputStream(src);    try {        OutputStream out = new FileOutputStream(dst);        try {            byte[] buf = new byte[BUFFER_SIZE];            int n;            while ((n = in.read(buf)) &gt;= 0)                out.write(buf, 0, n);        } finally {            out.close();        }    } finally {        in.close();    }}</code></pre><p>当 <code>Java 7</code> 引入了 try-with-resources 语句时，所有这些问题一下子都得到了解决。要使用这个构造，资源必须实现 AutoCloseable 接口，该接口由一个返回为 void 的 close 组成。Java 类库和第三方类库中的许多类和接口现在都实现或继承了 AutoCloseable 接口。如果你编写的类表示必须关闭的资源，那么这个类也应该实现 AutoCloseable 接口。</p><p>　　以下是我们的第一个使用 try-with-resources 的示例：</p><pre><code class="java">// 关闭资源的最佳方式static String firstLineOfFile(String path) throws IOException {    try (BufferedReader br = new BufferedReader(           new FileReader(path))) {       return br.readLine();    }}static void copy(String src, String dst) throws IOException {    try (InputStream   in = new FileInputStream(src);         OutputStream out = new FileOutputStream(dst)) {        byte[] buf = new byte[BUFFER_SIZE];        int n;        while ((n = in.read(buf)) &gt;= 0)            out.write(buf, 0, n);    }}</code></pre><p>这里有一个版本的 firstLineOfFile 方法，它不会抛出异常，但是如果它不能打开或读取文件，则返回默认值：</p><pre><code class="java">static String firstLineOfFile(String path, String defaultVal) {    try (BufferedReader br = new BufferedReader(new FileReader(path))) {        return br.readLine();    } catch (IOException e) {        return defaultVal;    }}</code></pre><p>结论很明确：在处理必须关闭的资源时，使用 try-with-resources 语句替代 try-finally 语句。生成的代码更简洁，更清晰，并且生成的异常更有用。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Effective Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Effective Java》笔记38-44：方法</title>
      <link href="/2019/06/16/%E3%80%8AEffective%20Java%E3%80%8B%E7%AC%94%E8%AE%B038-44%EF%BC%9A%E6%96%B9%E6%B3%95/"/>
      <url>/2019/06/16/%E3%80%8AEffective%20Java%E3%80%8B%E7%AC%94%E8%AE%B038-44%EF%BC%9A%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="第38条：检查参数的有效性"><a href="#第38条：检查参数的有效性" class="headerlink" title="第38条：检查参数的有效性"></a>第38条：检查参数的有效性</h1><p>绝大多数方法和构造器对于传递给它们的参数值都会有些限制。比如，索引值必须大于等于 0，且不能超过其最大值，对象不能为 null 等。这样就可以在导致错误的源头将错误捕获，从而避免了该错误被延续到今后的某一时刻再被引发，这样就是加大了错误追查的难度。就如同编译期能够报出的错误总比在运行时才发现要更好一些。事实上，我们不仅仅需要在函数的内部开始出进行这些通用的参数有效性检查，还需要在函数的文档中给予明确的说明，如在参数非法的情况下，会抛出那些异常，或导致函数返回哪些错误值等，见如下代码示例：</p><pre><code class="java">/** * Returns a BigInteger whose value is(this mod m). This method * differs from the remainder method in that it always returns a * non-negative BigInteger. * @param m the modulus, which must be positive. * @return this mod m. * @throws ArithmeticException if m is less than or equal to 0.*/public BigInteger mod(BigInteger m) {    if (m.signum() &lt;= 0)        throw new ArithmeticException(&quot;Modulus &lt;= 0: &quot; + m);    ... //Do the computation.}</code></pre><a id="more"></a><p>对于未被导出的方法，如包方法等，你可以控制这个方法将在哪些情况下被调用，因此，<strong>非公有方法</strong>可以使用<strong>断言</strong>来帮助进行参数的有效性检查，如：</p><pre><code class="java">private static void sort(long a[],int offset,int length) {    assert(a != null);    assert(offset &gt;= 0 &amp;&amp; offset &lt;= a.length);    assert(length &gt;= 0 &amp;&amp; length &lt;= a.length - offset);    ... //Do the computation}</code></pre><p>和通用的检查方式不同，断言在其条件为真时，无论外部包得客户端如何使用它。断言都将抛出 AssertionError。</p><p>需要强调的是，对于有些函数的参数，其在当前函数内并不使用，而是留给该类其他函数内部使用的，比较明显的就是类的构造函数，构造函数中的很多参数都不一样用于构造器内，只是在构造的时候进行有些赋值操作，而这些参数的真正使用者是该类的其他函数，对于这种情况，我们就更需要在构造的时候进行参数的有效性检查，否则一旦将该问题释放到域函数的时候，再追查该问题的根源，将不得不付出更大的代价和更多的调试时间。</p><p>对该条目的说法确实存在着一种例外情况，在有些情况下有效性检查工作的开销是非常大的，或者根本不切实际，因为这些检查已经隐含在计算过程中完成了，如 <code>Collections.sort(List)</code>，容器中对象的所有比较操作均在该函数执行时完成，一旦比较操作失败将会抛出 ClassCastException 异常。因此对于 sort 来讲，如果我们提前做出有效性检查将是毫无意义的。</p><h1 id="第39条：必要时进行保护性拷贝"><a href="#第39条：必要时进行保护性拷贝" class="headerlink" title="第39条：必要时进行保护性拷贝"></a>第39条：必要时进行保护性拷贝</h1><p>如果你的对象没有做很好的隔离，那么对于调用者而言，则有机会破坏该对象的内部约束条件，因此我们需要保护性的设计程序。该破坏行为一般由两种情况引起，首先就是恶意的破坏，再有就是调用者无意识的误用，例如如下代码：</p><pre><code class="java">// 表示一段不可变的时间周期public final class Period {    private final Date start;    private final Date end;    public Period(Date start,Date end) {        if (start.compareTo(end) &gt; 0) {            throw new IllegalArgumentException(start + &quot;After &quot; + end);        this.start = start;        this.end = end;    }    public Date start() {        return start;    }    public Date end() {        return end;    }}</code></pre><p>从表面上看，该类的实现确实对约束性的条件进行了验证，然而由于 Date 类本身是可变了，因此很容易违反这个约束，见如下代码：</p><pre><code class="java">public void testPeriod() {    Date start = new Date();    Date end = new Date();    Period p = new Period(start,end);    end.setYear(78);  // 该修改将直接影响 Period 内部的 end 对象。}</code></pre><p>为了避免这样的攻击，我们需要对 Period 的<strong>构造函数</strong>进行相应的修改，即对每个可变参数进行保护性拷贝。</p><pre><code class="java">public Period(Date start,Date end) {    this.start = new Date(start.getTime());    this.end = new Date(end.getTime());    if (start.compareTo(end) &gt; 0)        throw new IllegalArgumentException(start + &quot;After &quot; + end);}</code></pre><p>需要说明的是，<strong>保护性拷贝是在检查参数有效性之前进行的</strong>，并且有效性检查是针对拷贝之后的对象，而不是针对始对象的。这主要是为了避免在 <code>this.start = new Date(start.getTime())</code> 到 <code>if (start.compareTo(end) &gt; 0)</code> 这个时间窗口内，参数 start 和 end 可能会被其他线程修改。</p><p>现在构造函数已经安全了，后面我们需要用同样的方式继续修改另外两个对象访问函数。</p><pre><code class="java">public Date start() {    return new Date(start.getTime());}public Date end() {    return new Date(end.getTime());}</code></pre><p>经过这一番修改之后，Period 成为了不可变类，其内部的“周期的起始时间不能落后于结束时间”约束条件也不会被破坏。</p><p>对于参数类型可以被不可信任方子类化的参数，请不要使用 clone 方法进行保护性拷贝。</p><p>参数的保护性拷贝并不仅仅针对不可变类。每当编写方法或者构造器时，如果它要允许客户提供的对象进入到内部据结构中，则有必要考虑一下，客户提供的对象进入到内部数据结构中，则有必要考虑一下，客户提供的对象是否可能是可变的。如果是，就要考虑你的类是否能够容忍对象进入数据结构之后发生变化。如果答案是否定的，就必对该对象进行保护性拷贝，并且让拷贝之后的对象而不是原始对象进入到数据结构中。例如，如果你正在考虑使用客户提供的对象引用作为内部 Set 实例的元素，或者作为内部 Map 实例的键(Key)，就应该意识到，如果这个对象在入之后再被修改，Set 或者 Map 的约束条件就会遭到破坏。</p><p><strong>记住长度非零的数组总是可变的</strong>。因此，在把内部数组返回给客户端之前，应该总要进行保护性拷贝。另一种解决方案是，给客户端返回该数组的不可变视图。两种方法见<a href="2018/08/25/《Effective%20Java》笔记13：使类和成员的可访问性最小化/#数组">使类和成员的可访问性最小化</a></p><p>尽可能的应该使用不可变对象作为对象内部的组件，这样就可以不操心保护性拷贝了。通常使用 Date.getTime() 返回的 long 基本类型作为内部的时间表示法，而不是使用 Date 对象引用，主要因为 Date 是可变的。</p><h1 id="第40条：谨慎设计方法签名"><a href="#第40条：谨慎设计方法签名" class="headerlink" title="第40条：谨慎设计方法签名"></a>第40条：谨慎设计方法签名</h1><h2 id="谨慎地选择方法的名称"><a href="#谨慎地选择方法的名称" class="headerlink" title="谨慎地选择方法的名称"></a>谨慎地选择方法的名称</h2><p>方法的名称应该始终遵循标准的命名习惯。</p><h2 id="不要过于追求提供便利的方法"><a href="#不要过于追求提供便利的方法" class="headerlink" title="不要过于追求提供便利的方法"></a>不要过于追求提供便利的方法</h2><p>每个方法都应该尽其所能。方法太多会使得工作复杂起来。只有当一项操作被经常使用时，才考虑为它提供快捷方式。如果不能确定，还是不提供快捷为好。</p><h2 id="避免过长的参数列表"><a href="#避免过长的参数列表" class="headerlink" title="避免过长的参数列表"></a>避免过长的参数列表</h2><p>尽量四个以下的参数。</p><p>相同类型的长参数序列格外有害。如果弄错了顺序，仍然可以编译运行。</p><p>缩短参数列表的方法：①可以把方法分解为多个方法，②创建辅助类，用来保存参数的分组，这样就是辅助类单个参数，③从对象构建到方法调用都采用 Builder 模式</p><h2 id="对于参数类型优先使用接口而不是类"><a href="#对于参数类型优先使用接口而不是类" class="headerlink" title="对于参数类型优先使用接口而不是类"></a>对于参数类型优先使用接口而不是类</h2><p>例如，没有理由在编写方法时使用 HashMap 类来作为参数，应该使用 Map 接口作为参数。</p><h2 id="对于-boolean-参数，要优先使用两个元素的枚举类型"><a href="#对于-boolean-参数，要优先使用两个元素的枚举类型" class="headerlink" title="对于 boolean 参数，要优先使用两个元素的枚举类型"></a>对于 boolean 参数，要优先使用两个元素的枚举类型</h2><p>更易于阅读和编写，使以后更易于添加更多的选项。</p><pre><code class="java">public enum TemperatureScale { FAHRENHEIT, CELSIUS }</code></pre><p><code>Thermometer.newInstance(TemperatureScale.CELSIUS)</code> 不仅比 <code>Thermometer.newInstance(true)</code> 更有用，可以在以后将 <code>KELVIN</code> 添加到 <code>TemperatureScale</code> 中。</p><h1 id="第41条：慎用重载"><a href="#第41条：慎用重载" class="headerlink" title="第41条：慎用重载"></a>第41条：慎用重载</h1><pre><code class="java">public class CollectionClassfier {    public static String classify(Set&lt;?&gt; s) {        return &quot;Set&quot;;    }    public static String classify(List&lt;?&gt; l) {        return &quot;List&quot;;    }    public static String classify(Collection&lt;?&gt; c) {        return &quot;Unknown collection&quot;;    }    public static void main(String[] args) {        Collection&lt;?&gt;[] collections = {            new HashSet&lt;String&gt;(),            new ArrayList&lt;BigInteger&gt;(),            new HashMap&lt;String,String&gt;().values()        };        for (Collection&lt;?&gt; c : collections)            System.out.println(classify(c));    }}</code></pre><p>这里你可能会期望程序打印出，&quot;Set&quot;，&quot;List&quot;，&quot;Unknown Collection&quot;</p><p>然而实际上却不是这样，输出的结果是 3 个 &quot;Unknown Collection&quot;。为什么会是这样呢？因为函数重载后，需要调用哪个函数是在编译期决定的，这不同于多态的运行时动态绑定。针对此种情形，该条目给出了一个修正的方法，如下：</p><pre><code class="java">public static String classify(Collection&lt;?&gt; c) {    return c instanceof Set ? &quot;Set&quot; : c instanceof List        ? &quot;List&quot; : &quot;Unknown Collection&quot;;}</code></pre><p>和 override 不同，重载机制不会像 override 那样规范，并且每次都能得到期望的结果。因此在使用时需要非常谨慎，否则一旦出了问题，就会需要更多的时间去调试。该条目给出以下几种尽量不要使用重载的情形：</p><ol><li>函数的参数中包含可变参数；</li><li>当函数参数数目相同时，你无法准确的确定哪一个方法该被调用时；</li><li>在 Java 1.5 之后，需要对自动装箱机制保持警惕。</li></ol><p>我们先简单说一下第二种情形。比如两个重载函数均有一个参数，其中一个是 <code>int</code>，另一个是 <code>Collection&lt;?&gt;</code>，对于这种情况，<code>int</code> 和 <code>Collection&lt;?&gt;</code> 之间没有任何关联，也无法在两者之间做任何的类型转换，否则将会抛出 <code>ClassCastException</code> 的异常，因此对于这种函数重载，我们是可以准确确定的。反之，如果两个参数分别是 <code>int</code> 和 <code>short</code>，他们之间的差异就不是这么明显。</p><p>例如，ObjectOutputStream 类，对于每个基本类型引用类型，它的 write 方法都有一种变形，不是重载 write 方法，writeBoolean(boolean)，writeInt(int) 等方法。同样读方法也提供了类似的方法，readBoolean()，readInt()</p><p>对于第三种情形，该条目给出了一个非常典型的用例代码，如下：</p><pre><code class="java">public class SetList {    public static void main(String[] args) {        Set&lt;Integer&gt; s = new TreeSet&lt;Integer&gt;();        List&lt;Integer&gt; l = new ArrayList&lt;Integer&gt;();        for (int i = -3; i &lt; 3; ++i) {            s.add(i);            l.add(i);        }        for (int i = 0; i &lt; 3; ++i) {            s.remove(i);            l.remove(i);        }        System.out.println(s + &quot; &quot; + l);    }}</code></pre><p>在执行该段代码前，我们期望的结果是Set和List集合中大于等于 0 的元素均被移除出容器，然而在执行后却发现事实并非如此，其结果为：<code>[-3, -2, -1]</code> <code>[-2, 0, 2]</code></p><p>这个结果和我们的期望还是有很大差异的，为什么 Set 中的元素是正确的，而 List 则不是，是什么导致了这一结果的发生呢？下面给出具体的解释：</p><ol><li><code>s.remove(i)</code> 调用的是 Set 中的 <code>remove(E)</code>，这里的 E 表示 Integer，Java 的编译器会将i自动装箱到 Integer 中，因此我们得到了想要的结果。</li><li><code>l.remove(i)</code> 实际调用的是 List 中的 <code>remove(int index)</code> 重载方法，而该方法的行为是删除集合中指定索引的元素。这里分别对应第 0 个，第 1 个和第 2 个。</li></ol><p>为了解决这个问题，我们需要让 List 明确的知道，我们需要调用的是 <code>remove(E)</code> 重载函数，而不是其他的，这样我们就需要对原有代码进行如下的修改：</p><pre><code class="java">l.remove((Integer)i);</code></pre><p>Java1.4 时，String 类就有了一个 contentEquals(StringBuffer) 方法，在 Java1.5 中新增了一个 CharSequence 接口，用来为 StringBuffer、StringBuilder、String、CharBuffer等提供公共接口，为了实现这个接口，对原类进行了改造。String 新增了 contentEquals(CharSequence) 的重载方法，这样违反了本条目的原则，但它们执行的是相同的功能返回相同的结果，就没有影响。确保这种行为的方法是：</p><pre><code class="java">public boolean contentEquals(StringBuffer sb) {    return contentEquals((CharSequence)sb);}</code></pre><p>总之，通常，最好避免重载具有相同数量参数的多个签名的方法。在某些情况下，特别是涉及构造方法的情况下，可能无法遵循此建议。在这些情况下，至少应该避免通过添加类型转换将相同的参数集传递给不同的重载。如果这是无法避免的，例如，因为要对现有类进行改造以实现新接口，那么应该确保在传递相同的参数时，所有重载的行为都是相同的。</p><h1 id="第42条：慎用可变参数"><a href="#第42条：慎用可变参数" class="headerlink" title="第42条：慎用可变参数"></a>第42条：慎用可变参数</h1><p> 可变参数方法接受 0 个或者多个指定类型的参数。可变参数机制通过先创建一个数组，数组的大小为在调用位置所传递的参数数量，然后将参数值传到数组中，最后将数组传递给方法，如：</p><pre><code class="java">static int sum(int...args) {    int sum = 0;    for (int arg : args)        sum += arg;    retrun sum;}</code></pre><p>上面的方法可以正常的工作，但是在有的时候，我们可能需要至少一个或者多个某种类型参数的方法，如：</p><pre><code class="java">static int min(int...args) {    if (args.length == 0)        throw new IllegalArgumentException(&quot;Too few arguments.&quot;);    int min = args[0];    for (int i = 0; i &lt; args.length; ++i) {        if (args[i] &lt; min)            min = args[i];    }    return min;}</code></pre><p>对于上面的代码主要存在两个问题，一是如果调用者没有传递参数是，该函数将会在运行时抛出异常，而不是在编译期报错。另一个问题是这样的写法也是非常不美观的，函数内部必须做参数的数量验证，不仅如此，这也影响了效率。将编译期可以完成的事情推到了运行期。下面提供了一种较好的修改方式，如下：</p><pre><code class="java">static int min(int firstArg, int...remainingArgs) {    int min = firstArgs;    for (int arg : remainingArgs) {        if (arg &lt; min)            min = arg;    }    return min;}</code></pre><p>由此可见，当你真正需要让一个方法带有不定数量的参数时，可变参数就非常有效。</p><p>下面看看 1.4 与 1.5 中的 <code>Arrays.asList</code>，1.4 中的是这样 <code>public static List asList(Object[] a)</code>，到了 1.5 中改成了可变参数成这样 <code>public static &lt;T&gt; List&lt;T&gt; asList(T... a)</code> ，现在我们使用这个方法时要格外小心，看看下面几个问题：</p><pre><code class="java">public static void main(String[] args) {    String strs[] = new String[] { &quot;str1&quot;, &quot;str2&quot; };    int ints[] = new int[] { 1, 2 };    /*    * 1.4输出：[str1, str2]    * 1.5输出：[str1, str2]    */    System.out.println(Arrays.asList(strs));    /*    * 1.4编译不能通过!!    * 1.5输出：[[I@757aef]    */    System.out.println(Arrays.asList(ints));}</code></pre><p>由于 1.5 版本中，令人遗憾地决定将 <code>Arrays.asList</code> 改造成可变参数方法，现在上面这个程序在 1.5 中可以通过编译，但是运行时，输出的不是我们想要的结果而是 <code>[[I@757aef]</code>，这主要是由于基本类型不能用于泛型的原因所致，所以在将一个基本类型数组传给 <code>asList(T... a)</code> 方法时，将整个基本类型数组看作是可能参数集中的第一个参数了。</p><p>但从好的方面来看，本来 asList 方法就不是用来打印数组中的元素字面值的，它的作用是将数组转换成 List 而已，这在 1.5 中得到了修补，并增加了 <code>Arrays.toString</code> 的方法，它正是专门为了将任何类型的数组转变成字符串而设计的。如果用 Arrays.toString 来代替 Arrays.asList，我们将会得到想要的结果：</p><pre><code class="java">System.out.println(Arrays.toString(ints));//[1, 2]</code></pre><p>有的时候在重视性能的情况下，使用可变参数机制要特别小心。可变参数方法的每次调用都会导致进行一次数组分配和初始化。如果确定确实无法承受这一成本，但又需要可变参数的灵活性，还有一种模式可以弥补这一不足。假设确定对某个方法 95% 的调用会有 3 个或者更少的参数，就声明该方法的 5 个重载，每个重载方法带有 0 个至 3 个普通参数，当参数的数目超过 3 个时，就使用一个可变参数方法：</p><pre><code class="java">public void foo() {}public void foo(int a1) {}public void foo(int a1,int a2) {}public void foo(int a1,int a2,int a3) {}public void foo(int a1,int a2,int a3,int...rest) {}</code></pre><p>所有调用中只有 5% 参数数量超过 3 个的调用需要创建数组。就像大多数的性能优化一样，这种方法通常不恰当，但是一旦真正需要它时，还是非常有用处的。EnumSet 类的静态工厂方法就是使用了这种方法。</p><h1 id="第43条：返回零长度的数组或者集合，而不是-null"><a href="#第43条：返回零长度的数组或者集合，而不是-null" class="headerlink" title="第43条：返回零长度的数组或者集合，而不是 null"></a>第43条：返回零长度的数组或者集合，而不是 null</h1><p>对于一个返回null而不是零长度数组或者集合方法，几乎每次用到该方法时都需要额外处理是否为null，这样做很容易出错，因为缩写客户端程序的程序员可能会忘记写这种专门的代码来处理null返回值，如：</p><pre><code class="java">private final List&lt;Cheese&gt; cheesesInStock = …;public Cheese[] getCheeses(){    if(cheesesInStock.size() == 0)        return null;    //  …}</code></pre><p>客户端使用如下：</p><pre><code class="java">Cheese[] cheeses = shop.getCheeses();if(cheeses != null &amp;&amp; …);</code></pre><p>有时候有人会认为：null 返回值比零长度数组更好，因为它避免了分配数组所需要的开销，这种观点是站不住脚的，原因有二：一是，除非这个方法正是造成性能问题的真正源头。二是，完全可以使用一个零长度的数组共享。</p><p>使用标准做法把一些元素从一个集合转存到一个类型化的数组中时，就是使用了一个零长度的数组共享</p><pre><code class="java">private final List&lt;Cheese&gt; cheesesInStock = …;//将零长度的数组设为静态的，以便共享用private static final Cheese[] EMPTY_CHEESE_ARRAY = new Cheese[0];public Cheese[] getCheeses(){       //借助于List的toArray方法，将列表转换成数组，如果传进的数组长度为零，则会返这个零长度数组本身，并且这个零长度数组是共享的       return cheesesInStock.toArray(EMPTY_CHEESE_ARRAY);}</code></pre><p>下面看一下返回空集合的做法：</p><p>Collection 能转换成安全的数组，Collections 能在需要返回空集合时都返回同一个不可变的空集合，如 emptySet、emptyList、emptyMap：</p><pre><code class="java">public List&lt;Cheese&gt; getCheeseList(){    if(cheesesInStock.isEmpty())        return Collections.emptyList();  // 总是返回相同的空的 list    else        return new ArrayList&lt;Cheese&gt;(cheesesInStock);}</code></pre><h1 id="第44条：为所有导出的-API-元素编写文档注释"><a href="#第44条：为所有导出的-API-元素编写文档注释" class="headerlink" title="第44条：为所有导出的 API 元素编写文档注释"></a>第44条：为所有导出的 API 元素编写文档注释</h1><p>为了正确地编写API文档，<strong>必须</strong>在每个导出类、接口、构造器、方法和域声明之前增加一个文档注释。如果类是可序列化的，也应该对它的序列化形式编写文档。为了编写出可维护的代码，还应该为那些没有被导出的类、接口、构造器、方法和域编写文档注释。</p><p>方法的文档注释应该简洁地描述出它和客户端之间的约定。除了专门为继承而设计的类中的方法之外，这个约定应该说明这个方法做了什么，而不是说明它是如何完成这功项工作的。文档注释应该列举这个方法的前置条件与后置条件，前提条件指调用该方法要得到预期的结果必须满足的条件，如参数的约束。而后置就是指调用方法完后要完成预期的功能。</p><p>跟在 @param 标签或者 @return 标签后面的文字应该是一个名词短语，描述了这个参数或者返回值所表示的值，跟在 @throws 标签之后的文字应该包含单词 if ，紧接着是一个名词短语，它描述了这个异常将在什么样的条件下会被抛出。有时候，也会用表达式来代替名词短语。并且按照惯例，这个标签后面的短语或者子名都不用句点来结束。</p><p>类是否线程安全的，也应该在文档中对它的线程安全级别进行说明。</p><p>在文档注释内部出现任何 HTML 标签都是允许的，但是 HTML 元字符必须要经过转义。</p><p>代码片段使用 <code>{@code}</code> 标签，{@literal} 标签内的字符可以省去 HTML 转义。</p><p>当为泛型或者方法编写文档时，确保要在文档中说明所有的类型参数。当为枚举类型编写文档时，要确保在文档中说明常量，以及类型，还有所有的公有方法。为注解类型编写文档时，要确保在文档中说明所有成员，以及类型本身。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Effective Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Effective Java》笔记35-37：注解</title>
      <link href="/2019/06/16/%E3%80%8AEffective%20Java%E3%80%8B%E7%AC%94%E8%AE%B035-37%EF%BC%9A%E6%B3%A8%E8%A7%A3/"/>
      <url>/2019/06/16/%E3%80%8AEffective%20Java%E3%80%8B%E7%AC%94%E8%AE%B035-37%EF%BC%9A%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="第35条：注解优先于命名模式"><a href="#第35条：注解优先于命名模式" class="headerlink" title="第35条：注解优先于命名模式"></a>第35条：注解优先于命名模式</h1><p>没有注解之前，一般使用命名模式表明程序需要进行某些特殊处理，如：JUnit 测试框架原本要求要用 test 作为测试方法名称的开头。这种方法虽然可行，但有很多的弊端。</p><h2 id="简单的测试"><a href="#简单的测试" class="headerlink" title="简单的测试"></a>简单的测试</h2><p>注解很好地解决了所有的问题。定义一个注解类型来指定简单的测试，它们自动运行，并在抛出异常时失败。</p><pre><code class="java">import java.lang.annotation.*;// 只用于无参的静态方法，编译器无法限制，可以让测试工具解决@Retention(RetentionPolicy.RUNTIME)  // 注解应该在运行时保留@Target(ElementType.METHOD)  // Test 注解只在方法上声明才是合法的public @interface Test {}</code></pre><a id="more"></a><pre><code class="java">// 测试类public class Sample {    @Test    public static void m1() { }    public static void m2() { }    @Test    public static void m3() { throw new RuntimeException(&quot;Boom&quot;); }    public static void m4() { }    @Test    public void m5() { }    public static void m6() { }    @Test    public static void m7() { throw new RuntimeException(&quot;Crash&quot;); }    public static void m8() { }}</code></pre><pre><code class="java">// 测试工具public class RunTests {    public static void main(String[] args) throws ClassNotFoundException {        int tests = 0;        int passed = 0;        Class testClass = Class.forName(&quot;Sample&quot;);        for (Method m : testClass.getDeclaredMethods()) {            if (m.isAnnotationPresent(Test.class)) {  // 指定类型的注释存在于此元素上                tests++;                try {                    m.invoke(null);                    passed++;                } catch (InvocationTargetException e) {                    // 如果测试方法出现异常，会在这里                    System.out.println(m + &quot; failed: &quot; + e.getCause());                } catch (Exception e) {                    System.out.println(&quot;INVALID @Test: &quot; + m);                }            }        }        System.out.printf(&quot;Passed: %d, Failed: %d%n&quot;, passed, tests - passed);    }}// public static void Sample.m3() failed: java.lang.RuntimeException: Boom// INVALID @Test: public void Sample.m5()// public static void Sample.m7() failed: java.lang.RuntimeException: Crash// Passed: 1, Failed: 3</code></pre><h2 id="抛出指定异常才成功的测试"><a href="#抛出指定异常才成功的测试" class="headerlink" title="抛出指定异常才成功的测试"></a>抛出指定异常才成功的测试</h2><pre><code class="java">@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface ExceptionTest {    Class&lt;? extends Exception&gt; value();  // 某个扩展 Exception 的类的 Class 对象}</code></pre><pre><code class="java">public class Sample2 {    @ExceptionTest(ArithmeticException.class)    public static void m1() {        int i = 1 / 0;    }    @ExceptionTest(ArithmeticException.class)    public static void m2() {        int[] a = new int[0];        int i = a[1];  // 不是指定的异常    }    @ExceptionTest(ArithmeticException.class)    public static void m3() { }  // 没有异常}</code></pre><pre><code class="java">public class RunTests2 {    public static void main(String[] args) throws ClassNotFoundException {        int tests = 0;        int passed = 0;        Class testClass = Class.forName(&quot;Sample2&quot;);        for (Method m : testClass.getDeclaredMethods()) {            if (m.isAnnotationPresent(ExceptionTest.class)) {                tests++;                try {                    m.invoke(null);                    System.out.printf(&quot;%s，测试失败，没有异常%n&quot;, m);                } catch (InvocationTargetException e) {                    Throwable exc = e.getCause();                    Class&lt;? extends Exception&gt; excType = m.getAnnotation(ExceptionTest.class).value();                    if (excType.isInstance(exc)) {                        passed++;                    } else {                        System.out.printf(&quot;Test %s failed: expected %s, got %s%n&quot;, m, excType.getName(), exc);                    }                } catch (Exception e) {                    System.out.println(&quot;INVALID @Test: &quot; + m);                }            }        }        System.out.printf(&quot;Passed: %d, Failed: %d%n&quot;, passed, tests - passed);    }}// public static void Sample2.m3()，测试失败，没有异常// Test public static void Sample2.m2() failed: expected java.lang.ArithmeticException, got java.lang.ArrayIndexOutOfBoundsException: 1// Passed: 1, Failed: 2</code></pre><h2 id="抛出任一异常"><a href="#抛出任一异常" class="headerlink" title="抛出任一异常"></a>抛出任一异常</h2><p>测试可以在抛出任何一种异常时都得到通过。</p><pre><code class="java">@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface ExceptionTest {    Class&lt;? extends Exception&gt;[] value();  // 修改为数组形式}</code></pre><pre><code class="java">@ExceptionTest({IndexOutOfBoundsException.class, NullPointerException.class})  // 多个public static void doublyBad() {    List&lt;String&gt; list = new ArrayList&lt;&gt;();    list.addAll(5, null);}</code></pre><pre><code class="java">if (m.isAnnotationPresent(ExceptionTest.class)) {    tests++;    try {        m.invoke(null);        System.out.printf(&quot;%s，测试失败，没有异常%n&quot;, m);    } catch (InvocationTargetException e) {        Throwable exc = e.getCause();        Class&lt;? extends Exception&gt;[] excTypes = m.getAnnotation(ExceptionTest.class).value();        int oldPassed = passed;        for (Class&lt;? extends Exception&gt; excType : excTypes) {            if (excType.isInstance(exc)) {                passed++;                break;            }        }        if (passed == oldPassed) {            System.out.printf(&quot;Test %s failed: %s%n&quot;, m, exc);        }    } catch (Exception e) {        System.out.println(&quot;INVALID @Test: &quot; + m);    }}</code></pre><h1 id="第36条：坚持使用-Override-注解"><a href="#第36条：坚持使用-Override-注解" class="headerlink" title="第36条：坚持使用 Override 注解"></a>第36条：坚持使用 Override 注解</h1><p>可以防止错误</p><h1 id="第37条：用标记接口定义类型"><a href="#第37条：用标记接口定义类型" class="headerlink" title="第37条：用标记接口定义类型"></a>第37条：用标记接口定义类型</h1><p>标记接口是指没有包含方法声明的接口，而只是指明一个类实现了具有某种属性的接口。例如：Serializable。</p><h2 id="标记接口优点一"><a href="#标记接口优点一" class="headerlink" title="标记接口优点一"></a>标记接口优点一</h2><p>标记接口定义的类型是由被标记类的实例实现的；标记注解则没有定义这样的类型。这样可以在编译时期捕捉更多的错误。</p><p>使用 Serializable 标记接口来指示某个类型是可序列化的。对传递给它的对象进行序列化的 ObjectOutputStream.writeObject 方法要求其参数可序列化。如果此方法的参数是 Serializable 类型，则在编译时会检测到序列化不适当对象的尝试（通过类型检查）。编译时错误检测是标记接口的意图，但不幸的是，ObjectOutputStream.writeObject API 没有利用 Serializable 接口：它的参数被声明为 Object 类型，所以尝试序列化一个不可序列化的对象<strong>直到运行时</strong>才会失败。</p><h2 id="标记接口优点二"><a href="#标记接口优点二" class="headerlink" title="标记接口优点二"></a>标记接口优点二</h2><p>可以更精确地定位目标。</p><p>如果注解类型使用 @Target(ElementType.TYPE) 声明，它就可以被应用到任何类或者接口。假设有一个标记只适用于特殊接口的实现。如果将它定义成一个标记接口，就可以用它将唯一的接口扩展成它适用的接口</p><p>Set 接口可以说就是这种有限制的标记接口。它只适用于 Collection 子类型，但是它不会添加除了 Collection 定义之外的方法。一般情况下，不把它当作时标记接口，因为它改进了几个 Collection 方法的契约，包括 add，equals 和 hashCode。但是很容易想到只适用于某种特殊接口的子类型的标记接口，它没有改进接口的任何方法的契约。这种标记接口可以描述整个对象的某个约束条件，或者表明实例能够利用其它某个类的方法进行处理（就像 Serializable 接口表明实例可以通过 ObjectOutputStream 进行处理一样。</p><h2 id="标记注解优点"><a href="#标记注解优点" class="headerlink" title="标记注解优点"></a>标记注解优点</h2><p>可以通过默认的方式添加一个或多个注解类型元素，给已被使用的注解类型添加更多的信息。</p><p>另一个优点在于，它们是更大的注解机制的一部分。因此，标记注解允许在基于注解的框架中保持一致性。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果标记是应用到任何程序元素而不是类或者接口，就必须使用注解，因为只有类和接口可以用来实现或者扩展接口。</p><p>如果标记只应用给类或者接口，那么问自己问题：「我想编写一个或多个只接受具有此标记的对象的方法呢？」如果是这样，则应该优先使用标记接口而不是注解。这将使你可以将接口用作相关方法的参数类型，这将带来编译时类型检查的好处。</p><p>如果永远不会想写一个只接受带有标记的对象的方法，那么最好使用标记注解。另外，如果标记是大量使用注解的框架的一部分，则标记注解是明确的选择。</p><p>　　总之，标记接口和标记注释都有其用处。如果你想定义一个没有任何关联的新方法的类型，一个标记接口是一种可行的方法。如果要标记除类和接口以外的程序元素，或者将标记符合到已经大量使用注解类型的框架中，那么标记注解是正确的选择。如果发现自己正在编写目标为 ElementType.TYPE 的标记注解类型，那么请花时间弄清楚究竟应该用注解类型，还是标记接口更合适。</p><p>　　从某种意义来说，本条目与条目 22 的的意思正好相反，条目 22 的意思是：「如果你不想定义一个类型，不要使用接口」。本条目的意思是：「如果想定义一个类型，一定要使用接口。」</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Effective Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Effective Java》笔记05：依赖注入优于硬连接资源（hardwiring resources）</title>
      <link href="/2019/06/14/%E3%80%8AEffective%20Java%E3%80%8B%E7%AC%94%E8%AE%B005%EF%BC%9A%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E4%BC%98%E4%BA%8E%E7%A1%AC%E8%BF%9E%E6%8E%A5%E8%B5%84%E6%BA%90(hardwiring%20resources)/"/>
      <url>/2019/06/14/%E3%80%8AEffective%20Java%E3%80%8B%E7%AC%94%E8%AE%B005%EF%BC%9A%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E4%BC%98%E4%BA%8E%E7%A1%AC%E8%BF%9E%E6%8E%A5%E8%B5%84%E6%BA%90(hardwiring%20resources)/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://sjsdfg.github.io/effective-java-3rd-chinese/#/notes/05.%20依赖注入优于硬连接资源(hardwiring%20resources)" target="_blank" rel="noopener">https://sjsdfg.github.io/effective-java-3rd-chinese/#/notes/05.%20依赖注入优于硬连接资源(hardwiring%20resources)</a></p></blockquote><p>　　许多类依赖于一个或多个底层资源。例如，拼写检查器依赖于字典。将此类类实现为静态实用工具类并不少见 （详见第 4 条）:</p><pre><code class="java">// Inappropriate use of static utility - inflexible &amp; untestable!public class SpellChecker {    private static final Lexicon dictionary = ...;    private SpellChecker() {} // Noninstantiable    public static boolean isValid(String word) { ... }    public static List&lt;String&gt; suggestions(String typo) { ... }}</code></pre><a id="more"></a><p>　　同样地，将它们实现为单例也并不少见（详见第 3 条）：</p><pre><code class="java">// Inappropriate use of singleton - inflexible &amp; untestable!public class SpellChecker {    private final Lexicon dictionary = ...;    private SpellChecker(...) {}    public static INSTANCE = new SpellChecker(...);    public boolean isValid(String word) { ... }    public List&lt;String&gt; suggestions(String typo) { ... }}</code></pre><p>　　这两种方法都不令人满意，因为他们假设只有一本字典值得使用。在实际中，每种语言都有自己的字典，特殊的字典被用于特殊的词汇表。另外，使用专门的字典来进行测试也是可取的。想当然地认为一本字典就足够了，这是一厢情愿的想法。</p><p>　　可以通过使 <code>dictionary</code> 属性设置为非 <code>final</code>，并添加一个方法来更改现有拼写检查器中的字典，从而让拼写检查器支持多个字典，但是在并发环境中，这是笨拙的、容易出错的和不可行的。静态实用类和单例对于那些行为被底层资源参数化的类来说是不合适的。</p><p>　　所需要的是能够支持类的多个实例 （在我们的示例中，即 <code>SpellChecker</code>），每个实例都使用客户端所期望的资源（在我们的例子中是 <code>dictionary</code>）。满足这一需求的简单模式是在创建新实例时将资源传递到构造方法中。这是依赖项注入（dependency injection）的一种形式：字典是拼写检查器的一个依赖项，当它创建时被注入到拼写检查器中。</p><pre><code class="java">// Dependency injection provides flexibility and testabilitypublic class SpellChecker {    private final Lexicon dictionary;    public SpellChecker(Lexicon dictionary) {        this.dictionary = Objects.requireNonNull(dictionary);    }    public boolean isValid(String word) { ... }    public List&lt;String&gt; suggestions(String typo) { ... }}</code></pre><p>　　依赖注入模式非常简单，许多程序员使用它多年而不知道它有一个名字。 虽然我们的拼写检查器的例子只有一个资源（字典），但是依赖项注入可以使用任意数量的资源和任意依赖图。 它保持了不变性（详见第 17 条），因此多个客户端可以共享依赖对象（假设客户需要相同的底层资源）。 依赖注入同样适用于构造方法，静态工厂（详见第 1 条）和 builder 模式（详见第 2 条）。</p><p>　　该模式的一个有用的变体是将资源工厂传递给构造方法。 工厂是可以重复调用以创建类型实例的对象。 这种工厂体现了工厂方法模式（Factory Method pattern）[Gamma95]。 Java 8 中引入的 <code>Supplier&lt;T&gt;</code> 接口非常适合代表工厂。 在输入上采用 <code>Supplier&lt;T&gt;</code> 的方法通常应该使用有界的通配符类型（bounded wildcard type）（详见第 31 条）约束工厂的类型参数，以允许客户端传入工厂，创建指定类型的任何子类型。 例如，下面是一个使用客户端提供的工厂生成 tile 的方法：</p><pre><code class="java">Mosaic create(Supplier&lt;? extends Tile&gt; tileFactory) { ... }</code></pre><p>　　尽管依赖注入极大地提高了灵活性和可测试性，但它可能使大型项目变得混乱，这些项目通常包含数千个依赖项。使用依赖注入框架（如 Dagger [Dagger]、Guice [Guice] 或 Spring [Spring]）可以消除这些混乱。这些框架的使用超出了本书的范围，但是请注意，为手动依赖注入而设计的 API 非常适合这些框架的使用。</p><p>　　总之，不要使用单例或静态的实用类来实现一个类，该类依赖于一个或多个底层资源，这些资源的行为会影响类的行为，并且不让类直接创建这些资源。相反，将资源或工厂传递给构造方法（或静态工厂或 builder 模式）。这种称为依赖注入的实践将极大地增强类的灵活性、可重用性和可测试性。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Effective Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat 问题记录</title>
      <link href="/2019/06/12/Tomcat%20%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
      <url>/2019/06/12/Tomcat%20%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="JAVA-HOME-nor-the-JRE-HOME-environment-variable-is-defined"><a href="#JAVA-HOME-nor-the-JRE-HOME-environment-variable-is-defined" class="headerlink" title="JAVA_HOME nor the JRE_HOME environment variable is defined"></a>JAVA_HOME nor the JRE_HOME environment variable is defined</h1><p>通过 startup.bat 文件启动，报错</p><pre><code class="log">Neither the JAVA_HOME nor the JRE_HOME environment variable is definedAt least one of these environment variable is needed to run this program请按任意键继续. . .</code></pre><a id="more"></a><p>检查环境变量, 明明配置了 JAVA_HOME 的，那就看起来不是环境变量的问题了</p><p>打开 bin 目录下的 Catalina.bat 文件, 在下面添加:</p><pre><code class="bat">rem 添加下面两条set JAVA_HOME=C:/Program Files/Java/jdk1.8.0_91set JRE_HOME=C:/Program Files/Java/jdk1.8.0_91/jrerem Copy CATALINA_BASE from CATALINA_HOME if not definedif not &quot;%CATALINA_BASE%&quot; == &quot;&quot; goto gotBaseset &quot;CATALINA_BASE=%CATALINA_HOME%&quot;:gotBase</code></pre><p>然后重启即可，如果是 linux 系统将 set 使用 export 替换即可</p><blockquote><p><a href="https://www.cnblogs.com/wxylog/p/8653215.html" target="_blank" rel="noopener">https://www.cnblogs.com/wxylog/p/8653215.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat 会话持久化配置</title>
      <link href="/2019/06/12/Tomcat%20%E4%BC%9A%E8%AF%9D%E6%8C%81%E4%B9%85%E5%8C%96%E9%85%8D%E7%BD%AE/"/>
      <url>/2019/06/12/Tomcat%20%E4%BC%9A%E8%AF%9D%E6%8C%81%E4%B9%85%E5%8C%96%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>在 Java Web 应用中，会有一些应用重启的操作，怎么在重启后中，如何保证 Session 也能被恢复呢，这就可以通过 Tomcat 的会话持久化配置实现。</p><p>Tomcat <strong>默认支持会话持久化</strong>，在服务重启时将当前在线会话信息持久化本地磁盘。其配置文件为 context.xml</p><pre><code class="xml">&lt;!-- apache-tomcat-9.0.21 --&gt;&lt;Context&gt;    &lt;!-- Default set of monitored resources. If one of these changes, the web application will be reloaded. --&gt;    &lt;WatchedResource&gt;WEB-INF/web.xml&lt;/WatchedResource&gt;    &lt;WatchedResource&gt;WEB-INF/tomcat-web.xml&lt;/WatchedResource&gt;    &lt;WatchedResource&gt;${catalina.base}/conf/web.xml&lt;/WatchedResource&gt;    &lt;!-- Uncomment this to disable session persistence across Tomcat restarts --&gt;    &lt;!--  如果不需要 Tomcat 的默认会话持久化功能，解开该注释    &lt;Manager pathname=&quot;&quot; /&gt;    --&gt;    &lt;!-- Tomcat 8，7 存在以下内容 --&gt;    &lt;!-- Uncomment this to enable Comet connection tacking (provides events         on session expiration as well as webapp lifecycle) --&gt;    &lt;Valve className=&quot;org.apache.catalina.valves.CometConnectionManagerValve&quot; /&gt;    --&gt;&lt;/Context&gt;</code></pre><a id="more"></a><p>我们也可以定义配置 Manager 信息，指定持久化文件的目录：</p><pre><code class="xml">&lt;Manager className=&quot;org.apache.catalina.session.PersistentManager&quot;    debug=0    saveOnRestart=&quot;true&quot;    maxActiveSession=&quot;-1&quot;    minIdleSwap=&quot;-1&quot;    maxIdleSwap=&quot;-1&quot;    maxIdleBackup=&quot;-1&quot;&gt;    &lt;Store className=&quot;org.apache.catalina.session.FileStore&quot; directory=&quot;指定目录&quot; /&gt;    &lt;!-- 存储到数据库，使用 org.apache.catalina.session.JDBCStore --&gt;&lt;/Manager&gt;</code></pre><p>为了成功恢复会话属性的状态，所有<strong>这些属性必须实现 java.io.Serializable 接口</strong>。可以通过在（/WEB-INF/web.xml）中包含 <code>&lt;distributable/&gt;</code> 元素，使 Manager 强制实施此限制。</p><p>详细文档：<a href="http://tomcat.apache.org/tomcat-9.0-doc/config/manager.html" target="_blank" rel="noopener">http://tomcat.apache.org/tomcat-9.0-doc/config/manager.html</a></p><blockquote><p><a href="https://blog.csdn.net/wojiushiwo945you/article/details/78712136" target="_blank" rel="noopener">https://blog.csdn.net/wojiushiwo945you/article/details/78712136</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Effective Java》笔记30-34：枚举</title>
      <link href="/2019/06/11/%E3%80%8AEffective%20Java%E3%80%8B%E7%AC%94%E8%AE%B030-34%EF%BC%9A%E6%9E%9A%E4%B8%BE/"/>
      <url>/2019/06/11/%E3%80%8AEffective%20Java%E3%80%8B%E7%AC%94%E8%AE%B030-34%EF%BC%9A%E6%9E%9A%E4%B8%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="第30条：用-enum-代替-int-常量"><a href="#第30条：用-enum-代替-int-常量" class="headerlink" title="第30条：用 enum 代替 int 常量"></a>第30条：用 enum 代替 int 常量</h1><p>枚举类型是指<strong>由一组固定的常量组成合法值的类型</strong>。</p><h2 id="int-枚举模式"><a href="#int-枚举模式" class="headerlink" title="int 枚举模式"></a>int 枚举模式</h2><p>在还没有枚举时，表示枚举类型的常用模式是声明一组具名的 int 常量，每个类型成员一个常量：</p><pre><code class="java">public static final int APPLE_FUJI = 0;public static final int APPLE_PIPPIN = 1;public static final int APPLE_GRANNY_SMITH = 2;public static final int ORANGE_NAVEL = 0;public static final int ORANGE_TEMPLE = 1;public static final int ORANGE_BLOOD = 2;</code></pre><a id="more"></a><p>这种方法称作 int 枚举模式。这样的写法是比较脆弱的。首先是没有提供相应的类型安全性，如两个逻辑上不相关的常量值之间可以进行比较或运算(APPLE_FUJI - ORANGE_TEMPLE)，再有就是常量 int 是编译时常量，被直接编译到使用他们的客户端中。如果与该常量关联的 int 发生了变化，客户端就必须重新编译。如果没有重新编译，程序还是可以执行，但是他们的行为将不确定。</p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>Java 1.5 中提供的枚举的声明方式：</p><pre><code class="java">public enum Apple { FUJI, PIPPIN, GRANNY_SMITH }public enum Orange { NAVEL, TEMPLE, BLOOD }</code></pre><p>和 int 常量不同的是，如果函数的参数是枚举类型，如 Apple，那么他的实际值只能来自于该枚举所声明的枚举值，即 FUJI, PIPPIN, GRANNY_SMITH。如果试图将 传递类型错误的值时，将会导致编译错误。</p><p>枚举类型是真正的 final，是<a href="/2016/05/06/《Effective%20Java》笔记03-用私有构造器或者枚举类型强化Singleton属性/#使用枚举类型来实现单例">单例的泛型化</a>，Java 中允许在枚举中添加任意的方法和域，并实现任意的接口。下面先给出一个带有域方法和域字段的枚举声明：</p><pre><code class="java">public enum Planet {    MERCURY(3.302e+23,2.439e6),    VENUS(4.869e+24,6.052e6),    EARTH(5.975e+24,6.378e6),    MARS(6.419e+23,3.393e6),    JUPITER(1.899e+27,7.149e7),    SATURN(5.685e+26,6.027e7),    URANUS(8.683e+25,2.556e7),    NEPTUNE(1.024e+26,2.477e7);    private final double mass;   // 千克    private final double radius; // 米    private final double surfaceGravity;  // 表面重力    private static final double G = 6.67300E-11;    Planet(double mass,double radius) {        this.mass = mass;        this.radius = radius;        surfaceGravity = G * mass / (radius * radius);    }    public double mass() {        return mass;    }    public double radius() {        return radius;    }    public double surfaceGravity() {        return surfaceGravity;    }    public double surfaceWeight(double mass) {        return mass * surfaceGravity;    }}</code></pre><p>在上面的枚举示例代码中，已经将数据和枚举常量关联起来了，因此需要声明实例域字段，同时编写一个带有数据并将数据保存在域中的构造器。枚举天生就是不可变的，因此所有的域字段都应该为 final 的。下面看一下该枚举的应用示例：</p><pre><code class="java">public class WeightTable {    public static void main(String[] args) {        double earthWeight = Double.parseDouble(args[0]);        double mass = earthWeight/Planet.EARTH.surfaceGravity();        for (Planet p : Planet.values())            System.out.printf(&quot;Weight on %s is %f%n&quot;,p,p.surfaceWeight(mass));    }}// Weight on MERCURY is 66.133672// Weight on VENUS is 158.383926// Weight on EARTH is 175.000000// Weight on MARS is 66.430699// Weight on JUPITER is 442.693902// Weight on SATURN is 186.464970// Weight on URANUS is 158.349709// Weight on NEPTUNE is 198.846116</code></pre><h2 id="行为与每个常量关联起来"><a href="#行为与每个常量关联起来" class="headerlink" title="行为与每个常量关联起来"></a>行为与每个常量关联起来</h2><p>上文示例中的方法对于大多说枚举类型来说已经足够了。但有时需要将本质上不同的行为与每个常量关联起来。</p><p>编写一个枚举类型，来表示计算器的加减乘除，想要提供一个方法来执行每个常量所表示的算术运算</p><pre><code class="java">public enum Operation {    PLUS,MINUS,TIMES,DIVIDE;    double apply(double x,double y) {        switch (this) {            case PLUS: return x + y;            case MINUS: return x - y;            case TIMES: return x * y;            case DIVIDE: return x / y;        }        throw new AssertionError(&quot;Unknown op: &quot; + this);  // 没有 throw 将无法编译，虽然无法执行到    }}</code></pre><p>糟糕的是：如果我们新增枚举值的时候，所有和 apply 类似的域函数，都需要进行相应的修改。</p><h2 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h2><p>在枚举类型中声明一个抽象的 apply 方法，并在特定于常量的类主体中，用具体的方法覆盖每个常量的抽象 apply 方法</p><pre><code class="java">public enum Operation {    PLUS { double apply(double x,double y) { return x + y;} },    MINUS { double apply(double x,double y) { return x - y;} },    TIMES { double apply(double x,double y) { return x * y;} },    DIVIDE { double apply(double x,double y) { return x / y;} };    abstract double apply(double x, double y);}</code></pre><p>如果给 Operation 添加新的常量，也不会忘记添加 apply 方法。</p><h2 id="构造器与-toString-方法"><a href="#构造器与-toString-方法" class="headerlink" title="构造器与 toString 方法"></a>构造器与 toString 方法</h2><pre><code class="java">public enum Operation {    PLUS(&quot;+&quot;) { double apply(double x,double y) { return x + y;} },    MINUS(&quot;-&quot;) { double apply(double x,double y) { return x - y;} },    TIMES(&quot;*&quot;) { double apply(double x,double y) { return x * y;} },    DIVIDE(&quot;/&quot;) { double apply(double x,double y) { return x / y;} };    private final String symbol;    Operation(String symbol) {        this.symbol = symbol;    }    @Override    public String toString() {        return symbol;    }    abstract double apply(double x, double y);}</code></pre><p>枚举类型有一个自动产生的 valueOf(String) 方法，他将常量的名字转变为枚举常量本身，如果在枚举中覆盖了 toString 方法(如上例)，就需要考虑编写一个 fromString 方法，将定制的字符串表示法变回相应的枚举，见如下代码：</p><pre><code class="java">private static final Map&lt;String,Operation&gt; stringToEnum = new HashMap&lt;String,Operation&gt;();static {    for (Operation op: values())        stringToEnum.put(op.toString(),op);}public static Operation fromString(String symbol) {    return stringToEnum.get(symbol);}</code></pre><p>在常量被创建完成后，静态代码块将 Operation 常量放入到了 stringToEnum 的 map 中。不能在构造器中将自身放入 map 中，会编译错误。枚举构造器不可以访问枚举的静态域，除了编译时常量域之外。</p><h2 id="策略枚举"><a href="#策略枚举" class="headerlink" title="策略枚举"></a>策略枚举</h2><p>每次添加枚举常量时被迫选择加班费策略。 幸运的是，有一个很好的方法来实现这一点。 这个想法是将加班费计算移入私有嵌套枚举中，并将此<strong>策略枚举</strong>的实例传递给 PayrollDay 枚举的构造方法。 然后，PayrollDay 枚举将加班工资计算委托给策略枚举，从而无需在 PayrollDay 中实现 switch 语句或特定于常量的方法实现。 虽然这种模式不如 switch 语句简洁，但它更安全，更灵活：</p><pre><code class="java">// 策略枚举模式enum PayrollDay {    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY,    SATURDAY(PayType.WEEKEND), SUNDAY(PayType.WEEKEND);    private final PayType payType;    PayrollDay(PayType payType) { this.payType = payType; }    PayrollDay() { this(PayType.WEEKDAY); }  // 默认模式    int pay(int minutesWorked, int payRate) {        return payType.pay(minutesWorked, payRate);    }    // 策略枚举类型    private enum PayType {        WEEKDAY {            int overtimePay(int minsWorked, int payRate) {                return minsWorked &lt;= MINS_PER_SHIFT ? 0 :                  (minsWorked - MINS_PER_SHIFT) * payRate / 2;            }        },        WEEKEND {            int overtimePay(int minsWorked, int payRate) {                return minsWorked * payRate / 2;            }        };        abstract int overtimePay(int mins, int payRate);        private static final int MINS_PER_SHIFT = 8 * 60;        int pay(int minsWorked, int payRate) {            int basePay = minsWorked * payRate;            return basePay + overtimePay(minsWorked, payRate);        }    }}</code></pre><h2 id="枚举的-switch-语句应用"><a href="#枚举的-switch-语句应用" class="headerlink" title="枚举的 switch 语句应用"></a>枚举的 switch 语句应用</h2><p>枚举类型的 switch 有利于用常量特定的行为增加枚举类型。例如，假设 Operation 枚举不在你的控制之下，你希望它有一个实例方法来返回每个相反的操作。你可以用以下静态方法模拟效果:</p><pre><code class="java">public static Operation inverse(Operation op) {    switch(op) {        case PLUS:   return Operation.MINUS;        case MINUS:  return Operation.PLUS;        case TIMES:  return Operation.DIVIDE;        case DIVIDE: return Operation.TIMES;        default:  throw new AssertionError(&quot;Unknown op: &quot; + op);    }}</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>那么你应该什么时候使用枚举呢？任何时候使用枚举都需要一组常量，这些常量的成员在编译时已知。当然，这包括“天然枚举类型”，如行星，星期几和棋子。但是它也包含了其它你已经知道编译时所有可能值的集合，例如菜单上的选项，操作代码和命令行标志。<strong>枚举类型中的常量集不需要一直保持不变</strong>。枚举功能是专门设计用于允许二进制兼容的枚举类型的演变。</p><p>总之，枚举类型优于 int 常量的优点是令人信服的。枚举更具可读性，更安全，更强大。许多枚举不需要显式构造方法或成员，但其他枚举则可以通过<strong>将数据与每个常量关联</strong>并<strong>提供行为受此数据影响的方法</strong>而受益。如果多个枚举常量同时共享共同行为，请考虑策略枚举模式。</p><h1 id="第31条：用实例域代替序数"><a href="#第31条：用实例域代替序数" class="headerlink" title="第31条：用实例域代替序数"></a>第31条：用实例域代替序数</h1><p>枚举提供了 ordinal() 方法，返回每个枚举常量在类型中的数字位置</p><pre><code class="java">public enum Ensemble {    SOLO,   DUET,   TRIO, QUARTET, QUINTET,    SEXTET, SEPTET, OCTET, NONET,  DECTET;    public int numberOfMusicians() { return ordinal() + 1; }}</code></pre><p>虽然这个枚举能正常工作，但对于维护来说则是一场噩梦。如果常量被重新排序，numberOfMusicians 方法将会被破坏。</p><p>永远不要从枚举的序号中得出与它相关的值，而是要将其保存在实例属性中：</p><pre><code class="java">public enum Ensemble {    SOLO(1), DUET(2), TRIO(3), QUARTET(4), QUINTET(5),    SEXTET(6), SEPTET(7), OCTET(8), DOUBLE_QUARTET(8),    NONET(9), DECTET(10), TRIPLE_QUARTET(12);    private final int numberOfMusicians;    Ensemble(int size) { this.numberOfMusicians = size; }    public int numberOfMusicians() { return numberOfMusicians; }}</code></pre><p>枚举规范对此 ordinal 方法说道：大多数程序员对这种方法没有用处。 它被设计用于基于枚举的通用数据结构，如 EnumSet 和 EnumMap。除非你在编写这样数据结构的代码，否则最好避免使用 ordinal 方法。</p><h1 id="第32条：用-EnumSet-代替位域"><a href="#第32条：用-EnumSet-代替位域" class="headerlink" title="第32条：用 EnumSet 代替位域"></a>第32条：用 EnumSet 代替位域</h1><p>如果枚举类型的元素主要用于集合中，一般来说使用 int 枚举模式，下面将 2 的不同倍数赋值给每个常量：</p><pre><code class="java">public class Text {    public static final int STYLE_BOLD = 1 &lt;&lt; 0;  // 1    public static final int STYLE_ITALIC = 1 &lt;&lt; 1;  // 2    public static final int STYLE_UNDERLINE = 1 &lt;&lt; 2;  // 4    public static final int STYLE_STRIKETHROUGH = 1 &lt;&lt; 3;  // 8    public void applyStyles(int styles) { ... }}</code></pre><p>这种表示法让你用 OR 位运算将几个常量合并到一个集合中，称作位域：</p><pre><code class="java">text.applyStyles(Text.STYLE_BOLD | Text.STYLE_ITALIC);</code></pre><p>java.util 包提供了 EnumSet 类来有效地表示从单个枚举类型中提取的值集合。 这个类实现了 Set 接口，提供了所有其他 Set 实现的丰富性，类型安全性和互操作性。下面是前一个使用枚举和枚举集合替代位属性的示例。它更短，更清晰，更安全：</p><pre><code class="java">public class Text {    public enum Style { BOLD, ITALIC, UNDERLINE, STRIKETHROUGH }    public void applyStyles(Set&lt;Style&gt; styles) { ... }}</code></pre><p>下面是将 EnumSet 实例传递给 applyStyles 方法的客户端代码。EnumSet 类提供了一组丰富的静态工厂，可以轻松创建集合，其中一个代码如下所示：</p><pre><code class="java">text.applyStyles(EnumSet.of(Style.BOLD, Style.ITALIC));</code></pre><p>请注意，applyStyles 方法采用 <code>Set&lt;Style&gt;</code> 而不是 <code>EnumSet&lt;Style&gt;</code> 参数。尽管所有客户端都可能会将 EnumSet 传递给该方法，但接受接口类型而不是实现类型通常是很好的做法。</p><p>EnumSet 的一个真正缺点是，它不像 Java 9 那样创建一个不可变的 EnumSet，但是在即将发布的版本中可能会得到补救。 同时，你可以用 Collections.unmodifiableSet 封装一个 EnumSet，但是简洁性和性能会受到影响。</p><h1 id="第33条：用-EnumMap-代替序数索引"><a href="#第33条：用-EnumMap-代替序数索引" class="headerlink" title="第33条：用 EnumMap 代替序数索引"></a>第33条：用 EnumMap 代替序数索引</h1><p>有时可能会看到使用 ordinal 方法来索引到数组或列表的代码。例如，考虑一下这个简单的类来代表一种植物：</p><pre><code class="java">class Plant {    enum LifeCycle { ANNUAL, PERENNIAL, BIENNIAL }    final String name;    final LifeCycle lifeCycle;    Plant(String name, LifeCycle lifeCycle) {        this.name = name;        this.lifeCycle = lifeCycle;    }    @Override    public String toString() {        return name;    }}</code></pre><p>现在假设你有一组植物代表一个花园，想要列出这些由生命周期组织的植物(一年生，多年生，或双年生)。为此，需要构建三个集合，每个生命周期作为一个，并遍历整个花园，将每个植物放置在适当的集合中。</p><p>有一个非常快速的 Map 实现，设计用于枚举键，称为 java.util.EnumMap。</p><pre><code class="java">// Using an EnumMap to associate data with an enumMap&lt;Plant.LifeCycle, Set&lt;Plant&gt;&gt;  plantsByLifeCycle = new EnumMap&lt;&gt;(Plant.LifeCycle.class);for (Plant.LifeCycle lc : Plant.LifeCycle.values())    plantsByLifeCycle.put(lc, new HashSet&lt;&gt;());for (Plant p : garden)    plantsByLifeCycle.get(p.lifeCycle).add(p);System.out.println(plantsByLifeCycle);</code></pre><p>通过使用 stream 来管理 Map，可以进一步缩短以前的程序。 以下是最简单的基于 stream 的代码，它们在很大程度上重复了前面示例的行为：</p><pre><code class="java">// 选择了自己的 Map 实现，实际上它不是 EnumMapSystem.out.println(Arrays.stream(garden).collect(groupingBy(p -&gt; p.lifeCycle)));</code></pre><p>为了解决这个问题，使用 Collectors.groupingBy 的三个参数形式的方法，它允许调用者使用 mapFactory 参数指定 map 的实现：</p><pre><code class="java">System.out.println(Arrays.stream(garden)        .collect(groupingBy(p -&gt; p.lifeCycle,        () -&gt; new EnumMap&lt;&gt;(LifeCycle.class), toSet())));</code></pre><p>你可能会看到数组索引(两次)的数组，用序数来表示从两个枚举值的映射。例如，这个程序使用这样一个数组来映射两个阶段到一个阶段转换（phase transition）（液体到固体表示凝固，液体到气体表示沸腾等等）：</p><pre><code class="java">// Using ordinal() to index array of arrays - DON&#39;T DO THIS!public enum Phase {    SOLID, LIQUID, GAS;    public enum Transition {        MELT, FREEZE, BOIL, CONDENSE, SUBLIME, DEPOSIT;        // Rows indexed by from-ordinal, cols by to-ordinal        private static final Transition[][] TRANSITIONS = {            { null,    MELT,     SUBLIME },            { FREEZE,  null,     BOIL    },            { DEPOSIT, CONDENSE, null    }        };        // Returns the phase transition from one phase to another        public static Transition from(Phase from, Phase to) {            return TRANSITIONS[from.ordinal()][to.ordinal()];        }    }}</code></pre><p>这段程序可以运行，甚至可能显得优雅，但外观可能是骗人的。就像前面显示的简单的花园示例一样，编译器无法知道序数和数组索引之间的关系。如果在转换表中出错或者在修改 Phase 或 Phase.Transition 枚举类型时忘记更新它，则程序在运行时将失败。</p><p>同样，可以用 EnumMap 做得更好。 因为每个阶段转换都由一对阶段枚举来索引，所以最好将关系表示为从一个枚举（from 阶段）到第二个枚举（to 阶段）到结果（阶段转换）的 map。与阶段转换相关的两个阶段最好通过将它们与阶段转换枚举相关联来捕获，然后可以用它来初始化嵌套的 EnumMap：</p><pre><code class="java">// Using a nested EnumMap to associate data with enum pairspublic enum Phase {    SOLID, LIQUID, GAS;    public enum Transition {        MELT(SOLID, LIQUID), FREEZE(LIQUID, SOLID),        BOIL(LIQUID, GAS),   CONDENSE(GAS, LIQUID),        SUBLIME(SOLID, GAS), DEPOSIT(GAS, SOLID);        private final Phase from;        private final Phase to;        Transition(Phase from, Phase to) {            this.from = from;            this.to = to;        }        // Initialize the phase transition map        private static final Map&lt;Phase, Map&lt;Phase, Transition&gt;&gt; m = Stream.of(values()).collect(groupingBy(t -&gt; t.from,                () -&gt; new EnumMap&lt;&gt;(Phase.class), toMap(t -&gt; t.to, t -&gt; t, (x, y) -&gt; y, () -&gt; new EnumMap&lt;&gt;(Phase.class))));        // 相当于        // private static final Map&lt;Phase, Map&lt;Phase, Transition&gt;&gt; m = new EnumMap&lt;&gt;(Phase.class);        // static {        //     for (Phase p: Phase.values())        //         m.put(p, new EnumMap&lt;Phase, Transition&gt;(Phase.class));        //     for (Transition t: Transition.values())        //         m.get(t.from).put(t.to, t);        // }        public static Transition from(Phase from, Phase to) {            return m.get(from).get(to);        }    }}</code></pre><p>总之，使用序数来索引数组很不合适：改用 EnumMap。</p><h1 id="第34条：用接口模拟可伸缩的枚举"><a href="#第34条：用接口模拟可伸缩的枚举" class="headerlink" title="第34条：用接口模拟可伸缩的枚举"></a>第34条：用接口模拟可伸缩的枚举</h1><p>目前还没有很好的方法来枚举基本类型的所有元素及其扩展。最终，可伸缩性会导致设计和实现的许多方面变得复杂起来。</p><p>操作码是指这样的枚举类型：它的元素表示在某种机器上的那些操作，例如前面的 Operation 类型，它表示一个简单的计算器中的某些函数。有时需要用户提供它们自己的操作，这样可以有效地扩展 API 所提供的操作集。</p><p>由于枚举类型可以通过给操作码类型和（属于接口的标准实现的）枚举定义接口，来实现任意接口，基本的想法就是利用这一事实。</p><pre><code class="java">public interface Operation {    double apply(double x,double y);}// 定义枚举类型实现接口public enum BasicOperation implements Operation {    PLUS(&quot;+&quot;) {        public double apply(double x,double y) { return x + y; }    },    MINUS(&quot;-&quot;) {        public double apply(double x,double y) { return x - y; }    },    TIMES(&quot;*&quot;) {        public double apply(double x,double y) { return x * y; }    },    DIVIDE(&quot;/&quot;) {        public double apply(double x,double y) { return x / y; }    };    private final String symbol;    BasicOperation(String symbol) {        this.symbol = symbol;    }    @Override    public String toString() {        return symbol;    }}public enum ExtendedOperation implements Operation {    EXP(&quot;^&quot;) {        public double apply(double x,double y) {            return Math.pow(x,y);        }    },    REMAINDER(&quot;%&quot;) {        public double apply(double x,double y) {            return x % y;        }    };    private final String symbol;    ExtendedOperation(String symbol) {        this.symbol = symbol;    }    @Override public String toString() {        return symbol;    }}</code></pre><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><pre><code class="java">// 方法一public static void main(String[] args) {    double x = Double.parseDouble(args[0]);    double y = Double.parseDouble(args[1]);    test(ExtendedOperation.class, x, y);}private static &lt;T extends Enum&lt;T&gt; &amp; Operation&gt; void test(        Class&lt;T&gt; opSet, double x, double y) {    for (Operation op : opSet.getEnumConstants()) {        System.out.printf(&quot;%f %s %f = %f%n&quot;,x, op, y, op.apply(x, y));    }}</code></pre><p><code>&lt;T extends Enum&lt;T&gt; &amp; Operation&gt; Class&lt;T&gt;</code> 确保了 opSet 对象即表示枚举又表示 Operation 的子类型。</p><pre><code class="java">// 方法二public static void main(String[] args) {    double x = Double.parseDouble(args[0]);    double y = Double.parseDouble(args[1]);    test(Arrays.asList(ExtendedOperation.values()), x, y);}private static void test(Collection&lt;? extends Operation&gt; opSet, double x, double y) {    for (Operation op : opSet) {        System.out.printf(&quot;%f %s %f = %f%n&quot;,x, op, y, op.apply(x, y));    }}</code></pre><p>这样的代码没有那么复杂，更灵活，允许将多个实现类型的操作合并到一起。但也放弃了在指定操作上使用 EnumSet 和 EnumMap 的功能。所以如果不是要灵活地合并多个实现类型的操作，最好还是使用第一种方法。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Effective Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis MySQL Druid 批量更新</title>
      <link href="/2019/05/29/MyBatis%20MySQL%20Druid%20%E6%89%B9%E9%87%8F%E6%9B%B4%E6%96%B0/"/>
      <url>/2019/05/29/MyBatis%20MySQL%20Druid%20%E6%89%B9%E9%87%8F%E6%9B%B4%E6%96%B0/</url>
      
        <content type="html"><![CDATA[<p>使用 MyBatis 批量更新</p><pre><code class="xml">&lt;update id=&quot;updateImport&quot; parameterType=&quot;java.util.List&quot;&gt;    &lt;foreach collection=&quot;list&quot; item=&quot;item&quot; index=&quot;index&quot; open=&quot;&quot; close=&quot;&quot; separator=&quot;;&quot;&gt;        update ${item.tableName}        &lt;set&gt;            &lt;if test=&quot;item.name != null and item.name != &#39;&#39;&quot;&gt;                name=#{item.name},            &lt;/if&gt;        &lt;/set&gt;        &lt;where&gt;            &lt;if test=&quot;item.id !=null and item.id !=&#39;&#39;&quot;&gt;                and id =#{item.id}            &lt;/if&gt;        &lt;/where&gt;    &lt;/foreach&gt;&lt;/update&gt;</code></pre><a id="more"></a><p>报错</p><pre><code class="java">Caused by: java.sql.SQLException: sql injection violation, multi-statement not allow : update device_bd_token                 ...    at com.alibaba.druid.wall.WallFilter.check(WallFilter.java:714)    at com.alibaba.druid.wall.WallFilter.connection_prepareStatement(WallFilter.java:240)    at com.alibaba.druid.filter.FilterChainImpl.connection_prepareStatement(FilterChainImpl.java:448)    at com.alibaba.druid.filter.FilterAdapter.connection_prepareStatement(FilterAdapter.java:928)    at com.alibaba.druid.filter.FilterEventAdapter.connection_prepareStatement(FilterEventAdapter.java:122)    at com.alibaba.druid.filter.FilterChainImpl.connection_prepareStatement(FilterChainImpl.java:448)    at com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl.prepareStatement(ConnectionProxyImpl.java:342)    at com.alibaba.druid.pool.DruidPooledConnection.prepareStatement(DruidPooledConnection.java:318)</code></pre><p>查看资料，需在连接数据库的 url 上加上支持批量的参数</p><pre><code class="ini">jdbc.url=jdbc:mysql://192.168.1.1/dbname?failOverReadOnly=false&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;roundRobinLoadBalance=true&amp;allowMultiQueries=true</code></pre><p>结果还是同样的的错误，发现是 Druid 的问题，<a href="https://blog.csdn.net/goldenfish1919/article/details/50600053" target="_blank" rel="noopener">https://blog.csdn.net/goldenfish1919/article/details/50600053</a></p><p>看日志，是 Druid 的 <code>WallFilter.check()</code> 抛出来的，那就是说是 Druid 在做预编译的时候，给抛出的异常，还没有到 mysql 的服务器。</p><p>最终的解决办法是这样的，在 Druid 配置一个 <code>multiStatementAllow</code> 参数就可以了。：</p><pre><code class="xml">&lt;bean id=&quot;dataSourceOne&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; destroy-method=&quot;close&quot;&gt;    ...    &lt;property name=&quot;proxyFilters&quot;&gt;        &lt;list&gt;            &lt;ref bean=&quot;stat-filter&quot; /&gt;            &lt;ref bean=&quot;wall-filter&quot;/&gt;        &lt;/list&gt;    &lt;/property&gt;&lt;/bean&gt;&lt;bean id=&quot;wall-filter&quot; class=&quot;com.alibaba.druid.wall.WallFilter&quot;&gt;    &lt;property name=&quot;config&quot; ref=&quot;wall-config&quot; /&gt;&lt;/bean&gt;&lt;bean id=&quot;wall-config&quot; class=&quot;com.alibaba.druid.wall.WallConfig&quot;&gt;    &lt;property name=&quot;multiStatementAllow&quot; value=&quot;true&quot; /&gt;&lt;/bean&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB 用户、角色和认证</title>
      <link href="/2019/05/28/MongoDB%20%E7%94%A8%E6%88%B7%E3%80%81%E8%A7%92%E8%89%B2%E5%92%8C%E8%AE%A4%E8%AF%81/"/>
      <url>/2019/05/28/MongoDB%20%E7%94%A8%E6%88%B7%E3%80%81%E8%A7%92%E8%89%B2%E5%92%8C%E8%AE%A4%E8%AF%81/</url>
      
        <content type="html"><![CDATA[<h1 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h1><p>查看所有数据库</p><pre><code class="shell">show dbs</code></pre><p>mongodb是没有创建数据库的命令的，一般是这么做：</p><pre><code class="shell"># 使用 use 命令切换到 myTest 数据库，若没有系统会自动创建# 如果我们什么也不干，数据库会被系统回收掉&gt; use myTest# 创建一个集合，并创建数据&gt; db.myuser.insert({&quot;name&quot;:&quot;test&quot;, age:24})# 上面这条命令我们并没有显式创建集合 myuser# mongodb 会自动帮我们创建。# 这样数据库和一个集合（类似于表的概念）我们就创建好了</code></pre><h1 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h1><blockquote><p><a href="https://docs.mongodb.com/manual/reference/method/js-user-management/" target="_blank" rel="noopener">https://docs.mongodb.com/manual/reference/method/js-user-management/</a></p></blockquote><h2 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h2><pre><code class="js">use admindb.createUser(  {    user: &#39;admin&#39;,    customData:{description:&quot;superuser&quot;},  // 描述，非必需    pwd: &#39;password&#39;,    roles: [ { role: &#39;userAdminAnyDatabase&#39;, db: &#39;admin&#39; } ]  });</code></pre><h2 id="修改用户密码"><a href="#修改用户密码" class="headerlink" title="修改用户密码"></a>修改用户密码</h2><pre><code class="shell">&gt; use adminswitched to db admin&gt; db.auth(&quot;admin&quot;, &quot;password&quot;)1&gt; db.changeUserPassword(&quot;admin&quot;, &quot;123456&quot;)</code></pre><h2 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h2><pre><code class="shell"># 从当前数据库中删除指定用户&gt; db.dropUser(&quot;admin2&quot;)true</code></pre><pre><code class="shell"># 从当前数据库中删除所有用户。db.dropAllUsers( {w: &quot;majority&quot;, wtimeout: 5000} )</code></pre><h2 id="修改用户权限"><a href="#修改用户权限" class="headerlink" title="修改用户权限"></a>修改用户权限</h2><pre><code class="shell"># 为用户授予其他角色。追加权限。db.grantRolesToUser( &quot;admin&quot;, [ { role: &quot;readWrite&quot;, db: &quot;my&quot; } ] )</code></pre><p>替换用户权限</p><pre><code class="json"># 语法db.updateUser(   &quot;&lt;username&gt;&quot;,   {     customData : { &lt;any information&gt; },     roles : [       { role: &quot;&lt;role&gt;&quot;, db: &quot;&lt;database&gt;&quot; } | &quot;&lt;role&gt;&quot;,       ...     ],     pwd: &quot;&lt;cleartext password&gt;&quot;,     authenticationRestrictions: [        {          clientSource: [&quot;&lt;IP&gt;&quot; | &quot;&lt;CIDR range&gt;&quot;, ...],          serverAddress: [&quot;&lt;IP&gt;&quot;, | &quot;&lt;CIDR range&gt;&quot;, ...]        },        ...     ],     mechanisms: [ &quot;&lt;SCRAM-SHA-1|SCRAM-SHA-256&gt;&quot;, ... ], # New in version 4.0     passwordDigestor: &quot;&lt;server|client&gt;&quot; # New in version 4.0   },   writeConcern: { &lt;write concern&gt; })# 示例db.updateUser( &quot;appClient01&quot;,{   customData : { employeeId : &quot;0x3039&quot; },   roles : [      { role : &quot;read&quot;, db : &quot;assets&quot;  }   ]} )</code></pre><h2 id="删除权限"><a href="#删除权限" class="headerlink" title="删除权限"></a>删除权限</h2><pre><code class="shell"># { role: &quot;readWrite&quot;, db: &quot;my&quot; } 删除其他数据库的角色# &quot;readWrite&quot; 删除当前数据库的角色db.revokeRolesFromUser( &quot;admin&quot;,                        [ { role: &quot;readWrite&quot;, db: &quot;my&quot; }, &quot;readWrite&quot; ],                        { w: &quot;majority&quot; }                      )</code></pre><h2 id="查看用户"><a href="#查看用户" class="headerlink" title="查看用户"></a>查看用户</h2><pre><code class="shell">&gt; db.getUser(&quot;admin&quot;){        &quot;_id&quot; : &quot;admin.admin&quot;,        &quot;userId&quot; : UUID(&quot;dae54e25-4636-4968-95bf-e83971220178&quot;),        &quot;user&quot; : &quot;admin&quot;,        &quot;db&quot; : &quot;admin&quot;,        &quot;roles&quot; : [                {                        &quot;role&quot; : &quot;readWrite&quot;,                        &quot;db&quot; : &quot;my&quot;                },                {                        &quot;role&quot; : &quot;readWrite&quot;,                        &quot;db&quot; : &quot;readWriteAnyDatabase&quot;                },                {                        &quot;role&quot; : &quot;userAdminAnyDatabase&quot;,                        &quot;db&quot; : &quot;admin&quot;                }        ],        &quot;mechanisms&quot; : [                &quot;SCRAM-SHA-1&quot;,                &quot;SCRAM-SHA-256&quot;        ]}</code></pre><p>查看所有用户</p><pre><code class="shell">&gt; db.getUsers({ filter: { mechanisms: &quot;SCRAM-SHA-256&quot; } })[        {                &quot;_id&quot; : &quot;admin.admin&quot;,                &quot;userId&quot; : UUID(&quot;dae54e25-4636-4968-95bf-e83971220178&quot;),                ...        }]</code></pre><pre><code class="shell">show users# 或者db.system.users.find()</code></pre><h1 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h1><p>角色管理介绍：<a href="https://docs.mongodb.com/manual/reference/method/js-role-management/" target="_blank" rel="noopener">https://docs.mongodb.com/manual/reference/method/js-role-management/</a></p><p>Built-In Roles（内置角色）：<a href="https://docs.mongodb.com/manual/reference/built-in-roles/index.html" target="_blank" rel="noopener">https://docs.mongodb.com/manual/reference/built-in-roles/index.html</a></p><ol><li>数据库用户角色：read、readWrite;</li><li>数据库管理角色：dbAdmin、dbOwner、userAdmin；</li><li>集群管理角色：clusterAdmin、clusterManager、clusterMonitor、hostManager；</li><li>备份恢复角色：backup、restore；</li><li>所有数据库角色：readAnyDatabase、readWriteAnyDatabase、userAdminAnyDatabase、dbAdminAnyDatabase</li><li>超级用户角色：root<br>// 这里还有几个角色间接或直接提供了系统超级用户的访问（dbOwner 、userAdmin、userAdminAnyDatabase）</li><li>内部角色：__system</li></ol><ul><li>read：允许用户读取指定数据库</li><li>readWrite：允许用户读写指定数据库</li><li>dbAdmin：允许用户在指定数据库中执行管理函数，如索引创建、删除，查看统计或访问 system.profile</li><li>userAdmin：允许用户向 system.users 集合写入，可以找指定数据库里创建、删除和管理用户</li><li>clusterAdmin：只在 admin 数据库中可用，赋予用户所有分片和复制集相关函数的管理权限。</li><li>readAnyDatabase：只在 admin 数据库中可用，赋予用户所有数据库的读权限</li><li>readWriteAnyDatabase：只在 admin 数据库中可用，赋予用户所有数据库的读写权限</li><li>userAdminAnyDatabase：只在 admin 数据库中可用，赋予用户所有数据库的 userAdmin 权限</li><li>dbAdminAnyDatabase：只在 admin 数据库中可用，赋予用户所有数据库的 dbAdmin 权限。</li><li>root：只在 admin 数据库中可用。超级账号，超级权限</li></ul><blockquote><p><a href="https://www.jianshu.com/p/ca08e63fd587" target="_blank" rel="noopener">https://www.jianshu.com/p/ca08e63fd587</a></p></blockquote><h1 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h1><p>修改配置文件/usr/local/mongodb/bin/mongodb.conf，增加一行 <code>auth = true</code></p><p>Windows 下 修改 <code>C:\Program Files\MongoDB\Server\4.0\bin\mongod.cfg</code> 文件，添加</p><pre><code class="shell"># https://docs.mongodb.com/manual/reference/configuration-options/#security.authorizationsecurity:  authorization: enabled</code></pre><p>配置文件说明：<a href="https://docs.mongodb.com/manual/reference/configuration-options/" target="_blank" rel="noopener">https://docs.mongodb.com/manual/reference/configuration-options/</a></p><p>使用用户名密码登录</p><pre><code class="bat">C:\Program Files\MongoDB\Server\4.0\bin&gt;mongoMongoDB shell version v4.0.9connecting to: mongodb://127.0.0.1:27017/?gssapiServiceName=mongodbImplicit session: session { &quot;id&quot; : UUID(&quot;388b9f73-24e0-4bec-b2fd-96b957449be7&quot;) }MongoDB server version: 4.0.9&gt; use adminswitched to db admin&gt; db.auth(&quot;admin&quot;, &quot;123456&quot;)1</code></pre><p>或者</p><pre><code class="shell">mongo localhost:27017/admin --authenticationDatabase admin -u admin -p 123456</code></pre>]]></content>
      
      
      <categories>
          
          <category> MongoDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB 导出查询结果</title>
      <link href="/2019/05/28/MongoDB%20%20%E5%AF%BC%E5%87%BA%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C/"/>
      <url>/2019/05/28/MongoDB%20%20%E5%AF%BC%E5%87%BA%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="在-MongoDB-shell-中打印出超过20个文档"><a href="#在-MongoDB-shell-中打印出超过20个文档" class="headerlink" title="在 MongoDB shell 中打印出超过20个文档"></a>在 MongoDB shell 中打印出超过20个文档</h1><p>在 shell 中输入</p><pre><code class="shell">DBQuery.shellBatchSize = 300</code></pre><p>或者对所有 shell 生效，在 HOME 文件夹(Windows：<code>C:\Users\xxx</code>，Linux：<code>~</code>)下，<code>.mongorc.js</code> 写入 <code>DBQuery.shellBatchSize = 300</code>。</p><blockquote><p><a href="https://stackoverflow.com/questions/3705517/how-to-print-out-more-than-20-items-documents-in-mongodbs-shell" target="_blank" rel="noopener">https://stackoverflow.com/questions/3705517/how-to-print-out-more-than-20-items-documents-in-mongodbs-shell</a><br><a href="https://docs.mongodb.com/manual/tutorial/configure-mongo-shell/#change-the-mongo-shell-batch-size" target="_blank" rel="noopener">https://docs.mongodb.com/manual/tutorial/configure-mongo-shell/#change-the-mongo-shell-batch-size</a><br><a href="https://docs.mongodb.com/manual/mongo/#mongorc-js-file" target="_blank" rel="noopener">https://docs.mongodb.com/manual/mongo/#mongorc-js-file</a></p></blockquote><a id="more"></a><h1 id="导出查询结果"><a href="#导出查询结果" class="headerlink" title="导出查询结果"></a>导出查询结果</h1><p>导出 csv 格式（也可以导出 txt 格式，改下后缀名即可），新建 query.js ：</p><pre><code class="js">db.collection.find({},{&quot;id&quot;:1, &quot;username&quot;:1, &quot;add&quot;:1}).forEach(    function(document) {        print(document.id + &quot;,&quot; + document.username + &quot;,&quot; + document.add);    })</code></pre><p>执行</p><pre><code class="shell">mongo localhost:27017/db_name /path/to/query.js &gt; /path/to/1.csv</code></pre><p>如果需要认证</p><pre><code class="shell">mongo localhost:27017/数据库名 --authenticationDatabase &quot;数据库名&quot; -u &quot;用户名&quot; -p &quot;密码&quot;  /path/to/query.js &gt; /path/to/1.csv</code></pre>]]></content>
      
      
      <categories>
          
          <category> MongoDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Effective Java》笔记23-29：泛型</title>
      <link href="/2019/05/27/%E3%80%8AEffective%20Java%E3%80%8B%E7%AC%94%E8%AE%B023-29%EF%BC%9A%E6%B3%9B%E5%9E%8B/"/>
      <url>/2019/05/27/%E3%80%8AEffective%20Java%E3%80%8B%E7%AC%94%E8%AE%B023-29%EF%BC%9A%E6%B3%9B%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>#　第23条：请不要在新代码中使用原生态类型</p><p>声明中具有一个或者多个<strong>类型参数</strong>的类或者接口，就是泛型类或者泛型接口，统称为泛型。如 <code>List&lt;E&gt;</code>。</p><p>每种泛型可以定义一种<strong>参数化的类型</strong>，格式为：先是类或者接口的名称，接着用尖括号（<code>&lt;&gt;</code>）把对应于泛型的类型参数的实际类型参数列表括起来。如 <code>List&lt;String&gt;</code> 是一个参数化的类型，表示元素类型为 String 的列表。</p><p>每个泛型都定义一个<strong>原生态类型</strong>，即不带任何实际类型参数的泛型名称，也是没有泛型之前的类型。如：<code>List&lt;E&gt;</code> 相对应的原生态类型是 <code>List</code>。</p><p><strong>如果使用原生态类型，就失掉了泛型在安全性和表述性方面的所有优势</strong>。既然不应该使用原生态类型，为什么 Java 设计还要允许使用它们呢？这是为了提供兼容性，要兼容以前没有使用泛型的 Java 代码。</p><p>原生态类型 <code>List</code> 和参数化的类型 <code>List&lt;Object&gt;</code> 之间到底有什么区别呢？不严格地说，<strong>前者逃避了泛型检查，后者则明确告知编译器</strong>，它能够持有任意类型的对象。</p><p>你可以将 <code>List&lt;String&gt;</code> 传递给 <code>List</code> 的参数，但不能将它传递给类型 <code>List&lt;Object&gt;</code> 的参数。泛型有子类型化的规则：<strong><code>List&lt;String&gt;</code> 是原生态类型 List 的一个子类型，而不是参数化类型 List<Object> 的子类型</strong>。因此，如果用不用像 List 这样的原生态类型，就会失掉类型安全性，但是如果使用像 <code>List&lt;Object&gt;</code> 这样的参数化类型，则不会。</p><p>在不确定或者不在乎集合中的元素类型的情况下，也许会使用原生态类型，这是很危险的。Java 提供了一种安全的替代方法，称作<strong>无限制的通配符</strong>，可以使用一个问号代替。例如，泛型 <code>Set&lt;E&gt;</code> 的无限通配符为 <code>Set&lt;?&gt;</code> (读作某个类型的集合)。</p><p>在无限制通配类型 <code>Set&lt;?&gt;</code> 和原生态类型 <code>Set</code> 之间有什么区别呢？Set 可以将任何元素放进使用原生态类型的集合中，因此很容易破坏该集合的类型约束条件；但不能将任何元素（除了 null 之外）放到 <code>Set&lt;?&gt;</code> 中。</p><p>这条规则有两个例外，这是因为“泛型信息在运行时就会被擦除”：</p><ol><li>在获取类信息中必须使用原生态类型（数组类型和基本类型也算原生态类型），规范不允许使用参数化类型。换句话说：List.class，String[].class 和 int.class 都是合法，但是 <code>List&lt;String&gt;.class</code> 和 <code>List&lt;?&gt;.class</code> 都是不合法的。</li><li>这条规则的第二个例外与 <code>instanceof</code> 操作符有关，由于泛型信息在运行时已被擦除，因此在参数化类型而不是无限制通配符类型上使用 instanceof 操作符是非法的，用无限制通配符类型代替原生态类型，尖括号 <code>&lt;&gt;</code> 和问号 <code>?</code> 就显得多余了。下面是利用泛型来使用 instanceof 操作符的首先方法：</li></ol><pre><code class="java">if (o instanceof set) {    Set&lt;?&gt; m = (Set&lt;?&gt;)o;    // ...}</code></pre><p>术语介绍：</p><ul><li>参数化的类型： <code>List&lt;String&gt;</code></li><li>实际类型参数： <code>String</code></li><li>泛型： <code>List&lt;E&gt;</code></li><li>形式类型参数： <code>E</code></li><li>无限制通配符类型： <code>List&lt;?&gt;</code></li><li>原生态类型： <code>List</code></li><li>有限制类型参数： <code>List&lt;E extends Number&gt;</code></li><li>递归类型限制： <code>List &lt;T extends Comparable&lt;T&gt;&gt;</code></li><li>有限制通配符类型： <code>List&lt;? extends Number&gt;</code></li><li>泛型方法： <code>static&lt;E&gt; List&lt;E&gt; asList(E[] a)</code></li><li>泛型令牌： <code>String.class</code></li></ul><h1 id="第24条：消除非受检警告"><a href="#第24条：消除非受检警告" class="headerlink" title="第24条：消除非受检警告"></a>第24条：消除非受检警告</h1><p>用泛型编程时，会遇到许多编译器警告：非受检强制转换警告、非受检方法调用警告、非受检普通数组创建警告，以及非受检转换警告。</p><p>要尽可能地消除每一个非受检警告。如果消除了所有警告，就可以确保代码是类型安全的。</p><p>如果无法消除警告，同时可以证明引起警告的代码是类型安全的，只有在这种情况下才可以用一个 <code>@SuppressWarnings(&quot;unchecked&quot;)</code> 注解来禁止这条警告。</p><p>SuppressWarnings 注解可以用在任何粒度的级别中，从单独的局部变量到整个类都可以。<strong>应该始终在尽可能小的范围中使用 SuppressWarnings 注解</strong>。它通常是个变量声明，或者是非常简短的方法或者构造器。</p><p>将 SuppressWarnings 注解放在 return 语句中是非法的，应该声明一个局部变量来保存返回值，并注解其声明。</p><pre><code class="java">public &lt;T&gt; T[] toArray(T[] a) {    if (a.length &lt; size) {        //TODO: 加入更多的注释，以便后面的维护者可以非常清楚该转换是安全的。        @SuppressWarnings(&quot;unchecked&quot;)        T[] result = (T[]) Arrays.copyOf(elements,size,a.getClass());        return result;    }    System.arraycopy(elements,0,a,0,size);    if (a.length &gt; size)        a[size] = null;    return a;}</code></pre><p>总而言之，非受检警告很重要，不要忽略它们。每一条警告都表示可能在运行时抛出 ClassCastException 异常。要尽最大的努力消除这些警告。如果无法消掉同时确实是类型安全的，就可以在尽可能小的范围中，用 @SuppressWarnings(&quot;unchecked&quot;) 注解来禁止这条警告。<strong>要用注释把禁止该警告的原因记录下来</strong>。</p><h1 id="第25条：列表优先于数组"><a href="#第25条：列表优先于数组" class="headerlink" title="第25条：列表优先于数组"></a>第25条：列表优先于数组</h1><p>数组与泛型相比，有两个重要的不同点：首先，<strong>数组是协变的</strong>，如 Sub 为 Super 的子类型，那么数组类型 Sub[] 就是 Super[] 的子类型。但<strong>泛型则是不可变的</strong>，对于任意两个不同的类型 Type1 和 Type2，<code>List&lt;Type1&gt;</code> 与 <code>List&lt;Type2&gt;</code> 没有任何父子关系。</p><p>下面的代码片段是合法的：</p><pre><code class="java">Object[] objectArray = new Long[1];objectArray[0]= &quot;&quot;; // 运行时抛异常</code></pre><p>但下面这段代码则在编译时就不合法：</p><pre><code class="java">List&lt;Object&gt; ol = new ArrayList&lt;Long&gt;(); // 编译时就不能通过ol.add(&quot;&quot;);</code></pre><p>利用数组，你会在运行时才可以发现错误，而利用列表，则可以在编译时发现错误。</p><p>数组与泛型之间的<strong>第二大区别</strong>在于，<strong>数组是具体化的</strong>。因此数组会在运行时才知道并检查它们的元素类型约束。相比，泛型则是通过擦除来实现的。因此泛型只在编译时强化它们的类型信息，并在运行时丢弃它们的元素类型信息。</p><p>由于上述这些根本的区另，<strong>因此数组和泛型不能很好混合使用</strong>。例如，创建泛型、参数化类型或者类型参数的数组是非法的，如：<code>new List&lt;E&gt;[]</code>、<code>new List&lt;String&gt;[]</code>、<code>new E[]</code> <strong>都是非法的</strong>。</p><p>为什么不允许创建泛型数组呢？看具体例子：</p><pre><code class="java">List&lt;String&gt;[] stringLists= new List&lt;String&gt;[1]; // 1List&lt;Integer&gt; intList = Arrays.asList(42); // 2Object[] objects = stringLists; // 3objects[0] = intList; // 4String s = stringLists[0].get(0); // 5</code></pre><p>这里首先假设第一行可以，其他行本身编译是没有问题的，但运行到 5 行时肯定会抛出 ClassCastException 异常。为了防止出现这种情况，创建泛型数组第1行就不允许了。</p><p>从技术角度说，像 <code>List&lt;String&gt;</code>、<code>List&lt;E&gt;</code>、<code>E</code> 这样的类型应称作为<strong>不可具体化的类型</strong>。直观地说，不可具体化的类型是指<strong>其运行时表示法包含的信息比它的编译时表示法包含的信息更少的类型</strong>。唯一可具体化的参数化类型是无限制的符类型，如 <code>List&lt;?&gt;</code> 和 <code>Map&lt;?,?&gt;</code>，虽然不常用，但是<strong>创建无限制通配类型的数组是合法</strong>。</p><p>当你得到泛型数组创建错误时，最好的解决办法通常是优先使用集合类型 <code>List&lt;E&gt;</code>，而不是 <code>E[]</code> 。这样可以会损失一些性能或者简洁性，但是挽回的是更高的类型安全性和互用性。</p><h1 id="第26条：优先考虑泛型"><a href="#第26条：优先考虑泛型" class="headerlink" title="第26条：优先考虑泛型"></a>第26条：优先考虑泛型</h1><p>考虑第6条中的堆栈实现，将它定义成泛型类。</p><p>第一种是将 elements 定义成类型参数数组：</p><pre><code class="java">public class Stack&lt;E&gt; {    private E[] elements; // 定义成类型参数数组    private int size = 0;    private static final int DEFAULT_INITIAL_CAPACITY = 16;    @SuppressWarnings(&quot;unchecked&quot;)    public Stack() {        // elements = new E[DEFAULT_INITIAL_CAPACITY];  // 无法创建不可具体化的类型数组        elements = (E[]) new Object[DEFAULT_INITIAL_CAPACITY]; // 创建一个 Object 的数组，并将它转换成泛型数组类型        // 还是会有警告，可以加上 SuppressWarnings 注解    }    public void push(E e) {        ensureCapacity();        elements[size++] = e;    }    public E pop() {        if (size == 0)            throw new EmptyStackException();        E result = elements[--size];        elements[size] = null; // 解除过期引用        return result;    }    //...}</code></pre><p>第二种是将 elements 域的类型从 E[] 改为 Object[]：</p><pre><code class="java">public class Stack&lt;E&gt; {    private Object[] elements; // 定义成类型参数数组    private int size = 0;    private static final int DEFAULT_INITIAL_CAPACITY = 16;    public Stack() {        elements = new Object[DEFAULT_INITIAL_CAPACITY]; // 这里就不用强转了    }    public void push(E e) {//        ensureCapacity();        elements[size++] = e;    }    public E pop() {        if (size == 0)            throw new EmptyStackException();        // result = (E)elements[--size];  // 这行会报错        @SuppressWarnings(&quot;unchecked&quot;)        E result = (E)elements[--size];  // 装换为 E        elements[size] = null;        return result;    }    //...}</code></pre><p>禁止数组类型的未受检转换比禁止标量类型的更加危险，所以建议采用第二种方案。但第二种方案可能需要多次转换为 <code>E</code>，而不是只转换一次为 <code>E[]</code>，所以第一种方案更常用。</p><p>总之，使用泛型比使用需要在客户端代码中进行转换的类型来得更加安全，也更加容易。在设计新类型时，要确保它们不需要这种转换就可以使用。这通常意味着要把类做成是泛型的，只要时间允许，就把现有的类型都泛型化。这对于这些类型的新用户来说会变得更加轻松，又不会破坏现有的客户端。</p><h1 id="第27条：优先考虑泛型方法"><a href="#第27条：优先考虑泛型方法" class="headerlink" title="第27条：优先考虑泛型方法"></a>第27条：优先考虑泛型方法</h1><p>静态工具方法尤其适合泛型方法。Collections 工具类中的所有算法方法都泛型化了。</p><pre><code class="java">public class Union {    // 泛型方法    public static &lt;E&gt; Set&lt;E&gt; union(Set&lt;E&gt; s1, Set&lt;E&gt; s2) {        Set&lt;E&gt; result = new HashSet&lt;E&gt;(s1);        result.addAll(s2);        return result;    }}</code></pre><p>union 方法的局限性在于，三个集合的类型（两个输入参数和一个返回值）必须全部相同。利用<strong>有限制的通配符类型</strong>，可以使这个方法变得更加灵活。</p><p>泛型方法的一个显著特性是，无需明确指定类型参数的值，不像调用泛型构造器的时候是必须指定的。编译器通过检查方法参数的类型来计算出类型参数的值。对于上面两个参数都是 <code>Set&lt;String&gt;</code> 类型，因此知道类型参数E必须为 String，这个过程称作为<strong>类型推导</strong>。</p><p><strong>递归类型限制</strong>最普遍的用途与 Comparable 接口有关，<code>&lt;T extends Comparable&lt;T&gt;&gt;</code>，可以读作“针对可以与自身进行比较的每个类型 T”</p><p>例如根据元素的自然顺序计算列表的最大值：</p><pre><code class="java">public static &lt;T extends Comparable&lt;T&gt;&gt; T max(List&lt;T&gt; list) {    Iterator&lt;T&gt; i = list.iterator();    T result = i.next();    while (i.hasNext()) {        T t = i.next();        if (t.compareTo(result) &gt; 0) {            result = t;        }    }    return result;}</code></pre><p>总之，泛型方法就像泛型一样，使用起来比要求客户端转换输出参数并返回值的方法来得更加安全，也更加容易，就像类型一样，你应该确保新的方法可以不用转换就能使用，这通常意味着要将它们泛型化。</p><h1 id="第28条：利用有限制通配符来提升-API-的灵活性"><a href="#第28条：利用有限制通配符来提升-API-的灵活性" class="headerlink" title="第28条：利用有限制通配符来提升 API 的灵活性"></a>第28条：利用有限制通配符来提升 API 的灵活性</h1><h2 id="extends-E"><a href="#extends-E" class="headerlink" title="? extends E"></a>? extends E</h2><p>现在在前面前面第 26 条中的 <code>Stack&lt;E&gt;</code> 中加上以下方法，以便将某个集合一次性放入到栈中：</p><pre><code class="java">public void pushAll(Iterable&lt;E&gt; src) {    for (E e : src)        push(e);}</code></pre><p>这么写如果 src 的元素类型与 Stack 完全一致，就没有问题。但是假如有个 <code>Stack&lt;Number&gt;</code>，并且调用了 push(intVal)，这里的 intVal 就是 Integer 类型，因为 Integer 是 Number 的一个子类型。</p><pre><code class="java">Stack&lt;Number&gt; numberStack = new Stack&lt;Number&gt;();Iterable&lt;Integer&gt; integers = Arrays.asList(3, 1, 4, 1, 5, 9);numberStack.pushAll(integers);</code></pre><p>这么做，这就好比要将 <code>Iterable&lt;Integer&gt;</code> 赋值给 <code>Iterable&lt;Number&gt;</code> 一样，这显然是不可以的，因为 <code>Iterable&lt;Integer&gt;</code> 不是 <code>Iterable&lt;Number&gt;</code> 的子类型。这样就显得缺少灵活性了，幸好<strong>有限制的通配符类型</strong>可以帮我们解决：</p><pre><code class="java">public void pushAll(Iterable&lt;? extends E&gt; src) {    for (E e : src)        push(e);}</code></pre><p>经过上面的修改后 src 不只是可以接受 E 类型的 Iterable，还可以接受 E 的子类型 Iterable。</p><h2 id="super-E"><a href="#super-E" class="headerlink" title="? super E"></a>? super E</h2><p>现在编写一个 popAll 对应的方法，它从栈中弹出每个元素，并将这些元素到传进去参数集合中，下面如果这样设计：</p><pre><code class="java">public void popAll(Collection&lt;E&gt; dst) {    while (!isEmpty())        dst.add(pop());}</code></pre><p>应用代码如下：</p><pre><code class="java">Stack&lt;Number&gt; numberStack = new Stack&lt;Number&gt;();Collection&lt;Object&gt; objects = new ArrayList&lt;Object&gt;();numberStack.popAll(objects);</code></pre><p>不能将一个 <code>Collection&lt;Object&gt;</code> 赋值给 <code>Collection&lt;Number&gt;</code>，有这样一个限制通配类型来解决这个问题：</p><pre><code class="java">public void popAll(Collection&lt;? super E&gt; dst) {    while (!isEmpty())        dst.add(pop());}</code></pre><p>现在 dst 不只是可以接受 E 类型的 Collection 了，而且还可以接受 E 的父类型 Collection。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>为了获得最大限度的灵活性，要在表示生产者或者消费者的输入参数上使用通配符类型。</strong>如果某个输入参数既是生产者又是消费者，那么通配符就没什么用了，因为这时候需要的是严格的类型匹配。如果参数化类型表示一个 T 生产者，就使用 <code>&lt;? extends T&gt;</code>，如果它表示一个 T 消费者，就使用 <code>&lt;? super T&gt;</code>。</p><h2 id="显式的类型参数"><a href="#显式的类型参数" class="headerlink" title="显式的类型参数"></a>显式的类型参数</h2><p>将第 27 条的 union 方法修改一下，让它能同时接受 Integer 与 Double 集合，由于这两个集合是生产者，所以使用 <code>&lt;? extends E&gt;</code> 限制通配符：</p><pre><code class="java">public static &lt;E&gt; Set&lt;E&gt; union(Set&lt;? extends E&gt; s1, Set&lt;? extends E&gt; s2) ;</code></pre><p>注意<strong>不要使用通配符类型作为返回类型</strong>。</p><p>如果有这以下两个集合：</p><pre><code class="java">Set&lt;Integer&gt; integers = new HashSet&lt;Integer&gt;();Set&lt;Double&gt; doubles = new HashSet&lt;Double&gt;();Set&lt;Number&gt; numbers =Union.union(integers, doubles);  // 编译不能通过</code></pre><p>只能是这样使用<strong>显式的类型参数</strong>，而不使用类型推导：</p><pre><code class="java">Set&lt;Number&gt; numbers =Union.&lt;Number&gt;union(integers, doubles);</code></pre><p>或者使用类型推导，则只能以通配类型来接受：</p><pre><code class="java">Set&lt;? extends Number&gt; numbers = union(integers, doubles);</code></pre><h2 id="优先使用-Comparable-lt-super-T-gt"><a href="#优先使用-Comparable-lt-super-T-gt" class="headerlink" title="优先使用 Comparable&lt;? super T&gt;"></a>优先使用 Comparable&lt;? super T&gt;</h2><p>接下来，我们将第27条的 max 方法</p><pre><code class="java">// 原始的声明public static &lt;T extends Comparable&lt;T&gt;&gt; T max(List&lt;T&gt; list)// 修改为使用通配符类型的声明public static &lt;T extends Comparable&lt;? super T&gt;&gt; T max(List&lt;? extends T&gt; list) {    //只能使用通配类型来接受，因为iterator()方法返回的为Iterator&lt;E&gt; 类型，又Iterator&lt;Object&gt;并不是Iterator&lt;String&gt;的父类，所以这里也需要修改一下    Iterator&lt;? extends T&gt; i = list.iterator();  // 1    //但这里不需要使用通配类型来接收，因为next()返回的类型直接就是类型参数E，而不像上面返回的为Iterator&lt;E&gt;泛型类型    T result = i.next();  // 2    while (i.hasNext()) {  // 3       T t = i.next();  // 4       if (t.compareTo(result) &gt; 0) {  // 5           result = t;       }    }    return result;}</code></pre><p>因为 list 只用来读取或生产元素（第1、2、4行都是从 list 中读），所以从 <code>List&lt;T&gt;</code>修改成 <code>List&lt;? extends T&gt;</code>，让 list 可以接受 T 及其它的子类。</p><p>而 <code>Comparable&lt;T&gt;</code> 应该修改成 <code>Comparable&lt;? super T&gt;</code>，因为 Comparable 只是来消费 T 的实例（第5行属于消费，因为 T 的实例调用带有泛型类型参数的 compareTo 方法）。</p><p>假如现在有以下两个接口：</p><pre><code class="java">interface I1 extends Comparable&lt;I1&gt; {}interface I2 extends I1 {}</code></pre><p>如果上面不这样修改的话，下面第二行将不适用：</p><pre><code class="java">max(new ArrayList&lt;I1&gt;());max(new ArrayList&lt;I2&gt;());</code></pre><p>现在我们具体的分析一下上面代码：如果 <code>Comparable&lt;T&gt;</code> 不修改成 <code>Comparable&lt;? super T&gt;</code>，第一行还是可正常运行，但是第二行则不可以，因为此时的 T 为 I2，而 I2 又没有实现 Comparable 接口，而方法声明 <code>&lt;T extends Comparable&lt;T&gt;&gt;</code> 部分则要求 I2 直接实现 <code>Comparable</code> 接口，但父类I1实现了 <code>Comparable</code> 接口，I2 又已经继承了 I1，我们不需要再实现该接口，所以这里变通的作法是让 <code>Comparable&lt;T&gt;</code> 可以接收 T 及 T 的父类类型，所以修改成 <code>Comparable&lt;? super T&gt;</code> 即可，并且这样修改也符合前面的描述。</p><p>所以，使用时始终应该是 <code>Comparable&lt;? super T&gt;</code> 优先于 <code>Comparable&lt;T&gt;</code>，对于 <code>comparator</code> 也一样，使用时始终应该是 <code>Comparator&lt;? super T&gt;</code> 优先于 <code>Comparator&lt;T&gt;</code>。</p><h2 id="类型参数和通配符之间具有双重性"><a href="#类型参数和通配符之间具有双重性" class="headerlink" title="类型参数和通配符之间具有双重性"></a>类型参数和通配符之间具有双重性</h2><p>类型参数和通配符之间具有双重性，许多方法都可以利用其中一个或者另一个进行声明。例如下面是可能的两种静态方法声明，来交换列表中的两个元素，第一个使用无限的类型参数，第二个使用的是无限的通配符：</p><pre><code class="java">public static &lt;E&gt; void swap(List&lt;E&gt; list, int i, int j);public static void swap(List&lt;?&gt; list, int i, int j);</code></pre><p>一般来说，如果类型参数只在方法声明中出现一次（即只在方法参数声明列表中出现过，而方法体没有出现），就可以用通配符取代它。如果是无限制的类型参数 <code>&lt;E&gt;</code>，就用无限制的通配符取代它 <code>&lt;?&gt;</code>；如果是有限制的类型参数 <code>&lt;E extends Number&gt;</code>，就用有限制的通配符取代它 <code>&lt;? extends Number&gt;</code>。</p><p>第二种实质上会有问题，下面是简单的实现都不能通过编译：</p><pre><code class="java">public static void swap(List&lt;?&gt; list, int i, int j) {    list.set(i, list.get(j));  // 不能将 null 之外的任何值放到 List&lt;?&gt;中}</code></pre><p>但可以修改它，编写一个私有的辅助方法来捕捉通配符类型：</p><pre><code class="java">public static void swap(List&lt;?&gt; list, int i, int j) {    swapHelper(list, i, j);}private static &lt;E&gt; void swapHelper(List&lt;E&gt; list, int i, int j) {    list.set(i, list.get(j));}</code></pre><p>总之，在API中使用通配符类型使 API 变得灵活多。如果编写的是一个被广泛使用的类库，则一定要适当地利用通配类型。记住基本原则：<code>producer-extends</code>，<code>consumer-super</code>（<code>PECS</code>）。还要记住<strong>所有的 Comparable 和 Comparator 都是消费者</strong>，所以适合于 <code>&lt;? super XXX&gt;</code>。</p><p>PECS：如果参数化类型表示一个 T 生产者，就使用 <code>&lt;? extends T&gt;</code>；如果它表示一个 T 是消费者，就使用 <code>&lt;? super T&gt;</code>。</p><h1 id="第29条：优先考虑类型安全的异构容器"><a href="#第29条：优先考虑类型安全的异构容器" class="headerlink" title="第29条：优先考虑类型安全的异构容器"></a>第29条：优先考虑类型安全的异构容器</h1><p>不常用。</p><p>通过对泛型的学习我们知道，泛型集合一旦实例化，类型参数就确定下来，只能存入特定类型的元素，比如：</p><pre><code class="java">Map&lt;K, V&gt; map = new HashMap&lt;K, V&gt;();</code></pre><p>则只能将 K、V 及它们的子类放入 Map 中，就不能将其他类型元素存入。如果使用原生 Map 又会得到类型安全检查，也许你这样定义：</p><pre><code class="java">Map&lt;Object,Object&gt; map = new HashMap&lt;Object,Object&gt;();map.put(&quot;Derive&quot;, new Derive());map.put(&quot;Sub&quot;, new Sub());</code></pre><p>这样是可以存入各种类型的对象，虽然逃过了警告，但取出时我们无法知道确切的类型，它们都是 Object，那么有没有一种这样的 Map，即可以存放各种类型的对象，但取出时还是可以知道其确切类型，这是可以的：</p><pre><code class="java">public class Favorites {    // 可以存储不同类型元素的类型安全容器，但每种类型只允许一个值，如果存放同一类型多个值是不行的    private Map&lt;Class&lt;?&gt;, Object&gt; favorites = new HashMap&lt;Class&lt;?&gt;, Object&gt;();    public &lt;T&gt; void putFavorite(Class&lt;T&gt; type, T instance) {        if (type == null)            throw new NullPointerException(&quot;Type is null&quot;);        // favorites.put(type, instance);        /*        * 防止客户端传进原生的 Class 对象，虽然这会警告，但这就不能        * 确保后面 instance 实例为 type 类型了，所以在这种情况下强制检查        */        favorites.put(type, type.cast(instance));    }    public &lt;T&gt; T getFavorite(Class&lt;T&gt; type) {        //返回的还是存入时真真类型        return type.cast(favorites.get(type));    }    public static void main(String[] args) {        Favorites f = new Favorites();        f.putFavorite(String.class, &quot;Java&quot;);        f.putFavorite(Integer.class, 0xcafebabe);        f.putFavorite(Class.class, Favorites.class);        String favoriteString = f.getFavorite(String.class);        int favoriteInteger = f.getFavorite(Integer.class);        Class&lt;?&gt; favoriteClass = f.getFavorite(Class.class);        System.out.printf(&quot;%s %x %s%n&quot;, favoriteString, favoriteInteger, favoriteClass.getName());    }}</code></pre><p>总之，集合 API 说明了泛型的一般用法，限制你每个容器只能有固定数目的类型参数。你可以通过将类型参数放在键上而不是容器上来避开这一限制。对于这种类型安全的异构容器，可以用 Class 对象作为键。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Effective Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 转换文件编码格式</title>
      <link href="/2019/05/27/Python%20%E8%BD%AC%E6%8D%A2%E6%96%87%E4%BB%B6%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F/"/>
      <url>/2019/05/27/Python%20%E8%BD%AC%E6%8D%A2%E6%96%87%E4%BB%B6%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>因要更新图床地址，发现文件夹下存在两种编码的文件 GBK UTF-8，需对其统一修改为 UTF-8。</p><h1 id="转换文件编码格式"><a href="#转换文件编码格式" class="headerlink" title="转换文件编码格式"></a>转换文件编码格式</h1><pre><code class="py">import osimport codecsimport chardetdef convert(file_name, in_code=&quot;GBK&quot;, out_code=&quot;UTF-8&quot;):    &quot;&quot;&quot;    该程序用于将目录下的文件从指定格式转换到指定格式，默认的是 GBK 转到 UTF-8    :param file_name: 文件路径    :param in_code:  输入文件格式    :param out_code: 输出文件格式    :return:    &quot;&quot;&quot;    try:        with codecs.open(file_name, &#39;r&#39;, in_code) as f_in:            new_content = f_in.read()            f_out = codecs.open(file_name, &#39;w&#39;, out_code)            f_out.write(new_content)            f_out.close()    except IOError as err:        print(&quot;I/O error: {0}&quot;.format(err))path = r&#39;C:\my\temp&#39;for file in os.listdir(path):    file_name = os.path.join(path, file)    if os.path.isdir(file_name):        continue    with open(file_name, &quot;rb&quot;) as f:        data = f.read()        code_types = chardet.detect(data)[&#39;encoding&#39;]        encoding = code_types[&#39;encoding&#39;]        confidence = code_types[&#39;confidence&#39;]        if encoding != &#39;utf-8&#39;:            if confidence &lt; 0.9:  # 有一定的可能计算错误                print(file_name)            convert(file_name, encoding, &#39;UTF-8&#39;)</code></pre><a id="more"></a><h1 id="chardet-库"><a href="#chardet-库" class="headerlink" title="chardet 库"></a>chardet 库</h1><blockquote><p><a href="https://www.jianshu.com/p/d73c0017158c" target="_blank" rel="noopener">https://www.jianshu.com/p/d73c0017158c</a></p></blockquote><p>安装：<code>pip install chardet</code></p><p>文档：<a href="https://chardet.readthedocs.io/en/latest/usage.html" target="_blank" rel="noopener">https://chardet.readthedocs.io/en/latest/usage.html</a></p><pre><code class="py">&gt;&gt;&gt; data = &#39;文本太少很可能不准确&#39;.encode(&#39;gbk&#39;)&gt;&gt;&gt; chardet.detect(data){&#39;encoding&#39;: &#39;GB2312&#39;, &#39;confidence&#39;: 0.99, &#39;language&#39;: &#39;Chinese&#39;}</code></pre><pre><code class="py">with open(&#39;test1.txt&#39;, &#39;rb&#39;) as f:    result = chardet.detect(f.read())print(result)# {&#39;encoding&#39;: &#39;utf-8&#39;, &#39;confidence&#39;: 0.99, &#39;language&#39;: &#39;&#39;}</code></pre><p>大文件的编码判断</p><pre><code class="py">from chardet.universaldetector import UniversalDetectorbigdata = open(r&#39;C:\my\temp\1.txt&#39;, &#39;rb&#39;)detector = UniversalDetector()for line in bigdata.readlines():    print(line)    detector.feed(line)    if detector.done:        breakdetector.close()bigdata.close()print(detector.result)# {&#39;encoding&#39;: &#39;utf-8&#39;, &#39;confidence&#39;: 0.99, &#39;language&#39;: &#39;&#39;}</code></pre><p><strong>多个大文件的编码判断</strong>，可以重复使用单个的 UniversalDetector 对象。只需要在每次调用 UniversalDetector 对象时候，初始化<code>detector.reset()</code>。</p><pre><code class="py">import osfrom chardet.universaldetector import UniversalDetectordetector = UniversalDetector()dirs = os.listdir(r&#39;C:\my\temp&#39;)for name in dirs:    path = os.path.join(r&#39;C:\my\temp&#39;, name)    detector.reset()    for line in open(path, &#39;rb&#39;).readlines():        detector.feed(line)        if detector.done:            break    detector.close()    print(detector.result)# {&#39;encoding&#39;: &#39;utf-8&#39;, &#39;confidence&#39;: 0.99, &#39;language&#39;: &#39;&#39;}# {&#39;encoding&#39;: &#39;utf-8&#39;, &#39;confidence&#39;: 0.99, &#39;language&#39;: &#39;&#39;}# {&#39;encoding&#39;: &#39;GB2312&#39;, &#39;confidence&#39;: 0.99, &#39;language&#39;: &#39;Chinese&#39;}</code></pre><h1 id="Linux-命令行转换文件编码格式"><a href="#Linux-命令行转换文件编码格式" class="headerlink" title="Linux 命令行转换文件编码格式"></a>Linux 命令行转换文件编码格式</h1><p><code>iconv</code> 命令用于文件编码的转换，碰到 gbk 编码的文件，需要转换成 utf8，直接使用该命令即可。</p><p>命令用法</p><pre><code class="shell"># 列出iconv支持的编码列表iconv --list# 转换文件编码语法iconv -f 原编码 -t 新编码 filename -o newfile</code></pre><p>参数说明：</p><ul><li><code>-f</code>：from 来源编码</li><li><code>-t</code>：to 转换后新编码</li><li><code>-c</code>：忽略无效字符</li><li><code>-s</code>：--silent，忽略警告</li><li><code>-o</code>：可选，没有的话直接，转换当前文件，使用 -o 保留源文件</li></ul><p>命令实例</p><pre><code class="shell"># 查看文件$ file testtest: UTF-8 Unicode text# 转换$ iconv -f utf8 -t gbk test -o test.gbk# 效果$ file test*test:          UTF-8 Unicode texttest.gbk:     ISO-8859 text</code></pre><h1 id="批量更新图床地址"><a href="#批量更新图床地址" class="headerlink" title="批量更新图床地址"></a>批量更新图床地址</h1><pre><code class="py">import ospath = r&quot;C:\my\temp\_posts&quot;for i in os.listdir(path):    if os.path.isfile(os.path.join(path, i)):        filePath = os.path.join(path, i)        with open(filePath, &#39;r&#39;, encoding=&#39;utf-8&#39;) as a:            str = a.read()            str2 = str.replace(&#39;http://*.*.*.cn/&#39;, &#39;https://*.*.*.*.com/&#39;)            if str != str2:                with open(filePath, &#39;wt&#39;, encoding=&#39;utf-8&#39;) as b:                    b.write(str2)</code></pre><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote><p><a href="https://www.jianshu.com/p/d5030db5da0e" target="_blank" rel="noopener">https://www.jianshu.com/p/d5030db5da0e</a><br><a href="https://www.jianshu.com/p/d73c0017158c" target="_blank" rel="noopener">https://www.jianshu.com/p/d73c0017158c</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Spring 实战》笔记3：高级装配1</title>
      <link href="/2019/04/24/%E3%80%8ASpring%20%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B03%EF%BC%9A%E9%AB%98%E7%BA%A7%E8%A3%85%E9%85%8D1/"/>
      <url>/2019/04/24/%E3%80%8ASpring%20%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B03%EF%BC%9A%E9%AB%98%E7%BA%A7%E8%A3%85%E9%85%8D1/</url>
      
        <content type="html"><![CDATA[<h1 id="环境与-profile"><a href="#环境与-profile" class="headerlink" title="环境与 profile"></a>环境与 profile</h1><p>在开发软件的时候,有一个很大的挑战就是将应用程序从一个环境迁移到另外一个环境。开发阶段中,某些环境相关做法可能并不适合迁移到生产环境中,甚至即便迁移过去也无法正常工作。数据库配置、加密算法以及与外部系统的集成是跨环境部署时会发生变化的几个典型例子。</p><a id="more"></a><p>看起来简单的 <code>DataSource</code> 实际上并不是那么简单。它表现了在不同环境中某个bean会有所不同。我们必须有一种方式来配 <code>置DataSource</code> ，使其在每种环境下都会选择最为合适的配置。</p><p>其中一种方式就是在单独的配置类(或 XML )中配置每个 bean，然后在构造阶段确定要使用哪一个配置编译到可部署的环境中。这种方式的问题在于要为每种环境重新构建应用，当从开发阶段迁移到 QA 阶段时，重新构造也算不上什么大问题。但是，从QA阶段迁移到生产环境阶段时，重新构建可能引入BUG并且会在QA团队的成员中带来不安的情绪。</p><h2 id="配置-profile-bean"><a href="#配置-profile-bean" class="headerlink" title="配置 profile bean"></a>配置 profile bean</h2><p>Spring 为环境相关的 bean 所提供的解决方案其实与构建时的方案没有太大的差别。当然，在这个过程中需要根据环境决定该创建哪个 bean 和不创建哪个 bean。不过 Spring <strong>并不是在构建的时候</strong>做出这样的决策，而是<strong>等到运行时再来确定</strong>。这样的结果就是同一个部署单元（可能会是 WAR 文件）能够适用于所有的环境，<strong>没有必要进行重新构建</strong>。</p><p>在 3.1 版本中，Spring 引入了 bean profile 的功能。要使用 profile，你首先要将所有不同的 bean 定义整理到一个或多个 profile 之中，在将应用部署到每个环境时，<strong>要确保对应的 profile 处于激活的状态</strong>。</p><p>在 Java 配置中，可以使用 <code>@Profile</code> 注解指定某个 bean 属于哪一个 profile。例如，在配置类中，嵌入式数据库的 DataSource 可能会配置成如下所示：</p><pre><code class="java">@Configuration@Profile(&quot;dev&quot;)public class DataSourceConfig {    @Bean(destroyMethod=&quot;shutdown&quot;)    public DataSource dataSource() {        return new EmbeddedDatabaseBuilder()                .setType(EmbeddedDatabaseType.H2)                .addScript(&quot;classpath:schema.sql&quot;)                .addScript(&quot;classpath:test-data.sql&quot;)                .build();    }}</code></pre><p>需要注意的是 <code>@Profile</code> 注解应用到了类级别啥概念，它会告诉 Spring 这个配置来中的 bean 只有在 dev profile 激活时才创建。如果 dev profile 没有激活的话，那么带有 <code>@Bean</code> 注解的方法都会被忽略。</p><p>同时，你可能还需要有一个适用于生产环境的配置，如下所示：</p><pre><code class="java">@Configuration@Profile(&quot;prod&quot;)  // 只有 prod profile 激活的时候，才会创建对应的 bean。public class DataSourceConfig {    @Bean    public DataSource jndiDataSource() {        JndiObjectFactoryBean jndiObjectFactoryBean = new JndiObjectFactoryBean();        jndiObjectFactoryBean.setJndiName(&quot;jdbc/myDS&quot;);        jndiObjectFactoryBean.setResourceRef(true);        jndiObjectFactoryBean.setProxyInterface(javax.sql.DataSource.class);        return (DataSource) jndiObjectFactoryBean.getObject();    }}</code></pre><p>在 Spring 3.1 中，只能在类级别上使用 <code>@Profile</code> 注解。不过，从 Spring 3.2 开始，你也可以在方法级别上使用 <code>@Profile</code> 注解，与 <code>@Bean</code> 注解一同使用。这样的话，就能将这两个 bean 的声明放到同一个配置类之中，如下所示：</p><pre><code class="java">@Configurationpublic class DataSourceConfig {    @Bean(destroyMethod=&quot;shutdown&quot;)    @Profile(&quot;dev&quot;)    public DataSource dataSource() {        return new EmbeddedDatabaseBuilder()                .setType(EmbeddedDatabaseType.H2)                .addScript(&quot;classpath:schema.sql&quot;)                .addScript(&quot;classpath:test-data.sql&quot;)                .build();    }    @Bean    @Profile(&quot;prod&quot;)    public DataSource jndiDataSource() {        JndiObjectFactoryBean jndiObjectFactoryBean = new JndiObjectFactoryBean();        jndiObjectFactoryBean.setJndiName(&quot;jdbc/myDS&quot;);        jndiObjectFactoryBean.setResourceRef(true);        jndiObjectFactoryBean.setProxyInterface(javax.sql.DataSource.class);        return (DataSource) jndiObjectFactoryBean.getObject();    }}</code></pre><p>尽管每个 DataSource bean 都被声明在一个 profile 中，并且只能当规定的 profile 激活时，相应的 bean 才会被创建，但是可能会有其他的 bean 并没有声明到一个给定的 profile 范围内。<strong>没有指定的 profile 的 bean 都会创建，与激活那个 profile 没有关系</strong></p><h2 id="在-XML-中配置-profile"><a href="#在-XML-中配置-profile" class="headerlink" title="在 XML 中配置 profile"></a>在 XML 中配置 profile</h2><p>我们也可以通过 <code>&lt;beans&gt;</code> 元素的 profil 属性，在 XML 中配置 profile bean。</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans    ...    profile=&quot;dev&quot;&gt;    &lt;jdbc:embedded-database id=&quot;dataSource&quot;&gt;        &lt;jdbc:script location=&quot;classpath:schema.sql&quot; /&gt;        &lt;jdbc:script location=&quot;classpath:test-data.sql&quot; /&gt;    &lt;/jdbc:embedded-database&gt;&lt;/beans&gt;</code></pre><p>还可以在根 <code>&lt;beans&gt;</code> 元素中嵌套定义 <code>&lt;beans&gt;</code> 元素，而不是为每个环境都创建一个 profile XML 文件。这能够将所有的 profile bean 定义放到同一个 XML 文件中，如下所示：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans    ...&gt;    &lt;beans profile=&quot;dev&quot;&gt;        &lt;jdbc:embedded-database id=&quot;dataSource&quot;&gt;            &lt;jdbc:script location=&quot;classpath:schema.sql&quot; /&gt;            &lt;jdbc:script location=&quot;classpath:test-data.sql&quot; /&gt;        &lt;/jdbc:embedded-database&gt;    &lt;/beans&gt;    &lt;beans profile=&quot;qa&quot;&gt;        &lt;bean id=&quot;dataSource&quot;              class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;              destroy-method=&quot;close&quot;              p:url=&quot;jdbc:h2:tcp://dbserver/～/test&quot;              p:driverClassName=&quot;org.h2.Driver&quot;              p:username=&quot;test&quot;              p:password=&quot;123456&quot;              p:initialSize=&quot;20&quot;              p:maxActive=&quot;39&quot;/&gt;    &lt;/beans&gt;    &lt;beans profile=&quot;prod&quot;&gt;        &lt;jee:jndi-lookup id=&quot;dataSource&quot;                         lazy-init=&quot;true&quot;                         jndi-name=&quot;jdbc/myDatabase&quot;                         resource-ref=&quot;true&quot;                         proxy-interface=&quot;javax.sql.DataSource&quot; /&gt;    &lt;/beans&gt;&lt;/beans&gt;</code></pre><p>除了所有的 bean 定义到同一个 XML 文件中，这种配置方式与定义单独的 XML 文件中实际效果是一样的。在运行时，只会创建一个 bean，<strong>这取决于处于激活状态的是哪一个 profile</strong>。</p><h2 id="激活-profile"><a href="#激活-profile" class="headerlink" title="激活 profile"></a>激活 profile</h2><p>Spring 在确定哪个 profile 处于激活状态时，需要依赖两个独立的属性：<code>sring.profiles.active</code> 和 <code>spring.profiles.default</code> 。如果设置了 <code>spring.profiles.active</code> 属性的话，那么它的值就会用来确定哪个 profile 是激活的。但如果没有设置 <code>spring.profiles.active</code> 的话，那么 Spring 将会查找 <code>spring.profiles.default</code> 的值。如果两者都没有的话，那就没有激活的 profile。</p><p>有多种方式来设置这两个属性</p><ul><li>作为 <code>DispatcherServlet</code> 的初始化参数  <code>&lt;init-param&gt;</code></li><li>作为 Web 的应用上下文参数            <code>&lt;context-param&gt;</code></li><li>作为 JNDI 条目</li><li>作为环境变量</li><li>作为 JVM 的系统属性</li><li>在集成测试类上，使用 <code>@ActiveProfiles</code> 注解设置。</li></ul><p>作者喜欢的一种方式是使用 <code>DisPatcherServlet</code> 的参数将 <code>spring.profiles.default</code> 设置为开发环境，会在 Servlet 上下文中进行设置。</p><pre><code class="xml">&lt;!-- 在 Web 应用的 web.xml 文件中设置默认的 profile --&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app version=&quot;2.5&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;    xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;&gt;    &lt;!-- 加载 spring 容器 --&gt;    &lt;context-param&gt;        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;        &lt;param-value&gt;classpath:spring/applicationContext*.xml&lt;/param-value&gt;    &lt;/context-param&gt;    &lt;!-- 为上下文设置默认的 profile --&gt;    &lt;context-param&gt;        &lt;param-name&gt;spring.profiles.default&lt;/param-name&gt;        &lt;param-value&gt;dev&lt;/param-value&gt;    &lt;/context-param&gt;    &lt;listener&gt;        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;    &lt;/listener&gt;    &lt;!-- springmvc 的前端控制器 --&gt;    &lt;servlet&gt;        &lt;servlet-name&gt;appServlet&lt;/servlet-name&gt;        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;        &lt;!-- contextConfigLocation 不是必须的， 如果不配置 contextConfigLocation， springmvc 的配置文件默认在：WEB-INF/servlet 的 name+&quot;-servlet.xml&quot; --&gt;        &lt;init-param&gt;            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;            &lt;param-value&gt;classpath:spring/springmvc.xml&lt;/param-value&gt;        &lt;/init-param&gt;        &lt;!-- 为 Servlet 设置默认的 profile --&gt;        &lt;init-param&gt;            &lt;param-name&gt;spring.profiles.default&lt;/param-name&gt;            &lt;param-value&gt;dev&lt;/param-value&gt;        &lt;/init-param&gt;        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;    &lt;/servlet&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;appServlet&lt;/servlet-name&gt;        &lt;url-pattern&gt;/&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;&lt;/web-app&gt;</code></pre><p>按照这种方式设置 <code>spring.profiles.default</code> ，所有开发人员能从版本控制软件中获得应用的程序源码，并使用开发环境的设置(如切入式数据库)运行代码而不需要任何额外的设置。</p><p><strong>当应用程序部署到 QA、生产、或其他环境中时，负责部署的人根据情况使用系统属性、环境变量、或 JNDI 设置 <code>spring.profiles.active</code> 即可。当设置 <code>spring.profiles.avtive</code> 后，至于 <code>spring.profiles.default</code> 设置成什么已经无所谓了：系统会优先使用 <code>spring.profiles.active</code> 中设置的 profile</strong>。</p><p>在 spring.profiles.active 和 spring.profiles.default 中，profile 使用的都是复数形式。这意味着你可以同时激活多个 profile，这可以通过列出多个 profile 名称，并以逗号分隔来实现。当然，同时启用 dev 和 prod profile 可能也没有太大的意义，不过你可以同时设置多个彼此不相关的 profile。</p><h2 id="使用profile进行测试"><a href="#使用profile进行测试" class="headerlink" title="使用profile进行测试"></a>使用profile进行测试</h2><p>当运行集成测试时，通常会希望采用与生产环境（或者是生产环境的部分子集）相同的配置进行测试。但是，如果配置中的 bean 定义在了 profile 中，那么在运行测试时，我们就需要有一种方式来启用合适的 profile。</p><p>Spring 提供了 <code>@ActiveProfiles</code> 注解，我们可以使用它来指定运行测试时要激活哪个 profile。在集成测试时，通常想要激活的是开发环境的 profile。例如，下面的测试类片段展现了使用 <code>@ActiveProfiles</code> 激活 dev profile：</p><pre><code class="java">@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes = DataSourceConfig.class)@ActiveProfiles(&quot;dev&quot;)public static class PersistenceTest{    ...}</code></pre><p>在条件化创建 bean，Spring 的 profil 机制是一种很好的方法，这里的条件要基于哪个 profile 处于激活状态来判断。Spring 4.0 中提供了一种更为通用的机制来实现条件化的 bean 定义，这这种机制之中，条件化完全由你来确定，Spring 4 和 <code>@Conditional</code> 注解定义条件化的 bean。</p><h1 id="条件化的-bean"><a href="#条件化的-bean" class="headerlink" title="条件化的 bean"></a>条件化的 bean</h1><p>假设你希望一个或所个 bean 只有在类路径下包含特定的库时才创建。或者我们希望某个 bean 只有当另外某个特定的 bean 也声明了之后才创建，我们还可能要求只有某个特定的环境变量设置之后，才会创建某个 bean。</p><p>在 Spring 4 之前，很难实现这种级别的条件化配置，但是 Spring 4.0 引入了一个新的 <code>@Conditional</code> 注解，它可以用到带有 <code>@Bean</code> 注解的方法上。如果给定的条件计算结果为 true，就会创建这个 bean，否则的话，这个 bean 会被忽略。</p><p>假设有一个名为 MagicBean 的类，我们希望只有设置了 magic 环境属性的时候，Spring 才会实例化这个类。如果环境中没有这个属性，则忽略。</p><pre><code class="java">@Bean@Conditional(MagicExistsCondition.class)public MagicBean magicBean{    return new MagicBean();}</code></pre><h2 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h2><p>可以看到，<code>@Conditional</code> 中给定了一个 Class，它指明了条件，在本例中，也就是 <code>MagicExistsCondition</code>。<code>@Conditional</code> 将会通过 <code>Condition</code> 接口进行条件对比：</p><pre><code class="java">public interface Condition {    boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata);}</code></pre><p>设置给 <code>@Conditional</code> 的类可以是任意实现了 <code>Condition</code> 接口的类型。可以看出来，这个接口实现起来很简单直接，只需提供 <code>matches()</code> 方法的实现即可。如果 <code>matches()</code> 方法返回 true，那么就会创建带有 <code>@Conditional</code> 注解的 bean。如果 <code>matches()</code> 方法返回 false，将不会创建这些 bean。</p><p>在本例中，我们需要创建 Condition 的实现并根据环境中是否存在 magic 属性来做出决策。</p><pre><code class="java">public class MagicExistsCondition implements Condition {    @Override    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {        Environment env = context.getEnvironment();        return env.containsProperty(&quot;magic&quot;);  // 检查 magic 属性    }}</code></pre><p><code>matches()</code> 方法很简单但功能强大。它通过给定的 <code>ConditionContext</code> 对象进而得到 <code>Environment</code> 对象，并使用这个对象检查环境中是否存在名为 magic 的环境属性。如果满足这个条件的话，<code>matches()</code> 方法就会返回 true。所带来的结果就是条件能够得到满足，所有 <code>@Conditional</code> 注解上引用 <code>MagicExistsCondition</code> 的 bean 都会被创建。</p><p>话说回来，如果这个属性不存在的话，就无法满足条件，<code>matches()</code> 方法会返回 false，这些 bean 都不会被创建。</p><p><code>MagicExistsCondition</code> 中只是使用了 <code>ConditionContext</code> 得到的 <code>Environment，但</code> <code>Condition</code> 实现的考量因素可能会比这更多。<code>matches()</code> 方法会得到 <code>ConditionContext</code> 和 <code>AnnotatedTypeMetadata</code> 对象用来做出决策。</p><h2 id="ConditionContext"><a href="#ConditionContext" class="headerlink" title="ConditionContext"></a>ConditionContext</h2><pre><code class="java">public interface ConditionContext {    BeanDefinitionRegistry getRegistry();    ConfigurableListableBeanFactory getBeanFactory();    Environment getEnvironment();    ResourceLoader getResourceLoader();    ClassLoader getClassLoader();}</code></pre><p>通过 <code>ConditionContext</code> ，我们可以做到如下几点：</p><ul><li>借助 <code>getRegistry()</code> 返回的 <code>BeanDefinitionRegistry</code> 检查 bean 定义；</li><li>借助 <code>getBeanFactory()</code> 返回的 <code>ConfigurableListableBeanFactory</code> 检查 bean 是否存在，甚至探查 bean 的属性；</li><li>借助 <code>getEnvironment()</code> 返回的 <code>Environment</code> 检查环境变量是否存在以及它的值是什么；</li><li>读取并探查 <code>getResourceLoader()</code> 返回的 <code>ResourceLoader</code> 所加载的资源；</li><li>借助 <code>getClassLoader(</code>) 返回的 <code>ClassLoader</code> 加载并检查类是否存在。</li></ul><h2 id="AnnotatedTypeMetadata"><a href="#AnnotatedTypeMetadata" class="headerlink" title="AnnotatedTypeMetadata"></a>AnnotatedTypeMetadata</h2><p>AnnotatedTypeMetadata 则能够让我们检查带有 @Bean 注解的方法上还有什么其他的注解。AnnotatedTypeMetadata 也是一个接口。它如下所示：</p><pre><code class="java">public interface AnnotatedTypeMetadata {    boolean isAnnotated(String annotationName);    Map&lt;String, Object&gt; getAnnotationAttributes(String annotationName);    Map&lt;String, Object&gt; getAnnotationAttributes(String annotationName, boolean classValuesAsString);    MultiValueMap&lt;String, Object&gt; getAllAnnotationAttributes(String annotationName);    MultiValueMap&lt;String, Object&gt; getAllAnnotationAttributes(String annotationName, boolean classValuesAsString);}</code></pre><p>借助 <code>isAnnotated()</code> 方法，我们能够判断带有 <code>@Bean</code> 注解的方法是不是还有其他特定的注解。借助其他的那些方法，我们能够检查 <code>@Bean</code> 注解的方法上其他注解的属性。</p><h2 id="新版-Profile-注解重构"><a href="#新版-Profile-注解重构" class="headerlink" title="新版 Profile 注解重构"></a>新版 Profile 注解重构</h2><p>从 Spring 4 开始，<code>@Profile</code> 注解进行了重构，使其基于 <code>@Conditional</code> 和 <code>Condition</code> 实现。作为如何使用 <code>@Conditional</code> 和 <code>Condition</code> 的例子，我们来看一下在 Spring 4 中，<code>@Profile</code> 是如何实现的。</p><pre><code class="java">@Target({ElementType.TYPE, ElementType.METHOD})@Retention(RetentionPolicy.RUNTIME)@Documented@Conditional(ProfileCondition.class)public @interface Profile {    String[] value();}</code></pre><p><code>@Profile</code> 本身也使用了 <code>@Conditional</code> 注解，并且引用 <code>ProfileCondition</code> 作为 <code>Condition</code> 实现。如下所示， <code>ProfileCondition</code> 实现了 <code>Condition</code> 接口，并且在做出决策的过程中，考虑到了 <code>ConditionContext</code> 和 <code>AnnotatedTypeMetadata</code> 中的多个因素。</p><pre><code class="java">class ProfileCondition implements Condition {    @Override    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {        if (context.getEnvironment() != null) {            MultiValueMap&lt;String, Object&gt; attrs = metadata.getAllAnnotationAttributes(Profile.class.getName());            if (attrs != null) {                for (Object value : attrs.get(&quot;value&quot;)) {                    if (context.getEnvironment().acceptsProfiles(((String[]) value))) {                        return true;                    }                }                return false;            }        }        return true;    }}</code></pre><p>可以看到， <code>ProfileCondition</code> 通过 <code>AnnotatedTypeMetadata</code> 得到了用于 <code>@Profile</code> 注解的所有属性。借助该信息，它会明确地检查 value 属性，该属性包含了 bean 的 profile 名称。然后，它根据通过 <code>ConditionContext</code> 得到的 <code>Environment</code> 来检查［借助 <code>acceptsProfiles()</code> 方法］该 profile 是否处于激活状态。</p><h1 id="处理自动装配的歧义性"><a href="#处理自动装配的歧义性" class="headerlink" title="处理自动装配的歧义性"></a>处理自动装配的歧义性</h1><p>我们已经看到如何使用<strong>自动装配</strong>让 Spring 完全负责将 bean 引用注入到构造参数和属性中。自动装配能够提供很大的帮助，因为它会减少装配应用程序组件时所需要的显式配置的数量。</p><p>不过，<strong>仅有一个 bean 匹配所需的结果时，自动装配才是有效的</strong>。如果不仅有一个 bean 能够匹配结果的话，这种歧义性会阻碍 Spring 自动装配属性、构造器参数或方法参数。</p><p>为了阐述自动装配的歧义性，假设我们提供 <code>@Autowired</code> 注解标注了 setDessert 方法</p><pre><code class="java">@Autowiredpublic void setDessert(Dessert dessert) {  this.dessert = dessert;}</code></pre><p>Dessert 是一个接口，并且有三个类实现了这个接口</p><pre><code class="java">@Componentpublic class Cake implements Dessert {...}@Componentpublic class Cookies implements Dessert { ...}@Componentpublic class IceCream implements Dessert {...}</code></pre><p>因为这三个实现均使用 <code>@Component</code> 注解，在组件进行扫描的时候，能够发现他们并将其创建为 Spring 应用上下文里面的 bean。然后，当 Spring 试图自动装配的 setDessert() 中的 Dessert 参数时，<strong>它们并没有唯一、无歧义的可选值</strong><br>。Spring 只好宣告失败并抛出异常：<code>NoUniqueBeanDefinitionException</code></p><p>当确实发生歧义性的时候，Spring 提供了多种可选方案来解决这样的问题。你可以将可选 bean 中的某一个设为首选（<code>primary</code>）的bean，或者使用限定符（<code>qualifier</code>）来帮助 Spring 将可选的 bean 的范围缩小到只有一个 bean。</p><h2 id="标示首选的-bean-Primary"><a href="#标示首选的-bean-Primary" class="headerlink" title="标示首选的 bean (@Primary)"></a>标示首选的 bean (@Primary)</h2><p>在 Spring 中，可以通过 <code>@Primary</code> 来表达首选方案。</p><pre><code class="java">// 将 @Component 注解的 IceCream bean 声明为首选的 bean@Component@Primarypublic class IceCream implements Dessert {...}</code></pre><pre><code class="java">// 或者通过 JavaConfig 显示配置地声明 IceCream@Bean@Primarypublic Dessert IceCream() {  return new IceCream();}</code></pre><pre><code class="xml">&lt;!-- 使用 XML 配置 bean --&gt;&lt;bean id=&quot;ceCream&quot;    class=&quot;com.desserteater.IceCream&quot;    primary=&quot;true&quot;/&gt;</code></pre><p>当然如果标注了两个或者多个首选 bean，那么就无法工作了。</p><h2 id="限定自动装配的-bean-Qualifier"><a href="#限定自动装配的-bean-Qualifier" class="headerlink" title="限定自动装配的 bean (@Qualifier)"></a>限定自动装配的 bean (@Qualifier)</h2><h3 id="简单例子"><a href="#简单例子" class="headerlink" title="简单例子"></a>简单例子</h3><p>设置首选 bean 的局限性在于 <code>@Primary</code> 无法将可选方案的范围限定到唯一一个无歧义性的选项中。它只能标示一个优先的可选方案。当首选 bean 的数量超过一个时，我们并没有其他的方法进一步缩小可选范围。</p><p>就解决歧义性问题而言，限定符是一种更为强大的机制，Spring 的限定符能够在所有可选的 bean 上进行缩小范围的操作，最终能够达到只有一个 bean 满足所规定的限制条件。如果将所有的限定符都用上后依然存在歧义性，那么你可以继续使用更多的限定符来缩小选择范围。</p><p><code>@Qualifier</code> 注解是使用限定符的主要方式。它可以与 <code>@Autowired</code> 和 <code>@Inject</code> 协同使用，在注入的时候指定想要注入进去的是哪个 bean。例如,我们确保要将 IceCream 注入到 setDessert() 之中。</p><pre><code class="java">@Autowired@Qualifier(&quot;iceCream&quot;)public void setDessert(Dessert dessert) {  this.dessert = dessert;}</code></pre><p>这是使用限定符的最简单的例子。为 <code>@Qualifier</code> 注解所设置的参数就是想要注入的 bean 的 ID。所有使用 <code>@Component</code> 注解声明的类都会创建为 bean，并且 <strong>bean 的 ID 为首字母变为小写的类名</strong>。</p><p><code>@Qualifier(&quot;iceCream&quot;)</code> 所引用的 bean 要具有 <code>String</code> 类型的“iceCream”作为限定符。如果没有指定其他的限定符的话，所有的 bean 都会给定一个默认的限定符，这个限定符与 bean 的 ID 相同。</p><p>如果你重构了 IceCrean 类，将其重名为 Gelato 的话，bean 的默认 ID 和默认的限定符会变为 gelato，这就无法匹配 setDessert() 方法中的限定符，自动装配会失败。</p><h3 id="创建自定义的限定符"><a href="#创建自定义的限定符" class="headerlink" title="创建自定义的限定符"></a>创建自定义的限定符</h3><p>可以为 bean 设置自己的限定符，而不是依赖于将 ID 作为限定符。在这里所需要做的就是在 bean 声明上加 <code>@Qualifier</code> 注解。</p><pre><code class="java">@Component@Qualifier(&quot;cold&quot;)public class IceCream implements Dessert {...}</code></pre><p>在这种情况下，cold 限定符分配了 IceCream bean。因为它没耦合类名，因此你可以随意重构 IceCream 的类名，而不必担心会破坏自动装配。在注入的地方，只要引用cold限定符就可以了：</p><pre><code class="java">@Autowired@Qualifier(&quot;cold&quot;)public void setDessert(Dessert dessert) {  this.dessert = dessert;}</code></pre><pre><code class="java">// 通过 Java 配置显式定义 bean 的时候，@Qualifier 也可以与 @Bean 注解一起。@Bean@Qualifierpublic Dessert dessert () {  return new IceCream();}</code></pre><h3 id="使用自定义的限定符注解"><a href="#使用自定义的限定符注解" class="headerlink" title="使用自定义的限定符注解"></a>使用自定义的限定符注解</h3><p>面向特性的限定符要比基于 bean ID 的限定符更好一些。但是，如果多个 bean 都具备相同特性的话，这种做法也会出现问题。例如，如果引入了这个新的 Dessert bean，限定符也是 cold，这样再次产生了歧义。</p><p>可能想到的解决方案就是在注入点和 bean 定义的地方同时再添加另外一个 <code>@Qualifier</code> 注解。<strong>但 Java 不允许在同一个条目上重复出现相同类型的多个注解</strong>。（Java 8 允许出现重复的注解，只要这个注解本身在定义的时候带有 <code>@Repeatable</code> 注解就可以。不过，Spring 的 <code>@Qualifier</code> 注解并没有在定义时添加 <code>@Repeatable</code> 注解。）</p><p>但是，我们可以创建自定义的限定符注解，借助这样的注解来表达 bean 所希望限定的特性。这个注解，它本身要使用 <code>@Qualifier</code> 注解来标注。这样我们将不再使用 <code>@Qualifier(&quot;cold&quot;)</code>，而是使用自定义的 @Cold 注解，该注解的定义如下所示：</p><pre><code class="java">@Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.TYPE, ElementType.ANNOTATION_TYPE})@Retention(RetentionPolicy.RUNTIME)@Qualifierpublic @interface cold {}</code></pre><p>同样，你可以创建一个新的 <code>@Creamy</code> 注解来代替 <code>@Qualifier(&quot;creamy&quot;)</code>。</p><p>现在我们重新看一下 IceCream，并为其添加 <code>@Cold</code> 和 <code>@Creamy</code> 注解</p><pre><code class="java">@Component@Clod@Creamypublic class IceCream implements　Dessert {...}</code></pre><p>最终，在注入点，我们使用必要的限定符注解进行任意组合，从而将可选的范围缩小到只有一个 bean 满足需求。为了得到 IceCream bean，setDessert() 方法可以这样使用注解：</p><pre><code class="java">@Autowired@Cold@Creamypublic void setDessert(Dessert dessert) {  this.dessert = dessert;}</code></pre><p>通过声明自定义的限定符注解，我们可以同时使用多个限定符，不会再有 Java 编译器的限制或错误，与此同时，相对于原始的 @Qualifier 并借助于 String 类型来指定限定符，<strong>自定义的注解也更为类型安全</strong>。</p><p>在本节和前节中，我们讨论了几种通过自定义注解扩展 Spring 的方式，为了创建自定义的条件化注解，我们建议一个新的注解并在这个注解上添加了 <code>@Conditional</code>，为了创建自定义的限定符注解，我们创建一个新的注解并在这个注解上添加了 <code>@Qualifer</code>。这种技术可以用到很多 Spring 注解中，从而能够将他们组合在一起形成特定目标的自定义注解。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Spring 实战》笔记2：裝配 Bean</title>
      <link href="/2019/04/20/%E3%80%8ASpring%20%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B02%EF%BC%9A%E8%A3%9D%E9%85%8D%20Bean/"/>
      <url>/2019/04/20/%E3%80%8ASpring%20%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B02%EF%BC%9A%E8%A3%9D%E9%85%8D%20Bean/</url>
      
        <content type="html"><![CDATA[<h1 id="IoC-和-DI"><a href="#IoC-和-DI" class="headerlink" title="IoC 和 DI"></a>IoC 和 DI</h1><blockquote><p><a href="http://sishuok.com/forum/blogPost/list/2427.html" target="_blank" rel="noopener">http://sishuok.com/forum/blogPost/list/2427.html</a></p></blockquote><p><strong>IoC</strong> — Inversion of Control ，即“控制反转”，不是什么技术，而是一种设计思想。在 Java 开发中， Ioc 意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。IoC 很好的体现了面向对象设计法则之一—— 好莱坞法则：“别找我们，我们找你”；即由 IoC 容器帮对象找相应的依赖对象并注入，而不是由对象主动去找。</p><ul><li><strong>谁控制谁，控制什么</strong>：传统 Java SE 程序设计，我们直接在对象内部通过 new 进行创建对象，是程序主动去创建依赖对象；而 IoC 是有专门一个容器来创建这些对象，即由 Ioc 容器来控制对象的创建；谁控制谁？当然是 IoC 容器控制了对象；控制什么？那就是主要控制了外部资源获取（不只是对象包括比如文件等）。</li><li><strong>为何是反转，哪些方面反转了</strong>：有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了。</li></ul><p><strong>DI</strong> — Dependency Injection ，即“依赖注入”：是组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标</p><p>需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。理解 DI 的关键是：“谁依赖谁，为什么需要依赖，谁注入谁，注入了什么”，那我们来深入分析一下：</p><ul><li><strong>谁依赖于谁</strong>：当然是某个容器管理对象依赖于 IoC 容器；“被注入对象的对象”依赖于“依赖对象”；</li><li><strong>为什么需要依赖</strong>：容器管理对象需要 IoC 容器来提供对象需要的外部资源；</li><li><strong>谁注入谁</strong>：很明显是 IoC 容器注入某个对象，也就是注入“依赖对象”；</li><li><strong>注入了什么</strong>：就是注入某个对象所需要的外部资源（包括对象、资源、常量数据）。</li></ul><h1 id="三种装配方式"><a href="#三种装配方式" class="headerlink" title="三种装配方式"></a>三种装配方式</h1><p>Spring 容器负责创建应用中的 bean，并通过 DI 维护这些 bean 之间的协作关系。Spring 提供了三种装配方式：</p><ul><li>隐式的 bean 发现机制和自动装配</li><li>在 Java 中进行显示配置</li><li>在 XML 中进行显示配置</li></ul><p>建议使用：自动装配机制，显示配置越少越好。当你必须显示配置时，推荐使用类型安全并且比 XML 更加强大的 JavaConfig。最后只有当你想要使用便利的 XML 命名空间，并且在 JavaConfig 中没有同样的实现时，才应用使用 XML。</p><a id="more"></a><h1 id="自动化装配-bean"><a href="#自动化装配-bean" class="headerlink" title="自动化装配 bean"></a>自动化装配 bean</h1><p>Spring 从两个角度来实现自动化装配：</p><ul><li>组件扫描（component scanning）：Spring 会自动发现应用上下文中所创建的 bean</li><li>自动装配（autowiring）：Spring 自动满足 bean 之间的依赖。</li></ul><h2 id="创建可被发现的-bean"><a href="#创建可被发现的-bean" class="headerlink" title="创建可被发现的 bean"></a>创建可被发现的 bean</h2><p>CD 为我们阐述了 DI 是如何运行提供了一个很好的样例，如果你不将 CD 插入(注入)到 CD 播放器中，那么 CD 播放器其实没有太大的用处。CD 播放器依赖于 CD 才能完成它的使命。</p><pre><code class="java">// 定义 CD 的接口public interface CompactDisc {    void play();}</code></pre><pre><code class="java">// 定义 CD 接口的一个实现import org.springframework.stereotype.Component;@Component  // 表明该类会作为组件类public class SgtPeppers implements CompactDisc {    private String title = &quot;Sgt. Pepper&#39;s Lonely Hearts Club Band&quot;;    private String artist = &quot;The Beatles&quot;;    @Override    public void play() {        System.out.println(&quot;Playing &quot; + title + &quot; by &quot; + artist);    }}</code></pre><p>组件扫描默认是不启用的，需要显式配置下。</p><pre><code class="java">@Configuration@ComponentScan  // 默认会扫描与配置类相同的包public class CDPlayConfig {}</code></pre><p>使用 XMl 来启用组件扫描的话，可以使用 Spring context 命名空间的 <code>context:component-scan</code> 元素。</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns:Context=&quot;http://www.springframework.org/schema/context&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd        http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;Context:component-scan base-package=&quot;springaction02.auto&quot;/&gt;&lt;/beans&gt;</code></pre><pre><code class="java">// 测试组件扫描功能 创建一个简单的 JUnit 测试，它会创建 Spring 上下文，并判断 CompactDisc 是不是真的创建出来了。import org.junit.Assert;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;@RunWith(SpringJUnit4ClassRunner.class)  // 会自动创建 Spring 应用的上下文// @ContextConfiguration(locations = &quot;classpath:CDPlayConfig.xml&quot;)  // 使用 xml 加载配置@ContextConfiguration(classes = CDPlayConfig.class)  // 使用 Java 加载配置public class CDPalyConfigTest {    @Autowired    private CompactDisc cd;    @Test    public void cdShouldNotBeNull() {        Assert.assertNotNull(cd);    }}</code></pre><h2 id="为组件扫描的-bean-命名"><a href="#为组件扫描的-bean-命名" class="headerlink" title="为组件扫描的 bean 命名"></a>为组件扫描的 bean 命名</h2><p>Spring 应用上下文中所有的 bean 都会给定一个 ID，默认就是将类名的首字母变成小写。SgtPeppers ID 为 sgtPeppers。</p><p>如果要设置不同的 ID，则需要传递给 <code>@Component</code> 注解。</p><pre><code class="java">@Component(&quot;lonelyHeartsClub&quot;)public class SgtPeppers implements CompactDisc {    // ...}</code></pre><p>还有一种方式，使用 Java 依赖注入规范（Java Dependency Injection）中提供的 <code>@Named</code> 注解来为 bean 设置 ID</p><pre><code class="java">@Named(&quot;lonelyHeartsClub&quot;)public class SgtPeppers implements CompactDisc {    // ...}</code></pre><p>Spring 支持将 <code>@Named</code> 作为 <code>@Component</code> 注解的替代方案。两者之间有一些细微的差异，但是在大多数场景中，他们是可以互相替换的。</p><h2 id="设置组件扫描的基础包"><a href="#设置组件扫描的基础包" class="headerlink" title="设置组件扫描的基础包"></a>设置组件扫描的基础包</h2><p>没有为 <code>@ComponentScan</code> 设置任何属性，这意味着，按照默认规则，它会以配置类所在的包作为基础包(base package) 来扫描组件。</p><p>为了指定不同的基础包，你所需要做的就是在 <code>@ComponentScan</code> 的 value 属性中指明包的名称。</p><p>如果你想更加清晰的表明你所设置的是基础包，那么你可以通过 <code>basePackages</code> 属性来进行设置。<code>basePackages</code> 属性使用的是复数形式，这可以设置多个基础包。</p><pre><code class="java">@Configuration@Componentscan(&quot;springaction02&quot;)// @Componentscan(basePackages=&quot;springaction02&quot;)// @Componentscan(basePackages={&quot;springaction02&quot;, &quot;video&quot;})public class CDPlayerConfig{}</code></pre><p>在上面所有的例子中，所设置的基础包都是以 String 类型表示的，这是不安全的，如果重构代码，那么所指定的基础包可能会出现错误。<code>@ComponentScan</code> 还提供了另外一种方式，将其设置为包中所包含的类或接口。</p><pre><code class="java">@Configuration@Componentscan(basePackageClasses={CDPlayer.class,DVDPlayer.class})public class CDPlayerConfig{}</code></pre><p>可以考虑在包中创建一个用来扫描的<strong>空标记接口</strong>。通过标记接口的方式，你依然能够保持对重构友好的接口的引用，但是可以避免引用任何实际的应用程序代码。</p><h2 id="通过为-bean-添加注解实现自动装配"><a href="#通过为-bean-添加注解实现自动装配" class="headerlink" title="通过为 bean 添加注解实现自动装配"></a>通过为 bean 添加注解实现自动装配</h2><p>自动装配就是让 Spring 自动满足 bean 依赖的一种方法，在满足的依赖的过程中，会在 Spring 应用上下文寻找匹配某个 bean 需求的其他 bean。为了声明要进行自动装配，我们可以将可以借助于 Spring 提供的 <code>@Autowired</code> 注解。</p><pre><code class="java">@Componentpublic class CDPlayer implements MediaPlayer {    private CompactDisc cd;    @Autowired    public  CDPlayer(CompactDisc cd) {        this.cd = cd;    }    @Override    public void play() {        cd.play();    }}</code></pre><p>在构造器上添加了 <code>@Autowired</code> 注解，这表明当 Spring 创建 CDPlayer bean 时，会通过这个构造器来实例化并且传入一个可设置给 CompactDisc 类型的 bean</p><p><code>@Autowired</code> 注解不仅可以用于构造器上，还能用在属性 Setter 方法上，甚至 <code>@Autowired</code> 可以用在类的任何方法上</p><pre><code class="java">@Autowiredpublic void setCompactDisc(CompactDisc cd)｛    this.cd = cd;｝</code></pre><p>如果没有匹配的 bean，那么在应用上下文创建的时候，Spring 会抛出一个异常，为了避免异常的出现，你可以将 <code>@Autowired</code> 的 <code>required</code> 属性设置为 false。<strong>如果没有匹配的 bean 的话，代码中没有进行 null 检查的话，这个处于未装配的属性可能会出现 NullPointerException。</strong></p><pre><code class="java">@Autowired(required=false)</code></pre><p>如果有多个 bean 满足依赖关系时，Spring 将会抛出异常，表明没有明确指定要选择哪个 bean 进行装配。</p><p>@Autowired 是 Spring 特有的注解，也可以使用 <code>@Inject</code>，@Inject 注解来源于 Java 依赖注入规范，大多数情况下，它们是可以互相替换的。</p><h2 id="验证自动装配"><a href="#验证自动装配" class="headerlink" title="验证自动装配"></a>验证自动装配</h2><pre><code class="java">// import org.junit.contrib.java.lang.system.StandardOutputStreamLogimport org.junit.contrib.java.lang.system.SystemOutRule;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes = CDPlayerConfig.class)public class CDPlayerTest {    @Rule    public final SystemOutRule log = new SystemOutRule().enableLog();    @Autowired    private MediaPlayer player;    @Autowired    private CompactDisc cd;    @Test    public void  cdShouldNotBeNull() {        assertNotNull(cd);    }    @Test    public void play() {        player.play();        assertEquals(                &quot;Playing Sgt. Pepper&#39;s Lonely Hearts Club Band by The Beatles\n&quot;,                log.getLog());    }}</code></pre><p>书中使用了 StandardOutputStreamLog，这是来源于System Rules 库的一个 JUnit 规则，该规则能够基于控制台的输出编写断言。已过时，改用 <code>SystemOutRule</code>，需要导入 jar 包</p><pre><code class="xml">&lt;!-- https://mvnrepository.com/artifact/com.github.stefanbirkner/system-rules --&gt;&lt;dependency&gt;    &lt;groupId&gt;com.github.stefanbirkner&lt;/groupId&gt;    &lt;artifactId&gt;system-rules&lt;/artifactId&gt;    &lt;version&gt;1.19.0&lt;/version&gt;    &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;</code></pre><h1 id="通过-Java-代码装配-bean"><a href="#通过-Java-代码装配-bean" class="headerlink" title="通过 Java 代码装配 bean"></a>通过 Java 代码装配 bean</h1><p>JavaConfig 与应用程序中的业务逻辑和领域代码是不同的。JavaConfig 是配置代码。这意着它不应该包含任何业务逻辑，JavaConfig 也不应该侵入到业务逻辑代码中。<strong>通常会将 JavaConfig 放到单独的包中</strong>，使它与其他的应用程序逻辑分离开来。</p><h2 id="创建配置类"><a href="#创建配置类" class="headerlink" title="创建配置类"></a>创建配置类</h2><pre><code class="java">import org.springframework.context.annotation.Configuration;@Configurationpublic class CDPlayerConfig {}</code></pre><p>和上文相比，只是将 @ComponentScan 注解移除了。</p><h2 id="声明简单的-bean"><a href="#声明简单的-bean" class="headerlink" title="声明简单的 bean"></a>声明简单的 bean</h2><p>要在 JavaConfig 中声明 bean，需要编写一个方法，这个方法会创建锁需要类型的实例，然后给这个方法添加 <code>@Bean</code> 注解。</p><pre><code class="java">@Configurationpublic class CDPlayerConfig {    @Bean    public CompactDisc sgtPeppers() {        return new SgtPeppers();    }}</code></pre><p><code>@Bean</code> 注解会告诉 Spirng 这个方法将返回一个对象，该对象要注册为 Spring 应用上下文中的 bean，方法中最终产生了 bean 实例的逻辑。</p><p>默认情况下，bean 的 <code>ID</code> 与带有 <code>@Bean</code> 注解的方法名是一样的。这个例子中是 sgtPeppers，如果你想重命名该方面，也可以通过 name 属性指定一个不同的名字 <code>@Bean(name=&quot;lonelyHeartsClub&quot;)</code> 。</p><h2 id="借助-JavaConfig-实现注入"><a href="#借助-JavaConfig-实现注入" class="headerlink" title="借助 JavaConfig 实现注入"></a>借助 JavaConfig 实现注入</h2><p>现在需要声明 CDPlayer bean，它依赖与 CompactDisc。</p><p>在 JavaConfig 中最简单方式就是引用创建 bean 的方法，</p><pre><code class="java">@Bean  // 同 sgtPeppers 方法一样使用 @Bean 注解public CDPlayer cdPlayer() {    return new CDPlayer(sgtPeppers());    // 调用了需要传入 CompactDisc 的构造器，看样子是调用 sgtPeppers() 方法得到的，    // 因为 sgtPeppers() 方法上添加了 @Bean 注解，Spring 会拦截所有对它的调用，直接返回该方法的 bean，而不是每次都调用}@Beanpublic CDPlayer anotherCDPlayer() {    return new CDPlayer(sgtPeppers());}</code></pre><p>Spring 中的 bean 都是单例的，Spring 会拦截对 sgtPeppers() 的调用并确保返回的是 Spring 创建的 bean，所以两个方法会得到相同的 bean。</p><p>通过调用方法来引用 bean 的方式有点令人困惑，其实还有一种理解起来更为简单的方式</p><pre><code class="java">@Beanpublic CDPlayer cdPlayer(CompactDisc compactDisc) {    return new CDPlayer(compactDisc);}</code></pre><p>当 Spring 调用 cdPlayer 时，它会自动装配一个 CompactDisc 到配置方法中，然后，方法体就可以按照合适的方式来使用它。借助于这种技术，cdPlayer 也可以将 CompactDisc 注入到 CDPlayer 的构造器中，而不用明确引用 CompactDisc 的 @Bean 方法。</p><p>通过这种方式引用其他的 bean 是<strong>最佳的选择</strong>。因为它不会要求将 CompactDisc 声明到同一个配置类中。实际上它可以通过组件扫描能够自动发现或者通过 XML 来进行配置。你可以将配置分散到多个配置类、XML 文件以及自动扫描和装配的 bean 中。</p><h1 id="通过-XML-装配-bean"><a href="#通过-XML-装配-bean" class="headerlink" title="通过 XML 装配 bean"></a>通过 XML 装配 bean</h1><p>本节的内容只是用来帮助你维护已有的 XML 配置，在完成新的 Spring 工作时，希望你会使用自动化配置和 Java 配置。</p><h2 id="声明一个简单的-bean"><a href="#声明一个简单的-bean" class="headerlink" title="声明一个简单的 bean"></a>声明一个简单的 bean</h2><p>需要使用 spring-beans 模式中的另一个元素：<code>&lt;bean&gt;</code>，类似于 JavaConfig 中的 @Bean 注解。</p><pre><code class="xml">&lt;bean class=&quot;springaction02.SgtPeppers&quot;/&gt;</code></pre><p>这里声明了一个简单的 bean，创建这个 bean 的类通过 class 属性来指定的，并且要使用全限定类名。</p><p>因为没有明确给 ID，所以这个 bean 将会根据全限定名来进行命名 &quot;springaction02.SgtPeppers#0&quot;。其中，&quot;#0&quot; 是一个计数的形式,用来区分相同类型的其他 bean。如果你声明了另外一个 SgtPeppers，并且没有明确进行标识，那么它自动得到的 ID 将会是 &quot;springaction02.SgtPeppers#1&quot;。</p><p>尽管自动化的 bean 命名方式非常方便，但需要引用它的话，借助于 id 属性。为每个 bean 设置一个你自己选择的名字</p><pre><code class="xml">&lt;bean id=&quot;compactDisc&quot; class=&quot;springaction02.SgtPeppers&quot;/&gt;</code></pre><p>第一件需要注意的事情就是你不在需要直接负责创建 SgtPeppers 的实例，在基于 JavaConfig 的配置中，我们需要这样做。当 Spring 发现这个元素时，它会调用 SgtPeppers 的默认构造器来创建 bean。在 XML 配置中，bean 的创建显得更加被动，不过，它没有 javaConfig 那样强大，<strong>在 JavaConfig 中，你可以通过任何可以想象到的方法来创建 bean 实例。</strong></p><p>另一个需要注意的是，在这个简单的声明中，我们将 bean 的类型以<strong>字符串的形式</strong>设置在了 class 属性中。谁能确保设置给 Class 属性的值是真正的类呢？Spring 的 XML 配置并不能从编译器的类型检查中受益，即便它所引用的是实际的类型，如果你重命名了会发生什么呢？</p><p>以上介绍的只是 JavaConfig 要优于 XML 配置的部分原因。在你的应用选择配置风格时，要记住 XMl 配置的这些缺点。</p><h2 id="借助构造器注入初始化-bean"><a href="#借助构造器注入初始化-bean" class="headerlink" title="借助构造器注入初始化 bean"></a>借助构造器注入初始化 bean</h2><p>在 Spring XML 配置中，只有一种声明 bean 的方式，使用元素并制定 class 属性，Sprng 会从这里获取必要的信息来创建 bean。</p><p>在 XML 中声明 DI 时，会有多种可选的配置风格和方案。具体到<strong>构造器注入</strong>，有两种基本的配置方案可供选择</p><ul><li><code>&lt;constructor-arg&gt;</code> 元素</li><li>使用 Spring3.0 所引入的 <code>c-</code> 命名空间</li></ul><p><code>&lt;constructor-arg&gt;</code> 元素比使用 <code>c-</code> 命名空间会更加冗长。从而导致 XMl 更加难以读懂。另外有些事情 <code>&lt;constructor-arg&gt;</code> 可以做到，但是使用 <code>c-</code> 命名空间却无法实现。</p><h3 id="构造器注入-bean-引用"><a href="#构造器注入-bean-引用" class="headerlink" title="构造器注入 bean 引用"></a>构造器注入 bean 引用</h3><p>同样还是 CDPlayer 的例子，已经声明了 SgtPeppers bean。</p><pre><code class="xml">&lt;bean id=&quot;cdPlayer&quot; class=&quot;springaction02.CDPlayer&quot;&gt;    &lt;!--  index=&quot;0&quot; 可以表示位置 --&gt;    &lt;constructor-arg ref=&quot;compactDisc&quot;/&gt;&lt;/bean&gt;</code></pre><p>当Spring遇到这个 <code>&lt;bean&gt;</code> 元素时,它会创建一个 CDPlayer 实例。<code>&lt;constructor-arg&gt;</code> 元素会告知 Spring 要将一个 ID 为 compactDisc 的 bean 引用传递到 CDPlayer 的构造器中。</p><p>替代方案，可以使用 Spring 的 <code>c-</code> 命名空间。需在 XML 的顶部声明其模式</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns:c=&quot;http://www.springframework.org/schema/c&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean id=&quot;compactDisc&quot; class=&quot;springaction02.SgtPeppers&quot;/&gt;    &lt;bean id=&quot;cdPlayer&quot; class=&quot;springaction02.CDPlayer&quot; c:cd-ref=&quot;compactDisc&quot;/&gt;&lt;/beans&gt;</code></pre><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/007Eq6Awgy1g2ajuftsubj309o04kq3c.jpg" alt="通过 Spring 的 c- 命名空间将 bean 引用注入到构造器参数中"></p><p>这里直接引用了构造器参数的名称，还可以使用参数在整个参数列表中的位置信息。</p><pre><code class="xml">&lt;!-- 0 也就是参数的索引 --&gt;&lt;bean id=&quot;cdPlayer&quot; class=&quot;springaction02.CDPlayer&quot; c:_0-ref=&quot;compactDisc&quot;/&gt;&lt;!-- 因为只有一个构造器参数，所以可以不用写 0 --&gt;&lt;bean id=&quot;cdPlayer&quot; class=&quot;springaction02.CDPlayer&quot; c:_-ref=&quot;compactDisc&quot;/&gt;</code></pre><h3 id="将字面量注入到构造器中"><a href="#将字面量注入到构造器中" class="headerlink" title="将字面量注入到构造器中"></a>将字面量注入到构造器中</h3><p>创建 CompactDisc 的一个新实现 。</p><pre><code class="java">public class BlankDisc implements CompactDisc {    private String title;    private String artist;    public BlankDisc(String title, String artist) {        this.title = title;        this.artist = artist;    }    @Override    public void play() {        System.out.println(&quot;Playing &quot; + title + &quot; by &quot; + artist);    }}</code></pre><p>使用 constructor-arg</p><pre><code class="xml">&lt;bean id=&quot;compactDisc1&quot; class=&quot;springaction02.BlankDisc&quot;&gt;    &lt;constructor-arg value=&quot;Sgt. Pepper&#39;s Lonely Hearts Club Band&quot;/&gt;    &lt;constructor-arg value=&quot;The Beatles&quot;/&gt;    &lt;!-- &lt;constructor-arg name=&quot;title&quot; value=&quot;The Beatles&quot;/&gt; 根据参数名注入，不建议使用 --&gt;    &lt;!-- &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;The Beatles&quot;/&gt;  根据参数类型进行注入，不能有重复的 --&gt;&lt;/bean&gt;</code></pre><p>使用 c- 命名空间</p><pre><code class="xml">&lt;!-- 书中写的 c:_title 是错误的 --&gt;&lt;bean id=&quot;compactDisc2&quot; class=&quot;springaction02.BlankDisc&quot;          c:title=&quot;Sgt. Pepper&#39;s Lonely Hearts Club Band&quot;          c:artist=&quot;The Beatles&quot; /&gt;&lt;bean id=&quot;compactDisc3&quot; class=&quot;springaction02.BlankDisc&quot;        c:_0=&quot;Sgt. Pepper&#39;s Lonely Hearts Club Band&quot;        c:_1=&quot;The Beatles&quot; /&gt;&lt;!-- 同样如果只有一个构造器参数，可以使用 c:_=&quot;&quot; --&gt;</code></pre><h3 id="使用静态工厂方式实例化-Bean"><a href="#使用静态工厂方式实例化-Bean" class="headerlink" title="使用静态工厂方式实例化 Bean"></a>使用静态工厂方式实例化 Bean</h3><p>指定 <code>factory-method</code> 属性来指定实例化 Bean 的方法</p><pre><code class="java">public class HelloApiStaticFactory {    // 工厂方法    public static HelloApi newInstance(String message) {        // 返回需要的 Bean 实例        return new HelloImpl2(message);    }}</code></pre><pre><code class="xml">&lt;!-- 使用静态工厂方法 --&gt;&lt;bean id=&quot;bean3&quot; class=&quot;springaction02.HelloApiStaticFactory&quot;factory-method=&quot;newInstance&quot;&gt;    &lt;constructor-arg index=&quot;0&quot; value=&quot;Hello Spring!&quot;/&gt;&lt;/bean&gt;</code></pre><h3 id="使用实例工厂方法实例化-Bean"><a href="#使用实例工厂方法实例化-Bean" class="headerlink" title="使用实例工厂方法实例化 Bean"></a>使用实例工厂方法实例化 Bean</h3><p>使用这种方式不能指定 class 属性，此时必须使用 <code>factory-bean</code> 属性来指定工厂 Bean，<code>factory-method</code> 属性指定实例化 Bean 的方法</p><pre><code class="java">// 实例工厂类代码public class HelloApiInstanceFactory {    public HelloApi newInstance(String message) {        return new HelloImpl2(message);    }}</code></pre><pre><code class="xml">&lt;!—1 、定义实例工厂 Bean --&gt;&lt;bean id=&quot;beanInstanceFactory&quot; class=&quot;springaction02.HelloApiInstanceFactory&quot;/&gt;&lt;!—2 、使用实例工厂 Bean 创建 Bean --&gt;&lt;bean id=&quot;bean4&quot; factory-bean=&quot;beanInstanceFactory&quot; factory-method=&quot;newInstance&quot;&gt;    &lt;constructor-arg index=&quot;0&quot; value=&quot;Hello Spring!&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;</code></pre><h3 id="装配集合，null-值"><a href="#装配集合，null-值" class="headerlink" title="装配集合，null 值"></a>装配集合，null 值</h3><p><code>c-</code> 命名空间无法实现。</p><p>假设 BlankDisc 有了一个新的属性</p><pre><code class="java">private List&lt;String&gt; tracks;public BlankDisc(String title, String artist, List&lt;String&gt; tracks) {    this.title = title;    this.artist = artist;    this.tracks = tracks;}</code></pre><p>最简单的方法，直接传递 <code>null</code></p><pre><code class="xml">&lt;bean id=&quot;compactDisc4&quot; class=&quot;springaction02.BlankDisc&quot;&gt;    &lt;constructor-arg value=&quot;Sgt. Pepper&#39;s Lonely Hearts Club Band&quot;/&gt;    &lt;constructor-arg value=&quot;The Beatles&quot;/&gt;    &lt;constructor-arg&gt;&lt;null/&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;</code></pre><p>使用 <code>&lt;list&gt;</code>，<code>&lt;set&gt;</code></p><pre><code class="xml">&lt;bean id=&quot;compactDisc5&quot; class=&quot;springaction02.BlankDisc&quot;&gt;    &lt;constructor-arg value=&quot;Sgt. Pepper&#39;s Lonely Hearts Club Band&quot;/&gt;    &lt;constructor-arg value=&quot;The Beatles&quot;/&gt;    &lt;constructor-arg&gt;        &lt;list&gt; &lt;!-- 也可以使用 set --&gt;            &lt;value&gt;11&lt;/value&gt;            &lt;value&gt;22&lt;/value&gt;            &lt;value&gt;33&lt;/value&gt;            &lt;!-- 如果是引用，可以使用 &lt;ref bean=&quot;getbean&quot; /&gt; --&gt;        &lt;/list&gt;    &lt;/constructor-arg&gt;&lt;/bean&gt;</code></pre><h3 id="注入-Map-类型"><a href="#注入-Map-类型" class="headerlink" title="注入 Map 类型"></a>注入 Map 类型</h3><pre><code class="xml">&lt;bean id=&quot;mapBean&quot; class=&quot;springaction02.MapBean&quot;&gt;    &lt;property name=&quot;values&quot;&gt;        &lt;map key-type=&quot;java.lang.String&quot; value-type=&quot;java.lang.String&quot;&gt;            &lt;entry&gt;&lt;key&gt;&lt;value&gt;1&lt;/value&gt;&lt;/key&gt;&lt;value&gt;11&lt;/value&gt;&lt;/entry&gt;            &lt;entry key=&quot;2&quot; value=&quot;22&quot;/&gt;            &lt;!-- &lt;entry key-ref=&quot; 键引用 &quot; value-ref=&quot; 值引用 &quot;/&gt; --&gt;        &lt;/map&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre><h3 id="Properties-注入"><a href="#Properties-注入" class="headerlink" title="Properties 注入"></a>Properties 注入</h3><pre><code class="java">public void setValues(Properties values) {    this.values = values;}</code></pre><pre><code class="xml">&lt;bean id=&quot;propertiesBean&quot; class=&quot;&quot;&gt;    &lt;property name=&quot;values&quot;&gt;        &lt;props value-type=&quot;int&quot; merge=&quot;default&quot;&gt;  &lt;!-- value-type 不生效，类型固定为 String --&gt;            &lt;prop key=&quot;1&quot;&gt;less&lt;/prop&gt;            &lt;prop key=&quot;2&quot;&gt;2&lt;/prop&gt;        &lt;/props&gt;    &lt;/property&gt;&lt;/bean&gt;&lt;!-- 另一种方式 --&gt;&lt;bean id=&quot;propertiesBean&quot; class=&quot;&quot;&gt;    &lt;property name=&quot;values&quot;&gt;        &lt;value&gt;            1=11            2=22            3=33        &lt;/value&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre><h3 id="设置属性（setter-注入）"><a href="#设置属性（setter-注入）" class="headerlink" title="设置属性（setter 注入）"></a>设置属性（setter 注入）</h3><p>使用 Spring XML 配置实现属性注入</p><pre><code class="java">public class CDPlayer {    private CompactDisc compactDisc;    @Autowired    public void setCd(CompactDisc compactDisc){        this.compactDisc = compactDisc;    }    public void play() {        compactDisc.play();    }}</code></pre><p>该选择构造器注入还是属性注入呢？作为一个通用的规则，我倾向于对强依赖使用构造器注入，而对可选性的依赖使用属性注入。</p><pre><code class="xml">&lt;!-- CDPlayer 没有任何的构造器(除了隐含的默认构造器),可以采用如下的方式将其声明为 Spring bean --&gt;&lt;bean id=&quot;cdPlayer&quot; class=&quot;springaction02.CDPlayer&quot; /&gt;</code></pre><p>Spring 在创建 bean 的时候不会有任何问题，但是 CDPlayTest 会因为出现 NullPointException 而导致测试失败，因为我们并没有出入 CDPlayer 的 compactDisc 属性。不过按照下面的方式修改XML，就能解决该问题</p><pre><code class="xml">&lt;bean id=&quot;cdPlayer&quot; class=&quot;springaction02.CDPlayer&quot;&gt;    &lt;property name=&quot;compactDisc&quot; ref=&quot;compactDisc&quot;/&gt;    &lt;!-- &lt;property name=&quot;test&quot; value=&quot;test&quot;/&gt; --&gt;    &lt;!-- 如果是字面量，则使用 value --&gt;    &lt;!-- 如果是 list，也同样和构造器注入类似    &lt;propert name=&quot;listTest&quot;&gt;      &lt;list&gt;        &lt;value&gt;11&lt;/value&gt;        &lt;value&gt;22&lt;/value&gt;        &lt;value&gt;33&lt;/value&gt;      &lt;/list&gt;    &lt;/propert&gt;    --&gt;&lt;/bean&gt;</code></pre><p>替代 <code>&lt;property&gt;</code> 元素方案，<code>p-</code> 命名空间，需在 XML 文件中进行声明</p><pre><code class="xml">xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</code></pre><p>使用 <code>p-</code> 命名空间，与 <code>c-</code> 命名空间类似</p><pre><code class="xml">&lt;bean id=&quot;cdPlayer&quot; class=&quot;springaction02.CDPlayer&quot;    p:compactDisc-ref=&quot;compactDisc&quot;/&gt;</code></pre><h3 id="util-命名空间"><a href="#util-命名空间" class="headerlink" title="util- 命名空间"></a><code>util-</code> 命名空间</h3><p>需在 XML 文件中进行声明</p><pre><code class="xml">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;       xmlns:util=&quot;http://www.springframework.org/schema/util&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/util        http://www.springframework.org/schema/beans/spring-util.xsd&quot;&gt;&lt;/beans&gt;</code></pre><p><code>util-</code> 命名空间所提供的功能之一就是 <code>&lt;util:list&gt;</code> 元素它会创建一个列表的 bean，借助 <code>&lt;util:list&gt;</code>，将其声明到单独的 bean 之中。</p><pre><code class="xml">&lt;util:list id=&quot;trackList&quot;&gt;  &lt;value&gt;111&lt;/value&gt;  &lt;value&gt;222&lt;/value&gt;  &lt;value&gt;333&lt;/value&gt;&lt;/util:list&gt;</code></pre><p>现在,我们能够像使用其他的 bean 那样,将磁道列表 bean 注入到 BlankDisc bean 的 tracks 属性中:</p><pre><code class="xml">&lt;bean id=&quot;compactDisc6&quot; class=&quot;springaction02.BlankDisc&quot;    p:title=&quot;Sgt. Pepper&#39;s Lonely Hearts Club Band&quot;    p:artist=&quot;The Beatles&quot;    p:tracks-ref=&quot;trackList&quot;/&gt;</code></pre><p>Spring <code>util-</code> 命名空间中的元素</p><ul><li><code>&lt;util:constant&gt;</code>：引用某个类型的 public static 域，并将其暴露为 bean</li><li><code>&lt;util:list&gt;</code>：创建一个 java.util.List 类型的 bean，其中包含值和引用</li><li><code>&lt;util:map&gt;</code> ：创建一个 java.util.Map 类型的 bean，其中包含值或引用。</li><li><code>&lt;util:properties&gt;</code>：创建一个 java.util.properteis 类型的 bean。</li><li><code>&lt;util：set&gt;</code>：创建一个 java.util.Set 类型的 bean，其中包含值或引用。</li></ul><h1 id="导入和混合配置"><a href="#导入和混合配置" class="headerlink" title="导入和混合配置"></a>导入和混合配置</h1><p>在典型的 Spring 应用中，我们可能同时使用自动化和显示配置。即便你更喜欢通过 JavaConfig 实现显示配置，但有时候 XML 确实最佳的方案。可以将 JavaConfig 的组件扫描和自动装配或 XMl 配置混合在一起。</p><h2 id="在-JavaConfig-中引用-XML-配置"><a href="#在-JavaConfig-中引用-XML-配置" class="headerlink" title="在 JavaConfig 中引用 XML 配置"></a>在 JavaConfig 中引用 XML 配置</h2><p>多个 JavaConfig 文件时，方法一，直接在其中一个文件使用 <code>@Import</code> 注解。</p><pre><code class="java">@Configuration@Import(CDConfig.class)public class CDPlayerConfig {    @Bean    public CDPlayer cdPlayer(CompactDisc compactDisc) {        return new CDPlayer(compactDisc);    }}</code></pre><p>方法二，创建一个更高级别的 SoundSystemConfig，在这个类中使用 <code>@Import</code> 将两个配置组合在一起。</p><pre><code class="java">@Configuration@Import({CDPlayerConfig.class,CDConfig.class})public class SoundSystemConfig {}</code></pre><p>现在将一部分配置在了 XML 中，我们该如何让 Spring 同时加载它和其他基于 Java 的配置呢？</p><pre><code class="java">@Configuration@Import(CDPlayerConfig.class)@ImportResource(&quot;classpath:cd-config.xml&quot;)public class SoundSystemConfig {}</code></pre><h2 id="在-XML-配置中引用-JavaConfig"><a href="#在-XML-配置中引用-JavaConfig" class="headerlink" title="在 XML 配置中引用 JavaConfig"></a>在 XML 配置中引用 JavaConfig</h2><p>在 XML 中，我们可以使用 <code>import</code> 元素来拆分 XML 配置。</p><pre><code class="xml">&lt;import resource=&quot;cd-config.xml&quot;/&gt;&lt;bean id=&quot;cdPlayer&quot;      class=&quot;springaction02.CDPlayer&quot;      c:cd-ref=&quot;compactDisc&quot; /&gt;</code></pre><p>为了将 JavaConfig 类导入到 XML 配置中，我们可以这样声明 bean：</p><pre><code class="xml">&lt;bean class=&quot;springaction02.CDConfig&quot;/&gt;&lt;bean id=&quot;cdPlayer&quot;      class=&quot;springaction02.CDPlayer&quot;      c:cd-ref=&quot;compactDisc&quot; /&gt;</code></pre><p>还可以声明一个更高级被的层次的配置文件，这个文件不声明任何 bean，只是负责将两个或多个配置文件组合在一起。</p><pre><code class="xml">&lt;bean class=&quot;springaction02.CDConfig&quot;/&gt;&lt;import resource=&quot;cdplayer-config.xml&quot;/&gt;</code></pre><h1 id="延迟初始化-Bean"><a href="#延迟初始化-Bean" class="headerlink" title="延迟初始化 Bean"></a>延迟初始化 Bean</h1><p>延迟初始化的 Bean 通常会在第一次使用时被初始化；</p><pre><code class="xml">&lt;bean id=&quot;helloApi&quot; class=&quot;&quot; lazy-init=&quot;true&quot;/&gt;</code></pre><h1 id="小节"><a href="#小节" class="headerlink" title="小节"></a>小节</h1><p><strong>Spring 的核心是 Spring 容器。</strong>容器负责管理应用中组件的生命周期，它会创建这些组件并保证他们的依赖能够得到满足，这样的话，组件才能完成预定的任务。</p><p>在本章中，我们看到了 Spring 中装配 bean 的三种方式：<strong>自动化装配、基于 Java 的显示配置、以及基于 XML 的显示配置</strong>。不管采用什么方式，这些技术都描述了 Spring 应用中的组件以及这些组件之间的关系。</p><p><strong>尽可能使用自动化配置</strong>，以避免显示配置所带来的维护成本。但是，如果确实需要显示的配置 Spring 的话，<strong>应该优先选择基于 Java 的配置，它比基于 XML 的配置更加强大、类型安全、并且易于重构。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Spring 实战》笔记1：Spring 之旅</title>
      <link href="/2019/04/13/%E3%80%8ASpring%20%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B01%EF%BC%9ASpring%20%E4%B9%8B%E6%97%85/"/>
      <url>/2019/04/13/%E3%80%8ASpring%20%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B01%EF%BC%9ASpring%20%E4%B9%8B%E6%97%85/</url>
      
        <content type="html"><![CDATA[<h2 id="首先阐述几个概念"><a href="#首先阐述几个概念" class="headerlink" title="首先阐述几个概念"></a>首先阐述几个概念</h2><blockquote><p><a href="http://sishuok.com/forum/blogPost/list/2426.html" target="_blank" rel="noopener">http://sishuok.com/forum/blogPost/list/2426.html</a></p></blockquote><ol><li><strong>应用程序</strong>：是能完成我们所需要功能的成品，比如购物网站、 OA 系统。</li><li><strong>框架</strong>：是能完成一定功能的半成品，比如我们可以使用框架进行购物网站开发；框架做一部分功能，我们自己做一部分功能，这样应用程序就创建出来了。而且框架规定了你在开发应用程序时的整体架构，提供了一些基础功能，还规定了类和对象的如何创建、如何协作等，从而简化我们开发，让我们专注于业务逻辑开发。</li><li><strong>非侵入式设计</strong>：从框架角度可以这样理解，无需继承框架提供的类，这种设计就可以看作是非侵入式设计，如果继承了这些框架类，就是侵入设计，如果以后想更换框架之前写过的代码几乎无法重用，如果非侵入式设计则之前写过的代码仍然可以继续使用。</li><li><strong>轻量级及重量级</strong>：轻量级是相对于重量级而言的，轻量级一般就是非入侵性的、所依赖的东西非常少、资源占用非常少、部署简单等等，其实就是比较容易使用，而重量级正好相反。</li><li><strong>POJO</strong> ： POJO （ Plain Old Java Objects ）简单的 Java 对象，它可以包含业务逻辑或持久化逻辑，但不担当任何特殊角色且不继承或不实现任何其它 Java 框架的类或接口。</li><li><strong>容器</strong>：在日常生活中容器就是一种盛放东西的器具，从程序设计角度看就是装对象的的对象，因为存在放入、拿出等操作，所以容器还要管理对象的生命周期。</li><li><strong>控制反转</strong>：即 Inversion of Control ，缩写为 IoC ，控制反转还有一个名字叫做依赖注入（ Dependency Injection ），就是由容器控制程序之间的关系，而非传统实现中，由程序代码直接操控。</li><li><strong>Bean</strong> ：一般指容器管理对象，在 Spring 中指 Spring IoC 容器管理对象。</li></ol><h2 id="简化-Java-开发"><a href="#简化-Java-开发" class="headerlink" title="简化 Java 开发"></a>简化 Java 开发</h2><p>为了降低 Java 开发的复杂性，Spring 采取了以下 4 种 关键策略：</p><ul><li>基于 POJO 的轻量级和最小侵入性编程</li><li>通过依赖注入和面向接口实现松耦合</li><li>基于切面和惯例进行声明式编程</li><li>通过切面和模板减少样板式代码</li></ul><a id="more"></a><h3 id="激发-POJO-的潜力"><a href="#激发-POJO-的潜力" class="headerlink" title="激发 POJO 的潜力"></a>激发 POJO 的潜力</h3><p>Spring 尽量避免让自己的 API 污染你的应用代码。Spring 不会强制要求开发人员实现某个 Spring 提供的接口或者继承某个 Spring 提供的类，在 Spring 应用中的 Java 类看起来和普通类一样，不过，Spring 现在经常使用注解来修饰 Java 类，但是这个类还是一个 POJO。</p><pre><code class="java">public class HelloWorldBean {    public String sayHello() {        return &quot;Hello World&quot;;    }}</code></pre><p>可以看出，这就是一个简单的 Java 类——POJO，没有什么特殊的标志表明它是一个 Spring 组件。Spring 这种非侵入式编程模型使得这个类在 Spring 和非 Spring 框架下具备相同的功能。</p><h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><p>依赖注入这个词让人望而生畏，现在已经演变成一项<strong>复杂的编程技巧或设计模式理念</strong>。</p><p>多个类之间进行协作来完成特定的业务。按照传统的方法，每个对象负责管理与自己相关的对象的引用，这将导致高度耦合和难以测试的代码。</p><pre><code class="java">public class DamselRescuingKnight implements Knight {    private RescueDamselQuest quest;    public DamselRescuingKnight() {        // 紧耦合        this.quest = new RescueDamselQuest();    }    @Override    public void embarkOnQuest() {        quest.embark();    }}</code></pre><p>耦合具有两面性：</p><ul><li>紧密耦合的代码难以测试，难以复用，难以理解，并且典型地表现出“打地鼠”式的 BUG 特性,（修复一个 bug，将会出现新的 bug).</li><li>一定的程度耦合又是必须的，完全没有耦合的代码什么都做不了。为了完成更有实际意义的功能，不同的类必须以适当的方式进行交互，总而言之，<strong>耦合是必须的，但需要谨慎对待</strong>。</li></ul><p>通过 DI，对象的依赖关系将由系统中负责协调各对象的第三方组件在创建对象的时候进行设定。对象无需自行创建或管理它们的依赖关系，如图，依赖关系将被自动注入到需要它们的对象中去。</p><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/007Eq6Awgy1g18gafbn85j30av07c0tc.jpg" alt="依赖注入会将所依赖的关系自动交给目标对象,而不是让对象自己去获取依赖"></p><p>BraveKnight 足够灵活，可以接受任何赋予他的探险任务。</p><pre><code class="java">public class BraveKnight implements Knight {    private Quest quest;    public BraveKnight(Quest quest) {  // Quest 被注入进来        this.quest = quest;    }    @Override    public void embarkOnQuest() {        quest.embarck();    }}</code></pre><p>BraveKnight 没有自行创建 Quest，而是在构造的时候把 Quest 作为构造参数传入。这是依赖注入的方式之一，即<strong>构造注入</strong>(constructor injection).</p><p>BraveKnight 没有有特定的 Quest 实现发生耦合。对他来说，被要求挑战的探险任务只要实现了 Quest 接口，那么具体的是那种类型就无关紧要了。这就是 DI 带来最大的收益——<strong>松耦合</strong>。</p><h4 id="将-Quest-注入到-Knight-中"><a href="#将-Quest-注入到-Knight-中" class="headerlink" title="将 Quest 注入到 Knight 中"></a>将 Quest 注入到 Knight 中</h4><pre><code class="java">public class SlayDragonQuest implements Quest{    private PrintStream stream;    public SlayDragonQuest(PrintStream stream) {        this.stream = stream;    }    @Override    public void embarck() {        stream.println(&quot;SlayDragonQuest embark!&quot;);    }}</code></pre><p>SlayDragonQuest 实现了 Quest 接口，这样就可以注入到 BraveKnight 中去了。SlayDragonQuest 在构造器中使用了更为通用的 PrintStream。</p><h4 id="装配"><a href="#装配" class="headerlink" title="装配"></a>装配</h4><p>创建应用组件之间协作的行为通常称为<strong>装配（wiring）</strong>。</p><p>不管使用的是基于 XML 的配置还是基于 Java 的配置，DI 所带来的收益都是相同的。</p><h5 id="使用-XML-装配"><a href="#使用-XML-装配" class="headerlink" title="使用 XML 装配"></a>使用 XML 装配</h5><pre><code class="xml">&lt;!-- knights.xml --&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean id=&quot;quest&quot; class=&quot;com.bin.spring.SlayDragonQuest&quot;&gt;        &lt;constructor-arg value=&quot;#{T(System).out}&quot;/&gt;        &lt;!--Spring表达式语言(Spring Expression Language)，SpEL中, 使用T()运算符会调用类作用域的方法和常量--&gt;    &lt;/bean&gt;    &lt;bean id=&quot;knight&quot; class=&quot;com.bin.spring.BraveKnight&quot;&gt;        &lt;constructor-arg ref=&quot;quest&quot;/&gt; &lt;!-- 注入 Quest --&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><p>测试</p><pre><code class="java">public class KnightMain {    public static void main(String[] args) {        // 加载 Spring 上下文        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;knights.xml&quot;);        Knight knight = context.getBean(Knight.class);        knight.embarkOnQuest();        context.close();    }}// SlayDragonQuest embark!</code></pre><h5 id="使用-Java-装配"><a href="#使用-Java-装配" class="headerlink" title="使用 Java 装配"></a>使用 Java 装配</h5><pre><code class="java">@Configurationpublic class KnightConfig {    @Bean    public Quest quest() {        return new SlayDragonQuest(System.out);    }    @Bean    public Knight knight() {        return new BraveKnight(quest());    }}</code></pre><p>测试</p><pre><code class="java">public class KnightMainJava {    public static void main(String[] args) {        KnightConfig config = new KnightConfig();        Knight knight = config.knight();        knight.embarkOnQuest();    }}// SlayDragonQuest embark!</code></pre><h3 id="应用切面"><a href="#应用切面" class="headerlink" title="应用切面"></a>应用切面</h3><p>DI 能够让相互协作的软件组件<strong>保持松耦合</strong>，而面向切面编程(aspect-oriented programming AOP) 允许你把遍布应用各处的<strong>功能分离出来形成可重用的组件</strong>。</p><p>面向切面编程往往被定义为促使软件系统实现<strong>关注点分离的</strong>一项技术。系统由许多不同的组件组成，每个组件各负责一块特定功能。除了自己的核心功能之外，这些组件还经常承担着额外的任务。如日志，事务管理和安全这样的系统服务经常融入到自身具有核心业务逻辑的组件中，这些系统服务通常被称为<strong>横切关注点</strong>，因为它们会<strong>跨越系统的多个组件</strong>。</p><p>如果讲这些组件分散到多个组件中，则会带来双重的复杂性。</p><ul><li>代码会重复出现在多个组件中。</li><li>组件会因为那些有自身的核心业务无关的代码而变得混乱。</li></ul><p><strong>AOP 能够使这些组件模块化，并以声明的方式将它们应用到它们需要影响的组件中去。</strong>这样这些组件就会具有更高的内聚性并且会更加关注自身的业务，完全不需要了解涉及系统服务所带来的复杂性。总之，AOP 能够确保 POJO 的简单性。</p><p>我们可以把切面想象为覆盖在很多组件之上的一个外壳。应用是有那些实现各自业务功能的模块组成的。借助 AOP，可以使用各种功能层去包裹核心业务层。这些层以声明的方式灵活地应用到系统中，你的核心应用甚至根本不知道它们的存在。这是一个非常强大的理念，<strong>可以将安全、事务和日志关注点和核心业务逻辑相分离</strong>。</p><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/007Eq6Awgy1g25zezqgazj30fw0a33yw.jpg" alt="利用 AOP，系统范围内的关注点覆盖在它们所影响的组件之上"></p><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>使用咏游诗人这个服务类来记载骑士的所有事迹。</p><pre><code class="java">// 咏游诗人public class Minstrel {    private PrintStream stream;    public Minstrel(PrintStream stream) {        this.stream = stream;    }    public void singBeforeQuest() {        stream.println(&quot;探险前！&quot;);    }    public void singAfterQuest() {        stream.println(&quot;探险后！&quot;);    }}</code></pre><p>以前做法</p><pre><code class="java">public class BraveKnight implements Knight {    private Quest quest;    private Minstrel minstrel;    // 通过构造器来注入 Minstrel    public BraveKnight(Quest quest, Minstrel minstrel) {        this.quest = quest;        this.minstrel = minstrel;    }    @Override    public void embarkOnQuest() {        minstrel.singBeforeQuest();        quest.embarck();        minstrel.singAfterQuest();    }}</code></pre><p>这样可以达到预期效果。但 Knight 不应该管理咏游诗人。</p><p>利用 AOP，你可以声明咏游诗人必须歌颂骑士的探险事迹，而骑士本身不直接访问 Minstrel 的方法</p><p>对前文中 knights.xml 文件进行修改</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/aop       http://www.springframework.org/schema/aop/spring-aop-3.2.xsd       http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean id=&quot;quest&quot; class=&quot;com.bin.spring.SlayDragonQuest&quot;&gt;        &lt;constructor-arg value=&quot;#{T(System).out}&quot;/&gt;    &lt;/bean&gt;    &lt;bean id=&quot;knight&quot; class=&quot;com.bin.spring.BraveKnight&quot;&gt;        &lt;constructor-arg ref=&quot;quest&quot;/&gt;    &lt;/bean&gt;    &lt;bean id=&quot;minstrel&quot; class=&quot;com.bin.spring.Minstrel&quot;&gt;        &lt;constructor-arg value=&quot;#{T(System).out}&quot;/&gt;    &lt;/bean&gt;    &lt;aop:config&gt;        &lt;aop:aspect ref=&quot;minstrel&quot;&gt;            &lt;!--定义切点，Aspect 切点表达式--&gt;            &lt;aop:pointcut id=&quot;embark&quot; expression=&quot;execution(* *.embarkOnQuest(..))&quot;/&gt;            &lt;!--声明前置通知--&gt;            &lt;aop:before method=&quot;singBeforeQuest&quot; pointcut-ref=&quot;embark&quot;/&gt;            &lt;!--声明后置通知--&gt;            &lt;aop:after method=&quot;singAfterQuest&quot; pointcut-ref=&quot;embark&quot;/&gt;        &lt;/aop:aspect&gt;    &lt;/aop:config&gt;&lt;/beans&gt;</code></pre><p>Minstrel 仍然是一个 POJO，没有任何代码表明它要被作为一个切面使用，其次最重要的是 Minstrel 可以被应用到 BraveKnight 中，而 BraveKnight 不需要显示的调用它，实际上，BraveKnight 完全不知道 MInstrel 的存在</p><p>再次运行 KnightMain 测试</p><pre><code class="log">探险前！SlayDragonQuest embark!探险后！</code></pre><h3 id="使用模板消除样板式代码"><a href="#使用模板消除样板式代码" class="headerlink" title="使用模板消除样板式代码"></a>使用模板消除样板式代码</h3><p>在编程过程中有没有感觉经常需要写重复无用的代码才能实现简单的功能，最经典的例子是 JDBC 的使用，这些代码就是样板式代码（boilerplate code）。</p><p>Spring 试图通过模板来消除重复代码，这里所用的是模板设计模式。对于 JDBC 接口，Spring 提供了 JdbcTemplate 模板来消除上面那个代码片段中的样板式代码，例子代码如下：</p><pre><code class="java">public Employee getEmployeeById(long id) {    return jdbcTemplate.queryForObject(            &quot;select id, name from employee where id=?&quot;, // sql 查询            new RowMapper&lt;Employee&gt;() {                public Employee mapRow(ResultSet resultSet, int rowNum) throws SQLException {                    // 将结果匹配为对象                    Employee employee = new Employee();                    employee.setId(resultSet.getLong(&quot;id&quot;));                    employee.setName(resultSet.getString(&quot;name&quot;));                    return employee;                }            }, id);  // 指定查询参数}</code></pre><h2 id="容纳你的-Bean"><a href="#容纳你的-Bean" class="headerlink" title="容纳你的 Bean"></a>容纳你的 Bean</h2><p>在基于 Spring 的应用中，你的应用对象存在于 Spring 容器(container)中。Spring 负责创建对象，装配它们，配置它们并管理它们的整个生命周期，从生存到死亡(new 到 finalize())。</p><p>容器是 Spring 框架的核心。Spring 容器使用 DI 管理构成应用的组件，它会创建相互协作的组件之间的联系。</p><p>Spring 容器的两种类型：</p><ul><li>bean 工厂（由 org.springframework.beans.factory.BeanFactory 接口定义）是最简单的容器，提供基本的 DI 支持。对于大多数应用来说太低级，一般不用。</li><li>应用上下文（由 org.springframework.context.ApplicationContext 接口定义）基于 BeanFactory 构建，并提供应用框架级别的服务。</li></ul><h3 id="使用应用上下文"><a href="#使用应用上下文" class="headerlink" title="使用应用上下文"></a>使用应用上下文</h3><p>Spring 自带了多种应用上下文：</p><ul><li>AnnotationConfigApplicationContext：从一个或多个基于 Java 的配置文件类中加载 Spring 应用上下文</li><li>AnnotationConfigWebApplicationContext：从一个或多个基于 Java 配置类加载 Spring Web 应用上下文</li><li>ClassPathXmlApplicationContext：从类路径下的一个或多个 XML 配置文件中加载上下文定义，把应用上下文的定义文件作为类资源</li><li>FileSystemXmlapplicationContext：从文件系统下的一个或多个 XMl 配置文件中加载上下文定义。</li><li>XmlWebapplicationContext：从 web 应用下的一个或多个 XML 配置文件中加载上下文定义。</li><li>XmlBeanFactory ： BeanFactory 实现，提供基本的 IoC 容器功能，可以从 classpath 或文件系统等获取资源。</li></ul><p>无论是从文件系统中装配应用上下文还是从类路径下装配应用上下文，将 bean 加载到 bean 工厂的过程都是相似的。</p><pre><code class="java">ApplicationContext context =        new FileSystemXmlApplicationContext(&quot;c:/knight.xml&quot;);APPlicationContext context2 =        new ClassPathXmlApplicationContext(&quot;knight.xml&quot;);// 使用 Java 配置中加载上下文APPlicationContext context3 =        new AnnotationConfigApplicationContext(com.bin.spring.KnightConfig.class);File file = new File(&quot;knight.xml&quot;);Resource resource = new FileSystemResource(file);BeanFactory beanFactory = new XmlBeanFactory(resource);Resource resource = new ClassPathResource(&quot;knight.xml&quot;);BeanFactory beanFactory = new XmlBeanFactory(resource);</code></pre><p>应用上下文准备就绪之后，我们就可以调用上下文的 <code>getBean()</code> 方法从 Spring 容器中获取 bean。</p><ul><li><code>Object getBean(String name)</code> 根据名称返回一个 Bean ，客户端需要自己进行类型转换；</li><li><code>T getBean(String name, Class&lt;T&gt; requiredType)</code> 根据名称和指定的类型返回一个 Bean ，客户端无需自己进行类型转换，如果类型转换失败，容器抛出异常；</li><li><code>T getBean(Class&lt;T&gt; requiredType)</code> 根据指定的类型返回一个 Bean ，客户端无需自己进行类型转换，如果没有或有多于一个 Bean 存在容器将抛出异常；</li><li><code>Map&lt;String, T&gt; getBeansOfType(Class&lt;T&gt; type)</code> 根据指定的类型返回一个键值为名字和值为 Bean 对象的 Map ，如果没有 Bean 对象存在则返回空的 Map 。</li></ul><h3 id="bean-的生命周期"><a href="#bean-的生命周期" class="headerlink" title="bean 的生命周期"></a>bean 的生命周期</h3><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/007Eq6Awly1g274b7bkg5j30o60ei0xz.jpg" alt=""></p><p>在bean工厂执行力若干启动步骤；</p><ol><li>Spring 对 bean 进行实例化;</li><li>Spring 将值和 bean 的引用注入到 bean 对应的属性中;</li><li>如果 bean 实现了 BeanNameAware 接口，Spring 将 bean 的 ID 传给 setBeanName()方法;</li><li>如果 bean 实现了 BeanFactoryAware 接口，Spirng 将调用 setBeanFatory() 方法，将 BeanFactory 容器实例传入;</li><li>如果 bean 实现了 ApplicationContextAware 接口，Spring 将调用 setApplicationContext() 方法，将 bean 所在的应用上下文的引用传入进来;</li><li>如果 bean 实现了 BeanPostProcessor 接口，Spring 将调用它们的 postProcessBeforeInitialization() 方法;</li><li>如果 bean 实现了 InitializingBean 接口，Spring 将调用它们的 afterPropertiesSet() 方法。类似的，如果 bean 使用 init-method 声明了初始化方法，该方法也会被调用;</li><li>如果 bean 实现了 BeanPostProcessor 接口，Spring 将调用它们的 PostProcessAfterInitialization() 方法;</li><li>此时，bean 已经准备就绪，可以被应用程序使用了，他们将一直驻留在应用上下文中，直到该应用上下文被销毁。</li><li>如果 bean 实现了 DisposableBean 接口，Spring 将调用他的 destroy() 接口方法。同样，如果 bean 使用 destroy-mothod 声明销毁方法，该方法也会被调用。</li></ol><h3 id="Spring-的新功能"><a href="#Spring-的新功能" class="headerlink" title="Spring 的新功能"></a>Spring 的新功能</h3><h3 id="Spring-3-1-新特性"><a href="#Spring-3-1-新特性" class="headerlink" title="Spring 3.1 新特性"></a>Spring 3.1 新特性</h3><p>Spring 3.1 带来了多项有用的新特性和增强, 其中有很多都是关于如何简化和改善配置的。除此之外, Spring 3.1 还提供了声明式缓存的支持以及众多针对 SpringMVC 的功能增强。下面的列表展现了 Spring 3.1 重要的功能升级:</p><ul><li>为了解决各种环境下 (如开发、测试和生产) 选择不同配置的问题, Spring 3.1 引入了环境 profile 功能。借助于 profile, 就能根据应用部署在什么环境之中选择不同的数据源bean;</li><li>在 Spring 3.0 基于 Java 的配置之上, Spring 3.1 添加了多个 enable 注解, 这样就能使用这个注解启用 Spring 的特定功能;</li><li>添加了 Spring 对声明式缓存的支持, 能够使用简单的注解声明缓存边界和规则, 这与你以前声明事务边界很类似;</li><li>新添加的用于构造器注入的 c 命名空间, 它类似于 Spring 2.0 所提供的面向属性的 p 命名空间, p 命名空间用于属性注入, 它们都是非常简洁易用的;</li><li>Spring 开始支持 Servlet 3.0, 包括在基于 Java 的配置中声明 Servlet 和 Filter, 而不再借助于 web.xml;</li><li>改善 Spring 对 JPA 的支持, 使得它能够在 Spring 中完整地配置 JPA, 不必再使用 persistence.xml 文件。</li></ul><p>Spring 3.1 还包含了多项针对 Spring MVC 的功能增强:</p><ul><li>自动绑定路径变量到模型属性中;</li><li>提供了 @RequestMappingproduces 和 consumes 属性, 用于匹配请求中的 Accept 和 Content-Type 头部信息;</li><li>提供了 @RequestPart 注解, 用于将 multipart 请求中的某些部分绑定到处理器的方法参数中;</li><li>支持 flash 属性 (在 redirect 请求之后依然能够存活的属性) 以及用于在请求间存放 flash 属性的 RedirectAttributes 类型。</li></ul><h4 id="Spring-3-2-新特性"><a href="#Spring-3-2-新特性" class="headerlink" title="Spring 3.2 新特性"></a>Spring 3.2 新特性</h4><p>Spring 3.1 在很大程度上聚焦于配置改善以及其他的一些增强, 包括 SpringMVC 的增强, 而 Spring 3.2 是主要关注 Spring MVC 的一个发布版本。SpringMVC 3.2 带来了如下的功能提升:</p><ul><li>Spring 3.2 的控制器 (Controller) 可以使用 Servlet 3.0 的异步请求, 允许在一个独立的线程中处理请求, 从而将 Servlet 线程解放出来处理更多的请求;</li><li>引入了 Spring MVC 测试框架, 用于为控制器编写更为丰富的测试;</li><li>除了提升控制器的测试功能, Spring 3.2 还包含了基于 RestTemplate 的客户端的测试支持, 在测试的过程中, 不需要往真正的 REST 端点上发送请求;</li><li>@ControllerAdvice 注解能够将通用的 @ExceptionHandler、@ InitBinder 和 @ModelAttributes 方法收集到一个类中, 并应用到所有控制器上;</li><li>在 Spring 3.2 之前, 只能通过 ContentNegotiatingViewResolver 使用完整的内容协商 (full content negotiation) 功能。但是在 Spring 3.2 中, 完整的内容协商功能可以在整个Spring MVC 中使用, 即便是依赖于消息转换器 (message converter) 使用和产生内容的控制器方法也能使用该功能;</li><li>Spring MVC 3.2 包含了一个新的 @MatrixVariable 注解, 这个注解能够将请求中的矩阵变量 (matrix variable) 绑定到处理器的方法参数中;</li><li>基础的抽象类 AbstractDispatcherServletInitializer 能够非常便利地配置 DispatcherServlet, 而不必再使用 web.xml。与之类似, 当你希望通过基于 Java 的方式来配置 Spring 的时候, 可以使用 Abstract-AnnotationConfigDispatcherServletInitializer 的子类;</li><li>新增了 ResponseEntityExceptionHandler, 可以用来替代 DefaultHandlerException Resolver。ResponseEntityExceptionHandler 方法会返回 <code>ResponseEntity&lt;Object&gt;</code>, 而不是 ModelAndView;</li><li>RestTemplate 和 @RequestBody 的参数可以支持范型;</li><li>RestTemplate 和 @RequestMapping 可以支持 HTTP PATCH 方法;</li><li>在拦截器匹配时, 支持使用 URL 模式将其排除在拦截器的处理功能之外。</li></ul><p>虽然 Spring MVC 是 Spring 3.2 改善的核心内容, 但是它依然还增加了多项非 MVC 的功能改善。下面列出了 Spring 3.2 中几项最为有意思的新特性:</p><ul><li>@Autowired、@Value 和 @Bean 注解能够作为元注解, 用于创建自定义的注入和 bean 声明注解;</li><li>@DateTimeFormat 注解不再强依赖 JodaTime。如果提供了 JodaTime, 就会使用它, 否则的话, 会使用 SimpleDateFormat;</li><li>Spring 的声明式缓存提供了对 JCache 0.5 的支持;</li><li>支持定义全局的格式来解析和渲染日期与时间;</li><li>在集成测试中, 能够配置和加载 WebApplicationContext;</li><li>在集成测试中, 能够针对 request 和 session 作用域的 bean 进行测试。在本书的多个章节中, 都能看到 Spring 3.2 的特性, 尤其是在 Web 和 REST 相关的章节中。</li></ul><h4 id="Spring-4-0-新特性"><a href="#Spring-4-0-新特性" class="headerlink" title="Spring 4.0 新特性"></a>Spring 4.0 新特性</h4><ul><li>Spring 提供了对 WebSocket 编程的支持, 包括支持 JSR-356——Java API for WebSocket;</li><li>鉴于 WebSocket 仅仅提供了一种低层次的 API, 急需高层次的抽象, 因此 Spring 4.0 在 WebSocket 之上提供了一个高层次的面向消息的编程模型, 该模型基于 SockJS, 并且包含了对 STOMP 协议的支持;</li><li>新的消息 (messaging) 模块, 很多的类型来源于 Spring Integration 项目。这个消息模块支持 Spring 的 SockJS/STOMP 功能, 同时提供了基于模板的方式发布消息;</li><li>支持 Java 8 特性, 比如它所支持的 lambda 表达式。别的暂且不说, 这首先能够让使用特定的回调接口 (如 RowMapper 和 JdbcTemplate) 更加简洁, 代码更加易读;</li><li>与 Java 8 同时得到支持的是 JSR-310——Date 与 Time API, 在处理日期和时间时, 它为开发者提供了比 java.util.Date 或 java.util.Calendar 更丰富的 API;</li><li>为 Groovy 开发的应用程序提供了更加顺畅的编程体验, 尤其是支持非常便利地完全采用 Groovy 开发 Spring 应用程序。随这些一起提供的是来自于 Grails 的 BeanBuilder, 借助它能够通过 Groovy 配置 Spring 应用;</li><li>添加了条件化创建 bean 的功能, 在这里只有开发人员定义的条件满足时, 才会创建所声明的 bean;</li><li>Spring 4.0 包含了 Spring RestTemplate 的一个新的异步实现, 它会立即返回并且允许在操作完成后执行回调;</li><li>添加了对多项 JEE 规范的支持, 包括 JMS 2.0、JTA 1.2、JPA 2.1 和 Bean Validation 1.1。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 8新特性(10) StringJoiner</title>
      <link href="/2019/03/13/Java%208%E6%96%B0%E7%89%B9%E6%80%A7(10)%20StringJoiner/"/>
      <url>/2019/03/13/Java%208%E6%96%B0%E7%89%B9%E6%80%A7(10)%20StringJoiner/</url>
      
        <content type="html"><![CDATA[<p>原有的 StringBuilder 太死板，不支持分割，如果想让最终的字符串以逗号隔开，需要这样写</p><pre><code class="java">StringBuilder sb = new StringBuilder();IntStream.range(1,10).forEach(i-&gt;{    sb.append(i+&quot;&quot;);    if( i &lt; 10){        sb.append(&quot;,&quot;)    }});</code></pre><a id="more"></a><p>是不是太死板了，不好用，StringJoiner 怎样写呢？</p><pre><code class="java">StringJoiner sj = new StringJoiner(&quot;,&quot;);IntStream.range(1,10).forEach(i-&gt;sj.add(i+&quot;&quot;));  // 1,2,3,4,5,6,7,8,9// 还可以加前缀后缀StringJoiner sj = new StringJoiner(&quot;,&quot;, &quot;[&quot;, &quot;]&quot;);IntStream.range(1,10).forEach(i-&gt;sj.add(i+&quot;&quot;));  // [1,2,3,4,5,6,7,8,9]</code></pre><h2 id="String-的新方法"><a href="#String-的新方法" class="headerlink" title="String 的新方法"></a>String 的新方法</h2><pre><code class="java">String.join(&quot;:&quot;, &quot;foobar&quot;, &quot;foo&quot;, &quot;bar&quot;);// foobar:foo:bar// 源码也是使用了 StringJoinerpublic static String join(CharSequence delimiter, CharSequence... elements) {    Objects.requireNonNull(delimiter);    Objects.requireNonNull(elements);    // Number of elements not likely worth Arrays.stream overhead.    StringJoiner joiner = new StringJoiner(delimiter);    for (CharSequence cs: elements) {        joiner.add(cs);    }    return joiner.toString();}</code></pre><h2 id="Collector-joining"><a href="#Collector-joining" class="headerlink" title="Collector.joining"></a>Collector.joining</h2><pre><code class="java">String [] strArray = new String[] {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;};String s = Stream.of(strArray).collect(Collectors.joining(&quot;,&quot;));// 实现原理也是借助了 StringJoinerpublic static Collector&lt;CharSequence, ?, String&gt; joining(CharSequence delimiter,                                                            CharSequence prefix,                                                            CharSequence suffix) {    return new CollectorImpl&lt;&gt;(            () -&gt; new StringJoiner(delimiter, prefix, suffix),            StringJoiner::add, StringJoiner::merge,            StringJoiner::toString, CH_NOID);}</code></pre><h2 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h2><ul><li><code>setEmptyValue</code>：默认情况下的 emptyValue 是前缀加后缀， 用户可自定义 emptyValue</li><li><code>merge(StringJoiner other)</code>：合并另外一个 joiner</li><li><code>length</code>：当前长度，为空看 emptyValue 的长度</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://www.jianshu.com/p/469fe8fdd3be" target="_blank" rel="noopener">https://www.jianshu.com/p/469fe8fdd3be</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 8新特性(9) 重复注解</title>
      <link href="/2019/03/13/Java%208%E6%96%B0%E7%89%B9%E6%80%A7(9)%20%E9%87%8D%E5%A4%8D%E6%B3%A8%E8%A7%A3/"/>
      <url>/2019/03/13/Java%208%E6%96%B0%E7%89%B9%E6%80%A7(9)%20%E9%87%8D%E5%A4%8D%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>Java 8中的注解允许在同一申明类型（类，属性，或方法）的多次使用同一个注解。</p><p>首先，我们定义一个包装注解，它包括了一个实际注解的数组</p><pre><code class="java">@Retention(RetentionPolicy.RUNTIME)@interface Hints {    Hint[] value();}@Repeatable(Hints.class)@Retention(RetentionPolicy.RUNTIME)@interface Hint {    String value();}</code></pre><p>只要在前面加上注解名：<code>@Repeatable</code>，Java 8 允许我们对同一类型使用多重注解</p><a id="more"></a><pre><code class="java">// 变体1：使用注解容器（老方法）@Hints({@Hint(&quot;hint1&quot;), @Hint(&quot;hint2&quot;)})class Person {}// 变体2：使用可重复注解（新方法）@Hint(&quot;hint1&quot;)@Hint(&quot;hint2&quot;)class Person {}</code></pre><p>使用变体2，Java 编译器能够在内部自动对 <code>@Hint</code> 进行设置。这对于通过反射来读取注解信息来说，是非常重要的。</p><pre><code class="java">Hint hint = Person.class.getAnnotation(Hint.class);System.out.println(hint);                   // nullHints hints1 = Person.class.getAnnotation(Hints.class);System.out.println(hints1.value().length);  // 2Hint[] hints2 = Person.class.getAnnotationsByType(Hint.class);System.out.println(hints2.length);          // 2</code></pre><p>尽管我们绝对不会在 Person 类上声明 <code>@Hints</code> 注解，但是它的信息仍然可以通过 <code>getAnnotation(Hints.class)</code> 来读取。并且，<code>getAnnotationsByType</code> 方法会更方便，因为它赋予了所有 <code>@Hints</code> 注解标注的方法直接的访问权限。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>Java 8 API 示例：字符串、数值、算术和文件，并发：<br><a href="https://wizardforcel.gitbooks.io/modern-java/content/" target="_blank" rel="noopener">https://wizardforcel.gitbooks.io/modern-java/content/</a></p><p>精简的JRE详解：<br><a href="https://my.oschina.net/benhaile/blog/211804" target="_blank" rel="noopener">https://my.oschina.net/benhaile/blog/211804</a></p><p>跟OOM：Permgen说再见吧：<br><a href="https://my.oschina.net/benhaile/blog/214159" target="_blank" rel="noopener">https://my.oschina.net/benhaile/blog/214159</a></p><p>StampedLock将是解决同步问题的新宠：<br><a href="https://my.oschina.net/benhaile/blog/264383" target="_blank" rel="noopener">https://my.oschina.net/benhaile/blog/264383</a></p><p>Nashorn ：新犀牛：<br><a href="https://my.oschina.net/benhaile/blog/290276" target="_blank" rel="noopener">https://my.oschina.net/benhaile/blog/290276</a></p><p>类型注解 复杂还是便捷：<br><a href="https://my.oschina.net/benhaile/blog/179642" target="_blank" rel="noopener">https://my.oschina.net/benhaile/blog/179642</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 8新特性(8) Base64</title>
      <link href="/2019/03/13/Java%208%E6%96%B0%E7%89%B9%E6%80%A7(8)%20Base64/"/>
      <url>/2019/03/13/Java%208%E6%96%B0%E7%89%B9%E6%80%A7(8)%20Base64/</url>
      
        <content type="html"><![CDATA[<p>在 JDK1.6 之前，JDK 核心类一直没有 Base64 的实现类，可以使用用 Sun/Oracle JDK 里面的 sun.misc.BASE64Encoder 和 sun.misc.BASE64Decoder，使用它们的优点就是不需要依赖第三方类库，缺点就是可能在未来版本会被删除（用 maven 编译会发出警告），而且性能不佳。</p><p>JDK1.6 中添加了另一个 Base64 的实现，javax.xml.bind.DatatypeConverter 两个静态方法 parseBase64Binary 和 printBase64Binary，隐藏在 javax.xml.bind 包下面，不被很多开发者知道。</p><p>JDK8 java.util.Base64 提供了一套静态方法获取下面三种 BASE64 编解码器：</p><a id="more"></a><h2 id="Basic-编码"><a href="#Basic-编码" class="headerlink" title="Basic 编码"></a>Basic 编码</h2><p>是标准的 BASE64 编码，用于处理常规的需求</p><pre><code class="java">// 编码String asB64 = Base64.getEncoder().encodeToString(&quot;some string&quot;.getBytes(&quot;utf-8&quot;));System.out.println(asB64);  // c29tZSBzdHJpbmc=// 解码byte[] asBytes = Base64.getDecoder().decode(&quot;c29tZSBzdHJpbmc=&quot;);System.out.println(new String(asBytes, &quot;utf-8&quot;));  // some string</code></pre><h2 id="URL-编码"><a href="#URL-编码" class="headerlink" title="URL 编码"></a>URL 编码</h2><p>使用下划线替换 URL 里面的反斜线 <code>/</code></p><pre><code class="java">// 编码String urlEncoded = Base64.getUrlEncoder().encodeToString(&quot;subjects?abcd&quot;.getBytes(&quot;utf-8&quot;));System.out.println(urlEncoded);  // c3ViamVjdHM_YWJjZA==// 解码new String(Base64.getUrlDecoder().decode(urlEncoded), &quot;utf-8&quot;);  // subjects?abcd</code></pre><h2 id="MIME-编码"><a href="#MIME-编码" class="headerlink" title="MIME 编码"></a>MIME 编码</h2><p>使用基本的字母数字产生 BASE64 输出，而且对 MIME 格式友好：每一行输出不超过 76 个字符，而且每行以 <code>\r\n</code> 符结束。</p><pre><code class="java">// 编码StringBuilder sb = new StringBuilder();for (int t = 0; t &lt; 10; ++t) {  sb.append(UUID.randomUUID().toString());}byte[] toEncode = sb.toString().getBytes(&quot;utf-8&quot;);String mimeEncoded = Base64.getMimeEncoder().encodeToString(toEncode);System.out.println(mimeEncoded);// ZDRlYWEwM2YtZTFhMy00ODhlLTkxYTctYzhlMGIyZDE2MTZkNTE1NDY1MjctYTNmOS00NGI5LTk2// NjEtOWJmYTNmMGFmMTkzNjY5N2Q2ZTEtY2E5My00ZmViLWE2ZWUtNjkzMGEzMzlkZGEyZTQyZTZi// M2QtMGM4YS00YTM2LWIwY2EtNjM4MzVjNjkyOTliYzUxOTkxZjMtY2Y0OC00ODk4LTkyM2EtNzhi// MjE5OGQzNmQ2ZThiNTNlZWUtYzYxMS00OTAxLWI0MmYtNGQ1YzgzNTYxZDkwYzk2Y2IzMTktOGJl// ZS00NjBkLTk1ZTAtNDM5Y2NiM2UyZDc0ZjM5ZDFjNjMtMzY1OS00MDEwLTlmOTUtZWEwYzMyOTc5// NDUzNWYxOTQ4ODQtMDczNi00MjllLWIxZmItNTgzMmY1NDBkOWMwN2VlOTE0OGYtMDhiNS00OWUz// LTk4MzQtODkxYTNmY2IxYzU0// 解码new String(Base64.getMimeDecoder().decode(mimeEncoded), &quot;utf-8&quot;);// d4eaa03f-e1a3-488e-91a7-c8e0b2d1616d51546527-a3f9-44b9-9661-9bfa3f0af1936697d6e1-ca93-4feb-a6ee-6930a339dda2e42e6b3d-0c8a-4a36-b0ca-63835c69299bc51991f3-cf48-4898-923a-78b2198d36d6e8b53eee-c611-4901-b42f-4d5c83561d90c96cb319-8bee-460d-95e0-439ccb3e2d74f39d1c63-3659-4010-9f95-ea0c329794535f194884-0736-429e-b1fb-5832f540d9c07ee9148f-08b5-49e3-9834-891a3fcb1c54</code></pre><p><code>static Base64.Encoder getMimeEncoder(int lineLength, byte[] lineSeparator)</code></p><p>返回一个 Base64.Encoder ，编码使用 MIME 型 base64 编码方案，可以通过参数指定每行的长度及行的分隔符。</p><pre><code class="java">Base64.getMimeEncoder(80, &quot;, &quot;.getBytes(&quot;utf-8&quot;)).encodeToString(toEncode);  // 每行 80 个字符，以“, ”分隔</code></pre><blockquote><p><a href="https://my.oschina.net/benhaile/blog/267738" target="_blank" rel="noopener">https://my.oschina.net/benhaile/blog/267738</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 8新特性(7) 时间日期API</title>
      <link href="/2019/03/13/Java%208%E6%96%B0%E7%89%B9%E6%80%A7(7)%20%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9FAPI/"/>
      <url>/2019/03/13/Java%208%E6%96%B0%E7%89%B9%E6%80%A7(7)%20%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9FAPI/</url>
      
        <content type="html"><![CDATA[<p>在Java 8之前，所有关于时间和日期的API都存在各种使用方面的缺陷，主要有：</p><ol><li>Java 的 java.util.Date 和 java.util.Calendar 类易用性差，不支持时区，而且他们都不是线程安全的；</li><li>用于格式化日期的类 DateFormat 被放在 java.text 包中，它是一个抽象类，所以我们需要实例化一个 SimpleDateFormat 对象来处理日期格式化，并且 DateFormat 也是非线程安全，这意味着如果你在多线程程序中调用同一个 DateFormat 对象，会得到意想不到的结果。</li><li>对日期的计算方式繁琐，而且容易出错，因为月份是从 0 开始的，从 Calendar 中获取的月份需要加一才能表示当前月份。</li></ol><h2 id="JSR310"><a href="#JSR310" class="headerlink" title="JSR310"></a>JSR310</h2><p>以上种种，导致目前有些第三方的 java 日期库诞生，比如广泛使用的 JODA-TIME，还有 Date4j 等，虽然第三方库已经足够强大，好用，但还是有兼容问题的，比如标准的 JSF 日期转换器与 joda-time API 就不兼容，你需要编写自己的转换器，所以标准的 API 还是必须的，于是就有了 JSR310。</p><p>JSR 310 实际上有两个日期概念。第一个是 <code>Instant</code>，它大致对应于 java.util.Date 类，因为它代表了一个确定的时间点，即相对于标准 Java 纪元（1970年1月1日）的偏移量；但与 java.util.Date 类不同的是其精确到了纳秒级别。</p><p>第二个对应于人类自身的观念，比如 <code>LocalDate</code> 和 <code>LocalTime</code>。他们代表了一般的时区概念，要么是日期（不包含时间），要么是时间（不包含日期），类似于 java.sql 的表示方式。此外，还有一个 <code>MonthDay</code>，它可以存储某人的生日（不包含年份）。每个类都在内部存储正确的数据而不是像 java.util.Date 那样利用午夜 12 点来区分日期，利用 1970-01-01 来表示时间。</p><p>目前 Java8 已经实现了 JSR310 的全部内容。新增了 java.time 包定义的类表示了日期-时间概念的规则，包括 instants, durations, dates, times, time-zones and periods。这些都是基于 ISO 日历系统，它又是遵循 Gregorian 规则的。<strong>最重要的一点是值不可变，且线程安全</strong>，通过下面一张图，我们快速看下 java.time 包下的一些主要的类的值的格式，方便理解。</p><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/007Eq6Awly1g0ipfw6avzj30po0c3dhm.jpg" alt=""></p><a id="more"></a><h2 id="方法概览"><a href="#方法概览" class="headerlink" title="方法概览"></a>方法概览</h2><p>该包的 API 提供了大量相关的方法，这些方法一般有一致的方法前缀：</p><ul><li><code>of</code>：静态工厂方法。</li><li><code>parse</code>：静态工厂方法，关注于解析。</li><li><code>get</code>：获取某些东西的值。</li><li><code>is</code>：检查某些东西的是否是 true。</li><li><code>with</code>：不可变的 setter 等价物。</li><li><code>plus</code>：加一些量到某个对象。</li><li><code>minus</code>：从某个对象减去一些量。</li><li><code>to</code>：转换到另一个类型。</li><li><code>at</code>：把这个对象与另一个对象组合起来，例如： date.atTime(time)。</li></ul><h2 id="与旧的-API-对应关系"><a href="#与旧的-API-对应关系" class="headerlink" title="与旧的 API 对应关系"></a>与旧的 API 对应关系</h2><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/007Eq6Awly1g0ipo39i08j30or0c2jsu.jpg" alt=""></p><h2 id="Clock"><a href="#Clock" class="headerlink" title="Clock"></a>Clock</h2><p>时钟，类似于钟表的概念，提供了如系统时钟、固定时钟、特定时区的时钟</p><pre><code class="java">//时钟提供给我们用于访问某个特定 时区的 瞬时时间、日期 和 时间的。// systemUTC，系统默认UTC时钟（当前瞬时时间 System.currentTimeMillis()）Clock c1 = Clock.systemUTC();System.out.println(c1.millis());  // 每次调用将返回当前瞬时时间（UTC），1551083737596// systemDefaultZone，系统默认时区时钟（当前瞬时时间）Clock c2 = Clock.systemDefaultZone();  // 1551083737682// systemClock c31 = Clock.system(ZoneId.of(&quot;Europe/Paris&quot;));  // 巴黎时区System.out.println(c31.millis());  // 1551083737684Clock c32 = Clock.system(ZoneId.of(&quot;Asia/Shanghai&quot;));  // 上海时区System.out.println(c32.millis());  // 1551083737684// fixed，固定时钟Clock c4 = Clock.fixed(Instant.now(), ZoneId.of(&quot;Asia/Shanghai&quot;));//固定上海时区时钟System.out.println(c4.millis());  // 1551083737684Thread.sleep(1000);System.out.println(c4.millis()); // 1551083737684，不变 即时钟时钟在那一个点不动// offsetClock c5 = Clock.offset(c1, Duration.ofSeconds(2));  // 相对于系统默认时钟两秒的时钟System.out.println(c1.millis());  // 1551083738685System.out.println(c5.millis());  // 1551083740685</code></pre><h2 id="Instant"><a href="#Instant" class="headerlink" title="Instant"></a>Instant</h2><p>瞬时时间，等价于以前的 <code>System.currentTimeMillis()</code></p><pre><code class="java">Instant instant1 = Instant.now();System.out.println(instant1.getEpochSecond());  // 1551085125，精确到秒 得到相对于1970-01-01 00:00:00 UTC的一个时间System.out.println(instant1.toEpochMilli());  // 1551085125192，精确到毫秒Clock clock1 = Clock.systemUTC();Instant instant2 = Instant.now(clock1);  // 得到时钟的瞬时时间System.out.println(instant2.toEpochMilli());  // 1551085125193Clock clock2 = Clock.fixed(instant1, ZoneId.systemDefault());  // 固定瞬时时间时钟Instant instant3 = Instant.now(clock2);  // 得到时钟的瞬时时间System.out.println(instant3.toEpochMilli());  // 1551085125192，equals instant1</code></pre><h2 id="LocalDateTime、LocalDate、LocalTime"><a href="#LocalDateTime、LocalDate、LocalTime" class="headerlink" title="LocalDateTime、LocalDate、LocalTime"></a>LocalDateTime、LocalDate、LocalTime</h2><pre><code class="java">// 使用默认时区时钟瞬时时间创建 Clock.systemDefaultZone() --&gt;即相对于 ZoneId.systemDefault()默认时区LocalDateTime now = LocalDateTime.now();  // 2019-03-10T16:01:04.890// 自定义时区LocalDateTime now2 = LocalDateTime.now(ZoneId.of(&quot;Europe/Paris&quot;));  // 2019-03-10T09:01:04.892// 自定义时钟Clock clock = Clock.system(ZoneId.of(&quot;Asia/Dhaka&quot;));LocalDateTime now3 = LocalDateTime.now(clock);  // 2019-03-10T14:01:04.906// 不需要写什么相对时间 如 java.util.Date 年是相对于1900 月是从 0 开始LocalDateTime d1 = LocalDateTime.of(2013, 12, 31, 23, 59);  // 2013-12-31 23:59// 年月日 时分秒 纳秒LocalDateTime d2 = LocalDateTime.of(2013, 12, 31, 23, 59, 59, 11);// 使用瞬时时间 + 时区Instant instant = Instant.now();LocalDateTime d3 = LocalDateTime.ofInstant(Instant.now(), ZoneId.systemDefault());  // 2019-03-10T16:01:04.906// 解析 String --&gt; LocalDateTimeLocalDateTime d4 = LocalDateTime.parse(&quot;2013-12-31T23:59&quot;);  // 2013-12-31T23:59// 999毫秒 等价于999000000纳秒LocalDateTime d5 = LocalDateTime.parse(&quot;2013-12-31T23:59:59.999&quot;);  // 2013-12-31T23:59:59.999// 使用 DateTimeFormatter API 解析 和 格式化DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy/MM/dd HH:mm:ss&quot;);LocalDateTime d6 = LocalDateTime.parse(&quot;2013/12/31 23:59:59&quot;, formatter);System.out.println(formatter.format(d6));  // 2013/12/31 23:59:59// 时间获取System.out.println(d6.getYear());  // 2013System.out.println(d6.getMonth());  // DECEMBERSystem.out.println(d6.getMonthValue());  // 12System.out.println(d6.getDayOfYear());  // 365System.out.println(d6.getDayOfMonth());  // 31System.out.println(d6.getDayOfWeek());  // TUESDAYSystem.out.println(d6.getHour());  // 23System.out.println(d6.getMinute());  // 59System.out.println(d6.getSecond());  // 59System.out.println(d6.getNano());  // 0// 时间增减LocalDateTime d7 = d6.minusDays(1);  // 2013-12-30T23:59:59// IsoFields.QUARTER_YEARS: 四分之一年LocalDateTime d8 = d7.plus(1, IsoFields.QUARTER_YEARS);  // 2014-03-30T23:59:59</code></pre><ul><li><code>LocalDate</code> 即年月日 无时分秒</li><li><code>LocalTime</code> 即时分秒 无年月日</li></ul><p>和 <code>LocalDateTime</code> 类似就不演示了</p><h1 id="ZonedDateTime"><a href="#ZonedDateTime" class="headerlink" title="ZonedDateTime"></a>ZonedDateTime</h1><p>即带有时区的 date-time 存储纳秒、时区和时差（避免与本地date-time歧义）。</p><p>API 和 LocalDateTime 类似，只是多了时差(如 2013-12-20T10:35:50.711+08:00[Asia/Shanghai])</p><pre><code class="java">ZonedDateTime now = ZonedDateTime.now();System.out.println(now);  // 2019-03-12T14:07:02.143+08:00[Asia/Shanghai]ZonedDateTime now2= ZonedDateTime.now(ZoneId.of(&quot;Europe/Paris&quot;));System.out.println(now2);  // 2019-03-12T07:07:02.146+01:00[Europe/Paris]// 其他的用法也是类似的 就不介绍了ZonedDateTime z1 = ZonedDateTime.parse(&quot;2013-12-31T23:59:59Z[Europe/Paris]&quot;);System.out.println(z1);  // 2013-12-31T23:59:59+01:00[Europe/Paris]</code></pre><h1 id="Duration"><a href="#Duration" class="headerlink" title="Duration"></a>Duration</h1><p>表示两个瞬时时间的时间段</p><pre><code class="java">Duration d1 = Duration.between(Instant.ofEpochMilli(System.currentTimeMillis() - 12323123), Instant.now());//得到相应的时差System.out.println(d1.toDays());  // 0System.out.println(d1.toHours());  // 3System.out.println(d1.toMinutes());  // 205System.out.println(d1.toMillis());  // 12323125System.out.println(d1.toNanos());  // 12323125000000//1天时差 类似的还有如ofHours()Duration d2 = Duration.ofDays(1);System.out.println(d2.toDays());  // 1</code></pre><h1 id="Chronology"><a href="#Chronology" class="headerlink" title="Chronology"></a>Chronology</h1><p>用于对年历系统的支持，是 java.util.Calendar 的替代者</p><pre><code class="java">Chronology c  = HijrahChronology.INSTANCE;ChronoLocalDateTime d = c.localDateTime(LocalDateTime.now());System.out.println(d);  // Hijrah-umalqura AH 1440-07-05T14:15:37.388</code></pre><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>如果提供了年、年月、月日、周期的 API 支持</p><pre><code class="java">Year year = Year.now();YearMonth yearMonth = YearMonth.now();MonthDay monthDay = MonthDay.now();System.out.println(year);  // 2019System.out.println(yearMonth);  // 2019-03System.out.println(monthDay);  //  --03-12// 周期，如表示 10 天前  3 年 5 个月前Period period1 = Period.ofDays(10);System.out.println(period1);  // P10DPeriod period2 = Period.of(3, 5, 0);System.out.println(period2);  // P3Y5M</code></pre><blockquote><p><a href="https://my.oschina.net/benhaile/blog/193956" target="_blank" rel="noopener">https://my.oschina.net/benhaile/blog/193956</a><br><a href="https://jinnianshilongnian.iteye.com/blog/1994164" target="_blank" rel="noopener">https://jinnianshilongnian.iteye.com/blog/1994164</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 8新特性(6) Map 新增方法</title>
      <link href="/2019/03/13/Java%208%E6%96%B0%E7%89%B9%E6%80%A7(6)%20Map%20%E6%96%B0%E5%A2%9E%E6%96%B9%E6%B3%95/"/>
      <url>/2019/03/13/Java%208%E6%96%B0%E7%89%B9%E6%80%A7(6)%20Map%20%E6%96%B0%E5%A2%9E%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>在 Java 8 中的 Map 接口增加了一些 default 方法，提升了对 key， value 操作的便利性。</p><pre><code class="java">Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;();for (int i = 0; i &lt; 10; i++) {    map.put(i, &quot;val&quot; + i);}</code></pre><h2 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h2><p>遍历 Map 中的所有 Entry, 对 key, value 进行处理， 接收参数 (K, V) -&gt; void</p><pre><code class="java">map.forEach((id, val) -&gt; System.out.println(val));// val0// val1// val2// ...</code></pre><a id="more"></a><h2 id="putIfAbsent"><a href="#putIfAbsent" class="headerlink" title="putIfAbsent"></a>putIfAbsent</h2><p>如果 key 存在，则返回 value 值，否则相当于普通 put 操作</p><pre><code class="java">map.putIfAbsent(3, &quot;123&quot;)  // val3，未更新map.putIfAbsent(33, &quot;val33&quot;)  // null，put// 相当于V v = map.get(key);if (v == null)    v = map.put(key, value);return v;</code></pre><h2 id="computeIfPresent"><a href="#computeIfPresent" class="headerlink" title="computeIfPresent"></a>computeIfPresent</h2><ol><li>如果指定的 key 存在，则根据旧的 key 和 value 计算新的值 newValue<ul><li>如果 newValue 不为 null，则设置 key 新的值为 newValue；</li><li>如果 newValue 为 null，则删除该 key 的值；</li></ul></li><li>key 不存在，返回 null。</li></ol><pre><code class="java">// 源码default V computeIfPresent(K key,        BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) {    Objects.requireNonNull(remappingFunction);    V oldValue;    if ((oldValue = get(key)) != null) {        V newValue = remappingFunction.apply(key, oldValue);        if (newValue != null) {            put(key, newValue);            return newValue;        } else {            remove(key);            return null;        }    } else {        return null;    }}</code></pre><pre><code class="java">// 如果 newValue 不为null，则设置 key 新的值为 newValuemap.computeIfPresent(3, (num, val) -&gt; val + num);  // val33map.get(3); // val33// 如果 newValue 为 null，则删除该 key 的值map.computeIfPresent(9, (num, val) -&gt; null);  // nullmap.containsKey(9);  // false</code></pre><h2 id="computeIfAbsent"><a href="#computeIfAbsent" class="headerlink" title="computeIfAbsent"></a>computeIfAbsent</h2><p>如果指定的 key 不存在，则通过指定的 <code>K -&gt; V</code> 计算出新的值设置为 key 的值，类似代码如下：</p><pre><code class="java">// 源码default V computeIfAbsent(K key,        Function&lt;? super K, ? extends V&gt; mappingFunction) {    Objects.requireNonNull(mappingFunction);    V v;    if ((v = get(key)) == null) {        V newValue;        if ((newValue = mappingFunction.apply(key)) != null) {            put(key, newValue);            return newValue;        }    }    return v;}</code></pre><pre><code class="java">map.computeIfAbsent(23, num -&gt; &quot;val&quot; + num);  // val23map.containsKey(23);  // truemap.computeIfAbsent(3, num -&gt; &quot;bam&quot;);  // val33map.get(3);  // val33</code></pre><h2 id="compute"><a href="#compute" class="headerlink" title="compute"></a>compute</h2><ol><li>则根据旧的 key 和 value 计算新的值 newValue</li><li>如果 newValue 不为 null，则 put(key, newValue); return newValue;</li><li>如果 newValue 为 null<ul><li>如果 key 存在，或 oldValue 为 null，则删除该 key，return null;</li><li>如果 key 不存在，则 return null</li></ul></li></ol><pre><code class="java">// 源码default V compute(K key,        BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) {    Objects.requireNonNull(remappingFunction);    V oldValue = get(key);    V newValue = remappingFunction.apply(key, oldValue);    if (newValue == null) {        // delete mapping        if (oldValue != null || containsKey(key)) {            // something to remove            remove(key);            return null;        } else {            // nothing to do. Leave things as they were.            return null;        }    } else {        // add or replace old mapping        put(key, newValue);        return newValue;    }}</code></pre><pre><code class="java">map.compute(3, (num, val) -&gt; val + num);  // val333map.get(3);  // val333map.compute(8, (num, val) -&gt; null);  // nullmap.containsKey(8);  // falsemap.compute(19, (num, val) -&gt; val + num);  // null19map.containsKey(19);  // true</code></pre><h2 id="remove-Object-key-Object-value"><a href="#remove-Object-key-Object-value" class="headerlink" title="remove(Object key, Object value)"></a>remove(Object key, Object value)</h2><p>接收 2 个参数，key 和 value，如果 key 关联的 value 值与指定的 value 值相等（equals)，则删除这个元素</p><pre><code class="java">map.remove(3, &quot;val3&quot;);  // falsemap.get(3);  // val33map.remove(3, &quot;val33&quot;);  // truemap.get(3);  // null</code></pre><h2 id="getOrDefault"><a href="#getOrDefault" class="headerlink" title="getOrDefault"></a>getOrDefault</h2><p>如果指定的 key 存在，则返回该 key 对应的 value，如果不存在，则返回指定的值。</p><pre><code class="java">map.getOrDefault(42, &quot;not found&quot;);  // not found</code></pre><h2 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h2><p><code>replace(K key, V oldValue, V newValue)</code>：如果 key 关联的值与指定的 oldValue 的值相等，则替换成新的 newValue，返回 boolean。</p><p><code>replace(K key, V value)</code>：如果 map 中存在 key，则替换成 value 值，返回原 value 值，否则返回 null。</p><pre><code class="java">map.replace(2, &quot;val2&quot;, &quot;val22&quot;);  // truemap.get(2);  // val22map.replace(2, &quot;val2&quot;);  // val22，返回原 value 值map.get(2);  // val2</code></pre><h2 id="replaceAll"><a href="#replaceAll" class="headerlink" title="replaceAll"></a>replaceAll</h2><p>替换 Map 中所有 Entry 的 value 值，这个值由旧的 key 和 value 计算得出，接收参数 <code>(K, V) -&gt; V</code></p><pre><code class="java">System.out.println(map);  // {0=val0, 1=val1, 33=val33, 2=val2, ...map.replaceAll((key, value) -&gt; (key + 1) + value);System.out.println(map);  // {0=1val0, 1=2val1, 33=34val33, 2=3val2, ...</code></pre><h2 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h2><ol><li>oldValue = get(key);<ul><li>指定的 key 不存在，则 newValue 为指定的 value 值</li><li>指定的 key 存在，则根据 key 的旧的值 oldvalue 和 value 计算出新的值 newValue</li></ul></li><li>判断 newValue<ul><li>newValue 为 null，则 remove(key);</li><li>newValue 不为 null，put(key, newValue);</li></ul></li><li>return newValue;</li></ol><pre><code class="java">// 源码default V merge(K key, V value,        BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction) {    Objects.requireNonNull(remappingFunction);    Objects.requireNonNull(value);    V oldValue = get(key);    V newValue = (oldValue == null) ? value :                remappingFunction.apply(oldValue, value);    if(newValue == null) {        remove(key);    } else {        put(key, newValue);    }    return newValue;}</code></pre><pre><code class="java">map.merge(9, &quot;val9&quot;, (value, newValue) -&gt; value.concat(newValue));  // val9map.get(9);  // val9map.merge(9, &quot;concat&quot;, (value, newValue) -&gt; value.concat(newValue));  // val9concatmap.get(9);  // val9concat</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://wizardforcel.gitbooks.io/modern-java/content/ch1.html" target="_blank" rel="noopener">https://wizardforcel.gitbooks.io/modern-java/content/ch1.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 8新特性(5) Parallel Streams</title>
      <link href="/2019/03/13/Java%208%E6%96%B0%E7%89%B9%E6%80%A7(5)%20Parallel%20Streams/"/>
      <url>/2019/03/13/Java%208%E6%96%B0%E7%89%B9%E6%80%A7(5)%20Parallel%20Streams/</url>
      
        <content type="html"><![CDATA[<p>流操作可以是顺序的，也可以是并行的。顺序操作通过单线程执行，而并行操作则通过多线程执行。</p><p>下面的例子就演示了如何使用并行流进行操作来提高运行效率，代码非常简单。</p><p>首先我们创建一个大的 list，里面的元素都是唯一的：</p><pre><code class="java">int max = 1000000;List&lt;String&gt; values = new ArrayList&lt;&gt;(max);for (int i = 0; i &lt; max; i++) {    UUID uuid = UUID.randomUUID();    values.add(uuid.toString());}</code></pre><p>现在，我们测量一下对这个集合进行排序所使用的时间。</p><a id="more"></a><h1 id="顺序排序"><a href="#顺序排序" class="headerlink" title="顺序排序"></a>顺序排序</h1><pre><code class="java">long t0 = System.nanoTime();long count = values.stream().sorted().count();System.out.println(count);long t1 = System.nanoTime();long millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);System.out.println(String.format(&quot;sequential sort took: %d ms&quot;, millis));// sequential sort took: 899 ms</code></pre><h1 id="并行排序"><a href="#并行排序" class="headerlink" title="并行排序"></a>并行排序</h1><pre><code class="java">long t0 = System.nanoTime();long count = values.parallelStream().sorted().count();System.out.println(count);long t1 = System.nanoTime();long millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);System.out.println(String.format(&quot;parallel sort took: %d ms&quot;, millis));// parallel sort took: 472 ms</code></pre><p>如你所见，所有的代码段几乎都相同，唯一的不同就是把 stream() 改成了 parallelStream(), 结果并行排序快了 50%。</p><p>流可以并行执行，在大量输入元素上可以提升运行时的性能。并行流使用公共的 ForkJoinPool，由 ForkJoinPool.commonPool() 方法提供。底层线程池的大小最大为五个线程 -- 取决于 CPU 的物理核数。</p><pre><code class="java">ForkJoinPool commonPool = ForkJoinPool.commonPool();System.out.println(commonPool.getParallelism());    // 3</code></pre><p>在我的机器上，公共池默认初始化为 3。这个值可以通过设置下列 JVM 参数来增减：</p><pre><code class="java">-Djava.util.concurrent.ForkJoinPool.common.parallelism=5</code></pre><p>集合支持 <code>parallelStream()</code> 方法来创建元素的并行流。或者你可以在已存在的数据流上调用衔接方法 <code>parallel()</code>，将串行流转换为并行流。</p><p>总之，并行流对拥有大量输入元素的数据流具有极大的性能提升。但是要记住一些并行流的操作，例如 <code>reduce</code> 和 <code>collect</code> 需要额外的计算（组合操作），这在串行执行时并不需要。</p><blockquote><p><a href="https://wizardforcel.gitbooks.io/modern-java/content/ch2.html" target="_blank" rel="noopener">https://wizardforcel.gitbooks.io/modern-java/content/ch2.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 8新特性(4) Stream</title>
      <link href="/2019/03/13/Java%208%E6%96%B0%E7%89%B9%E6%80%A7(4)%20Stream/"/>
      <url>/2019/03/13/Java%208%E6%96%B0%E7%89%B9%E6%80%A7(4)%20Stream/</url>
      
        <content type="html"><![CDATA[<p>java.util.Stream 表示了某一种元素的序列，在这些元素上可以进行各种操作。Stream 操作可以是中间操作，也可以是完结操作。完结操作会返回一个某种类型的值，而中间操作会返回流对象本身，并且你可以通过多次调用同一个流操作方法来将操作结果串起来（就像 StringBuffer 的 append 方法一样）。Stream 是在一个源的基础上创建出来的，例如 java.util.Collection 中的 list 或者 set（map 不能作为 Stream 的源）。Stream 操作往往可以通过顺序或者并行两种方式来执行。</p><p>流的操作类型分为两种：</p><ul><li>Intermediate：一个流可以后面跟随零个或多个 intermediate 操作。其目的主要是打开流，做出某种程度的数据映射/过滤，然后返回一个新的流，交给下一个操作使用。这类操作都是惰性化的（lazy），就是说，仅仅调用到这类方法，并没有真正开始流的遍历。</li><li>Terminal：一个流只能有一个 terminal 操作，当这个操作执行后，流就被使用“光”了，无法再被操作。所以这必定是流的最后一个操作。Terminal 操作的执行，才会真正开始流的遍历，并且会生成一个结果，或者一个 side effect。</li></ul><p>还有一种操作被称为 short-circuiting。用以指：</p><ul><li>对于一个 intermediate 操作，如果它接受的是一个无限大（infinite/unbounded）的 Stream，但返回一个有限的新 Stream。</li><li>对于一个 terminal 操作，如果它接受的是一个无限大的 Stream，但能在有限的时间计算出结果。</li></ul><p>当操作一个无限大的 Stream，而又希望在有限时间内完成操作，则在管道内拥有一个 short-circuiting 操作是必要非充分条件。</p><a id="more"></a><h2 id="流的构造与转换"><a href="#流的构造与转换" class="headerlink" title="流的构造与转换"></a>流的构造与转换</h2><p>构造流的几种常见方法</p><pre><code class="java">// 1. Individual valuesStream stream = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);// 2. ArraysString [] strArray = new String[] {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;};stream = Stream.of(strArray);stream = Arrays.stream(strArray);// 3. CollectionsList&lt;String&gt; list = Arrays.asList(strArray);stream = list.stream();</code></pre><p>对于基本数值型，目前有三种对应的包装类型 Stream：<code>IntStream</code>、<code>LongStream</code>、<code>DoubleStream</code>。当然我们也可以用 Stream<Integer>、Stream<Long>、Stream<Double>，但是 boxing 和 unboxing 会很耗时，所以特别为这三种基本数值型提供了对应的 Stream。</p><pre><code class="java">IntStream.of(new int[]{1, 2, 3}).forEach(System.out::println); // 1,2,3IntStream.range(1, 3).forEach(System.out::println);  // 1,2IntStream.rangeClosed(1, 3).forEach(System.out::println); // 1,2,3</code></pre><p>流转换为其它数据结构，一个 Stream 只可以使用一次，下面的代码为了简洁而重复使用了数次。</p><pre><code class="java">Stream&lt;String&gt; stream = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);// 1. ArrayString[] strArray1 = stream.toArray(String[]::new);// 2. CollectionList&lt;String&gt; list1 = stream.collect(Collectors.toList());List&lt;String&gt; list2 = stream.collect(Collectors.toCollection(ArrayList::new));Set set1 = stream.collect(Collectors.toSet());Stack stack1 = stream.collect(Collectors.toCollection(Stack::new));// 3. StringString str = stream.collect(Collectors.joining()).toString();</code></pre><h2 id="流的操作"><a href="#流的操作" class="headerlink" title="流的操作"></a>流的操作</h2><ul><li><p><strong>Intermediate</strong>：map (mapToInt, flatMap 等)、 filter、 distinct、 sorted、 peek、 limit、 skip、 parallel、 sequential、 unordered</p></li><li><p><strong>Terminal</strong>：forEach、 forEachOrdered、 toArray、 reduce、 collect、 min、 max、 count、 anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 iterator</p></li><li><p><strong>Short-circuiting</strong>：anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 limit</p></li></ul><p>首先，我们通过 string 类型的 list 的形式创建示例数据：</p><pre><code class="java">List&lt;String&gt; stringCollection = new ArrayList&lt;&gt;();stringCollection.add(&quot;ddd2&quot;);stringCollection.add(&quot;aaa2&quot;);stringCollection.add(&quot;bbb1&quot;);stringCollection.add(&quot;aaa1&quot;);stringCollection.add(&quot;bbb3&quot;);stringCollection.add(&quot;ccc&quot;);stringCollection.add(&quot;bbb2&quot;);stringCollection.add(&quot;ddd1&quot;);</code></pre><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p><code>filter</code> 接受一个 <code>predicate</code> 接口类型的变量，并将所有流对象中的元素进行过滤。该操作是一个中间操作，因此它允许我们在返回结果的基础上再进行其他的流操作（forEach），例子见下文。</p><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><p><code>forEach</code> 接受一个 <code>function</code> 接口类型的变量，用来执行对每一个元素的操作。<code>forEach</code> 是一个中止操作。它不返回流，所以我们不能再调用其他的流操作。</p><pre><code class="java">stringCollection    .stream()    .filter((s) -&gt; s.startsWith(&quot;a&quot;))    .forEach(System.out::println);// &quot;aaa2&quot;, &quot;aaa1&quot;</code></pre><h3 id="peek"><a href="#peek" class="headerlink" title="peek"></a>peek</h3><p>peek 方法也是接收一个 Consumer 功能型接口，它与 forEach 的区别就是它会返回 Stream 接口，也就是说 forEach 是一个 Terminal 操作，而 peek 是一个 Intermediate 操作，forEach 完了以后 Stream 就消费完了，不能继续再使用，而 peek 还可以继续使用。</p><pre><code class="java">stringCollection    .stream()    .filter(s -&gt; s.startsWith(&quot;a&quot;))    .peek(System.out::println)    .map(s -&gt; s.toUpperCase())    .peek(System.out::println)    .collect(Collectors.toList());// aaa2// AAA2// aaa1// AAA1</code></pre><p>peek 是一个 Intermediate 操作，它并不会马上执行，当 collect 的时候才会把 peek 和 collect 一起执行，来提高效率，所以等于一个元素执行完所有操作之后再对下一个元素进行处理。</p><p>如果没有对流进行任何操作 peek 就不会执行。</p><h3 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h3><p><code>sorted</code> 是一个中间操作，能够返回一个排过序的流对象的视图。流对象中的元素会默认按照自然顺序进行排序，除非你自己指定一个 <code>Comparator</code> 接口来改变排序规则。</p><pre><code class="java">stringCollection    .stream()    .sorted()    .filter((s) -&gt; s.startsWith(&quot;a&quot;))    .forEach(System.out::println);// &quot;aaa1&quot;, &quot;aaa2&quot;</code></pre><p>一定要记住，sorted 只是创建一个流对象排序的视图，而不会改变原来集合中元素的顺序。原来 string 集合中的元素顺序是没有改变的。</p><pre><code class="java">System.out.println(stringCollection);// ddd2, aaa2, bbb1, aaa1, bbb3, ccc, bbb2, ddd1</code></pre><h3 id="map-flatMap"><a href="#map-flatMap" class="headerlink" title="map/flatMap"></a>map/flatMap</h3><p><code>map</code> 是一个对于流对象的中间操作，通过给定的方法，它能够把流对象中的每一个元素对应到另外一个对象上。下面的例子就演示了如何把每个 string 都转换成大写的 string。 不但如此，你还可以把每一种对象映射成为其他类型。对于带泛型结果的流对象，具体的类型还要由传递给 map 的泛型方法来决定。</p><pre><code class="java">stringCollection    .stream()    .map(String::toUpperCase)    .sorted((a, b) -&gt; b.compareTo(a))    .forEach(System.out::println);// &quot;DDD2&quot;, &quot;DDD1&quot;, &quot;CCC&quot;, &quot;BBB3&quot;, &quot;BBB2&quot;, &quot;AAA2&quot;, &quot;AAA1&quot;</code></pre><p>map 生成的是个 1:1 映射，每个输入元素，都按照规则转换成为另外一个元素。还有一些场景，是一对多映射关系的，这时需要 flatMap。flatMap 把 input Stream 中的层级结构扁平化，就是将最底层元素抽出来放到一起，最终 output 的新 Stream 里面已经没有 List 了，都是直接的数字。</p><pre><code class="java">Stream&lt;List&lt;Integer&gt;&gt; inputStream = Stream.of(        Arrays.asList(1),        Arrays.asList(2, 3),        Arrays.asList(4, 5, 6));Stream&lt;Integer&gt; outputStream = inputStream.        flatMap((childList) -&gt; childList.stream());outputStream.forEach(s -&gt; System.out.print(s + &quot;, &quot;));// 1, 2, 3, 4, 5, 6,</code></pre><pre><code class="java">List&lt;String&gt; strs = Arrays.asList(&quot;好,好,学&quot;, &quot;习,天,天&quot;, &quot;向,上&quot;);List&lt;String[]&gt; strArray = strs.stream().map(str -&gt; str.split(&quot;,&quot;)).collect(Collectors.toList());// flatMap 与 map 的区别在于 flatMap是将一个流中的每个值都转成一个个流，然后再将这些流扁平化成为一个流 。List&lt;String&gt; strList = strs.stream().map(str -&gt; str.split(&quot;,&quot;))        .flatMap(Arrays::stream)        .collect(Collectors.toList());System.out.println(&quot;strList =&gt; &quot; + strList);// strList =&gt; [好, 好, 学, 习, 天, 天, 向, 上]</code></pre><h3 id="anyMatch-allMatch-noneMatch"><a href="#anyMatch-allMatch-noneMatch" class="headerlink" title="anyMatch/allMatch/noneMatch"></a>anyMatch/allMatch/noneMatch</h3><p>匹配操作有多种不同的类型，都是用来判断某一种规则是否与流对象相互吻合的。所有的匹配操作都是终结操作，只返回一个 <code>boolean</code> 类型的结果。</p><pre><code class="java">boolean anyStartsWithA =    stringCollection        .stream()        .anyMatch((s) -&gt; s.startsWith(&quot;a&quot;));  // 任意System.out.println(anyStartsWithA);      // trueboolean allStartsWithA =    stringCollection        .stream()        .allMatch((s) -&gt; s.startsWith(&quot;a&quot;));  // 全部System.out.println(allStartsWithA);      // falseboolean noneStartsWithZ =    stringCollection        .stream()        .noneMatch((s) -&gt; s.startsWith(&quot;z&quot;));  // 全都不System.out.println(noneStartsWithZ);      // true</code></pre><h3 id="count"><a href="#count" class="headerlink" title="count"></a>count</h3><p><code>count</code> 是一个终结操作，它的作用是返回一个数值，用来标识当前流对象中包含的元素数量。</p><pre><code class="java">long startsWithB =    stringCollection        .stream()        .filter((s) -&gt; s.startsWith(&quot;b&quot;))        .count();System.out.println(startsWithB);    // 3</code></pre><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><p><code>reduce</code> 操作是一个终结操作，它能够把 Stream 元素组合起来。字符串拼接、数值的 sum、min、max、average 都是特殊的 reduce。该操作的结果会放在一个 <code>Optional</code> 变量里返回。</p><p>例如 Stream 的 sum 就相当于：</p><pre><code class="java">Integer[] sixNums = {1, 2, 3, 4, 5, 6};Stream&lt;Integer&gt; integers = Stream.of(sixNums);// 1，初始值，和一个 BinaryOperator 累加器Integer sum = integers.reduce(0, (a, b) -&gt; a+b);// 或Integer sum = integers.reduce(0, Integer::sum);// 2，无初始值，BinaryOperator 积累函数Integer sum = integers.reduce(Integer::sum).orElse(0);// 3，初始值，BiFunction 累加器和 BinaryOperator 类型的组合器函数Integer sum = integers.reduce(0, (sum, p) -&gt; sum += p, (sum1, sum2) -&gt; sum1 + sum2);</code></pre><p>添加一些调试输出来扩展3</p><pre><code class="java">Integer[] sixNums = {1, 2, 3};Stream&lt;Integer&gt; integers = Stream.of(sixNums);Integer sums = integers.reduce(0,    (sum, p) -&gt; {System.out.println(&quot;accumulator: sum=&quot;+sum+&quot;, p=&quot;+p);return sum += p;},    (sum1, sum2) -&gt; {System.out.println(&quot;combiner: sum1=&quot;+sum1+&quot;, sum2=&quot;+sum2);return sum1 + sum2;});// accumulator: sum=0, p=1// accumulator: sum=1, p=2// accumulator: sum=3, p=3</code></pre><p>可以看到，累加器函数做了所有工作。组合器从来没有调用过。</p><p>下面以并行方式执行相同的流</p><pre><code class="java">Integer sums = integers.parallel().reduce(0,    (sum, p) -&gt; {System.out.println(&quot;accumulator: sum=&quot;+sum+&quot;, p=&quot;+p);return sum += p;},    (sum1, sum2) -&gt; {System.out.println(&quot;combiner: sum1=&quot;+sum1+&quot;, sum2=&quot;+sum2);return sum1 + sum2;});// accumulator: sum=0, p=1// accumulator: sum=0, p=3// accumulator: sum=0, p=2// combiner: sum1=2, sum2=3// combiner: sum1=1, sum2=5</code></pre><p>这个流的并行执行行为会完全不同。现在实际上调用了组合器。由于累加器被并行调用，组合器需要用于计算部分累加值的总和。</p><h3 id="limit-skip"><a href="#limit-skip" class="headerlink" title="limit/skip"></a>limit/skip</h3><p>limit 返回 Stream 的前面 n 个元素；skip 则是扔掉前 n 个元素。</p><pre><code class="java">stringCollection.stream().limit(3).forEach(System.out::println);// ddd2, aaa2, bbb1stringCollection.stream().skip(2).limit(3).forEach(System.out::println);// bbb1, aaa1, bbb3stringCollection.stream().limit(3).skip(2).forEach(System.out::println);// bbb1</code></pre><h3 id="min-max-distinct"><a href="#min-max-distinct" class="headerlink" title="min/max/distinct"></a>min/max/distinct</h3><p>min 和 max 的功能也可以通过对 Stream 元素先排序，再 findFirst 来实现，但前者的性能会更好，为 O(n)，而 sorted 的成本是 O(n log n)。同时它们作为特殊的 reduce 方法被独立出来也是因为求最大最小值是很常见的操作。</p><pre><code class="java">Integer[] sixNums = {1, 2, 3, 4, 5, 6, 6};Stream&lt;Integer&gt; integers = Stream.of(sixNums);integers.min(Integer::compareTo);  // 返回值 Optional，terminal 操作，下面为简洁而重复使用integers.max(Integer::compareTo);  // 返回值 Optional，terminal 操作，下面为简洁而重复使用integers.distinct().forEach(System.out::println);</code></pre><h3 id="findFirst-findAny"><a href="#findFirst-findAny" class="headerlink" title="findFirst/findAny"></a>findFirst/findAny</h3><p>findFirst：返回第一个元素的 Optional，findAny：返回任意元素的 Optional。</p><pre><code class="java">integers.findFirst().ifPresent(System.out::println);  // 终结操作integers.findAny().ifPresent(System.out::println);</code></pre><h3 id="mapToInt-mapToLong-mapToDouble-mapToObj"><a href="#mapToInt-mapToLong-mapToDouble-mapToObj" class="headerlink" title="mapToInt/mapToLong/mapToDouble/mapToObj"></a>mapToInt/mapToLong/mapToDouble/mapToObj</h3><p>有时需要将通常的对象数据流转换为基本数据流，或者相反。出于这种目的，对象数据流支持特殊的映射操作mapToInt()、mapToLong() 和 mapToDouble()：</p><pre><code class="java">Stream.of(&quot;a1&quot;, &quot;a2&quot;, &quot;a3&quot;)    .map(s -&gt; s.substring(1))    .mapToInt(Integer::parseInt)    .max()    .ifPresent(System.out::println);  // 3</code></pre><p>基本数据流可以通过mapToObj()转换为对象数据流：</p><pre><code class="java">IntStream.range(1, 4)    .mapToObj(i -&gt; &quot;a&quot; + i)    .forEach(System.out::println);// a1// a2// a3</code></pre><p>下面是组合示例：浮点数据流首先映射为整数数据流，之后映射为字符串的对象数据流：</p><pre><code class="java">Stream.of(1.0, 2.0, 3.0)    .mapToInt(Double::intValue)    .mapToObj(i -&gt; &quot;a&quot; + i)    .forEach(System.out::println);// a1// a2// a3</code></pre><h3 id="Stream-generate"><a href="#Stream-generate" class="headerlink" title="Stream.generate"></a>Stream.generate</h3><p>通过实现 Supplier 接口，你可以自己来控制流的生成。这种情形通常用于随机数、常量的 Stream，或者需要前后元素间维持着某种状态信息的 Stream。把 Supplier 实例传递给 Stream.generate() 生成的 Stream，默认是串行（相对 parallel 而言）但无序的（相对 ordered 而言）。由于它是无限的，在管道中，必须利用 limit 之类的操作限制 Stream 大小。</p><p>生成 10 个随机整数</p><pre><code class="java">Random seed = new Random();Supplier&lt;Integer&gt; random = seed::nextInt;Stream.generate(random).limit(10).forEach(System.out::println);//Another wayIntStream.generate(() -&gt; (int) (System.nanoTime() % 1000)).        limit(10).forEach(System.out::println);// -1718100697 -848168940 -2008666631 1248576610 -1224934545 943407587 -689001410 1506937317 -1229890500 976825946// 50 37 88 5 17 29 10 49 31 25</code></pre><p>Stream.generate() 还接受自己实现的 Supplier。例如在构造海量测试数据的时候，用某种自动的规则给每一个变量赋值；或者依据公式计算 Stream 的每个元素值。这些都是维持状态信息的情形。</p><pre><code class="java">Stream.generate(new PersonSupplier()).        limit(10).        forEach(p -&gt; System.out.println(p.getName() + &quot;, &quot; + p.getAge()));class PersonSupplier implements Supplier&lt;Person&gt; {    private int index = 0;    private Random random = new Random();    @Override    public Person get() {        return new Person(index++, &quot;StormTestUser&quot; + index, random.nextInt(100));    }}/* output:tormTestUser1, 0StormTestUser2, 1StormTestUser3, 2StormTestUser4, 3StormTestUser5, 4StormTestUser6, 5StormTestUser7, 6StormTestUser8, 7StormTestUser9, 8StormTestUser10, 9*/</code></pre><h3 id="Stream-iterate"><a href="#Stream-iterate" class="headerlink" title="Stream.iterate"></a>Stream.iterate</h3><p>iterate 跟 reduce 操作很像，接受一个种子值，和一个 UnaryOperator（例如 f）。然后种子值成为 Stream 的第一个元素，f(seed) 为第二个，f(f(seed)) 第三个，以此类推。</p><p>生成一个等差数列</p><pre><code class="java">Stream.iterate(0, n -&gt; n + 3).limit(10). forEach(x -&gt; System.out.print(x + &quot; &quot;));// 0 3 6 9 12 15 18 21 24 27</code></pre><p>与 Stream.generate 相仿，在 iterate 时候管道必须有 limit 这样的操作来限制 Stream 大小。</p><h3 id="collect"><a href="#collect" class="headerlink" title="collect"></a>collect</h3><p><code>collect</code> 方法跟 <code>reduce</code> 方法功能很类似，都是聚合方法。不同的是，reduce 方法在操作每一个元素时总创建一个新值，而 collect 方法只是修改现存的值，而不是创建一个新值。</p><h4 id="方法定义一"><a href="#方法定义一" class="headerlink" title="方法定义一"></a>方法定义一</h4><pre><code class="java">&lt;R&gt; R collect(Supplier&lt;R&gt; supplier,                  BiConsumer&lt;R, ? super T&gt; accumulator,                  BiConsumer&lt;R, R&gt; combiner);&lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector);</code></pre><p>调用方式如下,很明显第一个参数 supplier 为结果存放容器,第二个参数 accumulator 为结果如何添加到容器的操作,第三个参数 combiner 则为多个容器的聚合策略.</p><pre><code class="java">import com.google.common.collect.Lists;// 例一，字符串相加：String concat = stringStream.collect(StringBuilder::new, StringBuilder::append,StringBuilder::append).toString();//等价于上面,这样看起来应该更加清晰String concat = stringStream.collect(() -&gt; new StringBuilder(),(l, x) -&gt; l.append(x), (r1, r2) -&gt; r1.append(r2)).toString();// 例二，对 List 值求和：// 由于基本类型都是不可变类型,所以这里用数组当做容器final Integer[] integers = Lists.newArrayList(1, 2, 3, 4, 5)        .stream()        .collect(() -&gt; new Integer[]{0}, (a, x) -&gt; a[0] += x, (a1, a2) -&gt; a1[0] += a2[0]);// 例三：Lists.&lt;Person&gt;newArrayList().stream()        .collect(HashMap&lt;Integer, List&lt;Person&gt;&gt;::new,                (h, x) -&gt; {                    List&lt;Person&gt; value = h.getOrDefault(x.getAge(), Lists.newArrayList());                    value.add(x);                    h.put(x.getAge(), value);                },                HashMap::putAll        );</code></pre><h4 id="方法定义二"><a href="#方法定义二" class="headerlink" title="方法定义二"></a>方法定义二</h4><pre><code class="java">&lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector);</code></pre><p>接收一个 <code>Collector</code> 接口作为参数，它由四个不同的操作组成：供应器（supplier）、累加器（accumulator）、组合器（combiner）和终止器（finisher）。如果要自己实现它会很麻烦，好在 java.util.stream 包中给我们提供了一个叫 Collectors 的类。通过 Collectors 这个类可以很容易得到一个 Collector 对象，这个类中提供了很多统计的操作和创建集合的操作。</p><p><strong>构建自己的特殊收集器</strong>。我们希望将流中的所有人转换为一个字符串，包含所有大写的名称，并以 <code>|</code> 分割。为了完成它，我们通过 <code>Collector.of()</code> 创建了一个新的收集器。我们需要传递一个收集器的四个组成部分：供应器、累加器、组合器和终止器。</p><pre><code class="java">Collector&lt;Person, StringJoiner, String&gt; personNameCollector =    Collector.of(        () -&gt; new StringJoiner(&quot; | &quot;),          // supplier        (j, p) -&gt; j.add(p.name.toUpperCase()),  // accumulator        (j1, j2) -&gt; j1.merge(j2),               // combiner        StringJoiner::toString);                // finisherString names = persons    .stream()    .collect(personNameCollector);System.out.println(names);  // MAX | PETER | PAMELA | DAVID</code></pre><p>由于 Java 中的字符串是不可变的，我们需要一个助手类 <code>StringJointer</code>。让收集器构造我们的字符串。供应器最开始使用相应的分隔符构造了这样一个 StringJointer。累加器用于将每个人的大写名称加到 StringJointer 中。组合器知道如何把两个 StringJointer 合并为一个。最后一步，终结器从 StringJointer 构造出预期的字符串。</p><h3 id="Collectors"><a href="#Collectors" class="headerlink" title="Collectors"></a>Collectors</h3><h4 id="toList-toSet-toCollection"><a href="#toList-toSet-toCollection" class="headerlink" title="toList/toSet/toCollection"></a>toList/toSet/toCollection</h4><pre><code class="java">List&lt;Person&gt; persons = Arrays.asList(        new Person(&quot;Max&quot;, 18), new Person(&quot;Peter&quot;, 23),        new Person(&quot;Pamela&quot;, 23), new Person(&quot;David&quot;, 12));// 从流的元素中构造了一个列表List&lt;Person&gt; filtered = persons        .stream()        .filter(p -&gt; p.name.startsWith(&quot;P&quot;))        .collect(Collectors.toList());  // 如果需要以Set来替代List，只需要使用Collectors.toSet()就好了。System.out.println(filtered);  // [Peter, Pamela]</code></pre><p><code>toList</code> 使用了 <code>ArrayList</code> 作为列表的实现。<code>toSet</code> 方法使用了 <code>HashSet</code> 作为集合的实现来存储结果集。时候我们可能会想要人为指定容器的实际类型，这个需求可通过 <code>Collectors.toCollection(Supplier&lt;C&gt; collectionFactory)</code> 方法完成。</p><pre><code class="java">// 使用 toCollection() 指定规约容器的类型ArrayList&lt;String&gt; arrayList = stream.collect(Collectors.toCollection(ArrayList::new));HashSet&lt;String&gt; hashSet = stream.collect(Collectors.toCollection(HashSet::new));</code></pre><h4 id="toMap-toConcurrentMap"><a href="#toMap-toConcurrentMap" class="headerlink" title="toMap/toConcurrentMap"></a>toMap/toConcurrentMap</h4><p>可以使用 <code>toMap</code> 收集器将一个流转换为一个映射。<code>toMap</code> 收集器需要两个映射方法来获得映射的键和值。在下面展示的代码中，<code>Person::getAge</code> 是接收一个 Person 并产生一个只包含该 Person 的 Age 键的 <code>Function</code>。<code>t-&gt;t</code> 是一个用来返回 Person 本身的 lambda 表达式，也可以使用 <code>Function.identity()</code>。</p><pre><code class="java">Map&lt;Integer, Person&gt; map = persons.stream().collect(Collectors.toMap(Person::getAge, t-&gt;t));</code></pre><p>从一个流中创建映射的代码会在存在<strong>重复的键</strong>时抛出异常。将会得到一个类似下面的错误。</p><pre><code class="java">Exception in thread &quot;main&quot; java.lang.IllegalStateException: Duplicate key Person{name=&#39;Peter&#39;}    at java.util.stream.Collectors.lambda$throwingMerger$0(Collectors.java:133)    ...</code></pre><p>可以通过使用 toMap 方法的<strong>另一个变体</strong>来处理重复问题，它允许我们指定一个<strong>合并方法</strong>。这个合并方法允许用户他们指定想如何处理多个值关联到同一个键的冲突。在下面展示的代码中，我们只是使用了新的值，当然也可以编写一个智能的算法来处理冲突。</p><pre><code class="java">Map&lt;Integer, Person&gt; map = persons.stream().collect(Collectors.toMap(Person::getAge, t-&gt;t, (t1, t2) -&gt; t2));</code></pre><p>你可以通过使用 toMap 方法的<strong>第三个变体</strong>来<strong>指定其他的映射实现</strong>。这需要你指定将用来存储结果的 Map 和 Supplier。</p><pre><code class="java">Map&lt;Integer, Person&gt; map = persons.stream().collect(Collectors.toMap(Person::getAge, t-&gt;t, (t1, t2) -&gt; t2, LinkedHashMap::new));</code></pre><p>类似于 toMap 收集器，也有 <code>toConcurrentMap</code> 收集器，它产生一个 ConcurrentMap 而不是 HashMap。</p><h4 id="maxBy-minBy"><a href="#maxBy-minBy" class="headerlink" title="maxBy/minBy"></a>maxBy/minBy</h4><p>查找最大最小值</p><pre><code class="java">persons.stream().collect(Collectors.maxBy(Comparator.comparingInt(Person::getAge)))        .ifPresent(System.out::println);  // Person{name=&#39;Peter&#39;}persons.stream().collect(Collectors.minBy(Comparator.comparingInt(Person::getAge)))        .ifPresent(System.out::println);  // Person{name=&#39;David&#39;}// 类似于persons.stream().max(Comparator.comparingInt(Person::getAge))        .ifPresent(System.out::println);persons.stream().min(Comparator.comparingInt(Person::getAge))        .ifPresent(System.out::println);</code></pre><h4 id="collectingAndThen"><a href="#collectingAndThen" class="headerlink" title="collectingAndThen"></a>collectingAndThen</h4><p>转换函数返回的类型</p><pre><code class="java">// 返回最大 Age 的 PersonPerson maxAgePerson = persons.stream().collect(Collectors.collectingAndThen(        Collectors.maxBy(Comparator.comparingInt(Person::getAge)),        Optional::get));  // 为转换函数，转换最终的数据</code></pre><h4 id="counting"><a href="#counting" class="headerlink" title="counting"></a>counting</h4><p>计算流中元素的个数</p><pre><code class="java">long count = persons.stream().collect(Collectors.counting());  // 4long count = persons.stream().count();int count = persons.size();</code></pre><h4 id="summingInt-summingLong-summingDouble"><a href="#summingInt-summingLong-summingDouble" class="headerlink" title="summingInt/summingLong/summingDouble"></a>summingInt/summingLong/summingDouble</h4><p>求和</p><pre><code class="java">long sumAge = persons.stream().collect(Collectors.summingInt(Person::getAge));// 类似于long sumAge = persons.stream().mapToInt(Person::getAge).sum();</code></pre><h4 id="averagingInt-averagingDouble-averagingLong"><a href="#averagingInt-averagingDouble-averagingLong" class="headerlink" title="averagingInt/averagingDouble/averagingLong"></a>averagingInt/averagingDouble/averagingLong</h4><p>求平均值</p><pre><code class="java">double averag = persons.stream().collect(Collectors.averagingInt(Person::getAge)); // 19.0</code></pre><h4 id="summarizingInt-summarizingDouble-summarizingLong"><a href="#summarizingInt-summarizingDouble-summarizingLong" class="headerlink" title="summarizingInt/summarizingDouble/summarizingLong"></a>summarizingInt/summarizingDouble/summarizingLong</h4><p>综合方法，和，平均，最大最小全求出来</p><pre><code class="java">IntSummaryStatistics statistics = persons.stream().collect(Collectors.summarizingInt(Person::getAge));System.out.println(&quot;the max:&quot; + statistics.getMax());System.out.println(&quot;the min:&quot; + statistics.getMin());System.out.println(&quot;the average:&quot; + statistics.getAverage());System.out.println(&quot;the sum:&quot; + statistics.getSum());System.out.println(&quot;the count:&quot; + statistics.getCount());</code></pre><h4 id="joining"><a href="#joining" class="headerlink" title="joining"></a>joining</h4><p>连接流中元素上指定的属性</p><pre><code class="java">// 已 ; 分隔persons.stream().map(Person::getName).collect(Collectors.joining(&quot;;&quot;));// Max;Peter;Pamela;David// 已 ; 分隔，前缀 [，后缀 ]persons.stream().map(Person::getName).collect(Collectors.joining(&quot;;&quot;, &quot;[&quot;, &quot;]&quot;));// [Max;Peter;Pamela;David]// 字符串相连persons.stream().map(Person::getName).collect(Collectors.joining());// MaxPeterPamelaDavid</code></pre><h4 id="reducing"><a href="#reducing" class="headerlink" title="reducing"></a>reducing</h4><p>从一个累加器的初始值开始，使用BinaryOperator与流中的元素逐个集合，最后将流规约为单个值。</p><pre><code class="java">persons.stream().collect(Collectors.reducing(0, Person::getAge, Integer::sum));persons.stream().map(Person::getAge).reduce(0, Integer::sum);persons.stream().collect(Collectors.reducing((a, b) -&gt; a)).ifPresent(System.out::println);persons.stream().reduce((a, b) -&gt; a).ifPresent(System.out::println);</code></pre><h4 id="groupingBy"><a href="#groupingBy" class="headerlink" title="groupingBy"></a>groupingBy</h4><p>按照年龄归组</p><pre><code class="java">Map&lt;Integer, List&lt;Person&gt;&gt; personGroups = persons.stream().        collect(Collectors.groupingBy(Person::getAge));Iterator it = personGroups.entrySet().iterator();while (it.hasNext()) {    Map.Entry&lt;Integer, List&lt;Person&gt;&gt; ps = (Map.Entry) it.next();    System.out.println(&quot;Age &quot; + ps.getKey() + &quot; = &quot; + ps.getValue().size());}// Age 18 = 1// Age 23 = 2// Age 12 = 1</code></pre><h4 id="partitioningBy"><a href="#partitioningBy" class="headerlink" title="partitioningBy"></a>partitioningBy</h4><p>按照未成年人和成年人归组</p><pre><code class="java">Map&lt;Boolean, List&lt;Person&gt;&gt; children = persons.stream().        collect(Collectors.partitioningBy(p -&gt; p.getAge() &lt; 18));System.out.println(&quot;Children number: &quot; + children.get(true).size());System.out.println(&quot;Adult number: &quot; + children.get(false).size());// Children number: 1// Adult number: 3</code></pre><p>在使用条件“年龄小于 18”进行分组后可以看到，不到 18 岁的未成年人是一组，成年人是另外一组。<code>partitioningBy</code> 其实是一种特殊的 <code>groupingBy</code>，它依照条件测试的是否两种结果来构造返回的数据结构，<code>get(true)</code> 和 <code>get(false)</code> 能即为全部的元素对象。</p><h2 id="IntStream、LongStream-和-DoubleStream"><a href="#IntStream、LongStream-和-DoubleStream" class="headerlink" title="IntStream、LongStream 和 DoubleStream"></a>IntStream、LongStream 和 DoubleStream</h2><p>Java8 还自带了特殊种类的流，用于处理基本数据类型 int、long 和 double。</p><p>IntStream 可以使用 IntStream.range() 替换通常的 for 循环：</p><pre><code class="java">IntStream.range(1, 4)    .forEach(System.out::println);// 1// 2// 3</code></pre><p>所有这些基本数据流都像通常的对象数据流一样，但有一些不同。基本的数据流使用特殊的 lambda 表达式，例如，IntFunction 而不是 Function，IntPredicate 而不是 Predicate。而且基本数据流支持<strong>额外的聚合终止操作 sum() 和 average()</strong>：</p><pre><code class="java">Arrays.stream(new int[] {1, 2, 3})    .map(n -&gt; 2 * n + 1)    .average()  // OptionalDouble    .ifPresent(System.out::println);  // 5.0</code></pre><h2 id="复用数据流"><a href="#复用数据流" class="headerlink" title="复用数据流"></a>复用数据流</h2><p>Java8 的数据流不能被复用。一旦你调用了任何终止操作，数据流就关闭了。否则会产生 java.lang.IllegalStateException: stream has already been operated upon or closed 异常。</p><p>要克服这个限制，我们需要为每个我们想要执行的终止操作创建新的数据流调用链。例如，我们创建一个数据流供应器，来构建新的数据流，并且设置好所有衔接操作：</p><pre><code class="java">Supplier&lt;Stream&lt;String&gt;&gt; streamSupplier =    () -&gt; Stream.of(&quot;d2&quot;, &quot;a2&quot;, &quot;b1&quot;, &quot;b3&quot;, &quot;c&quot;)            .filter(s -&gt; s.startsWith(&quot;a&quot;));streamSupplier.get().anyMatch(s -&gt; true);   // okstreamSupplier.get().noneMatch(s -&gt; true);  // ok</code></pre><p>每次对 get() 的调用都构造了一个新的数据流，我们将其保存来调用终止操作。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://wizardforcel.gitbooks.io/modern-java/content/ch1.html" target="_blank" rel="noopener">https://wizardforcel.gitbooks.io/modern-java/content/ch1.html</a><br><a href="https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/index.html</a><br><a href="https://juejin.im/post/59c7d39b6fb9a00a3d136291" target="_blank" rel="noopener">https://juejin.im/post/59c7d39b6fb9a00a3d136291</a><br><a href="https://blog.csdn.net/u013291394/article/details/52662761" target="_blank" rel="noopener">https://blog.csdn.net/u013291394/article/details/52662761</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 8新特性(3) 内置函数式接口</title>
      <link href="/2019/03/13/Java%208%E6%96%B0%E7%89%B9%E6%80%A7(3)%20%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/"/>
      <url>/2019/03/13/Java%208%E6%96%B0%E7%89%B9%E6%80%A7(3)%20%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<p>JDK 1.8 API 中包含了很多内置的函数式接口。有些是在以前版本的 Java 中大家耳熟能详的，例如 Comparator 接口，或者 Runnable 接口。对这些现成的接口进行实现，可以通过 @FunctionalInterface 标注来启用 Lambda 功能支持。</p><p>文档查看：<a href="https://docs.oracle.com/javase/8/docs/api/" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/</a></p><h1 id="Predicate"><a href="#Predicate" class="headerlink" title="Predicate"></a>Predicate</h1><p>Predicate 是一个布尔类型的函数，该函数只有一个输入参数。Predicate 接口包含了多种默认方法，用于处理复杂的逻辑动词（and, or，negate）</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><pre><code class="java">package java.util.function;import java.util.Objects;@FunctionalInterfacepublic interface Predicate&lt;T&gt; {    boolean test(T t);    default Predicate&lt;T&gt; and(Predicate&lt;? super T&gt; other) {        Objects.requireNonNull(other);        return (t) -&gt; test(t) &amp;&amp; other.test(t);    }    default Predicate&lt;T&gt; negate() {        return (t) -&gt; !test(t);    }    default Predicate&lt;T&gt; or(Predicate&lt;? super T&gt; other) {        Objects.requireNonNull(other);        return (t) -&gt; test(t) || other.test(t);    }    static &lt;T&gt; Predicate&lt;T&gt; isEqual(Object targetRef) {        return (null == targetRef)                ? Objects::isNull                : object -&gt; targetRef.equals(object);    }</code></pre><a id="more"></a><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><pre><code class="java">Predicate&lt;String&gt; predicate = (s) -&gt; s.length() &gt; 0;predicate.test(&quot;foo&quot;);  // truepredicate.negate().test(&quot;foo&quot;);  // falsePredicate&lt;Boolean&gt; nonNull = Objects::nonNull;Predicate&lt;Boolean&gt; isNull = Objects::isNull;Predicate&lt;String&gt; isEmpty = String::isEmpty;Predicate&lt;String&gt; isNotEmpty = isEmpty.negate();Predicate&lt;String&gt; isEqual = Predicate.isEqual(&quot;Str&quot;);nonNull.test(null)  // false</code></pre><h1 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h1><p>Function 接口接收一个参数，并返回单一的结果。默认方法可以将多个函数串在一起（compse, andThen）</p><h2 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h2><pre><code class="java">package java.util.function;import java.util.Objects;/** * @param &lt;T&gt; 函数的输入类型 * @param &lt;R&gt; 函数结果的类型 */@FunctionalInterfacepublic interface Function&lt;T, R&gt; {    /**     * 将此函数应用于给定的参数。     */    R apply(T t);    /**     * 返回一个复合函数，该函数首先计算{@code before}函数，再计算当前函数，顺序同 andThen 方法相反。     *     * @param &lt;V&gt; {@code before}函数的输出类型，也是复合函数的输入类型     */    default &lt;V&gt; Function&lt;V, R&gt; compose(Function&lt;? super V, ? extends T&gt; before) {        Objects.requireNonNull(before);        return (V v) -&gt; apply(before.apply(v));    }    /**     * 返回一个复合函数，该函数首先计算当前函数，然后将{@code after}函数应用于结果。     *     * @param &lt;V&gt; {@code after}函数的输出类型，也是复合函数的输出类型     */    default &lt;V&gt; Function&lt;T, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after) {        Objects.requireNonNull(after);        return (T t) -&gt; after.apply(apply(t));    }    /**     * Returns a function that always returns its input argument.     *     * @param &lt;T&gt; the type of the input and output objects to the function     * @return a function that always returns its input argument     */    static &lt;T&gt; Function&lt;T, T&gt; identity() {        return t -&gt; t;    }}</code></pre><h2 id="andThen-方法实例"><a href="#andThen-方法实例" class="headerlink" title="andThen 方法实例"></a>andThen 方法实例</h2><pre><code class="java">Function&lt;String, Integer&gt; toInteger = Integer::valueOf;Function&lt;String, String&gt; backToString = toInteger.andThen(String::valueOf);  // 先计算 toInteger 函数System.out.println(backToString.apply(&quot;123&quot;) + 1);    // 1231Function&lt;String, String&gt; toString = String::valueOf;Function&lt;String, Integer&gt; backToInt = toString.andThen(toInteger);    // 先计算 toString 函数System.out.println(backToInt.apply(&quot;123&quot;) + 1);    // 124</code></pre><h2 id="compose-方法实例"><a href="#compose-方法实例" class="headerlink" title="compose 方法实例"></a>compose 方法实例</h2><pre><code class="java">Function&lt;String, Integer&gt; toInteger = Integer::valueOf;Function&lt;String, Integer&gt; backToString = toInteger.compose(String::valueOf);  // 先计算 String::valueOf 函数System.out.println(backToString.apply(&quot;123&quot;) + 1);    // 124Function&lt;Integer, String&gt; toString = String::valueOf;Function&lt;String, String&gt; backToInt = toString.compose(toInteger);  // 先计算 toInteger 函数System.out.println(backToInt.apply(&quot;123&quot;) + 1);    // 1231</code></pre><h2 id="identity-方法实例"><a href="#identity-方法实例" class="headerlink" title="identity 方法实例"></a>identity 方法实例</h2><p>返回一个始终返回其输入参数的函数。</p><pre><code class="java">// 源码static &lt;T&gt; Function&lt;T, T&gt; identity() {    return t -&gt; t;}// 例子Function.identity().apply(4);  // 4</code></pre><p><code>Function.identity()</code> 与 <code>t-&gt;t</code> 区别：</p><ul><li><code>t-&gt;t</code>：可读性好</li><li><code>Function.identity()</code>：可节省一些内存，有些情况下不可用</li></ul><blockquote><p><a href="https://stackoverflow.com/questions/28032827/java-8-lambdas-function-identity-or-t-t" target="_blank" rel="noopener">https://stackoverflow.com/questions/28032827/java-8-lambdas-function-identity-or-t-t</a></p></blockquote><h1 id="Supplier"><a href="#Supplier" class="headerlink" title="Supplier"></a>Supplier</h1><p>Supplier 接口产生一个给定类型的结果。与 Function 不同的是，Supplier 没有输入参数。</p><h2 id="源码-2"><a href="#源码-2" class="headerlink" title="源码"></a>源码</h2><pre><code class="java">@FunctionalInterfacepublic interface Supplier&lt;T&gt; {    /**     * Gets a result.     */    T get();}</code></pre><h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><pre><code class="java">Supplier&lt;Person&gt; personSupplier = Person::new;personSupplier.get();   // new Person</code></pre><h1 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h1><p>Consumer 代表了在一个输入参数上需要进行的操作。</p><h2 id="源码-3"><a href="#源码-3" class="headerlink" title="源码"></a>源码</h2><pre><code class="java">@FunctionalInterfacepublic interface Consumer&lt;T&gt; {    void accept(T t);    /**     * 同 Function 类中的 andThen 方法调用顺序    */    default Consumer&lt;T&gt; andThen(Consumer&lt;? super T&gt; after) {        Objects.requireNonNull(after);        return (T t) -&gt; { accept(t); after.accept(t); };    }}</code></pre><h2 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h2><pre><code class="java">Consumer&lt;Person&gt; greeter = (p) -&gt; System.out.println(&quot;Hello, &quot; + p.firstName);Consumer&lt;Person&gt; greeter2 = greeter.andThen((p) -&gt; System.out.println(&quot;Hello, &quot; + p.lastName));// greeter.accept(new Person(&quot;Luke&quot;, &quot;Skywalker&quot;));greeter2.accept(new Person(&quot;Luke&quot;, &quot;Skywalker&quot;));/** output:Hello, LukeHello, Skywalker/</code></pre><h1 id="Comparator"><a href="#Comparator" class="headerlink" title="Comparator"></a>Comparator</h1><p>java.util.Comparator 接口在早期的Java版本中非常著名。Java 8 为这个接口添加了很多默认方法。</p><pre><code class="java">Comparator&lt;Person&gt; comparator = (p1, p2) -&gt; p1.firstName.compareTo(p2.firstName);Person p1 = new Person(&quot;John&quot;, &quot;Doe&quot;);Person p2 = new Person(&quot;Alice&quot;, &quot;Wonderland&quot;);comparator.compare(p1, p2);             // &gt; 0comparator.reversed().compare(p1, p2);  // &lt; 0  // reversed() 返回一个比较器，相反顺序。</code></pre><p>reverseOrder()，返回与自然顺序相反的比较器。</p><p>naturalOrder()，返回按自然顺序比较对象的比较器。</p><h2 id="comparing"><a href="#comparing" class="headerlink" title="comparing"></a>comparing</h2><p>静态方法，两种重载方法</p><pre><code class="java">Comparator&lt;Person&gt; comparator = (p1, p2) -&gt; p1.firstName.compareTo(p2.firstName);Person p1 = new Person(&quot;John&quot;, &quot;Doe&quot;);Person p2 = new Person(&quot;Alice&quot;, &quot;Wonderland&quot;);Comparator&lt;Person&gt; c = Comparator.comparing(Person::getFirstName, String.CASE_INSENSITIVE_ORDER);System.out.println(c.compare(p1, p2));  // &gt; 0Comparator&lt;Person&gt; c2 = Comparator.comparing(Person::getFirstName);System.out.println(c2.compare(p1, p2));  // &gt; 0</code></pre><p>另外还有 comparingInt，comparingLong，comparingDouble 方法。</p><h2 id="thenComparing"><a href="#thenComparing" class="headerlink" title="thenComparing"></a>thenComparing</h2><p>thenComparing 有三种重载方法</p><pre><code class="java">// 1.default Comparator&lt;T&gt; thenComparing(Comparator&lt;? super T&gt; other) {    Objects.requireNonNull(other);    return (Comparator&lt;T&gt; &amp; Serializable) (c1, c2) -&gt; {        int res = compare(c1, c2);        return (res != 0) ? res : other.compare(c1, c2);    };}// 实例1：要根据长度进行排序，然后对不区分大小写的自然顺序进行排序，可以使用以下代码组合比较器，Comparator&lt;String&gt; cmp = Comparator.comparingInt(String::length).thenComparing(String.CASE_INSENSITIVE_ORDER);System.out.println(cmp.compare(&quot;abc&quot;, &quot;ccc&quot;));  // &lt; 0// 实例2：firstName 相同，按 lastName 排序p1 = new Person(&quot;Alice&quot;, &quot;Doe&quot;);p2 = new Person(&quot;Alice&quot;, &quot;Wonderland&quot;);Comparator&lt;Person&gt; comparator2 = (p1, p2) -&gt; p1.lastName.compareTo(p2.lastName);Comparator&lt;Person&gt; cmp3 = comparator.thenComparing(comparator2);cmp3.compare(p1, p2)  // &lt; 0// 2.default &lt;U&gt; Comparator&lt;T&gt; thenComparing(        Function&lt;? super T, ? extends U&gt; keyExtractor, Comparator&lt;? super U&gt; keyComparator) {    return thenComparing(comparing(keyExtractor, keyComparator));}// 实例：firstName 相同，按 lastName 排序Comparator&lt;Person&gt; cmp4 = comparator.thenComparing(Person::getLastName, String.CASE_INSENSITIVE_ORDER);System.out.println(cmp4.compare(p1, p2));  // &lt; 0// 3.default &lt;U extends Comparable&lt;? super U&gt;&gt; Comparator&lt;T&gt; thenComparing(        Function&lt;? super T, ? extends U&gt; keyExtractor) {    return thenComparing(comparing(keyExtractor));}// 实例：自然顺序相同，按长度排序Comparator&lt;String&gt; cmp2 = String.CASE_INSENSITIVE_ORDER.thenComparing(String::length);System.out.println(cmp2.compare(&quot;abc&quot;, &quot;acc&quot;));  // &lt; 0</code></pre><p>另外还有 thenComparingInt，thenComparingLong，thenComparingDouble 方法。</p><h2 id="nullsFirst，nullsLast"><a href="#nullsFirst，nullsLast" class="headerlink" title="nullsFirst，nullsLast"></a>nullsFirst，nullsLast</h2><p>返回一个空值友好的比较器，当两者都是 null 时相等，如果两者都为非 null，则使用指定的 Comparator 来确定顺序。如果指定的比较器是 null ，则所有非空值都相等。</p><p>nullsFirst，它将 null 视为小于非 null。</p><p>nullsLast，它将 null 视为大于非 null。</p><pre><code class="java">public static &lt;T&gt; Comparator&lt;T&gt; nullsFirst(Comparator&lt;? super T&gt; comparator) {    return new Comparators.NullComparator&lt;&gt;(true, comparator);}public static &lt;T&gt; Comparator&lt;T&gt; nullsLast(Comparator&lt;? super T&gt; comparator) {    return new Comparators.NullComparator&lt;&gt;(false, comparator);}</code></pre><h1 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h1><p>Optional 不是一个函数式接口，而是一个精巧的工具接口，用来防止 NullPointerException 产生。我们在这里快速地浏览一下 Optional 的工作原理。</p><p>Optional 是一个简单的值容器，这个值可以是 null，也可以是 non-null。考虑到一个方法可能会返回一个 non-null 的值，也可能返回一个空值。为了不直接返回 null，我们在 Java8 中就返回一个 Optional。</p><h2 id="生成对象"><a href="#生成对象" class="headerlink" title="生成对象"></a>生成对象</h2><pre><code class="java">// 构造器是私有的，可通过 of 方法生成非 null 对象。Optional&lt;String&gt; optional = Optional.of(&quot;bam&quot;);  // 参数不能为空// empty 生成空对象Optional&lt;String&gt; opnull = Optional.empty();// ofNullable，即可生成空对象又可生成非空对象Optional&lt;String&gt; ofNullable = Optional.ofNullable(&quot;bam&quot;);</code></pre><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><pre><code class="java">optional.get();                 // &quot;bam&quot; // 如果此 optional 中存在值，则返回值，否则抛出 NoSuchElementException。</code></pre><h3 id="ifPresent"><a href="#ifPresent" class="headerlink" title="ifPresent"></a>ifPresent</h3><pre><code class="java">optional.isPresent();           // true  // 如果存在值，则返回 true，否则返回 false。// 如果存在值，则使用值调用指定的使用者，否则不执行任何操作。optional.ifPresent((s) -&gt; System.out.println(s.charAt(0)));     // &quot;b&quot;// 源码public boolean isPresent() {    return value != null;}public void ifPresent(Consumer&lt;? super T&gt; consumer) {    if (value != null)        consumer.accept(value);}</code></pre><h3 id="orElse，orElseGet，orElseThrow"><a href="#orElse，orElseGet，orElseThrow" class="headerlink" title="orElse，orElseGet，orElseThrow"></a>orElse，orElseGet，orElseThrow</h3><pre><code class="java">optional.orElse(&quot;fallback&quot;);    // &quot;bam&quot; // 返回值（如果存在），否则返回&quot;fallback&quot;。Supplier&lt;String&gt; ss = String::new;opnull.orElseGet(ss); // 返回值（如果存在），否则调用other并返回该 Supplier.get() 的结果。opnull.orElseThrow(()-&gt;new NullPointerException());  // 返回值（如果存在），否则会抛出异常// 源码public T orElse(T other) {    return value != null ? value : other;}public T orElseGet(Supplier&lt;? extends T&gt; other) {    return value != null ? value : other.get();}public &lt;X extends Throwable&gt; T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier) throws X {    if (value != null) {        return value;    } else {        throw exceptionSupplier.get();    }}</code></pre><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>如果当前 Optional 为 Optional.empty，则依旧返回 Optional.empty；否则返回一个新的  Optional，该 Optional 包含的是：函数 mapper 在以 value 作为输入时的输出值。可以多次使用 map 操作：</p><pre><code class="java">ofNullable.map(s-&gt;s.toUpperCase()).map(s -&gt; s.replace(&quot;A&quot;, &quot;AA&quot;)); // BAAM// 源码public&lt;U&gt; Optional&lt;U&gt; map(Function&lt;? super T, ? extends U&gt; mapper) {    Objects.requireNonNull(mapper);    if (!isPresent())        return empty();    else {        return Optional.ofNullable(mapper.apply(value));    }}</code></pre><h3 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h3><p>flatMap 方法与 map 方法的区别在于，map 方法参数中的函数 mapper 输出的是值，然后 map 方法会使用 Optional.ofNullable 将其包装为 Optional；而 flatMap 要求参数中的函数 mapper 输出的就是 Optional。</p><pre><code class="java">ofNullable.map(s-&gt;s.toUpperCase()).flatMap(s -&gt; Optional.of(s.replace(&quot;A&quot;, &quot;AA&quot;))); // BAAM// 源码public&lt;U&gt; Optional&lt;U&gt; flatMap(Function&lt;? super T, Optional&lt;U&gt;&gt; mapper) {    Objects.requireNonNull(mapper);    if (!isPresent())        return empty();    else {        return Objects.requireNonNull(mapper.apply(value));    }}</code></pre><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>filter 方法接受一个 Predicate 来对 Optional 中包含的值进行过滤，如果包含的值满足条件，那么还是返回这个 Optional；否则返回 Optional.empty。</p><pre><code class="java">ofNullable.filter(s-&gt;s.startsWith(&quot;b&quot;));  // bam// 源码public Optional&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate) {    Objects.requireNonNull(predicate);    if (!isPresent())        return this;    else        return predicate.test(value) ? this : empty();}</code></pre><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote><p><a href="https://wizardforcel.gitbooks.io/modern-java/content/ch1.html" target="_blank" rel="noopener">https://wizardforcel.gitbooks.io/modern-java/content/ch1.html</a><br><a href="https://www.jianshu.com/p/82ed16613072" target="_blank" rel="noopener">https://www.jianshu.com/p/82ed16613072</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 8新特性(2) Lambda 表达式</title>
      <link href="/2019/03/13/Java%208%E6%96%B0%E7%89%B9%E6%80%A7(2)%20Lambda%20%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2019/03/13/Java%208%E6%96%B0%E7%89%B9%E6%80%A7(2)%20Lambda%20%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>Lambda 表达式，也可称为闭包，它是推动 Java 8 发布的最重要新特性。</p><p>Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。</p><p>使用 Lambda 表达式可以使代码变的更加简洁紧凑。</p><h1 id="Lambda语法"><a href="#Lambda语法" class="headerlink" title="Lambda语法"></a>Lambda语法</h1><pre><code class="s">(parameters) -&gt; expression或(parameters) -&gt;{ statements; }</code></pre><ul><li>可选类型声明：不需要声明参数类型，编译器可以统一识别参数值。</li><li>可选的参数圆括号：一个参数无需定义圆括号，但多个参数需要定义圆括号。</li><li>可选的大括号：如果主体包含了一个语句，就不需要使用大括号。</li><li>可选的返回关键字：如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。</li></ul><a id="more"></a><h1 id="Lambda-表达式实例"><a href="#Lambda-表达式实例" class="headerlink" title="Lambda 表达式实例"></a>Lambda 表达式实例</h1><pre><code class="java">// 1. 不需要参数,返回值为 5() -&gt; 5// 2. 接收一个参数(数字类型),返回其2倍的值x -&gt; 2 * x// 3. 接受2个参数(数字),并返回他们的差值(x, y) -&gt; x – y// 4. 接收2个int型整数,返回他们的和(int x, int y) -&gt; x + y// 5. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void)(String s) -&gt; System.out.print(s)</code></pre><p>完整的例子</p><pre><code class="java">public class TestLambda {    public static void runThreadUseLambda() {        //Runnable 是一个函数接口，只包含了有个无参数的，返回 void 的 run 方法；        //所以 lambda 表达式左边没有参数，右边也没有 return，只是单纯的打印一句话        new Thread(() -&gt;System.out.println(&quot;lambda实现的线程&quot;)).start();    }    public static void runThreadUseInnerClass() {        //这种方式就不多讲了，以前旧版本比较常见的做法        new Thread(new Runnable() {            @Override            public void run() {                System.out.println(&quot;内部类实现的线程&quot;);            }        }).start();    }    public static void main(String[] args) {        TestLambda.runThreadUseLambda();        TestLambda.runThreadUseInnerClass();    }}</code></pre><h1 id="方法和构造函数引用（-）"><a href="#方法和构造函数引用（-）" class="headerlink" title="方法和构造函数引用（::）"></a>方法和构造函数引用（::）</h1><p>有时候 Lambda 表达式的代码就只是一个简单的方法调用而已，遇到这种情况，Lambda 表达式还可以进一步简化为方法引用（<a href="https://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html" target="_blank" rel="noopener">Method References</a>）。一共有四种形式的方法引用：</p><h2 id="引用静态方法"><a href="#引用静态方法" class="headerlink" title="引用静态方法"></a>引用静态方法</h2><pre><code class="java">List&lt;Integer&gt; ints = Arrays.asList(3, 7, 2);  // [3, 7, 2]// ints.sort((a,b) -&gt; Integer.compare(a,b));  // [2, 3, 7]ints.sort(Integer::compare);  // [2, 3, 7]</code></pre><h2 id="引用特定对象的实例方法（单个对象的）"><a href="#引用特定对象的实例方法（单个对象的）" class="headerlink" title="引用特定对象的实例方法（单个对象的）"></a>引用特定对象的实例方法（单个对象的）</h2><pre><code class="java">List&lt;Integer&gt; ints = Arrays.asList(3, 7, 2);// ints.forEach(x -&gt; System.out.print(x));ints.forEach(System.out::print);/** output:372*/</code></pre><pre><code class="java">@FunctionalInterfaceinterface Converter&lt;F, T&gt; {    T convert(F from);}class Something {    String startsWith(String s) {        return String.valueOf(s.charAt(0));    }}Something something = new Something();Converter&lt;String, String&gt; converter = something::startsWith;String converted = converter.convert(&quot;Java&quot;);System.out.println(converted);    // &quot;J&quot;</code></pre><h2 id="对特定类型的任意对象的实例方法的引用"><a href="#对特定类型的任意对象的实例方法的引用" class="headerlink" title="对特定类型的任意对象的实例方法的引用"></a>对特定类型的<code>任意对象</code>的实例方法的引用</h2><pre><code class="java">String[] stringArray = {&quot;Barbara&quot;, &quot;James&quot;, &quot;Mary&quot;, &quot;John&quot;, &quot;Patricia&quot;, &quot;Robert&quot;, &quot;Michael&quot;, &quot;Linda&quot;};Arrays.sort(stringArray, String::compareToIgnoreCase);// Arrays.sort(stringArray, (a,b) -&gt; a.compareToIgnoreCase(b));System.out.println(Arrays.toString(stringArray));</code></pre><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>首先我们定义一个示例 bean，包含不同的构造方法：</p><pre><code class="java">class Person {    String firstName;    String lastName;    Person() {}    Person(String firstName, String lastName) {        this.firstName = firstName;        this.lastName = lastName;    }}</code></pre><p>接下来，我们定义一个 person 工厂接口，用来创建新的 person 对象：</p><pre><code class="java">interface PersonFactory&lt;P extends Person&gt; {    P create(String firstName, String lastName);}</code></pre><p>然后我们通过构造函数引用来把所有东西拼到一起，而不是像以前一样，通过手动实现一个工厂来这么做。</p><pre><code class="java">// PersonFactory&lt;Person&gt; personFactory = (a,b) -&gt; new Person(a,b);PersonFactory&lt;Person&gt; personFactory = Person::new;Person person = personFactory.create(&quot;Peter&quot;, &quot;Parker&quot;);</code></pre><p>我们通过 <code>Person::new</code> 来创建一个 Person 类构造函数的引用。Java 编译器会自动地选择合适的构造函数来匹配 PersonFactory.create 函数的签名，并选择正确的构造函数形式。</p><h1 id="Lambda-的范围"><a href="#Lambda-的范围" class="headerlink" title="Lambda 的范围"></a>Lambda 的范围</h1><p>对于 lambdab 表达式外部的变量，其访问权限的粒度<strong>与匿名对象的方式非常类似</strong>。你能够访问局部对应的外部区域的局部 final 变量，以及成员变量和静态变量。</p><h2 id="访问局部变量"><a href="#访问局部变量" class="headerlink" title="访问局部变量"></a>访问局部变量</h2><p>我们可以访问 lambda 表达式外部的 final 局部变量：</p><pre><code class="java">final int num = 1;  // final 不是必须的Converter&lt;Integer, String&gt; stringConverter =        (from) -&gt; String.valueOf(from + num);stringConverter.convert(2);     // 3num = 3; // 编译失败，即使 num 没有声明 final，也是 final 的，无法改变</code></pre><h2 id="访问成员变量和静态变量"><a href="#访问成员变量和静态变量" class="headerlink" title="访问成员变量和静态变量"></a>访问成员变量和静态变量</h2><p>与局部变量不同，我们在 lambda 表达式的内部能获取到对成员变量或静态变量的读写权。这种访问行为在匿名对象里是非常典型的。</p><pre><code class="java">class Lambda4 {    static int outerStaticNum;    int outerNum;    void testScopes() {        Converter&lt;Integer, String&gt; stringConverter1 = (from) -&gt; {            outerNum = 23;            return String.valueOf(from);        };        Converter&lt;Integer, String&gt; stringConverter2 = (from) -&gt; {            outerStaticNum = 72;            return String.valueOf(from);        };    }}</code></pre><h2 id="访问默认接口方法"><a href="#访问默认接口方法" class="headerlink" title="访问默认接口方法"></a>访问默认接口方法</h2><pre><code class="java">interface Formula {    double calculate(int a);    default double sqrt(int a) {        return Math.sqrt(a);    }}Formula formula = new Formula() {  // 默认方法可以在匿名对象中使用    @Override    public double calculate(int a) {        return sqrt(a * 100);    }};formula.calculate(100);     // 100.0formula.sqrt(16);           // 4.0</code></pre><p>默认方法无法在lambda表达式内部被访问。因此下面的代码是无法通过编译的：</p><pre><code class="java">Formula formula = (a) -&gt; sqrt( a * 100);</code></pre><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote><p><a href="https://blog.csdn.net/zxhoo/article/details/38349011" target="_blank" rel="noopener">https://blog.csdn.net/zxhoo/article/details/38349011</a><br><a href="https://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html</a><br><a href="http://www.runoob.com/java/java8-lambda-expressions.html" target="_blank" rel="noopener">http://www.runoob.com/java/java8-lambda-expressions.html</a><br><a href="https://wizardforcel.gitbooks.io/modern-java/content/ch1.html" target="_blank" rel="noopener">https://wizardforcel.gitbooks.io/modern-java/content/ch1.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 8新特性(1) 函数式接口与默认方法</title>
      <link href="/2019/03/13/Java%208%E6%96%B0%E7%89%B9%E6%80%A7(1)%20%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%E4%B8%8E%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95/"/>
      <url>/2019/03/13/Java%208%E6%96%B0%E7%89%B9%E6%80%A7(1)%20%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%E4%B8%8E%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>JDK8 下载：<a href="https://jdk8.java.net/download.html" target="_blank" rel="noopener">https://jdk8.java.net/download.html</a></p><h1 id="函数式接口简介"><a href="#函数式接口简介" class="headerlink" title="函数式接口简介"></a>函数式接口简介</h1><p>在 Java 中，Marker（标记）类型的接口是一种没有方法或属性声明的接口，简单地说，marker 接口是<strong>空接口</strong>。相似地，函数式接口（functional interface）是<strong>只包含一个抽象方法声明的接口</strong>。</p><p>定义了这种类型的接口，使得以其为参数的方法，可以在调用时，使用一个 lambda 表达式作为参数。从另一个方面说，一旦我们调用某方法，可以传入 lambda 表达式作为参数，则这个方法的参数类型，必定是一个函数式的接口。</p><p>JDK8 提供 <code>@FunctionalInterface</code> 作为注解，这个注解是非必须的，只要接口符合函数式接口的标准（即只包含一个方法的接口）。</p><p>函数式接口中，只能有一个函数需要被实现，但是也可以有如下例外:</p><ol><li>默认方法与静态方法并不影响函数式接口的契约，可以任意使用，即：<ul><li>函数式接口中可以有静态方法（JDK8 接口可以有公有的静态方法，JDK9 接口可以有非公有的静态方法）。</li><li>可以由 default 修饰的默认方法方法，这个关键字是 Java8 中新增的，为的目的就是使得某一些接口，原则上只有一个方法被实现，但是由于历史原因，不得不加入一些方法来兼容整个 JDK 中的 API，所以就需要使用 default 关键字来定义这样的方法</li></ul></li><li>可以有 Object 中覆盖的方法，也就是 equals，toString，hashcode 等方法。</li></ol><p>JDK 中以前所有的函数式接口都已经使用 <code>@FunctionalInterface</code> 定义，如 java.lang.Runnable 和 java.util.Comparator</p><a id="more"></a><h1 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h1><p>Default 方法是指，在接口内部包含了一些默认的方法实现（也就是接口中可以包含方法体，这打破了Java 之前版本对接口的语法限制），从而使得接口在进行扩展的时候，不会破坏与接口相关的实现类代码。接下来，让我们看一个例子：</p><pre><code class="java">public interface SimpleInterface {    public void doSomeWork();    //使用 default 关键字，创建一个 default 方法，该方法包含了具体的实现代码    default public void doSomeOtherWork(){        System.out.println(&quot;DoSomeOtherWork implementation in the interface&quot;);    }}class SimpleInterfaceImpl implements SimpleInterface{    @Override    public void doSomeWork() {        System.out.println(&quot;Do Some Work implementation in the class&quot;);    }    /*     * 在 SimpleInterfaceImpl 里，不需要再去实现接口中定义的 doSomeOtherWork 方法     */    public static void main(String[] args) {        SimpleInterfaceImpl simpObj = new SimpleInterfaceImpl();        simpObj.doSomeWork();        simpObj.doSomeOtherWork();    }}/** output:Do Some Work implementation in the classDoSomeOtherWork implementation in the interface*/</code></pre><h2 id="实现多个接口"><a href="#实现多个接口" class="headerlink" title="实现多个接口"></a>实现多个接口</h2><p>如果一个类实现了两个接口，这两个接口又同时都包含了一个名字相同的 default 方法，并且该类没有实现 default 方法，则会得到一个编译器错误，因为编译器不知道应该在两个同名的 default 方法中选择哪一个，因此产生了二义性。</p><pre><code class="java">interface A {    default public void hello(){        System.out.println(&quot;A&quot;);    }}interface B extends A{  // 优先选取最具体的实现    @Override    default public void hello(){        System.out.println(&quot;B&quot;);    }}public class C implements A, B{    public static void main(String[] args) {        C c = new C();        c.hello();    }//    @Override//    public void hello(){  // 类实现的方法，优先级最高//        System.out.println(&quot;C&quot;);//    }}/** output:B*/</code></pre><p>如果想调用 A 的默认函数，则用到新语法 <code>X.super.m(...)</code>，下面修改 C 类，实现 A 接口，重写一个 hello 方法，如下所示：</p><pre><code class="java">public class C implements A{    @Override    public void hello(){        A.super.hello();    }    public static void main(String[] args){        new C().hello();    }}/** output:A*/</code></pre><h2 id="默认方法与抽象类的非抽象方法的区别"><a href="#默认方法与抽象类的非抽象方法的区别" class="headerlink" title="默认方法与抽象类的非抽象方法的区别"></a>默认方法与抽象类的非抽象方法的区别</h2><p>相同点：</p><ol><li>都是抽象类型；</li><li>都可以有实现方法（以前接口不行）；</li><li>都可以不需要实现类或者继承者去实现所有方法，（以前不行，现在接口中默认方法不需要实现者实现）</li></ol><p>不同点：</p><ol><li>抽象类不可以多重继承，接口可以（无论是多重类型继承还是多重行为继承）；</li><li>抽象类和接口所反映出的设计理念不同。其实抽象类表示的是 &quot;is-a&quot; 关系，接口表示的是 &quot;like-a&quot; 关系；</li><li>接口中定义的变量默认是 public static final 型，且必须给其初值，所以实现类中不能改变其值；抽象类中的变量默认是 friendly 型，其值可以在子类中重新定义，也可以重新赋值。</li><li>接口的 default methods 只能是 public。抽象类的 abstract method 可以是 protected。</li></ol><h1 id="接口的静态方法"><a href="#接口的静态方法" class="headerlink" title="接口的静态方法"></a>接口的静态方法</h1><p>除了抽象方法和默认方法，从 Java8 开始，接口也可以有公有静态方法了。JDK9 接口可以有非公有的静态方法。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote><p><a href="https://www.cnblogs.com/ownraul/p/5551545.html" target="_blank" rel="noopener">https://www.cnblogs.com/ownraul/p/5551545.html</a><br><a href="http://www.importnew.com/7302.html" target="_blank" rel="noopener">http://www.importnew.com/7302.html</a><br><a href="https://my.oschina.net/benhaile/blog/176007" target="_blank" rel="noopener">https://my.oschina.net/benhaile/blog/176007</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu 常用软件</title>
      <link href="/2019/03/11/Ubuntu%20%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/"/>
      <url>/2019/03/11/Ubuntu%20%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="视频播放器"><a href="#视频播放器" class="headerlink" title="视频播放器"></a>视频播放器</h1><pre><code class="shell">sudo apt install mpvsudo apt-get install smplayer</code></pre><h1 id="搜狗拼音"><a href="#搜狗拼音" class="headerlink" title="搜狗拼音"></a>搜狗拼音</h1><blockquote><p><a href="https://www.jianshu.com/p/429b8f75af2c" target="_blank" rel="noopener">https://www.jianshu.com/p/429b8f75af2c</a></p></blockquote><pre><code class="shell">sudo apt install Fcitxsudo dpkg -i sogoupinyin_2.2.0.0108_amd64.deb</code></pre><p>候选框中候选词不是中文，而是英文的乱码字符，试了很多方法，卸载重装、更换字体等均不奏效。<br>解决办法：</p><pre><code class="shell">rm -rf ~/.config/SogouPY ~/.config/sogou*</code></pre><h1 id="安装-Microsoft-Windows-Fonts-微软字体库"><a href="#安装-Microsoft-Windows-Fonts-微软字体库" class="headerlink" title="安装 Microsoft Windows Fonts 微软字体库"></a>安装 Microsoft Windows Fonts 微软字体库</h1><blockquote><p><a href="https://blog.csdn.net/gatieme/article/details/51901396" target="_blank" rel="noopener">https://blog.csdn.net/gatieme/article/details/51901396</a></p></blockquote><p><code>ttf-mscorefonts-installer</code> 包就是微软的字体包, 可以直接在软件中心中找到安装</p><p>也可以使用命令的方式安装</p><pre><code class="shell">sudo apt-get install ttf-mscorefonts-installer</code></pre><p>在安装字体后，我们需要使用命令来更新字体缓存：</p><pre><code class="shell">sudo fc-cache -f -v</code></pre><h1 id="电驴下载"><a href="#电驴下载" class="headerlink" title="电驴下载"></a>电驴下载</h1><pre><code class="shell">sudo apt-get install amule</code></pre><h1 id="GoldenDict-词典"><a href="#GoldenDict-词典" class="headerlink" title="GoldenDict 词典"></a>GoldenDict 词典</h1><pre><code class="shell">sudo apt-get install goldendict</code></pre><p>词典下载 <a href="http://pan.baidu.com/share/link?shareid=443301&amp;uk=3189859145" target="_blank" rel="noopener">http://pan.baidu.com/share/link?shareid=443301&amp;uk=3189859145</a></p><p>词典的下载网址： <a href="http://www.pdawiki.com/forum/forum-4-1.html" target="_blank" rel="noopener">http://www.pdawiki.com/forum/forum-4-1.html</a></p><p>词典介绍：<a href="https://www.jianshu.com/p/f82240fe486d" target="_blank" rel="noopener">https://www.jianshu.com/p/f82240fe486d</a></p><p>简明英汉字典增强版：<a href="https://github.com/skywind3000/ECDICT" target="_blank" rel="noopener">https://github.com/skywind3000/ECDICT</a></p><h1 id="屏幕色温调节软件-F-lux"><a href="#屏幕色温调节软件-F-lux" class="headerlink" title="屏幕色温调节软件 F.lux"></a>屏幕色温调节软件 F.lux</h1><blockquote><p><a href="https://blog.csdn.net/gatieme/article/details/62922164" target="_blank" rel="noopener">https://blog.csdn.net/gatieme/article/details/62922164</a></p></blockquote><p>github 地址：<a href="https://github.com/xflux-gui/fluxgui" target="_blank" rel="noopener">https://github.com/xflux-gui/fluxgui</a></p><h2 id="使用-PPA-源安装-flux-gui"><a href="#使用-PPA-源安装-flux-gui" class="headerlink" title="使用 PPA 源安装 flux-gui"></a>使用 PPA 源安装 flux-gui</h2><pre><code class="shell">sudo add-apt-repository ppa:nathan-renniewaldock/fluxsudo apt-get updatesudo apt-get install fluxgui</code></pre><h2 id="安装守护进程"><a href="#安装守护进程" class="headerlink" title="安装守护进程"></a>安装守护进程</h2><pre><code class="shell">wget https://justgetflux.com/linux/xflux64.tgztar -zxvf xflux64.tgzsudo cp xflux /usr/bin</code></pre><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><pre><code class="shell">fluxgui</code></pre><h1 id="坚果云"><a href="#坚果云" class="headerlink" title="坚果云"></a>坚果云</h1><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p><a href="https://www.jianguoyun.com/s/downloads/linux" target="_blank" rel="noopener">https://www.jianguoyun.com/s/downloads/linux</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code class="shell"># 1. 使用gdebi安装，自动安装依赖（18.04 找不到命令，需安装 sudo apt-get install gdebi）sudo gdebi nautilus_nutstore_amd64.deb# 2. ubuntu双击使用软件中心安装，自动安装依赖# 3. 使用dpkg安装，使用apt-get -f install安装依赖sudo dpkg -i nautilus_nutstore_amd64.debsudo apt-get install -f</code></pre><p>用了一段时间，突然无法自动同步，点击图标也无法打开，所以放弃使用。</p><h1 id="Shadowsocks"><a href="#Shadowsocks" class="headerlink" title="Shadowsocks"></a>Shadowsocks</h1><pre><code class="shell">apt-get install python-pippip install shadowsocks</code></pre><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><blockquote><p><a href="https://blog.huihut.com/2017/08/25/LinuxInstallConfigShadowsocksClient/" target="_blank" rel="noopener">https://blog.huihut.com/2017/08/25/LinuxInstallConfigShadowsocksClient/</a></p></blockquote><p>找个地方放 shadowsocks 的配置文件，如用户目录下：</p><pre><code class="shell">vi /home/xx/shadowsocks.json</code></pre><p>然后在 shadowsocks.json 里面添加配置信息，如：</p><pre><code class="json">{  &quot;server&quot;:&quot;my_server_ip&quot;,  &quot;local_address&quot;:&quot;127.0.0.1&quot;,  &quot;local_port&quot;:1080,  &quot;server_port&quot;:my_server_port,  &quot;password&quot;:&quot;my_password&quot;,  &quot;timeout&quot;:300,  &quot;method&quot;:&quot;aes-256-cfb&quot;}</code></pre><p>my_server_ip：自己的服务器IP<br>my_server_port：自己的服务器端口<br>my_server_password：自己的密码<br>method：为自己的加密方式，一般是aes-256-cfb或者rc4-md5</p><p>设置系统代理，在设置--&gt;网络设置--&gt;代理设置中选择手动代理，在 Socks 主机处填写：127.0.0.1，端口 1080。</p><p>但是系统代理是全局走代理的，访问国内网站一般会有限制（速度较慢、浪费流量、版权受限等）。</p><h2 id="设置自动代理"><a href="#设置自动代理" class="headerlink" title="设置自动代理"></a>设置自动代理</h2><blockquote><p><a href="https://www.jianshu.com/p/f85b8b5cd647" target="_blank" rel="noopener">https://www.jianshu.com/p/f85b8b5cd647</a></p></blockquote><p>生成 PAC 文件有以下两个工具：</p><ul><li><a href="https://github.com/JinnLynn/genpac" target="_blank" rel="noopener">Genpac</a><pre><code class="shell">  genpac --proxy=&quot;SOCKS5 127.0.0.1:1080&quot; --gfwlist-proxy=&quot;SOCKS5 127.0.0.1:1080&quot; -o autoproxy.pac --gfwlist-url=&quot;https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt&quot;</code></pre></li><li><a href="https://github.com/clowwindy/gfwlist2pac" target="_blank" rel="noopener">gfwlist2pac</a></li></ul><p>或下载已经生成的 <a href="https://raw.githubusercontent.com/Neutree/note/master/tool/shadowsocks/autoproxy.pac" target="_blank" rel="noopener">PAC 文件</a></p><p>设置系统自动代理，在设置--&gt;网络设置--&gt;代理设置中选择自动代理，URL 填写生成的 PAC 文件地址，file://文件路径/文件名(可以直接把文件拖到URL栏)，可能某些系统是 <code>file:///..../....pac</code>，可以把文件拖到浏览器看地址</p><h2 id="测试启动"><a href="#测试启动" class="headerlink" title="测试启动"></a>测试启动</h2><p>配置文件的路径改成自己的，如：/etc/shadowsocks.json</p><p>前端启动：<code>sslocal -c /home/xx/shadowsocks.json</code><br>后端启动：<code>sslocal -c /home/xx/shadowsocks.json -d start</code><br>后端停止：<code>sslocal -c /home/xx/shadowsocks.json -d stop</code><br>重启(修改配置要重启才生效)：<code>sslocal -c /home/xx/shadowsocks.json -d restart</code></p><h2 id="开机自启"><a href="#开机自启" class="headerlink" title="开机自启"></a>开机自启</h2><p>以下使用 Systemd 来实现 shadowsocks 开机自启。</p><pre><code class="shell">sudo vi /etc/systemd/system/shadowsocks.service</code></pre><p>在里面填写如下内容：</p><pre><code class="ini">[Unit]Description=Shadowsocks Client ServiceAfter=network.target[Service]Type=simpleUser=rootExecStart=/usr/bin/sslocal -c /home/xx/shadowsocks.json[Install]WantedBy=multi-user.target</code></pre><p>把 /home/xx/shadowsocks.json 修改为你的 shadowsocks.json 路径，如：/etc/shadowsocks.json</p><p>配置生效：</p><pre><code class="shell">systemctl enable /etc/systemd/system/shadowsocks.service</code></pre><h1 id="chm-阅读器"><a href="#chm-阅读器" class="headerlink" title="chm 阅读器"></a>chm 阅读器</h1><pre><code class="shell">sudo apt-get install kchmviewer</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows 文件共享不同网段之间访问设置</title>
      <link href="/2019/03/11/Windows%20%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB%E4%B8%8D%E5%90%8C%E7%BD%91%E6%AE%B5%E4%B9%8B%E9%97%B4%E8%AE%BF%E9%97%AE%E8%AE%BE%E7%BD%AE/"/>
      <url>/2019/03/11/Windows%20%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB%E4%B8%8D%E5%90%8C%E7%BD%91%E6%AE%B5%E4%B9%8B%E9%97%B4%E8%AE%BF%E9%97%AE%E8%AE%BE%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="不同网段之间访问设置"><a href="#不同网段之间访问设置" class="headerlink" title="不同网段之间访问设置"></a>不同网段之间访问设置</h1><p>在防火墙设置里“允许程序或功能通过防火墙”中启用“文件和打印机共享”。</p><p>进入高级设置，“入站设置”，在“文件和打印机共享(SMB-In)-属性-作用域”远程IP地址下面增加你要的网段就可以了。 例如：10.247.200.0/24</p><blockquote><p><a href="https://blog.csdn.net/rrrrssss00/article/details/6456976" target="_blank" rel="noopener">https://blog.csdn.net/rrrrssss00/article/details/6456976</a> 含下方评论</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu 使用技巧</title>
      <link href="/2019/03/11/Ubuntu%20%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
      <url>/2019/03/11/Ubuntu%20%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="合上笔记本，系统不睡眠"><a href="#合上笔记本，系统不睡眠" class="headerlink" title="合上笔记本，系统不睡眠"></a>合上笔记本，系统不睡眠</h1><blockquote><p><a href="https://linux.cn/article-2485-1.html" target="_blank" rel="noopener">https://linux.cn/article-2485-1.html</a></p></blockquote><p>直接编辑 Login Manager 的配置文件（logind.conf）。这个方法基本能生效，建议使用这个。</p><p>要开始了，按下 <code>Ctrl – Alt – T</code> 组合键，打开终端。然后运行下面的命令打开 <code>logind.conf</code> 文件。你的所有修改都在这个文件内。</p><pre><code class="shell">sudo gedit /etc/systemd/logind.conf</code></pre><p>打开文件后修改下面这行：</p><pre><code class="ini">#HandleLidSwitch=suspend</code></pre><p>改成这样：</p><pre><code class="ini">HandleLidSwitch=ignore</code></pre><p>保存文件，重启 Login Manager 服务(实测不成功 sudo: restart：找不到命令)：</p><pre><code class="shell">sudo restart systemd-logind</code></pre><a id="more"></a><h1 id="文件管理器左侧快捷方式管理"><a href="#文件管理器左侧快捷方式管理" class="headerlink" title="文件管理器左侧快捷方式管理"></a>文件管理器左侧快捷方式管理</h1><blockquote><p><a href="https://my.oschina.net/lieefu/blog/469407" target="_blank" rel="noopener">https://my.oschina.net/lieefu/blog/469407</a></p></blockquote><pre><code class="shell">vim ~/.config/user-dirs.dirs</code></pre><p>默认的内容是文档，图片，下载等目录</p><pre><code class="ini"># This file is written by xdg-user-dirs-update# If you want to change or add directories, just edit the line you&#39;re# interested in. All local changes will be retained on the next run.# Format is XDG_xxx_DIR=&quot;$HOME/yyy&quot;, where yyy is a shell-escaped# homedir-relative path, or XDG_xxx_DIR=&quot;/yyy&quot;, where /yyy is an# absolute path. No other format is supported.#XDG_DESKTOP_DIR=&quot;$HOME/Desktop&quot;XDG_DOWNLOAD_DIR=&quot;$HOME/Downloads&quot;XDG_TEMPLATES_DIR=&quot;$HOME/Templates&quot;XDG_PUBLICSHARE_DIR=&quot;$HOME/Public&quot;XDG_DOCUMENTS_DIR=&quot;$HOME/Documents&quot;XDG_MUSIC_DIR=&quot;$HOME/Music&quot;XDG_PICTURES_DIR=&quot;$HOME/Pictures&quot;# XDG_VIDEOS_DIR=&quot;$HOME/soft&quot;DG_VIDEOS_DIR=&quot;$HOME/Videos&quot;</code></pre><p>参考资料： <a href="http://askubuntu.com/questions/325518/how-can-i-edit-nautilus-places-sidebar-and-unity-quicklist" target="_blank" rel="noopener">http://askubuntu.com/questions/325518/how-can-i-edit-nautilus-places-sidebar-and-unity-quicklist</a></p><h1 id="应用程序，卸载图标残留"><a href="#应用程序，卸载图标残留" class="headerlink" title="应用程序，卸载图标残留"></a>应用程序，卸载图标残留</h1><p>图标位置：<code>/usr/share/applications</code></p><h1 id="apt-get-彻底卸载软件包"><a href="#apt-get-彻底卸载软件包" class="headerlink" title="apt-get 彻底卸载软件包"></a>apt-get 彻底卸载软件包</h1><p>浏览已安装的程序。要查看已安装的软件包列表，请输入以下命令。请注意你希望卸载的软件包的名称。</p><pre><code class="shell">dpkg --list</code></pre><p><a href="https://blog.csdn.net/get_set/article/details/51276609?utm_source=copy" target="_blank" rel="noopener">https://blog.csdn.net/get_set/article/details/51276609?utm_source=copy</a></p><pre><code class="shell"># 删除软件及其配置文件apt-get --purge remove &lt;package&gt;# 只卸载程序。保留配置文件：sudo apt-get remove &lt;package&gt;# 删除没用的依赖包apt-get autoremove &lt;package&gt;# 此时dpkg的列表中有“rc”状态的软件包，可以执行如下命令做最后清理：dpkg -l |grep ^rc|awk &#39;{print $2}&#39; |sudo xargs dpkg -P</code></pre><h1 id="访问-windows-的共享目录"><a href="#访问-windows-的共享目录" class="headerlink" title="访问 windows 的共享目录"></a>访问 windows 的共享目录</h1><p>windows 网络主机的 IP: 192.168.0.1<br>网络主机的使用者名称: myusername<br>网络主机的登录密码: mypassword<br>分享中的目录名称: linux<br>主机上要挂载的目录: /media/sharename</p><p>要挂载网络共享目录时</p><pre><code class="shell">sudo mkdir /media/sharenamesudo mount //192.168.0.1/linux /media/sharename/ -o username=myusername,password=mypasswordsudo mount //192.168.1.104/Users/zb/Documents /media/win7/ -o username=zb,password=1</code></pre><p>要卸载网络共享目录时</p><pre><code class="shell">sudo umount /media/sharename/</code></pre><p>更简单的方式：</p><ol><li>安装 <code>samba</code>，<code>apt-get install smbfs</code></li><li>打开一个文件浏览窗口，按快捷键 ctrl + L ，输入 smb://192.168.0.* 既可以访问 windows 的共享目录了。</li></ol><h1 id="查看-IP-地址"><a href="#查看-IP-地址" class="headerlink" title="查看 IP 地址"></a>查看 IP 地址</h1><blockquote><p><a href="https://zh.wikihow.com/在Linux系统中查看IP地址" target="_blank" rel="noopener">https://zh.wikihow.com/在Linux系统中查看IP地址</a></p></blockquote><p><code>ip addr show</code></p><pre><code class="shell">$ ip addr show1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet 127.0.0.1/8 scope host lo       valid_lft forever preferred_lft forever    inet6 ::1/128 scope host       valid_lft forever preferred_lft forever2: enp0s25: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc fq_codel state DOWN group default qlen 1000    link/ether e8:9a:8f:cf:82:65 brd ff:ff:ff:ff:ff:ff3: wlp5s0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000    link/ether 74:e5:0b:34:96:0c brd ff:ff:ff:ff:ff:ff    inet 192.168.86.224/24 brd 192.168.86.255 scope global dynamic noprefixroute wlp5s0       valid_lft 74929sec preferred_lft 74929sec    inet6 fe80::fa93:6b62:7197:fd42/64 scope link noprefixroute       valid_lft forever preferred_lft forever</code></pre><p><code>hostname -I</code></p><pre><code class="shell">$ hostname -I192.168.86.224</code></pre><h1 id="设置-root-用户初始密码"><a href="#设置-root-用户初始密码" class="headerlink" title="设置 root 用户初始密码"></a>设置 root 用户初始密码</h1><p>输入 sudo passwd 命令</p><h1 id="截图"><a href="#截图" class="headerlink" title="截图"></a>截图</h1><p>可在 <code>设置 --&gt; 设备 --&gt; 键盘</code>，查看或修改</p><ul><li>复制整个窗口截图到剪贴板：Ctrl + Print</li><li>复制当前窗口截图到剪贴板：Ctrl + Alt + Print</li><li>复制选区截图到剪贴板：Shift + Ctrl + Print</li><li>将整个窗口截图保存到 Pictures 目录：Print</li><li>将当前窗口截图保存到 Pictures 目录：Alt + Print</li><li>将选区截图保存到 Pictures 目录：Shift + Print</li><li>屏幕录像：Shift + Ctrl + Alt + R</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 下查看和添加环境变量</title>
      <link href="/2019/03/11/Linux%20%E4%B8%8B%E6%9F%A5%E7%9C%8B%E5%92%8C%E6%B7%BB%E5%8A%A0%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
      <url>/2019/03/11/Linux%20%E4%B8%8B%E6%9F%A5%E7%9C%8B%E5%92%8C%E6%B7%BB%E5%8A%A0%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/aaronLinux/p/5837702.html" target="_blank" rel="noopener">https://www.cnblogs.com/aaronLinux/p/5837702.html</a></p><h1 id="可用-export-命令查看-PATH-值"><a href="#可用-export-命令查看-PATH-值" class="headerlink" title="可用 export 命令查看 PATH 值"></a>可用 export 命令查看 PATH 值</h1><pre><code class="shell">zb@zbUbuntu:~$ exportdeclare -x CLASSPATH=&quot;./:/usr/java/jdk1.8.0_181/lib:/usr/java/jdk1.8.0_181/jre/lib&quot;declare -x CLUTTER_IM_MODULE=&quot;xim&quot;declare -x COLORTERM=&quot;truecolor&quot;...</code></pre><a id="more"></a><h1 id="查看-PATH-环境变量"><a href="#查看-PATH-环境变量" class="headerlink" title="查看 PATH 环境变量"></a>查看 PATH 环境变量</h1><pre><code class="shell">zb@zbUbuntu:~$ echo $PATH/home/zb/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/usr/java/jdk1.8.0_181/bin</code></pre><h1 id="添加-PATH-环境变量（临时）"><a href="#添加-PATH-环境变量（临时）" class="headerlink" title="添加 PATH 环境变量（临时）"></a>添加 PATH 环境变量（临时）</h1><p>设置/取消代理，临时设置（终端关闭失效）</p><pre><code class="shell">export http_proxy=118.210.42.251:44367# 或：export https_proxy=118.210.42.251:44367# 要取消该设置：unset http_proxy# 或：unset https_proxy</code></pre><h1 id="永久添加环境变量（影响当前用户）"><a href="#永久添加环境变量（影响当前用户）" class="headerlink" title="永久添加环境变量（影响当前用户）"></a>永久添加环境变量（影响当前用户）</h1><pre><code class="shell">zb@zbUbuntu:~$ vim ~/.bashrcexport JAVA_HOME=/usr/java/jdk1.8.0_181</code></pre><h1 id="永久添加环境变量（影响所有用户）"><a href="#永久添加环境变量（影响所有用户）" class="headerlink" title="永久添加环境变量（影响所有用户）"></a>永久添加环境变量（影响所有用户）</h1><pre><code class="shell">root@zbUbuntu:/home/zb# vim /etc/profile# 在文档最后，添加:export JAVA_HOME=/usr/java/jdk1.8.0_181# 保存，退出，然后运行：root@zbUbuntu:/home/zb# source /etc/profile</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python filecmp 文件和目录比较</title>
      <link href="/2019/01/26/Python%20filecmp%20%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%AF%94%E8%BE%83/"/>
      <url>/2019/01/26/Python%20filecmp%20%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%AF%94%E8%BE%83/</url>
      
        <content type="html"><![CDATA[<h1 id="filecmp，文件比较"><a href="#filecmp，文件比较" class="headerlink" title="filecmp，文件比较"></a>filecmp，文件比较</h1><p>filecmp 模块定义了用于比较文件和目录的函数，具有各种可选的时间/正确性权衡。要比较文件，请参见 difflib 模块。</p><p>filecmp 模块定义了以下函数：</p><h2 id="filecmp-cmp-f1-f2-shallow-True"><a href="#filecmp-cmp-f1-f2-shallow-True" class="headerlink" title="filecmp.cmp(f1, f2, shallow=True)"></a>filecmp.cmp(f1, f2, shallow=True)</h2><p>比较名为 f1 和 f2 的文件，如果它们相等则返回 True，否则返回 False。</p><p>如果 shallow 为真，则具有相同 os.stat() 签名的文件将被视为相等。否则，将比较文件的内容。</p><p>此函数使用缓存进行过去的比较和结果，如果文件的 os.stat() 信息更改，缓存条目将无效。可以使用 clear_cache() 清除整个高速缓存。</p><a id="more"></a><h2 id="filecmp-cmpfiles-dir1-dir2-common-shallow-True"><a href="#filecmp-cmpfiles-dir1-dir2-common-shallow-True" class="headerlink" title="filecmp.cmpfiles(dir1, dir2, common, shallow=True)"></a>filecmp.cmpfiles(dir1, dir2, common, shallow=True)</h2><p>比较 dir1 和 dir2 两个目录中文件，文件的名字由 common 给出。返回三个文件名列表：match、mismatch、errors。</p><ul><li><strong>mtach</strong>：包含匹配文件的列表</li><li><strong>mismatch</strong>：包含不匹配文件的列表</li><li><strong>errors</strong>：列出无法比较的文件的名称。如果文件在其中一个目录中不存在，用户没有足够的权限读取它们，或者某些其他原因不可比较，那么它们将在 errors 中列出。</li></ul><p>例如，<code>cmpfiles(&#39;a&#39;， &#39;b&#39;， [&#39;c&#39;， &#39;d / e&#39; ])</code> 会将 <code>a/c</code> 与 <code>b/c</code> 和 <code>a/d/e</code> 与 <code>b/d/e&#39;c&#39;</code> 和 <code>&#39;d/e&#39;</code> 将分别位于三个返回的列表之一。</p><h2 id="filecmp-clear-cache"><a href="#filecmp-clear-cache" class="headerlink" title="filecmp.clear_cache()"></a>filecmp.clear_cache()</h2><p>清除 filecmp 缓存。</p><h1 id="dircmp，目录比较"><a href="#dircmp，目录比较" class="headerlink" title="dircmp，目录比较"></a>dircmp，目录比较</h1><p>class filecmp.dircmp(a, b, ignore=None, hide=None)</p><p>构造一个新的目录比较对象，比较目录 a 和 b。ignore 是要忽略的名称列表，默认为 <code>filecmp.DEFAULT_IGNORES</code> 。hide 是要隐藏的名称列表，默认为 <code>os.curdir(.)</code>，<code>os.pardir(..)</code>。</p><p>filecmp.DEFAULT_IGNORES：[&#39;RCS&#39;, &#39;CVS&#39;, &#39;tags&#39;, &#39;.git&#39;, &#39;.hg&#39;, &#39;.bzr&#39;, &#39;<em>darcs&#39;, &#39;<em>_pycache</em></em>&#39;]</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="report"><a href="#report" class="headerlink" title="report()"></a>report()</h3><p>打印 a 和 b 之间的比较报告，仅仅展示了给定的两个目录比较结果而<strong>没有递归</strong>。这里没有办法像 cmp() 那样比较文件内容。即具有相同 os.stat() 签名的文件将被视为相等。</p><h3 id="report-partial-closure"><a href="#report-partial-closure" class="headerlink" title="report_partial_closure()"></a>report_partial_closure()</h3><p>打印 a 和 b 以及共有的直接子目录之间的比较。</p><h3 id="report-full-closure"><a href="#report-full-closure" class="headerlink" title="report_full_closure()"></a>report_full_closure()</h3><p>打印 a 和 b 以及共有的子目录（<strong>递归地</strong>）之间的比较。</p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>可用于获取有关正在比较的目录树的各种位信息。</p><ul><li><strong>left</strong>：目录 a。</li><li><strong>right</strong>：目录 b。</li><li><strong>left_list</strong>：通过 hide 和 ignore 筛选后，a 中的文件和子目录（不含 a）。</li><li><strong>right_list</strong>：通过 hide 和 ignore 筛选后，b 中的文件和子目录。</li><li><strong>common</strong>：a 和 b 中共同的文件和子目录。</li><li><strong>left_only</strong>：只是 a 中的文件和子目录。</li><li><strong>right_only</strong>：只是 b 中的文件和子目录。</li><li><strong>common_dirs</strong>：a 和 b 中共同的子目录。</li><li><strong>common_files</strong>：a 和 b 中的文件。</li><li><strong>common_funny</strong>：a 和 b 中的名称，以使类型在目录之间不同，或 os.stat() 报告错误的名称。在 a 中是一个文件，而在 b 中是个子目录。</li><li><strong>same_files</strong>：a 和 b 中相同的文件，使用该类的文件比较运算符（os.stat()）。</li><li><strong>diff_files</strong>：a 和 b 中根据该类的文件比较操作符，其内容不同的文件。</li><li><strong>funny_files</strong>：a 和 b 中无法比较的文件。</li><li><strong>subdirs</strong>：将 common_dirs 中的名称映射到 dircmp 对象的字典。</li></ul><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><h2 id="判断两个文件夹是否一致"><a href="#判断两个文件夹是否一致" class="headerlink" title="判断两个文件夹是否一致"></a>判断两个文件夹是否一致</h2><blockquote><p><a href="https://bbs.csdn.net/topics/392363043" target="_blank" rel="noopener">https://bbs.csdn.net/topics/392363043</a></p></blockquote><pre><code class="py">from filecmp import dircmpdef is_samedir(dcmp):    if(len(dcmp.diff_files + dcmp.left_only + dcmp.right_only)):        return False    for sub_dcmp in dcmp.subdirs.values():        is_samedir(sub_dcmp)    return Truedcmp = dircmp(r&#39;D:\dir1&#39;,r&#39;D:\dir2&#39;)print(is_samedir(dcmp))</code></pre><h2 id="使用-subdirs-属性通过两个目录递归搜索以显示不同文件："><a href="#使用-subdirs-属性通过两个目录递归搜索以显示不同文件：" class="headerlink" title="使用 subdirs 属性通过两个目录递归搜索以显示不同文件："></a>使用 subdirs 属性通过两个目录递归搜索以显示不同文件：</h2><pre><code class="py">from filecmp import dircmpdef print_diff_files(dcmp):    for name in dcmp.diff_files:        print(&quot;diff_file %s found in %s and %s&quot; % (name, dcmp.left, dcmp.right))    for sub_dcmp in dcmp.subdirs.values():        print_diff_files(sub_dcmp)dcmp = dircmp(r&#39;D:\dir1&#39;,r&#39;D:\dir2&#39;)print_diff_files(dcmp)</code></pre><blockquote><p><a href="https://docs.python.org/3/library/filecmp.html" target="_blank" rel="noopener">https://docs.python.org/3/library/filecmp.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python APScheduler 任务调度利器</title>
      <link href="/2019/01/26/Python%20APScheduler%20%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%88%A9%E5%99%A8/"/>
      <url>/2019/01/26/Python%20APScheduler%20%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%88%A9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>官网文档：<a href="https://apscheduler.readthedocs.io/en/v3.3.0/index.html" target="_blank" rel="noopener">https://apscheduler.readthedocs.io/en/v3.3.0/index.html</a><br>GitHub：<a href="https://github.com/agronholm/apscheduler" target="_blank" rel="noopener">https://github.com/agronholm/apscheduler</a><br>安装：<code>pip install apscheduler</code></p><h1 id="调度模式"><a href="#调度模式" class="headerlink" title="调度模式"></a>调度模式</h1><p>内置了三种调度模式：</p><ul><li>Cron 风格</li><li>间隔性(Interval-based)执行</li><li>仅在某个时间执行一次</li></ul><a id="more"></a><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><pre><code class="py">from datetime import datetimefrom apscheduler.schedulers.blocking import BlockingSchedulerdef cronJob():    nowtime = datetime.now().strftime(&quot;%Y-%m-%d %H:%M:%S&quot;)    print(nowtime + &quot;, cronJob&quot;)def intervalJob():    nowtime = datetime.now().strftime(&quot;%Y-%m-%d %H:%M:%S&quot;)    print(nowtime + &quot;, intervalJob&quot;)# 带参数def dateJob(text):    print(text)scheduler = BlockingScheduler()scheduler.add_job(cronJob, &#39;cron&#39;, hour=&#39;10&#39;, minute=&#39;10&#39;)  # 每天10点10分执行scheduler.add_job(intervalJob, &#39;interval&#39;, minutes=1)  # 每一分钟执行一次scheduler.add_job(dateJob, &#39;date&#39;, run_date=datetime(2019, 1, 25, 16, 47, 0), args=[&#39;text&#39;])  # 指定时间执行，也可以是 from datetime import date 类型scheduler.start()</code></pre><h2 id="date"><a href="#date" class="headerlink" title="date"></a>date</h2><p>仅在某个时间执行一次</p><pre><code class="py">scheduler.add_job(dateJob, &#39;date&#39;, run_date=date(2009, 11, 6), args=[&#39;text&#39;])scheduler.add_job(dateJob, &#39;date&#39;, run_date=datetime(2019, 1, 25, 16, 47, 0), args=[&#39;text&#39;])scheduler.add_job(dateJob, args=[&#39;text&#39;])  # 立即执行，&#39;date&#39;, run_date=datetime.now()，是默认的</code></pre><h2 id="interval"><a href="#interval" class="headerlink" title="interval"></a>interval</h2><p>间隔性(Interval-based)执行</p><p>按指定的时间间隔触发，如果指定则从 start_date 开始，否则为 datetime.now（）+ interval。</p><p>参数:</p><ul><li>weeks (int) – number of weeks to wait</li><li>days (int) – number of days to wait</li><li>hours (int) – number of hours to wait</li><li>minutes (int) – number of minutes to wait</li><li>seconds (int) – number of seconds to wait</li><li>start_date (datetime|str) – starting point for the interval calculation</li><li>end_date (datetime|str) – latest possible date/time to trigger on</li><li>timezone (datetime.tzinfo|str) – time zone to use for the date/time calculations</li></ul><pre><code class="py">scheduler.add_job(intervalJob, &#39;interval&#39;, hours=2, start_date=&#39;2019-01-10 09:30:00&#39;, end_date=&#39;2019-06-15 11:00:00)</code></pre><h2 id="interval-设置立刻执行"><a href="#interval-设置立刻执行" class="headerlink" title="interval 设置立刻执行"></a>interval 设置立刻执行</h2><pre><code class="py">scheduler.add_job(intervalJob, &#39;interval&#39;, hours=2, next_run_time=datetime.datetime.now())</code></pre><h2 id="使用装饰器"><a href="#使用装饰器" class="headerlink" title="使用装饰器"></a>使用装饰器</h2><pre><code class="py">from apscheduler.scheduler import BlockingScheduler@scheduler.scheduled_job(&#39;interval&#39;, id=&#39;my_job_id&#39;, hours=2)def job_function():    print(&quot;Hello World&quot;)</code></pre><h2 id="cron"><a href="#cron" class="headerlink" title="cron"></a>cron</h2><p>当前时间与所有指定的时间约束匹配时触发，类似于 UNIX cron 调度程序的工作方式。与 crontab 表达式不同，您可以省略不需要的字段（默认为 *）。</p><p>参数:</p><ul><li>year (int|str) – 4-digit year</li><li>month (int|str) – month (1-12)</li><li>day (int|str) – day of the (1-31)</li><li>week (int|str) – ISO week (1-53)</li><li>day_of_week (int|str) – number or name of weekday (0-6 or mon,tue,wed,thu,fri,sat,sun)</li><li>hour (int|str) – hour (0-23)</li><li>minute (int|str) – minute (0-59)</li><li>second (int|str) – second (0-59)</li><li>start_date (datetime|str) – earliest possible date/time to trigger on (inclusive)</li><li>end_date (datetime|str) – latest possible date/time to trigger on (inclusive)</li><li>timezone (datetime.tzinfo|str) – time zone to use for the date/time calculations (defaults to scheduler timezone)</li></ul><table><thead><tr><th>表达式</th><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>*</td><td>任意</td><td>任意值</td></tr><tr><td>*/a</td><td>任意</td><td>从最小值开始，触发每个值</td></tr><tr><td>a-b</td><td>任意</td><td>触发a-b范围内的任何值（必须小于b）</td></tr><tr><td>a-b/c</td><td>任意</td><td>触发a-b范围内的每个c值</td></tr><tr><td>xth y</td><td>day</td><td>在该月内的工作日y的第x次出现时触发</td></tr><tr><td>last x</td><td>day</td><td>在工作日x的最后一次出现在月内</td></tr><tr><td>last</td><td>day</td><td>在这个月的最后一天</td></tr><tr><td>x,y,z</td><td>任意</td><td>触发任何匹配的表达式；可以组合任意数量的任何上述表达式</td></tr></tbody></table><pre><code class="py"># 在6-8,11-12月的第三个星期五的 00:00, 01:00, 02:00, 03:00 运行scheduler.add_job(job_function, &#39;cron&#39;, month=&#39;6-8,11-12&#39;, day=&#39;3rd fri&#39;, hour=&#39;0-3&#39;)# 周一至周五上午5:30 至 2014-05-30 00:00:00sched.add_job(job_function, &#39;cron&#39;, day_of_week=&#39;mon-fri&#39;, hour=5, minute=30, end_date=&#39;2014-05-30&#39;)</code></pre><h1 id="job"><a href="#job" class="headerlink" title="job"></a>job</h1><h2 id="添加jobs"><a href="#添加jobs" class="headerlink" title="添加jobs"></a>添加jobs</h2><ul><li>调用 scheduler.add_job() 方法，会返回 apscheduler.job.Job 实例(可用于job修改、移除等)</li><li>使用装饰器scheduled_job()</li></ul><h2 id="作业存储注意事项"><a href="#作业存储注意事项" class="headerlink" title="作业存储注意事项"></a>作业存储注意事项</h2><p>除了 Memory 方式不需要序列化之外(一个例外是使用 ProcessPoolExecutor)，其余都需要作业函数参数可序列化。</p><p>如果需要存储作业，而且每次启动时你的应用都会重新添加一遍作业，那么请在<strong>添加 job时指定一个唯一的 ID</strong>，以及指定 <code>replace_existing=True</code>，否则每次启动应用都会添加一次 job 的副本。</p><h2 id="移除job"><a href="#移除job" class="headerlink" title="移除job"></a>移除job</h2><ol><li>scheduler.remove_job(job_id, jobstore=None)</li><li>调用 job 实例的 remove() 方法</li></ol><p>注意：如果任务已经调度完毕，并且之后也不会再被执行的情况下，会被自动移除。</p><pre><code class="py">job = scheduler.add_job(myfunc, &#39;interval&#39;, minutes=2)job.remove()scheduler.add_job(myfunc, &#39;interval&#39;, minutes=2, id=&#39;my_job_id&#39;)scheduler.remove_job(&#39;my_job_id&#39;)</code></pre><h2 id="暂停和恢复-job"><a href="#暂停和恢复-job" class="headerlink" title="暂停和恢复 job"></a>暂停和恢复 job</h2><pre><code class="py">apscheduler.job.Job.pause()apscheduler.schedulers.base.BaseScheduler.pause_job()apscheduler.job.Job.resume()apscheduler.schedulers.base.BaseScheduler.resume_job()</code></pre><h2 id="获取-jobs-列表"><a href="#获取-jobs-列表" class="headerlink" title="获取 jobs 列表"></a>获取 jobs 列表</h2><pre><code class="py">apscheduler.get_jobs()</code></pre><h2 id="修改-job"><a href="#修改-job" class="headerlink" title="修改 job"></a>修改 job</h2><p>可以通过 <code>apscheduler.job.Job.modify()</code> or <code>apscheduler.modify_job()</code> 修改除了 id 之外的 job 属性。</p><pre><code class="py">job.modify(max_instances=6, name=&#39;Alternate name&#39;)</code></pre><p>如果你想修改 job 的调度器，你可以使用 <code>apscheduler.job.Job.reschedule()</code> or <code>reschedule_job()</code></p><pre><code class="py">scheduler.reschedule_job(&#39;my_job_id&#39;, trigger=&#39;cron&#39;, minute=&#39;*/5&#39;)</code></pre><h1 id="interval，限制同一个-job-实例的并发执行数"><a href="#interval，限制同一个-job-实例的并发执行数" class="headerlink" title="interval，限制同一个 job 实例的并发执行数"></a>interval，限制同一个 job 实例的并发执行数</h1><p>默认情况下同一个 job，<strong>只允许一个 job 实例运行</strong>。这在某个 job 在下次运行时间到达之后仍未执行完毕时，能达到控制的目的。你也可以该变这一行为，在你调用 add_job 时可以传递 <code>max_instances=5</code> 来运行同时运行同一个 job 的 5 个 job 实例。</p><p>cron 模式，不受影响。</p><h1 id="job-错过执行时间与-job-合并"><a href="#job-错过执行时间与-job-合并" class="headerlink" title="job 错过执行时间与 job 合并"></a>job 错过执行时间与 job 合并</h1><p>一个 job 可能由于某些情况错过执行时间，比如上一点提到的，或者是线程池或进程池用光了，或者是当要调度 job 时，突然 down 机了等。</p><p>这时可以通过设置 job 的 <code>misfire_grace_time</code> 选项来指示之后尝试执行的次数。</p><p>当然如果这不符合你的期望，你可以合并所有错过时间的 job 到一个 job 来执行，通过设定 job 的 <code>coalesce=True</code>。</p><h1 id="Scheduler-events"><a href="#Scheduler-events" class="headerlink" title="Scheduler events"></a>Scheduler events</h1><p>可以监听调度、任务执行情况相关的事件。</p><p>支持的事件列表：<a href="https://apscheduler.readthedocs.io/en/v3.3.0/modules/events.html#module-apscheduler.events" target="_blank" rel="noopener">https://apscheduler.readthedocs.io/en/v3.3.0/modules/events.html#module-apscheduler.events</a></p><pre><code class="py">def my_listener(event):    if event.exception:        print(&#39;The job crashed :(&#39;)    else:        print(&#39;The job worked :)&#39;)scheduler.add_listener(my_listener, EVENT_JOB_EXECUTED | EVENT_JOB_ERROR)</code></pre><blockquote><p><a href="https://segmentfault.com/a/1190000007739974" target="_blank" rel="noopener">https://segmentfault.com/a/1190000007739974</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python Set</title>
      <link href="/2019/01/25/Python%20Set/"/>
      <url>/2019/01/25/Python%20Set/</url>
      
        <content type="html"><![CDATA[<h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p>集合（<code>Set</code>）由序列（或其他可迭代对象）构建的，元素不能重复，无序。</p><pre><code class="py">&gt;&gt;&gt; {3, 5, 1, 1}  # 元素不能重复，无序{1, 3, 5}</code></pre><a id="more"></a><h2 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a>创建集合</h2><pre><code class="py"># Python 2.7&gt;&gt;&gt; set(range(10))set([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])&gt;&gt;&gt; {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}set([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</code></pre><pre><code class="py"># Python 3.5&gt;&gt;&gt; set(range(10)){0, 1, 2, 3, 4, 5, 6, 7, 8, 9}&gt;&gt;&gt; set([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]){0, 1, 2, 3, 4, 5, 6, 7, 8, 9}</code></pre><h2 id="集合间的运算"><a href="#集合间的运算" class="headerlink" title="集合间的运算"></a>集合间的运算</h2><pre><code class="py">&gt;&gt;&gt; a = {1, 2, 3}&gt;&gt;&gt; b = {2, 3, 4}&gt;&gt;&gt; a.union(b)  # 并集{1, 2, 3, 4}&gt;&gt;&gt; a | b  # 并集{1, 2, 3, 4}</code></pre><pre><code class="py">&gt;&gt;&gt; a &amp; b  # 交集{2, 3}&gt;&gt;&gt; a.intersection(b)  # 交集{2, 3}&gt;&gt;&gt; a.isdisjoint(b)  # 如果 a b 两集合不相交，则返回True。False</code></pre><pre><code class="py">&gt;&gt;&gt; c = a &amp; b&gt;&gt;&gt; c.issubset(a)  # c 是否属于 a 的一部分True&gt;&gt;&gt; c &lt;= aTrue&gt;&gt;&gt; c.issuperset(a)  # a 是否属于 c 的一部分False&gt;&gt;&gt; c &gt;= aFalse</code></pre><pre><code class="py">&gt;&gt;&gt; a.difference(b)  # a 存在，b 不存在的元素{1}&gt;&gt;&gt; a - b{1}</code></pre><pre><code class="py">&gt;&gt;&gt; a.symmetric_difference(b)  # a, b 不同的部分{1, 4}&gt;&gt;&gt; a ^ b{1, 4}&gt;&gt;&gt;</code></pre><h2 id="集合的基本操作"><a href="#集合的基本操作" class="headerlink" title="集合的基本操作"></a>集合的基本操作</h2><h3 id="添加，add"><a href="#添加，add" class="headerlink" title="添加，add"></a>添加，add</h3><pre><code class="py">&gt;&gt;&gt; a.add(5)  # 添加&gt;&gt;&gt; a{1, 2, 3, 5}</code></pre><h3 id="update"><a href="#update" class="headerlink" title="update"></a>update</h3><p>这里的操作同集合间的运算，将运算结果赋值给原 Set。</p><pre><code class="py">&gt;&gt;&gt; a.update([5, 4], {&quot;6&quot;: &quot;7&quot;})  # 也可以添加元素，且参数可以是列表，元组，字典等&gt;&gt;&gt; a{1, 2, 3, 4, 5, &#39;6&#39;}&gt;&gt;&gt; a = {1, 2, 3}&gt;&gt;&gt; a |= {5, 4}  # |= 操作需要是 Set 类型&gt;&gt;&gt; a{1, 2, 3, 4, 5}</code></pre><pre><code class="py">&gt;&gt;&gt; a.intersection_update([1, 2, 3, 8])  # 更新集合，只保留交集。&gt;&gt;&gt; a{1, 2, 3}&gt;&gt;&gt; a &amp;= {1, 3, 4}&gt;&gt;&gt; a{1, 3}</code></pre><pre><code class="py">&gt;&gt;&gt; a = {1, 2, 3}&gt;&gt;&gt; a.difference_update([1, 4])  # 更新集合，删除参数中存在的元素&gt;&gt;&gt; a{2, 3}&gt;&gt;&gt; a -= {3, 5}&gt;&gt;&gt; a{2}</code></pre><pre><code class="py">&gt;&gt;&gt; a = {1, 2, 3}&gt;&gt;&gt; a.symmetric_difference_update([1, 4])  # 更新集合，只保留不同时存在于两者中的元素。&gt;&gt;&gt; a{2, 3, 4}&gt;&gt;&gt; a ^= {3, 5}&gt;&gt;&gt; a{2, 4, 5}</code></pre><h3 id="删除，remove，discard，pop"><a href="#删除，remove，discard，pop" class="headerlink" title="删除，remove，discard，pop"></a>删除，remove，discard，pop</h3><pre><code class="py">&gt;&gt;&gt; a.remove(5)  # 删除&gt;&gt;&gt; a{1, 2, 3, 4, &#39;6&#39;}&gt;&gt;&gt; a.remove(5)  # 如果元素不存在，则会发生错误Traceback (most recent call last):  File &quot;&lt;pyshell#79&gt;&quot;, line 1, in &lt;module&gt;    a.remove(5)KeyError: 5</code></pre><pre><code class="py"># 还有一个方法也是移除集合中的元素，且如果元素不存在，不会发生错误。&gt;&gt;&gt; a.discard(4)&gt;&gt;&gt; a.discard(4)&gt;&gt;&gt; a{1, 2, 3, &#39;6&#39;}</code></pre><pre><code class="py"># 随机删除集合中的一个元素(在交互模式，pop 是删除集合的第一个元素)&gt;&gt;&gt; a.pop()1&gt;&gt;&gt; a{2, 3, &#39;6&#39;}</code></pre><h2 id="计算集合元素个数"><a href="#计算集合元素个数" class="headerlink" title="计算集合元素个数"></a>计算集合元素个数</h2><pre><code class="py">&gt;&gt;&gt; len(a)3</code></pre><h2 id="清空集合"><a href="#清空集合" class="headerlink" title="清空集合"></a>清空集合</h2><pre><code class="py">&gt;&gt;&gt; a.clear()&gt;&gt;&gt; aset()</code></pre><h2 id="判断元素是否在集合中存在"><a href="#判断元素是否在集合中存在" class="headerlink" title="判断元素是否在集合中存在"></a>判断元素是否在集合中存在</h2><pre><code class="py">&gt;&gt;&gt; a = {1, 2, 3}&gt;&gt;&gt; 2 in aTrue</code></pre><h2 id="浅拷贝，copy"><a href="#浅拷贝，copy" class="headerlink" title="浅拷贝，copy()"></a>浅拷贝，copy()</h2><pre><code class="py">&gt;&gt;&gt; a.copy(){1, 2, 3}&gt;&gt;&gt; a.copy() is aFalse&gt;&gt;&gt; a.copy() == aTrue</code></pre><h1 id="frozenset"><a href="#frozenset" class="headerlink" title="frozenset"></a>frozenset</h1><p>集合是可变的，所以不能用作字典的键。集合中只能包含不可变值，也就是不能包含集合。</p><p>使用<code>frozenset</code>类型，用于代表不可变的集合，这样也就可以用于字典的键。</p><pre><code class="py">&gt;&gt;&gt; a = {1, 2, 3}&gt;&gt;&gt; b = {2, 3, 4}&gt;&gt;&gt; a.add(b)Traceback (most recent call last):  File &quot;&lt;pyshell#48&gt;&quot;, line 1, in &lt;module&gt;    a.add(b)TypeError: unhashable type: &#39;set&#39;&gt;&gt;&gt; a.add(frozenset(b))&gt;&gt;&gt; a{1, 2, 3, frozenset({2, 3, 4})}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python datetime 模块</title>
      <link href="/2019/01/17/Python%20datetime%20%E6%A8%A1%E5%9D%97/"/>
      <url>/2019/01/17/Python%20datetime%20%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<p><a href="https://docs.python.org/3/library/datetime.html" target="_blank" rel="noopener">datetime</a> 模块常量：</p><p><code>datetime.MINYEAR</code>：date 和 datetime 对象中允许的最小年份。MINYEAR 为 1。</p><p><code>datetime.MAXYEAR</code>：date 和 datetime 对象中允许的最大年份数。MAXYEAR 为 9999。</p><p>子类关系：</p><pre><code class="py">object    timedelta    tzinfo        timezone    time    date        datetime</code></pre><a id="more"></a><h1 id="time-时间"><a href="#time-时间" class="headerlink" title="time 时间"></a>time 时间</h1><p>一个独立于任何特定的日子，假设每天有 <code>24 \* 60 \* 60</code> 秒（这里没有“闰秒”的概念）。属性：<code>hour</code>、<code>minute</code>、<code>second</code>、<code>microsecond</code> 和 <code>tzinfo</code>。</p><p><code>class datetime.time(hour=0, minute=0, second=0, microsecond=0, tzinfo=None)</code></p><p>所有参数都是可选的。tzinfo 可以是 None 或 <code>tzinfo</code> 子类的实例。其余的参数可以是以下范围内的整数：</p><ul><li>0 &lt;= hour &lt; 24</li><li>0 &lt;= minute &lt; 60</li><li>0 &lt;= second &lt; 60</li><li>0 &lt;= microsecond &lt; 1000000.</li></ul><h2 id="类属性"><a href="#类属性" class="headerlink" title="类属性"></a>类属性</h2><pre><code class="py">&gt;&gt;&gt; import datetime&gt;&gt;&gt; datetime.time.min  # 最早的 timedatetime.time(0, 0)&gt;&gt;&gt; datetime.time.max  # 最晚的 timedatetime.time(23, 59, 59, 999999)&gt;&gt;&gt; datetime.time.resolution  # 不相等的 time 对象之间的最小可能差 1 微秒datetime.timedelta(0, 0, 1)&gt;&gt;&gt; print(datetime.time.resolution)0:00:00.000001</code></pre><h2 id="实例属性（只读）"><a href="#实例属性（只读）" class="headerlink" title="实例属性（只读）"></a>实例属性（只读）</h2><pre><code class="py">&gt;&gt;&gt; t = datetime.time(1, 2, 3)&gt;&gt;&gt; t.hour1&gt;&gt;&gt; t.minute2&gt;&gt;&gt; t.second3&gt;&gt;&gt; t.microsecond0&gt;&gt;&gt; t.tzinfo  # None&gt;&gt;&gt;</code></pre><h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><pre><code class="py">&gt;&gt;&gt; t = datetime.time(1, 2, 3)&gt;&gt;&gt; t.isoformat()  # 返回格式 HH:MM:SS.mmmmmm 表示的字符串，如果 microsecond 为 0，则以 HH:MM:SS 的格式。&#39;01:02:03&#39;&gt;&gt;&gt; t.__str__()  # 等同于 t.isoformat()&#39;01:02:03&#39;&gt;&gt;&gt; t.strftime(&#39;%H&#39;)  # 返回一个表示 time 的指定格式字符串，&#39;01&#39;&gt;&gt;&gt; t.__format__(&#39;%H&#39;)  # 与 time.strftime() 相同&#39;01&#39;# time.replace([hour[, minute[, second[, microsecond[, tzinfo]]]]])&gt;&gt;&gt; t.replace(2)  # 返回具有相同值的 timedatetime.time(2, 2, 3)&gt;&gt;&gt; tdatetime.time(1, 2, 3)&gt;&gt;&gt; t.replace()datetime.time(1, 2, 3)</code></pre><h1 id="date-日期"><a href="#date-日期" class="headerlink" title="date 日期"></a>date 日期</h1><p><code>class datetime.date(year, month, day)</code></p><p>所有参数都是必需的。参数可以是以下范围内的整数：</p><ul><li>MINYEAR &lt;= year &lt;= MAXYEAR</li><li>1 &lt;= month &lt;= 12</li><li>1 &lt;= day &lt;= 给定年下给定月份中的天数</li></ul><h2 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h2><pre><code class="py">&gt;&gt;&gt; datetime.date.today()  # 返回当前的本地日期。这相当于date.fromtimestamp(time.time())。datetime.date(2019, 1, 26)&gt;&gt;&gt; datetime.date.fromtimestamp(time.time())datetime.date(2019, 1, 26)&gt;&gt;&gt; datetime.date.today().toordinal()737085&gt;&gt;&gt; datetime.date.fromordinal(1)  # 返回对应于格雷高尔顺序的日期，其中第1年的1月1有序号1。datetime.date(1, 1, 1)&gt;&gt;&gt; datetime.date.fromordinal(737085)  # 对于任何日期d，date.fromordinal(d.toordinal()) == d。datetime.date(2019, 1, 26)</code></pre><h2 id="类属性-1"><a href="#类属性-1" class="headerlink" title="类属性"></a>类属性</h2><pre><code class="py">&gt;&gt;&gt; datetime.date.min  # 可表示的最早日期datetime.date(1, 1, 1)&gt;&gt;&gt; datetime.date.max  # 可表示最晚的日期datetime.date(9999, 12, 31)&gt;&gt;&gt; datetime.date.resolution  # 不相等的日期对象之间的最小可能差异datetime.timedelta(1)</code></pre><h2 id="实例属性（只读）-1"><a href="#实例属性（只读）-1" class="headerlink" title="实例属性（只读）"></a>实例属性（只读）</h2><pre><code class="py">d = datetime.date.today()&gt;&gt;&gt; d.year2019&gt;&gt;&gt; d.month1&gt;&gt;&gt; d.day26</code></pre><h2 id="实例方法-1"><a href="#实例方法-1" class="headerlink" title="实例方法"></a>实例方法</h2><pre><code class="py">&gt;&gt;&gt; d.replace(day=27)  # 返回一个日期datetime.date(2019, 1, 27)&gt;&gt;&gt; d.timetuple()  # 返回一个time.struct_time，类似time.localtime()的返回值。time.struct_time(tm_year=2019, tm_mon=1, tm_mday=26, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=5, tm_yday=26, tm_isdst=-1)&gt;&gt;&gt; yday = d.toordinal() - datetime.date(d.year, 1, 1).toordinal() + 1&gt;&gt;&gt; time.struct_time((d.year, d.month, d.day, 0, 0, 0, d.weekday(), yday, -1))  # 等同于 d.timetuple()time.struct_time(tm_year=2019, tm_mon=1, tm_mday=26, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=5, tm_yday=26, tm_isdst=-1)&gt;&gt;&gt; d.toordinal()  # 返回该日期的预测格里历序号737085&gt;&gt;&gt; datetime.date.fromordinal(d.toordinal()) == dTrue&gt;&gt;&gt; d.weekday()  # 将星期几作为整数返回，其中星期一为0，星期日为6。5&gt;&gt;&gt; d.isoweekday()  # 将星期几作为整数返回，其中星期一为1，星期日为7。6&gt;&gt;&gt; d.isocalendar()  # 返回3元组（ISO年，ISO周编号，ISO工作日）。(2019, 4, 6)# ISO年包括52或53个整周，其中一周从星期一开始并在星期日结束。ISO年的第一周是一年的第一个包含星期四的（公历）日历周。这称为周数1，该周四的ISO年与其公历年相同。# 例如，2004年从星期四开始，因此ISO 2004年的第一周从2003年12月29日星期一开始，2004年1月4日星期日结束# 因此 date(2003, 12, 29).isocalendar() == (2004, 1, 1) 以及 date(2004, 1, 4).isocalendar() == (2004, 1, 7)。&gt;&gt;&gt; d.isoformat()  # 以ISO 8601格式返回表示日期的字符串&#39;YYYY-MM-DD&#39;&#39;2019-01-26&#39;&gt;&gt;&gt; d.__str__()  # 等同于d.isoformat()。&#39;2019-01-26&#39;&gt;&gt;&gt; d.ctime()  # 返回表示日期的字符串&#39;Sat Jan 26 00:00:00 2019&#39;&gt;&gt;&gt; time.ctime(time.mktime(d.timetuple()))  # 等效于 d.ctime()&#39;Sat Jan 26 00:00:00 2019&#39;&gt;&gt;&gt; d.strftime(&#39;%Y年%m月%d日&#39;)  # 返回一个表示日期的字符串&#39;2019年01月26日&#39;&gt;&gt;&gt; d.__format__(&#39;%Y年%m月%d日&#39;)  # 与 date.strftime() 相同。&#39;2019年01月26日&#39;</code></pre><h1 id="timedeltas-时间差"><a href="#timedeltas-时间差" class="headerlink" title="timedeltas 时间差"></a>timedeltas 时间差</h1><p>timedelta 对象表示两个 date、time 或 datetime 实例之间相差的时间，分辨率达到微秒。</p><pre><code class="py">class datetime.timedelta(days=0, seconds=0, microseconds=0, milliseconds=0, minutes=0, hours=0, weeks=0)</code></pre><p>所有参数都是可选的且默认为0。参数可以是整数或浮点数，也可以是正数或负数。</p><p><strong>只有days（天），seconds（秒）和microseconds（微秒）存储在内部</strong>。参数被转换为这些单位：</p><ul><li>1毫秒转换为1000微秒。</li><li>1分钟转换为60秒。</li><li>1小时转换为3600秒。</li><li>1周被转换为7天。</li></ul><p>然后对天，秒和微秒进行归一化，以便表示是唯一的</p><ul><li>0 &lt;= microseconds &lt; 1000000</li><li>0 &lt;= seconds &lt; 3600*24（一天中的秒数）</li><li>-999999999 &lt;= days &lt;= 999999999</li></ul><h2 id="类属性-2"><a href="#类属性-2" class="headerlink" title="类属性"></a>类属性</h2><pre><code class="py">&gt;&gt;&gt; from datetime import timedelta&gt;&gt;&gt; timedelta.min  # 最小的 timedelta 对象datetime.timedelta(-999999999)&gt;&gt;&gt; timedelta.max  # 最大的 timedelta 对象，timedelta(days=999999999, hours=23, minutes=59, seconds=59, microseconds=999999)datetime.timedelta(999999999, 86399, 999999)&gt;&gt;&gt; timedelta.resolution  # 不相等的 timedelta 对象之间的最小可能差值 timedelta(microseconds=1)datetime.timedelta(0, 0, 1)</code></pre><h2 id="实例属性（只读）-2"><a href="#实例属性（只读）-2" class="headerlink" title="实例属性（只读）"></a>实例属性（只读）</h2><pre><code class="py">&gt;&gt;&gt; t = timedelta.max&gt;&gt;&gt; t.days999999999&gt;&gt;&gt; t.seconds86399&gt;&gt;&gt; t.microseconds999999</code></pre><h2 id="支持的操作"><a href="#支持的操作" class="headerlink" title="支持的操作"></a>支持的操作</h2><pre><code class="py">&gt;&gt;&gt; t2 = timedelta(1)&gt;&gt;&gt; t2datetime.timedelta(1)&gt;&gt;&gt; t3 = timedelta(0,1)&gt;&gt;&gt; t3datetime.timedelta(0, 1)&gt;&gt;&gt; t2 + t3  # t2 和 t3 的和datetime.timedelta(1, 1)&gt;&gt;&gt; t2 - t3  # t2 和 t3 的差datetime.timedelta(0, 86399)&gt;&gt;&gt; t2 * 2  # 乘以一个整数datetime.timedelta(2)&gt;&gt;&gt; t2 * 1.1  # 乘以一个浮点数，结果使用 round-half-to-even 舍入到 timedelta.resolution 最近的倍数datetime.timedelta(1, 8640)&gt;&gt;&gt; t2 / t3  # t2 除以 t3。返回一个 float 对象。86400.0&gt;&gt;&gt; t2 / 2  # 除以一个浮点数或整数datetime.timedelta(0, 43200)&gt;&gt;&gt; t2 // 2  # 计算商，余数被丢弃datetime.timedelta(0, 43200)&gt;&gt;&gt; t2 // t3  # 计算商，返回一个整数86400&gt;&gt;&gt; t2 % t3  # 计算余数datetime.timedelta(0)&gt;&gt;&gt; divmod(t3, t2)  # 计算商和余数：q = t1 // t2 且 r = t1 % t2。q一个是整数，r是一个timedelta对象。(0, datetime.timedelta(0, 1))&gt;&gt;&gt; -t2  # 等效于 timedelta(-t1.days, -t1.seconds, -t1.microseconds)，和 t1* -1。datetime.timedelta(-1)&gt;&gt;&gt; abs(t2)  # 当 t.days &gt;= 0 时等效于 +t，当 t.days &lt; 0 时等效于 -tdatetime.timedelta(1)&gt;&gt;&gt; str(t2)&#39;1 day, 0:00:00&#39;&gt;&gt;&gt; repr(t2)&#39;datetime.timedelta(1)&#39;</code></pre><h2 id="实例方法-2"><a href="#实例方法-2" class="headerlink" title="实例方法"></a>实例方法</h2><pre><code class="py">&gt;&gt;&gt; t2.total_seconds()  # 返回持续时间中包含的总秒数。等同于 t2 / timedelta(seconds=1)。86400.0</code></pre><h1 id="日期算术运算"><a href="#日期算术运算" class="headerlink" title="日期算术运算"></a>日期算术运算</h1><pre><code class="py">&gt;&gt;&gt; today = datetime.date.today()&gt;&gt;&gt; one_day = datetime.timedelta(days=1)&gt;&gt;&gt; yesterday = today - one_day  # 日期减一天&gt;&gt;&gt; tomorrow = today + one_day  # 日期加一天&gt;&gt;&gt; yesterdaydatetime.date(2019, 1, 26)&gt;&gt;&gt; tomorrowdatetime.date(2019, 1, 28)&gt;&gt;&gt; tomorrow - yesterday  # 日期实例之间相减会产生时间差datetime.timedelta(2)&gt;&gt;&gt; yesterday - tomorrowdatetime.timedelta(-2)</code></pre><h1 id="比较数值"><a href="#比较数值" class="headerlink" title="比较数值"></a>比较数值</h1><p>日期值和时间值都可以使用标准比较运算符进行比较，以确定哪个值更早或更晚。</p><pre><code class="py">&gt;&gt;&gt; t1 = datetime.time(12, 55, 0)&gt;&gt;&gt; t1datetime.time(12, 55)&gt;&gt;&gt; t2 = datetime.time(13, 5, 0)&gt;&gt;&gt; t2datetime.time(13, 5)&gt;&gt;&gt; t1 &lt; t2True&gt;&gt;&gt; d1 = datetime.date.today()&gt;&gt;&gt; d1datetime.date(2019, 1, 27)&gt;&gt;&gt; d2 = datetime.date.today() + datetime.timedelta(days=1)&gt;&gt;&gt; d2datetime.date(2019, 1, 28)&gt;&gt;&gt; d1 &gt; d2False</code></pre><h1 id="datetime-日期与时间"><a href="#datetime-日期与时间" class="headerlink" title="datetime 日期与时间"></a>datetime 日期与时间</h1><p>datetime 对象是一个包含 date 对象和 time 对象所有信息的单个对象。</p><pre><code class="py">class datetime.datetime(year, month, day, hour=0, minute=0, second=0, microsecond=0, tzinfo=None)</code></pre><p>年，月和日的参数是必需的。tzinfo 可以是 None 或 tzinfo 子类的实例。其余的参数可以是以下范围内的整数：</p><ul><li>MINYEAR &lt;= year &lt;= MAXYEAR</li><li>1 &lt;= month &lt;= 12</li><li>1 &lt;= day &lt;= 给定年下给定月份中的天数</li><li>0 &lt;= hour &lt; 24</li><li>0 &lt;= minute &lt; 60</li><li>0 &lt;= second &lt; 60</li><li>0 &lt;= microsecond &lt; 1000000</li></ul><h2 id="类方法-1"><a href="#类方法-1" class="headerlink" title="类方法"></a>类方法</h2><pre><code class="py">&gt;&gt;&gt; from datetime import datetime&gt;&gt;&gt; datetime.today()  # 返回当前本地日期时间，相当于 datetime.fromtimestamp(time.time())datetime.datetime(2019, 1, 27, 13, 58, 55, 518472)&gt;&gt;&gt; datetime.now()  # 返回当前的本地日期和时间。如果可选参数 时区tz 为 None 或未指定，则这类似于 today()datetime.datetime(2019, 1, 27, 13, 59, 6, 547804)&gt;&gt;&gt; datetime.utcnow()  # 返回当前 UTC 日期和时间datetime.datetime(2019, 1, 27, 5, 59, 18, 215222)&gt;&gt;&gt; datetime.fromtimestamp(time.time())  # 返回与时间戳对应的本地日期和时间datetime.datetime(2019, 1, 27, 13, 59, 35, 268036)&gt;&gt;&gt; datetime.utcfromtimestamp(time.time())  # 返回与时间戳对应的 UTC datetimedatetime.datetime(2019, 1, 27, 5, 59, 59, 106960)&gt;&gt;&gt; datetime.now().toordinal()  # 实例方法，获得对应于普通公历的序数737086&gt;&gt;&gt; datetime.fromordinal(737086)  # 返回对应于普通公历的序数的 datetimedatetime.datetime(2019, 1, 27, 0, 0)&gt;&gt;&gt; d = datetime.now()&gt;&gt;&gt; datetime.combine(d.date(), d.timetz())  # 根据 date time 对象返回一个 datetime 对象datetime.datetime(2019, 1, 27, 14, 9, 37, 908094) # 等同于 d&gt;&gt;&gt; from datetime import date&gt;&gt;&gt; from datetime import time&gt;&gt;&gt; datetime.combine(date(2017,1,1), time(1))datetime.datetime(2017, 1, 1, 1, 0)&gt;&gt;&gt; datetime.strptime(&#39;20180101&#39;, &#39;%Y%m%d&#39;)datetime.datetime(2018, 1, 1, 0, 0)</code></pre><h2 id="类属性-3"><a href="#类属性-3" class="headerlink" title="类属性"></a>类属性</h2><pre><code class="py">&gt;&gt;&gt; datetime.min  # 可表示的最早 datetimedatetime.datetime(1, 1, 1, 0, 0)  # 可表示的最晚 datetime&gt;&gt;&gt; datetime.maxdatetime.datetime(9999, 12, 31, 23, 59, 59, 999999)&gt;&gt;&gt; datetime.resolution  # 不相等的 datetime 对象之间的最小可能差值datetime.timedelta(0, 0, 1)</code></pre><h2 id="实例属性（只读）-3"><a href="#实例属性（只读）-3" class="headerlink" title="实例属性（只读）"></a>实例属性（只读）</h2><pre><code class="py">&gt;&gt;&gt; d = datetime.now()&gt;&gt;&gt; d.year2019&gt;&gt;&gt; d.month1&gt;&gt;&gt; d.day27&gt;&gt;&gt; d.hour14&gt;&gt;&gt; d.minute22&gt;&gt;&gt; d.second21&gt;&gt;&gt; d.microsecond17905&gt;&gt;&gt; d.tzinfo&gt;&gt;&gt;</code></pre><h2 id="实例方法-3"><a href="#实例方法-3" class="headerlink" title="实例方法"></a>实例方法</h2><pre><code class="py">&gt;&gt;&gt; d = datetime.now()&gt;&gt;&gt; d.date()  # 返回具有相同年、月和日的date对象。datetime.date(2019, 1, 27)&gt;&gt;&gt; d.time()  # 返回具有相同小时、分钟、秒和微秒的 time 对象datetime.time(14, 22, 21, 17905)&gt;&gt;&gt; d.timetz()  # 返回具有相同小时、分钟、秒、微秒和 tzinfo 属性的 time 对象。datetime.time(14, 22, 21, 17905)&gt;&gt;&gt; d.replace(2020)  # [year[, month[, day[, hour[, minute[, second[, microsecond[, tzinfo]]]]]]]]datetime.datetime(2020, 1, 27, 14, 22, 21, 17905)&gt;&gt;&gt; d.astimezone(tz=None)  # 返回带有新 tzinfo 属性 tz(默认本地地区) 的 datetime 对象datetime.datetime(2019, 1, 27, 14, 22, 21, 17905, tzinfo=datetime.timezone(datetime.timedelta(0, 28800), &#39;中国标准时间&#39;))&gt;&gt;&gt; dd = d.astimezone()&gt;&gt;&gt; dd.tzname()&#39;中国标准时间&#39;&gt;&gt;&gt; d.timetuple()  # 返回一个 time.struct_time，类似 time.localtime() 的返回值。time.struct_time(tm_year=2019, tm_mon=1, tm_mday=27, tm_hour=14, tm_min=22, tm_sec=21, tm_wday=6, tm_yday=27, tm_isdst=-1)&gt;&gt;&gt; d.utctimetuple()time.struct_time(tm_year=2019, tm_mon=1, tm_mday=27, tm_hour=14, tm_min=22, tm_sec=21, tm_wday=6, tm_yday=27, tm_isdst=0)&gt;&gt;&gt; d.toordinal()  # 返回日期的公历序数。737086&gt;&gt;&gt; d.timestamp()  # 返回对应于 datetime 实例的时间戳1548570141.017905&gt;&gt;&gt; d.weekday()  # 将星期几作为整数返回，其中星期一为0，星期日为6。等同于 self.date().weekday()。6&gt;&gt;&gt; d.isoweekday()  # 将星期几作为整数返回，其中星期一为1，星期日为7。等同于 self.date().isoweekday()。7&gt;&gt;&gt; d.isocalendar()  # 返回 3 元组（ISO年，ISO周编号，ISO工作日）。等同于 self.date().isocalendar()。(2019, 4, 7)&gt;&gt;&gt; d.isoformat(sep=&#39;T&#39;)  # 返回以 ISO 8601 格式 YYYY-MM-DDTHH:MM:SS.mmmmmm 表示日期和时间的字符串，如果 microsecond 为 0，则以 YYYY-MM-DDTHH:MM:SS 的格式。&#39;2019-01-27T14:22:21.017905&#39;&gt;&gt;&gt; d.__str__()  # 等效于 d.isoformat(&#39; &#39;)&#39;2019-01-27 14:22:21.017905&#39;&gt;&gt;&gt; d.ctime()  # 返回一个表示日期和时间的字符串，等效于 time.ctime(time.mktime(d.timetuple()))。&#39;Sun Jan 27 14:22:21 2019&#39;&gt;&gt;&gt; d.strftime(&#39;%Y-%m-%d&#39;)  # 返回一个表示日期和时间的字符串，由显式的格式字符串控制。&#39;2019-01-27&#39;&gt;&gt;&gt; d.__format__(&#39;%Y-%m-%d&#39;) 与 d.strftime() 相同。&#39;2019-01-27&#39;</code></pre><h1 id="格式代码"><a href="#格式代码" class="headerlink" title="格式代码"></a>格式代码</h1><ul><li><code>%y</code> 两位数的年份表示（00-99）</li><li><code>%Y</code> 四位数的年份表示（000-9999）</li><li><code>%m</code> 月份（01-12）</li><li><code>%d</code> 月内中的一天（01-31）</li><li><code>%H</code> 24小时制小时数（0-23）</li><li><code>%I</code> 12小时制小时数（01-12）</li><li><code>%M</code> 分钟数（00=59）</li><li><code>%S</code> 秒（00-59）</li><li><code>%a</code> 本地简化星期名称</li><li><code>%A</code> 本地完整星期名称</li><li><code>%b</code> 本地简化的月份名称</li><li><code>%B</code> 本地完整的月份名称</li><li><code>%c</code> 本地相应的日期表示和时间表示</li><li><code>%j</code> 年内的一天（001-366）</li><li><code>%p</code> 本地A.M.或P.M.的等价符</li><li><code>%U</code> 一年中的星期数（00-53）星期天为星期的开始</li><li><code>%w</code> 星期（0-6），星期天为星期的开始</li><li><code>%W</code> 一年中的星期数（00-53）星期一为星期的开始</li><li><code>%x</code> 本地相应的日期表示</li><li><code>%X</code> 本地相应的时间表示</li><li><code>%Z</code> 当前时区的名称</li><li><code>%%</code> %号本身</li></ul><blockquote><p><a href="https://docs.python.org/3/library/datetime.html" target="_blank" rel="noopener">https://docs.python.org/3/library/datetime.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PyCharm 使用</title>
      <link href="/2019/01/17/PyCharm%20%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/01/17/PyCharm%20%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="类中定义函方法-PyCharm-提示-Method-xxx-may-be-39-static-39"><a href="#类中定义函方法-PyCharm-提示-Method-xxx-may-be-39-static-39" class="headerlink" title="类中定义函方法 PyCharm 提示 Method xxx may be &#39;static&#39;"></a>类中定义函方法 PyCharm 提示 Method xxx may be &#39;static&#39;</h1><blockquote><p><a href="https://blog.csdn.net/zwt0909/article/details/52302992" target="_blank" rel="noopener">https://blog.csdn.net/zwt0909/article/details/52302992</a><br><a href="http://stackoverflow.com/questions/23554872/why-does-pycharm-propose-to-change-method-to-static" target="_blank" rel="noopener">http://stackoverflow.com/questions/23554872/why-does-pycharm-propose-to-change-method-to-static</a></p></blockquote><p>原因是该方法不涉及对该类属性的操作，编译器建议声明为 <code>@staticmethod</code>，面向对象思想体现</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python SQL 语句 拼接 in 查询</title>
      <link href="/2019/01/02/Python%20SQL%20%E8%AF%AD%E5%8F%A5%20%E6%8B%BC%E6%8E%A5%20in%20%E6%9F%A5%E8%AF%A2/"/>
      <url>/2019/01/02/Python%20SQL%20%E8%AF%AD%E5%8F%A5%20%E6%8B%BC%E6%8E%A5%20in%20%E6%9F%A5%E8%AF%A2/</url>
      
        <content type="html"><![CDATA[<p>想要实现这样的查询语句：</p><pre><code class="sql">select * from server where id=1 and ip in (&#39;1.1.1.1&#39;,&#39;2.2.2.2&#39;,&#39;2.2.2.2&#39;)</code></pre><p>我们希望在查询语句的 in 中放入一个 IP 列表，这里我们首先会想到的是用 join 来对这个列表处理成一个字符串，如下：</p><pre><code class="py">&gt;&gt;&gt; a=[&#39;1.1.1.1&#39;,&#39;2.2.2.2&#39;,&#39;2.2.2.2&#39;]&gt;&gt;&gt; &#39;,&#39;.join(a)&#39;1.1.1.1,2.2.2.2,2.2.2.2&#39;</code></pre><p>可以看到，join 后的结果并不是我们想要的结果，因为引号的问题。所以我们会想到另外的办法：</p><pre><code class="py">&gt;&gt;&gt; sql_str = &quot;select * from server where id=%s and ip in (%s)&quot;&gt;&gt;&gt; a = [&#39;1.1.1.1&#39;,&#39;2.2.2.2&#39;,&#39;2.2.2.2&#39;]&gt;&gt;&gt; &#39;,&#39;.join([&quot;&#39;%s&#39;&quot; % item for item in a])&quot;&#39;1.1.1.1&#39;,&#39;2.2.2.2&#39;,&#39;2.2.2.2&#39;&quot;&gt;&gt;&gt; ips = &#39;, &#39;.join(list(map(lambda item: &quot;&#39;%s&#39;&quot; % item, a)))&quot;&#39;1.1.1.1&#39;, &#39;2.2.2.2&#39;, &#39;2.2.2.2&#39;&quot;&gt;&gt;&gt; sql_str % (&#39;1&#39;, ips)&quot;select * from server where id=1 and ip in (&#39;1.1.1.1&#39;, &#39;2.2.2.2&#39;, &#39;2.2.2.2&#39;)&quot;&gt;&gt;&gt; cursor.execute(sql_str % (&#39;1&#39;, ips))</code></pre><p>另一种方式，如下：</p><pre><code class="py">&gt;&gt;&gt; a = [&#39;1.1.1.1&#39;,&#39;2.2.2.2&#39;,&#39;3.3.3.3&#39;]&gt;&gt;&gt; sql_str = &#39;select * from server where id=%s and ip in (%s)&#39; % (&#39;%s&#39;, &#39;,&#39;.join([&#39;%s&#39;] * len(a)))&gt;&gt;&gt; sql_str&#39;select * from server where id=%s and ip in (%s,%s,%s)&#39;&gt;&gt;&gt; cursor.execute(sql_str，[&#39;1&#39;, ] + a))</code></pre><blockquote><p><a href="https://www.jianshu.com/p/2eaabb5c797d" target="_blank" rel="noopener">https://www.jianshu.com/p/2eaabb5c797d</a><br><a href="https://blog.csdn.net/u011085172/article/details/79044490" target="_blank" rel="noopener">https://blog.csdn.net/u011085172/article/details/79044490</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 使用 psutil 获取系统信息</title>
      <link href="/2018/12/31/Python%20%E4%BD%BF%E7%94%A8%20psutil%20%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF/"/>
      <url>/2018/12/31/Python%20%E4%BD%BF%E7%94%A8%20psutil%20%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF/</url>
      
        <content type="html"><![CDATA[<p>GitHub 地址：<a href="https://github.com/giampaolo/psutil" target="_blank" rel="noopener">https://github.com/giampaolo/psutil</a></p><p>文档地址：<a href="https://psutil.readthedocs.io/en/latest/#" target="_blank" rel="noopener">https://psutil.readthedocs.io/en/latest/#</a></p><p>psutil - 廖雪峰的官方网站：<a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001511052957192bb91a56a2339485c8a8c79812b400d49000" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001511052957192bb91a56a2339485c8a8c79812b400d49000</a></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><pre><code class="shell">pip install psutil</code></pre><a id="more"></a><h1 id="获取-CPU-信息"><a href="#获取-CPU-信息" class="headerlink" title="获取 CPU 信息"></a>获取 CPU 信息</h1><pre><code class="py">&gt;&gt;&gt; import psutil&gt;&gt;&gt; psutil.cpu_count() # CPU逻辑数量8&gt;&gt;&gt; psutil.cpu_count(logical=False) # CPU物理核心4# 4说明是四核超线程, 8则是8核非超线程</code></pre><p>统计 CPU 的用户／系统／空闲时间：</p><pre><code class="py">&gt;&gt;&gt; psutil.cpu_times()scputimes(user=8526.40625, system=9484.421875, idle=1319748.125, interrupt=257.640625, dpc=321.4375)</code></pre><p>再实现类似 top 命令的 CPU 使用率，每秒刷新一次，累计 10 次：</p><pre><code class="py">&gt;&gt;&gt; for x in range(10):        psutil.cpu_percent(interval=1, percpu=True)[17.9, 4.7, 6.2, 4.7, 18.8, 6.2, 15.6, 1.6][6.2, 4.7, 6.2, 1.6, 18.8, 1.6, 14.1, 4.7][10.8, 9.4, 9.4, 9.4, 12.5, 6.2, 20.3, 7.8][9.2, 4.7, 4.7, 0.0, 9.4, 1.6, 9.4, 3.1][3.1, 10.9, 4.7, 0.0, 17.2, 4.7, 10.9, 6.2][10.9, 4.7, 10.9, 0.0, 21.9, 1.6, 12.5, 7.7][10.6, 6.2, 7.8, 9.4, 9.4, 7.8, 10.9, 1.6][12.1, 14.1, 9.2, 1.6, 15.6, 1.6, 7.8, 3.1][10.4, 3.1, 3.1, 1.6, 7.8, 4.7, 9.4, 3.1][13.6, 4.7, 3.1, 1.6, 10.9, 4.7, 15.6, 4.7]</code></pre><h1 id="获取内存信息"><a href="#获取内存信息" class="headerlink" title="获取内存信息"></a>获取内存信息</h1><p>使用 psutil 获取物理内存和交换内存信息，分别使用：</p><pre><code class="py">&gt;&gt;&gt; psutil.virtual_memory()svmem(total=34192486400, available=24073785344, percent=29.6, used=10118701056, free=24073785344)&gt;&gt;&gt; psutil.swap_memory()sswap(total=39292760064, used=22848684032, free=16444076032, percent=58.1, sin=0, sout=0)</code></pre><p>返回的是字节为单位的整数，可以看到，总内存大小是 34192486400 ≈ 32 GB，已用 10118701056 = 9.4 GB，使用了29.6%。</p><p>而交换区大小是 39292760064。</p><h1 id="获取磁盘信息"><a href="#获取磁盘信息" class="headerlink" title="获取磁盘信息"></a>获取磁盘信息</h1><p>可以通过 psutil 获取磁盘分区、磁盘使用率和磁盘 IO 信息：</p><pre><code class="py">&gt;&gt;&gt; psutil.disk_partitions() # 磁盘分区信息[sdiskpart(device=&#39;C:\\&#39;, mountpoint=&#39;C:\\&#39;, fstype=&#39;NTFS&#39;, opts=&#39;rw,fixed&#39;), sdiskpart(device=&#39;D:\\&#39;, mountpoint=&#39;D:\\&#39;, fstype=&#39;NTFS&#39;, opts=&#39;rw,fixed&#39;)]&gt;&gt;&gt; psutil.disk_usage(&#39;/&#39;) # 磁盘使用情况sdiskusage(total=499581448192, used=127942549504, free=371638898688, percent=25.6)&gt;&gt;&gt; psutil.disk_io_counters() # 磁盘IOsdiskio(read_count=304774, write_count=1072936, read_bytes=9930344448, write_bytes=21363569152, read_time=241, write_time=363)</code></pre><p>可以看到，磁盘&#39;/&#39;的总容量是 499581448192 = 465 GB，使用了25.6%。文件格式是 HFS，opts 中包含 rw 表示可读写。</p><h1 id="获取网络信息"><a href="#获取网络信息" class="headerlink" title="获取网络信息"></a>获取网络信息</h1><p>psutil 可以获取网络接口和网络连接信息：</p><pre><code class="py">&gt;&gt;&gt; psutil.net_io_counters() # 获取网络读写字节／包的个数snetio(bytes_sent=137762746, bytes_recv=4244858457, packets_sent=1678156, packets_recv=3637825, errin=0, errout=0, dropin=0, dropout=0)&gt;&gt;&gt; psutil.net_if_addrs() # 获取网络接口信息{  &#39;以太网&#39;: [snicaddr(family = &lt;AddressFamily.AF_LINK: -1 &gt; , address = &#39;FC-AA-14-9C-5C-9F&#39;, netmask = None, broadcast = None, ptp = None), snicaddr(family = &lt;AddressFamily.AF_INET: 2 &gt; , address = &#39;192.168.81.88&#39;, netmask = &#39;255.255.255.0&#39;, broadcast = None, ptp = None), snicaddr(family = &lt;AddressFamily.AF_INET6: 23 &gt; , address = &#39;fe80::5c91:1b95:bbd8:eba9&#39;, netmask = None, broadcast = None, ptp = None)],  &#39;Loopback Pseudo-Interface 1&#39;: [snicaddr(family = &lt;AddressFamily.AF_INET: 2 &gt; , address = &#39;127.0.0.1&#39;, netmask = &#39;255.0.0.0&#39;, broadcast = None, ptp = None), snicaddr(family = &lt;AddressFamily.AF_INET6: 23 &gt; , address = &#39;::1&#39;, netmask = None, broadcast = None, ptp = None)]}&gt;&gt;&gt; psutil.net_if_stats() # 获取网络接口状态{  &#39;以太网&#39;: snicstats(isup = True, duplex = &lt;NicDuplex.NIC_DUPLEX_FULL: 2 &gt; , speed = 100, mtu = 1500),  &#39;Loopback Pseudo-Interface 1&#39;: snicstats(isup = True, duplex = &lt;NicDuplex.NIC_DUPLEX_FULL: 2 &gt; , speed = 1073, mtu = 1500)}</code></pre><p>要获取当前网络连接信息，使用 net_connections()：</p><p>你可能会得到一个 AccessDenied 错误，原因是 psutil 获取信息也是要走系统接口，而获取网络连接信息需要 root 权限。</p><pre><code class="py">&gt;&gt;&gt; psutil.net_connections()[    sconn(fd=83, family=&lt;AddressFamily.AF_INET6: 30&gt;, type=1, laddr=addr(ip=&#39;::127.0.0.1&#39;, port=62911), raddr=addr(ip=&#39;::127.0.0.1&#39;, port=3306), status=&#39;ESTABLISHED&#39;, pid=3725),    ...    sconn(fd=27, family=&lt;AddressFamily.AF_INET: 2&gt;, type=2, ..., pid=1)]</code></pre><h1 id="获取进程信息"><a href="#获取进程信息" class="headerlink" title="获取进程信息"></a>获取进程信息</h1><p>通过 psutil 可以获取到所有进程的详细信息：</p><pre><code class="py">&gt;&gt;&gt; psutil.pids() # 所有进程ID[0, 4, 120, 428, 612, 720, ..., 21396, 3312, 18888, 10804]&gt;&gt;&gt; p = psutil.Process(10804) # 获取指定进程ID=3776，其实就是当前Python交互环境&gt;&gt;&gt; ppsutil.Process(pid=10804, name=&#39;python.exe&#39;, started=&#39;15:09:40&#39;)&gt;&gt;&gt; p.name() # 进程名称&#39;python.exe&#39;&gt;&gt;&gt; p.exe() # 进程exe路径&#39;C:\\Program Files\\Python36\\python.exe&#39;&gt;&gt;&gt; p.cwd() # 进程工作目录&#39;C:\\Users\\Administrator&#39;&gt;&gt;&gt; p.cmdline() # 进程启动的命令行[&#39;C:\\Program Files\\Python36\\python.exe&#39;]&gt;&gt;&gt; p.ppid() # 父进程ID3312&gt;&gt;&gt; p.parent() # 父进程psutil.Process(pid=3312, name=&#39;powershell.exe&#39;, started=&#39;15:08:42&#39;)&gt;&gt;&gt; p.children() # 子进程列表[]&gt;&gt;&gt; p.status() # 进程状态&#39;running&#39;&gt;&gt;&gt; p.username() # 进程用户名&#39;DESKTOP-4P1JQ5U\\Administrator&#39;&gt;&gt;&gt; p.create_time() # 进程创建时间1546240180.0&gt;&gt;&gt; p.terminal() # 进程终端（Linux下存在）Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;AttributeError: &#39;Process&#39; object has no attribute &#39;terminal&#39;&gt;&gt;&gt; p.cpu_times() # 进程使用的CPU时间pcputimes(user=0.0625, system=0.0625, children_user=0.0, children_system=0.0)&gt;&gt;&gt; p.cpu_percent(None) # 进程占用的CPU，第一次调用得到的是0，第二次调用得到的是从上一次调用同一个进程对象的cpu_percent方法到第二次调用之间的cpu利用率0.0&gt;&gt;&gt; p.memory_info() # 进程使用的内存pmem(rss=15048704, vms=8454144, num_page_faults=5448, peak_wset=15052800, wset=15048704, peak_paged_pool=190608, paged_pool=190328, peak_nonpaged_pool=14016, nonpaged_pool=13304, pagefile=8454144, peak_pagefile=8572928, private=8454144)&gt;&gt;&gt; p.memory_percent()# 进程占用的内存0.04451485575497663&gt;&gt;&gt; p.open_files() # 进程打开的文件[popenfile(path=&#39;C:\\Program Files\\WindowsApps\\Microsoft.LanguageExperiencePackzh-CN_17763.6.11.0_neutral__8wekyb3d8bbwe\\Windows\\System32\\zh-CN\\KernelBase.dll.mui&#39;, fd=-1), popenfile(path=&#39;C:\\Program Files\\WindowsApps\\Microsoft.LanguageExperiencePackzh-CN_17763.6.11.0_neutral__8wekyb3d8bbwe\\Windows\\System32\\zh-CN\\kernel32.dll.mui&#39;, fd=-1)]&gt;&gt;&gt; p.connections() # 进程相关网络连接[]&gt;&gt;&gt; p.num_threads() # 进程的线程数量5&gt;&gt;&gt; p.threads() # 所有线程信息[pthread(id=6312, user_time=0.0625, system_time=0.171875), pthread(id=8484, user_time=0.0, system_time=0.0), pthread(id=12192, user_time=0.0, system_time=0.0), pthread(id=11580, user_time=0.0, system_time=0.0)]&gt;&gt;&gt; p.environ() # 进程环境变量{&#39;ALLUSERSPROFILE&#39;: &#39;C:\\ProgramData&#39;, ..., &#39;WINDIR&#39;: &#39;C:\\Windows&#39;}&gt;&gt;&gt; p.terminate() # 结束进程</code></pre><p>psutil还提供了一个 <code>test() 函数</code>，可以模拟出 ps 命令的效果：</p><pre><code class="py">&gt;&gt;&gt; psutil.test()USER         PID %MEM     VSZ     RSS TTY           START    TIME  COMMANDroot           0 24.0 74270628 2016380 ?             Nov18   40:51  kernel_taskroot           1  0.1 2494140    9484 ?             Nov18   01:39  launchdroot          44  0.4 2519872   36404 ?             Nov18   02:02  UserEventAgentroot          45    ? 2474032    1516 ?             Nov18   00:14  syslogdroot          47  0.1 2504768    8912 ?             Nov18   00:03  kextdroot          48  0.1 2505544    4720 ?             Nov18   00:19  fseventsd_appleeven    52  0.1 2499748    5024 ?             Nov18   00:00  appleeventsdroot          53  0.1 2500592    6132 ?             Nov18   00:02  configd...</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 常见陷阱</title>
      <link href="/2018/12/31/Python%20%E5%B8%B8%E8%A7%81%E9%99%B7%E9%98%B1/"/>
      <url>/2018/12/31/Python%20%E5%B8%B8%E8%A7%81%E9%99%B7%E9%98%B1/</url>
      
        <content type="html"><![CDATA[<h2 id="可变默认参数"><a href="#可变默认参数" class="headerlink" title="可变默认参数"></a>可变默认参数</h2><p>看起来，最让 Python 程序员感到惊奇的是 Python 对函数定义中可变默认参数的处理。</p><pre><code class="py">def append_to(element, to=[]):    to.append(element)    return tomy_list = append_to(12)print(my_list)my_other_list = append_to(42)print(my_other_list)</code></pre><p>每次调用函数时，如果不提供第二个参数，就会创建一个新的列表，所以结果应是这样的：</p><pre><code class="shell">[12][42]</code></pre><p>而事实是</p><pre><code class="shell">[12][12, 42]</code></pre><p>当函数被定义时，一个新的列表就被创建一次，而且同一个列表在每次成功的调用中都被使用。</p><p>当函数被定义时，Python 的默认参数就被创建一次，而不是每次调用函数的时候创建。这意味着，如果您使用一个可变默认参数并改变了它，您将会在未来所有对此函数的调用中改变这个对象。</p><p>您应该做的</p><p>在每次函数调用中，通过使用指示没有提供参数的默认参数 <code>None</code> 通常是个好选择，来创建一个新的对象。</p><pre><code class="py">def append_to(element, to=None):    if to is None:        to = []    to.append(element)    return to</code></pre><p>别忘了，您在把列表对象作为第二个参数传入。</p><p>有时您可以专门“利用”（或者说特地使用）这种行为来维护函数调用间的状态。这通常用于编写缓存函数。</p><h2 id="延迟绑定闭包"><a href="#延迟绑定闭包" class="headerlink" title="延迟绑定闭包"></a>延迟绑定闭包</h2><p>另一个常见的困惑是 Python 在闭包(或在周围全局作用域（surrounding global scope）)中<br>绑定变量的方式。</p><pre><code class="py">def create_multipliers():    return [lambda x : i x for i in range(5)]for multiplier in create_multipliers():    print(multiplier(2))</code></pre><p>一个包含五个函数的列表，每个函数有它们自己的封闭变量 <code>i</code> 乘以它们的参数，得到::</p><pre><code class="shell">02468</code></pre><p>而事实是</p><pre><code class="shell">88888</code></pre><p>五个函数被创建了，它们全都用4乘以 <code>x</code> 。</p><p>Python 的闭包是迟绑定。这意味着闭包中用到的变量的值，是在内部函数被调用时查询得到的。</p><p>这里，不论任何返回的函数是如何被调用的， <code>i</code> 的值是调用时在周围作用域中查询到的。接着，循环完成， <code>i</code> 的值最终变成了4。</p><p>关于这个陷阱有一个普遍严重的误解，它被认为是和Python的 <code>lambdas &lt;python:lambda&gt;</code> 有关。 由 <code>lambda</code> 表达式创建的函数并没什么特别，而且事实上，同样的问题也出现在使用普通的定义上：</p><pre><code class="py">def create_multipliers():    multipliers = []    for i in range(5):        def multiplier(x):            return i x        multipliers.append(multiplier)    return multipliers</code></pre><p>最一般的解决方案可以说是有点取巧（hack）。由于 Python 拥有在前文提到的为函数默认参数赋值的行为）,您可以创建一个立即绑定参数的闭包,像下面这样：</p><pre><code class="py">def create_multipliers():    return [lambda x, i=i : i x for i in range(5)]</code></pre><p>或者，您可以使用 <code>functools.partial</code> 函数：</p><pre><code class="py">from functools import partialfrom operator import muldef create_multipliers():    return [partial(mul, i) for i in range(5)]</code></pre><blockquote><p><a href="https://pythonguidecn.readthedocs.io/zh/latest/writing/gotchas.html" target="_blank" rel="noopener">https://pythonguidecn.readthedocs.io/zh/latest/writing/gotchas.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python Pipenv 使用</title>
      <link href="/2018/12/28/Python%20Pipenv%20%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/12/28/Python%20Pipenv%20%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>Pipenv 管理每个项目的依赖关系。</p><p>pipenv 使用 <a href="https://github.com/pypa/pipfile" target="_blank" rel="noopener">Pipfile</a> 来代替 requirement.txt 文件记录 python 包。</p><p>增加了 Pipfile.lock 文件来锁定 python 软件的包名及版本，以及其依赖关系的列表。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code class="shell">pip install pipenv</code></pre><p>用户模式安装，见<a href="用户模式安装">用户模式安装</a></p><h2 id="安装软件包"><a href="#安装软件包" class="headerlink" title="安装软件包"></a>安装软件包</h2><pre><code class="shell">$ cd myproject$ pipenv install requests</code></pre><p><code>pipenv install</code>，后面不跟软件包名，可以初始化虚拟环境。</p><p>通过 <code>requirements.txt</code> 安装</p><pre><code class="shell">pipenv install -r requirements.txt</code></pre><p>这样我们可以重用之前的 <code>requirement.txt</code> 文件来构建我们新的开发环境，可以把我们的项目顺利的迁到 pipenv。</p><p>可通过以下命令生成 <code>requirements</code> 文件：</p><pre><code class="shell">pipenv lock -r [--dev] &gt; requirements.txt</code></pre><h2 id="查看已安装模块"><a href="#查看已安装模块" class="headerlink" title="查看已安装模块"></a>查看已安装模块</h2><pre><code class="shell">$ pipenv graphrequests==2.21.0  - certifi [required: &gt;=2017.4.17, installed: 2018.11.29]  - chardet [required: &gt;=3.0.2,&lt;3.1.0, installed: 3.0.4]  - idna [required: &gt;=2.5,&lt;2.9, installed: 2.8]  - urllib3 [required: &gt;=1.21.1,&lt;1.25, installed: 1.24.1]</code></pre><h2 id="使用安装好的包"><a href="#使用安装好的包" class="headerlink" title="使用安装好的包"></a>使用安装好的包</h2><p>现在安装了 Requests，您可以创建一个简单的 main.py 文件来使用它：</p><pre><code class="py">import requestsresponse = requests.get(&#39;https://httpbin.org/ip&#39;)print(&#39;Your IP is {0}&#39;.format(response.json()[&#39;origin&#39;]))</code></pre><p>然后您就可以使用 <code>pipenv run</code> 运行这段脚本：</p><pre><code class="shell">pipenv run python main.py</code></pre><p>您应该获取到类似的输出：</p><pre><code class="shell">Your IP is 8.8.8.8</code></pre><p>使用 <code>pipenv run</code> 可确保您的安装包可用于您的脚本。我们还可以生成一个新的 shell， 确保所有命令都可以使用  <code>pipenv shell</code> 访问已安装的包。</p><h2 id="删除虚拟环境及包"><a href="#删除虚拟环境及包" class="headerlink" title="删除虚拟环境及包"></a>删除虚拟环境及包</h2><p>删除包:</p><pre><code class="shell">pipenv uninstall reuqests</code></pre><p>删除虚拟环境：</p><pre><code class="shell">pipenv --rm</code></pre><blockquote><p><a href="https://pythonguidecn.readthedocs.io/zh/latest/dev/virtualenvs.html#id3" target="_blank" rel="noopener">https://pythonguidecn.readthedocs.io/zh/latest/dev/virtualenvs.html#id3</a><br><a href="https://segmentfault.com/a/1190000012837890" target="_blank" rel="noopener">https://segmentfault.com/a/1190000012837890</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python pip 使用</title>
      <link href="/2018/12/26/Python%20pip%20%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/12/26/Python%20pip%20%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="安装-pip"><a href="#安装-pip" class="headerlink" title="安装 pip"></a>安装 pip</h2><pre><code class="shell">curl https://bootstrap.pypa.io/get-pip.py -o get-pip.pypython get-pip.py</code></pre><h2 id="安装软件包"><a href="#安装软件包" class="headerlink" title="安装软件包"></a>安装软件包</h2><pre><code class="shell">pip install SomePackage            # latest versionpip install SomePackage==1.0.4     # specific versionpip install &#39;SomePackage&gt;=1.0.4&#39;     # minimum version# 通过 whl 文件安装pip install SomePackage-1.0-py2.py3-none-any.whl# 通过文件安装，文件内容类似如下：# requests==2.18.4# SomePackage==1.0.4pip install -r requirements.txt</code></pre><h2 id="生成-requirements"><a href="#生成-requirements" class="headerlink" title="生成 requirements"></a>生成 requirements</h2><pre><code class="shell">pip freeze &gt; requirements.txt</code></pre><h2 id="更新软件包"><a href="#更新软件包" class="headerlink" title="更新软件包"></a>更新软件包</h2><pre><code class="shell">pip install --upgrade requests</code></pre><h2 id="卸载软件包"><a href="#卸载软件包" class="headerlink" title="卸载软件包"></a>卸载软件包</h2><pre><code class="shell">pip uninstall requests</code></pre><h2 id="显示安装的文件"><a href="#显示安装的文件" class="headerlink" title="显示安装的文件"></a>显示安装的文件</h2><pre><code class="shell"># 显示某个软件包的详情$ pip show --files requestsName: requestsVersion: 2.18.4Summary: Python HTTP for Humans.Home-page: http://python-requests.orgAuthor: Kenneth ReitzAuthor-email: me@kennethreitz.orgLicense: Apache 2.0Location: /usr/lib/python3/dist-packagesRequires:Required-by:Files:Cannot locate installed-files.txt# 列出过时的软件包（不加 --outdated 就是列出全部）$ pip list --outdatedPackage            Version     Latest     Type------------------ ----------- ---------- -----requests           2.18.4      2.21.0     wheel</code></pre><h2 id="命令调用方式"><a href="#命令调用方式" class="headerlink" title="命令调用方式"></a>命令调用方式</h2><pre><code class="shell"># 如果 pip 命令不可用（不在环境变量中）python -m pip &lt;pip arguments&gt;</code></pre><h2 id="用户模式安装"><a href="#用户模式安装" class="headerlink" title="用户模式安装"></a>用户模式安装</h2><pre><code class="shell"># 将会安装在 ~/.local 目录下，export PYTHONUSERBASE=/myappenv 可指定安装目录$ pip install --user pipenv</code></pre><p>这进行了用户安装，以防止破坏任何系统范围的包。如果安装后, shell 中没有 pipenv，则需要将用户基础目录的二进制文件目录添加到 PATH 中。</p><p>在 Linux 和 macOS 上，您可以通过运行 <code>python -m site --user-base</code> 找到 用户基础目录，然后把 bin 加到目录末尾。比如，上述命令典型地会打印出 <code>~/.local</code>，然后将 <code>~/.local/bin</code> 添加到 PATH 中。您可以通过 修改 <code>~/.profile</code> 永久地设置 <code>PATH</code>。</p><h2 id="设置配置文件"><a href="#设置配置文件" class="headerlink" title="设置配置文件"></a>设置配置文件</h2><p>每个用户：</p><ol><li>Linux 下 <code>$HOME/.config/pip/pip.conf</code>，如需修改可设置环境变量 <code>XDG_CONFIG_HOME</code>。</li><li>Windows 下 <code>%APPDATA%\pip\pip.ini</code>。</li></ol><p>全局设置：</p><ol><li>Linux 下 <code>/etc/pip.conf</code>，如需修改可设置环境变量 <code>XDG_CONFIG_DIRS</code>。</li><li>全局设置：Windows 下 <code>C:\ProgramData\pip\pip.ini</code>。</li></ol><p>设置阿里云的镜像源</p><pre><code class="ini">[global]trusted-host =  mirrors.aliyun.comindex-url = https://mirrors.aliyun.com/pypi/simple</code></pre><p>也可以直接命令行：</p><pre><code class="shell">pip install requests -i=https://mirrors.aliyun.com/pypi/simple</code></pre><blockquote><p><a href="https://pip.pypa.io/en/stable/quickstart/" target="_blank" rel="noopener">https://pip.pypa.io/en/stable/quickstart/</a><br><a href="https://pip.pypa.io/en/stable/user_guide/#user-installs" target="_blank" rel="noopener">https://pip.pypa.io/en/stable/user_guide/#user-installs</a><br><a href="https://pythonguidecn.readthedocs.io/zh/latest/dev/virtualenvs.html#id3" target="_blank" rel="noopener">https://pythonguidecn.readthedocs.io/zh/latest/dev/virtualenvs.html#id3</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PyCharm 使用技巧</title>
      <link href="/2018/12/06/PyCharm%20%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
      <url>/2018/12/06/PyCharm%20%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="Find-Usages（查找引用）"><a href="#Find-Usages（查找引用）" class="headerlink" title="Find Usages（查找引用）"></a>Find Usages（查找引用）</h1><p>可以查找某个对象（变量、函数、或者类等）被引用的地方。</p><p>在要查找的对象上 <code>右键-&gt; Find Usages-&gt;</code> 界面下方会列出查找结果。</p><p>快捷键：<code>Alt + F7</code></p><a id="more"></a><h1 id="Column-Selection-Mode（列选择模式）"><a href="#Column-Selection-Mode（列选择模式）" class="headerlink" title="Column Selection Mode（列选择模式）"></a>Column Selection Mode（列选择模式）</h1><p>在当前文件 <code>右键-&gt;Column Selection Mode-&gt;</code> 用鼠标垂直选择文本</p><p>快捷键：<code>Alt + Shift + Insert</code></p><h1 id="创建-py-文件时自动生成注释：作者、时间、文件名等"><a href="#创建-py-文件时自动生成注释：作者、时间、文件名等" class="headerlink" title="创建 py 文件时自动生成注释：作者、时间、文件名等"></a>创建 py 文件时自动生成注释：作者、时间、文件名等</h1><p>使用：<code>File-&gt; Setting-&gt; File and Code Templates-&gt; Python Script</code></p><pre><code class="py">#!/usr/bin/env python# -*- coding: utf-8 -*-# @Time    : ${DATE} ${TIME}__author__ = &#39;${USER}&#39;</code></pre><p>其他的一些可选的预定义变量有：</p><pre><code>${PROJECT_NAME} - the name of the current project.${NAME} - the name of the new file which you specify in the New File dialog box during the file creation.${USER} - the login name of the current user.${DATE} - the current system date.${TIME} - the current system time.${YEAR} - the current year.${MONTH} - the current month.${DAY} - the current day of the month.${HOUR} - the current hour.${MINUTE} - the current minute.${PRODUCT_NAME} - the name of the IDE in which the file will be created.${MONTH_NAME_SHORT} - the first 3 letters of the month name. Example: Jan, Feb, etc.${MONTH_NAME_FULL} - full name of a month. Example: January, February, etc.</code></pre><h1 id="Save-File-as-Template（把当前文件保存为模板）"><a href="#Save-File-as-Template（把当前文件保存为模板）" class="headerlink" title="Save File as Template（把当前文件保存为模板）"></a>Save File as Template（把当前文件保存为模板）</h1><p>创建模板步骤（以下面的代码为模板）：</p><ol><li><p>打开test.py</p></li><li><p>点击 <code>Tools-&gt; Save File as Template</code> 保存模板命名为 mySum</p></li></ol><p>使用模板步骤：</p><ol><li><p>在菜单点击 <code>File-&gt; New</code></p></li><li><p>选择 mySum，输入文件名 xxx.py</p></li><li><p>生产的 xxx.py 就是前面创建模板代码</p></li></ol><h1 id="Split-Vertically-Horizontally（垂直-水平拆分窗口）"><a href="#Split-Vertically-Horizontally（垂直-水平拆分窗口）" class="headerlink" title="Split Vertically/Horizontally（垂直/水平拆分窗口）"></a>Split Vertically/Horizontally（垂直/水平拆分窗口）</h1><p><code>在编辑窗口文件名中右键点击 Split Vertically 或者 Split Horizontally</code> 就可以垂直或者水平拆分成两个窗口，方便比较文件。</p><h1 id="Execute-Selection-in-Console（控制台执行选中的文本）"><a href="#Execute-Selection-in-Console（控制台执行选中的文本）" class="headerlink" title="Execute Selection in Console（控制台执行选中的文本）"></a>Execute Selection in Console（控制台执行选中的文本）</h1><p><code>选中代码-&gt; 右键-&gt; Execute Selection in Console-&gt;</code> 控制台输出结果</p><p>快捷键：<code>Alt + Shift + E</code></p><h1 id="TODO（代码特殊注释技术）"><a href="#TODO（代码特殊注释技术）" class="headerlink" title="TODO（代码特殊注释技术）"></a>TODO（代码特殊注释技术）</h1><p>PyCharm支持的代码特殊注释包括TODO和FIXME。</p><p>TODO：表示这个地方需要实现一些功能，现在还没来得及做，先做个标记防止遗忘。</p><p>FIXME：表示需要修复的bug，优先级比较高。</p><p>把鼠标移到 PyCharm 左下角的矩形内，在弹出的菜单中点击 TODO 进入 TODO 界面。TODO 界面会列出代码中所有的特殊注释包括 TODO 和 FIXME。在 TODO 界面中点击某一行可以跳转到对应的代码中。</p><h1 id="Start-SSH-Session（远程登录）"><a href="#Start-SSH-Session（远程登录）" class="headerlink" title="Start SSH Session（远程登录）"></a>Start SSH Session（远程登录）</h1><p><code>Tools-&gt; Start SSH Session-&gt; Edit credentials</code></p><p>输入 Host、Port、User name 和 Password 之后即可远程登录。</p><h1 id="Test-RESTful-Web-Service（RESTful接口测试界面）"><a href="#Test-RESTful-Web-Service（RESTful接口测试界面）" class="headerlink" title="Test RESTful Web Service（RESTful接口测试界面）"></a>Test RESTful Web Service（RESTful接口测试界面）</h1><p>PyCharm 的 Test RESTful Web Service 工具提供了 RESTful 接口测试界面，提供了 get、post，put 等 http 方法，其中的 Request 子界面 headers，Parameters，Body 等功能，Response 子界面用于显示返回值，Response Headers 用于显示返回的消息头。</p><p>进入: <code>Tools-&gt; HTTP Client-&gt; Test RESTful Web Service</code></p><h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><p>Regex Tester，可以测试正则表达式</p><p>Key Promoter X，显示使用鼠标进行可通过键盘快捷键完成的操作时的提示。</p><p>Markdown support</p><p>Material Theme UI</p><p>Translation</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/xiemanr/article/category/6928127" target="_blank" rel="noopener">https://blog.csdn.net/xiemanr/article/category/6928127</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 字符串操作</title>
      <link href="/2018/11/13/MySQL%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/"/>
      <url>/2018/11/13/MySQL%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="字符串截取"><a href="#字符串截取" class="headerlink" title="字符串截取"></a>字符串截取</h1><h2 id="left-str-length"><a href="#left-str-length" class="headerlink" title="left(str, length)"></a>left(str, length)</h2><pre><code class="sql">mysql&gt; select left(&#39;sqlstudy.com&#39;, 3);+-------------------------+| left(&#39;sqlstudy.com&#39;, 3) |+-------------------------+| sql                     |+-------------------------+</code></pre><a id="more"></a><h2 id="right-str-length"><a href="#right-str-length" class="headerlink" title="right(str, length)"></a>right(str, length)</h2><pre><code class="sql">mysql&gt; select right(&#39;sqlstudy.com&#39;, 3);+--------------------------+| right(&#39;sqlstudy.com&#39;, 3) |+--------------------------+| com                      |+--------------------------+</code></pre><h2 id="substring-str-pos-substring-str-pos-len"><a href="#substring-str-pos-substring-str-pos-len" class="headerlink" title="substring(str, pos); substring(str, pos, len)"></a>substring(str, pos); substring(str, pos, len)</h2><p>从字符串的第 4 个字符位置开始取，直到结束。</p><pre><code class="sql">mysql&gt; select substring(&#39;sqlstudy.com&#39;, 4);+------------------------------+| substring(&#39;sqlstudy.com&#39;, 4) |+------------------------------+| study.com                    |+------------------------------+</code></pre><p>从字符串的第 4 个字符位置开始取，只取 2 个字符。</p><pre><code class="sql">mysql&gt; select substring(&#39;sqlstudy.com&#39;, 4, 2);+---------------------------------+| substring(&#39;sqlstudy.com&#39;, 4, 2) |+---------------------------------+| st                              |+---------------------------------+</code></pre><p>从字符串的第 4 个字符位置（倒数）开始取，直到结束。</p><pre><code class="sql">mysql&gt; select substring(&#39;sqlstudy.com&#39;, -4);+-------------------------------+| substring(&#39;sqlstudy.com&#39;, -4) |+-------------------------------+| .com                          |+-------------------------------+</code></pre><p>从字符串的第 4 个字符位置（倒数）开始取，只取 2 个字符。</p><pre><code class="sql">mysql&gt; select substring(&#39;sqlstudy.com&#39;, -4, 2);+----------------------------------+| substring(&#39;sqlstudy.com&#39;, -4, 2) |+----------------------------------+| .c                               |+----------------------------------+</code></pre><p>我们注意到在函数 substring(str, pos, len)中，pos 可以是负值，但 len 不能取负值。</p><h2 id="substring-index-str-delim-count"><a href="#substring-index-str-delim-count" class="headerlink" title="substring_index(str, delim, count)"></a>substring_index(str, delim, count)</h2><p>截取第二个 &#39;.&#39; 之前的所有字符。</p><pre><code class="sql">mysql&gt; select substring_index(&#39;www.sqlstudy.com.cn&#39;, &#39;.&#39;, 2);+------------------------------------------------+| substring_index(&#39;www.sqlstudy.com.cn&#39;, &#39;.&#39;, 2) |+------------------------------------------------+| www.sqlstudy                                   |+------------------------------------------------+</code></pre><p>截取倒数第二个 &#39;.&#39; 之后的所有字符。</p><pre><code class="sql">mysql&gt; select substring_index(&#39;www.sqlstudy.com.cn&#39;, &#39;.&#39;, -2);+-------------------------------------------------+| substring_index(&#39;www.sqlstudy.com.cn&#39;, &#39;.&#39;, -2) |+-------------------------------------------------+| com.cn                                          |+-------------------------------------------------+</code></pre><p>如果在字符串中找不到 delim 参数指定的值，就返回整个字符串</p><pre><code class="sql">mysql&gt; select substring_index(&#39;www.sqlstudy.com.cn&#39;, &#39;.coc&#39;, 1);+---------------------------------------------------+| substring_index(&#39;www.sqlstudy.com.cn&#39;, &#39;.coc&#39;, 1) |+---------------------------------------------------+| www.sqlstudy.com.cn                               |+---------------------------------------------------+</code></pre><h1 id="字符串连接"><a href="#字符串连接" class="headerlink" title="字符串连接"></a>字符串连接</h1><h2 id="CONCAT-str1-str2"><a href="#CONCAT-str1-str2" class="headerlink" title="CONCAT(str1,str2,...)"></a>CONCAT(str1,str2,...)</h2><p>返回来自于参数连结的字符串。如果任何参数是NULL，返回NULL。可以有超过2个的参数。一个数字参数被变换为等价的字符串形式。</p><pre><code class="sql">select CONCAT(&#39;My&#39;, &#39;S&#39;, &#39;QL&#39;);  # MySQLselect CONCAT(12.3);  # &#39;12.3&#39;</code></pre><p>如果你想要明确地变换一个数字到一个字符串，把它作为参数传递到CONCAT()。</p><pre><code class="sql">SELECT CONCAT(2,&#39; test&#39;);  # &#39;2 test&#39;</code></pre><h1 id="字符串长度-LENGTH-str"><a href="#字符串长度-LENGTH-str" class="headerlink" title="字符串长度 LENGTH(str)"></a>字符串长度 LENGTH(str)</h1><p>计算字符串长度。</p><pre><code class="sql">select length(&#39;text&#39;);  # 4</code></pre><h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><h2 id="LOCATE-substr-str-与-POSITION-substr-IN-str"><a href="#LOCATE-substr-str-与-POSITION-substr-IN-str" class="headerlink" title="LOCATE(substr, str) 与 POSITION(substr IN str)"></a>LOCATE(substr, str) 与 POSITION(substr IN str)</h2><p>返回子串 substr 在字符串 str 第一个出现的位置，如果 substr 不是在 str 里面，返回 0.</p><pre><code class="sql">select LOCATE(&#39;bar&#39;, &#39;foobarbar&#39;);  # 4select LOCATE(&#39;xbar&#39;, &#39;foobar&#39;);  # 0select POSITION(&#39;bar&#39; IN &#39;foobarbar&#39;);  # 4select POSITION(&#39;xbar&#39; IN &#39;foobarbar&#39;);  # 0</code></pre><h2 id="LOCATE-substr-str-pos"><a href="#LOCATE-substr-str-pos" class="headerlink" title="LOCATE(substr, str, pos)"></a>LOCATE(substr, str, pos)</h2><p>返回子串 substr 在字符串 str 第一个出现的位置，从位置 pos 开始。如果 substr 不是在 str 里面，返回 0。</p><pre><code class="sql">select LOCATE(&#39;bar&#39;, &#39;foobarbar&#39;, 5);  # 7</code></pre><h2 id="INSTR-str-substr"><a href="#INSTR-str-substr" class="headerlink" title="INSTR(str, substr)"></a>INSTR(str, substr)</h2><p>返回子串 substr 在字符串 str 中的第一个出现的位置。这的两个参数与 LOCATE() 前两个参数颠倒。</p><pre><code class="sql">select INSTR(&#39;foobarbar&#39;, &#39;bar&#39;);  # 4select INSTR(&#39;xbar&#39;, &#39;foobar&#39;);  # 0</code></pre><h2 id="ELT-N-str1-str2-str3"><a href="#ELT-N-str1-str2-str3" class="headerlink" title="ELT(N, str1, str2, str3, ...)"></a>ELT(N, str1, str2, str3, ...)</h2><p>如果 N= 1，返回 str1，如果 N= 2，返回 str2，等等。如果 N 小于 1 或大于参数个数，返回 NULL。ELT() 是 FIELD() 反运算。</p><pre><code class="sql">select ELT(1, &#39;ej&#39;, &#39;Heja&#39;, &#39;hej&#39;, &#39;foo&#39;);  # &#39;ej&#39;</code></pre><h2 id="FIELD-str-str1-str2-str3"><a href="#FIELD-str-str1-str2-str3" class="headerlink" title="FIELD(str, str1, str2, str3, ...)"></a>FIELD(str, str1, str2, str3, ...)</h2><p>返回 str 在 str1, str2, str3, ...清单的索引。如果 str 没找到，返回 0。FIELD() 是 ELT() 反运算。</p><pre><code class="sql">select FIELD(&#39;ej&#39;, &#39;Hej&#39;, &#39;ej&#39;, &#39;Heja&#39;, &#39;hej&#39;, &#39;foo&#39;);  # 2select FIELD(&#39;fo&#39;, &#39;Hej&#39;, &#39;ej&#39;, &#39;Heja&#39;, &#39;hej&#39;, &#39;foo&#39;);  # 0</code></pre><h2 id="FIND-IN-SET-str-strlist"><a href="#FIND-IN-SET-str-strlist" class="headerlink" title="FIND_IN_SET(str, strlist)"></a>FIND_IN_SET(str, strlist)</h2><p>如果字符串 str 在由 N 子串组成的表 strlist 之中，返回一个 1 到 N 的值。一个字符串表是被“,”分隔的子串组成的一个字符串。如果第一个参数是一个常数字符串并且第二个参数是一种类型为 SET 的列，FIND_IN_SET() 函数被优化而使用位运算！如果 str 不是在 strlist 里面或如果 strlist 是空字符串，返回 0。如果任何一个参数是 NULL，返回 NULL。如果第一个参数包含一个“,”，该函数将工作不正常。</p><pre><code class="sql">SELECT FIND_IN_SET(&#39;b&#39;,&#39;a,b,c,d&#39;);  # 2</code></pre><h1 id="更改"><a href="#更改" class="headerlink" title="更改"></a>更改</h1><h2 id="LPAD-str-len-padstr"><a href="#LPAD-str-len-padstr" class="headerlink" title="LPAD(str, len, padstr)"></a>LPAD(str, len, padstr)</h2><p>返回字符串 str，左面用字符串 padstr 填补直到 str 是 len 个字符长。</p><pre><code class="sql">select LPAD(&#39;hi&#39;,4,&#39;??&#39;);  # &#39;??hi&#39;</code></pre><h2 id="RPAD-str-len-padstr"><a href="#RPAD-str-len-padstr" class="headerlink" title="RPAD(str, len, padstr)"></a>RPAD(str, len, padstr)</h2><p>返回字符串 str，右面用字符串 padstr 填补直到 str 是 len 个字符长。</p><pre><code class="sql">select RPAD(&#39;hi&#39;,5,&#39;?&#39;);  # &#39;hi???&#39;</code></pre><h2 id="LTRIM-str"><a href="#LTRIM-str" class="headerlink" title="LTRIM(str)"></a>LTRIM(str)</h2><p>返回删除了其前置空格字符的字符串 str。</p><pre><code class="sql">select LTRIM(&#39;  barbar&#39;);  # &#39;barbar&#39;</code></pre><h2 id="RTRIM-str"><a href="#RTRIM-str" class="headerlink" title="RTRIM(str)"></a>RTRIM(str)</h2><p>返回删除了其拖后空格字符的字符串 str。</p><pre><code class="sql">select RTRIM(&#39;barbar   &#39;);  # &#39;barbar&#39;</code></pre><h2 id="TRIM-BOTH-LEADING-TRAILING-remstr-FROM-str"><a href="#TRIM-BOTH-LEADING-TRAILING-remstr-FROM-str" class="headerlink" title="TRIM([[BOTH | LEADING | TRAILING] [remstr] FROM] str)"></a>TRIM([[BOTH | LEADING | TRAILING] [remstr] FROM] str)</h2><p>返回字符串 str，其所有 remstr 前缀或后缀被删除了。如果没有修饰符 BOTH、LEADING 或 TRAILING 给出，BOTH 被假定。如果 remstr 没被指定，空格被删除。</p><pre><code class="sql">select TRIM(&#39;  bar   &#39;);  # &#39;bar&#39;select TRIM(LEADING &#39;x&#39; FROM &#39;xxxbarxxx&#39;);  # &#39;barxxx&#39;select TRIM(BOTH &#39;x&#39; FROM &#39;xxxbarxxx&#39;);  # &#39;bar&#39;select TRIM(TRAILING &#39;xyz&#39; FROM &#39;barxxyz&#39;);  # &#39;barx&#39;</code></pre><h2 id="SPACE-N"><a href="#SPACE-N" class="headerlink" title="SPACE(N)"></a>SPACE(N)</h2><p>返回由 N 个空格字符组成的一个字符串。</p><pre><code class="sql">select SPACE(6);  # &#39;      &#39;</code></pre><h2 id="REPLACE-str-from-str-to-str"><a href="#REPLACE-str-from-str-to-str" class="headerlink" title="REPLACE(str, from_str, to_str)"></a>REPLACE(str, from_str, to_str)</h2><p>返回字符串 str，其字符串 from_str 的所有出现由字符串 to_str 代替。</p><pre><code class="sql">select REPLACE(&#39;www.mysql.com&#39;, &#39;w&#39;, &#39;Ww&#39;);  # &#39;WwWwWw.mysql.com&#39;</code></pre><h2 id="REPEAT-str-count"><a href="#REPEAT-str-count" class="headerlink" title="REPEAT(str, count)"></a>REPEAT(str, count)</h2><p>返回由重复 count 次的字符串 str 组成的一个字符串。如果 count &lt;= 0，返回一个空字符串。如果 str 或 count 是 NULL，返回NULL。</p><pre><code class="sql">select REPEAT(&#39;MySQL&#39;, 3);  # &#39;MySQLMySQLMySQL&#39;</code></pre><h2 id="REVERSE-str"><a href="#REVERSE-str" class="headerlink" title="REVERSE(str)"></a>REVERSE(str)</h2><p>返回颠倒字符顺序的字符串 str。</p><pre><code class="sql">select REVERSE(&#39;abc&#39;);  # &#39;cba&#39;</code></pre><h2 id="INSERT-str-pos-len-newstr"><a href="#INSERT-str-pos-len-newstr" class="headerlink" title="INSERT(str, pos, len, newstr)"></a>INSERT(str, pos, len, newstr)</h2><p>返回字符串 str，在位置 pos 起始的子串且 len 个字符长得子串由字符串 newstr 代替。</p><pre><code class="sql">select INSERT(&#39;Quadratic&#39;, 3, 4, &#39;What&#39;);  # &#39;QuWhattic&#39;</code></pre><h2 id="LCASE-str"><a href="#LCASE-str" class="headerlink" title="LCASE(str)"></a>LCASE(str)</h2><p>LOWER(str) 返回字符串 str 的小写。</p><pre><code class="sql">select LCASE(&#39;QUADRATICALLY&#39;);  &#39;quadratically&#39;</code></pre><h2 id="UCASE-str"><a href="#UCASE-str" class="headerlink" title="UCASE(str)"></a>UCASE(str)</h2><p>返回字符串 str 的大写。</p><pre><code class="sql">select UCASE(&#39;Hej&#39;);  # &#39;HEJ&#39;</code></pre><h1 id="LOAD-FILE-file-name"><a href="#LOAD-FILE-file-name" class="headerlink" title="LOAD_FILE(file_name)"></a>LOAD_FILE(file_name)</h1><p>读入文件并且作为一个字符串返回文件内容。文件必须在服务器上，你必须指定到文件的完整路径名，而且你必须有file权限。文件必须所有内容都是可读的并且小于max_allowed_packet。如果文件不存在或由于上面原因之一不能被读出，函数返回NULL。</p><pre><code class="sql">mysql&gt; UPDATE table_name           SET blob_column=LOAD_FILE(&quot;/tmp/picture&quot;)           WHERE id=1;</code></pre><h1 id="ASCII-码-转换"><a href="#ASCII-码-转换" class="headerlink" title="ASCII 码 转换"></a>ASCII 码 转换</h1><h2 id="ASCII-str"><a href="#ASCII-str" class="headerlink" title="ASCII(str)"></a>ASCII(str)</h2><p>返回字符串 str 的<strong>最左面字符</strong>的 ASCII 代码值。如果 str 是空字符串，返回 0。如果 str 是 NULL，返回 NULL。</p><pre><code class="sql">select ASCII(&#39;2&#39;);  # 50select ASCII(2);  # 50select ASCII(&#39;&#39;);  # 0select ASCII(NULL);  # NULL</code></pre><h2 id="CHAR-N"><a href="#CHAR-N" class="headerlink" title="CHAR(N,...)"></a>CHAR(N,...)</h2><p>CHAR() 将参数解释为整数并且返回由这些整数的 ASCII 代码字符组成的一个字符串。NULL 值被跳过。</p><pre><code class="sql">select CHAR(77,121,83,81,NULL);  #  MySQ</code></pre><blockquote><p><a href="http://justdo2008.iteye.com/blog/1141609" target="_blank" rel="noopener">http://justdo2008.iteye.com/blog/1141609</a></p></blockquote><h2 id="base64-函数"><a href="#base64-函数" class="headerlink" title="base64 函数"></a>base64 函数</h2><p>MySQL 在 5.6 版本的时候增加了 <a href="http://dev.mysql.com/doc/refman/5.6/en/string-functions.html#function_to-base64" target="_blank" rel="noopener">to_base64</a> 和 <a href="http://dev.mysql.com/doc/refman/5.6/en/string-functions.html#function_from-base64" target="_blank" rel="noopener">from_base64</a> 函数。</p><pre><code class="sql">mysql&gt; select to_base64(&#39;helloworld&#39;);+-------------------------+| to_base64(&#39;helloworld&#39;) |+-------------------------+| aGVsbG93b3JsZA==        |+-------------------------+1 row in setmysql&gt; select from_base64(&#39;aGVsbG93b3JsZA==&#39;);+---------------------------------+| from_base64(&#39;aGVsbG93b3JsZA==&#39;) |+---------------------------------+| helloworld                      |+---------------------------------+1 row in set</code></pre><p>5.6版本之前的，具体查看原文：</p><p><a href="https://blog.csdn.net/cjfeii/article/details/50980721" target="_blank" rel="noopener">https://blog.csdn.net/cjfeii/article/details/50980721</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Effective Java》笔记18-22：类和接口</title>
      <link href="/2018/10/12/%E3%80%8AEffective%20Java%E3%80%8B%E7%AC%94%E8%AE%B018-22%EF%BC%9A%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/"/>
      <url>/2018/10/12/%E3%80%8AEffective%20Java%E3%80%8B%E7%AC%94%E8%AE%B018-22%EF%BC%9A%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="第18条：接口优于抽象类"><a href="#第18条：接口优于抽象类" class="headerlink" title="第18条：接口优于抽象类"></a>第18条：接口优于抽象类</h1><p>Java 提供两种机制用来定义允许多个实现的类型：接口和抽象类。</p><h2 id="接口的优势"><a href="#接口的优势" class="headerlink" title="接口的优势"></a>接口的优势</h2><ul><li><p><strong>现有的类可以很容易被更新，以实现新的接口。</strong>当需要增加方法的时候只需要 implements 具体的接口即可，非常方便，而如果通过抽象类来实现，则需要在抽象类里新增方法，而这会导致其他继承该抽象类的类也被强制加上额外的方法!</p></li><li><p><strong>接口是定义mixin(混合类型)的理想选择。</strong>mixin 是指主要的类型：类除了实现它的&quot;基本类型&quot;之外，还可以实现 mixin 类型（利用实现多个接口可以达到混合类型的目的，而利用抽象类只能继承一个类，则不能达到混合类型的效果）</p></li><li><p><strong>接口允许我们构造非层次结构的类型框架。</strong>类型层次对于组织某些事物是非常合适的，但是其他有些事物并不能被整齐地组织成一个严格的层次结构。例如，假设我们有一个接口代表一个 Singer（歌唱家），另一个接口代表一个 SongWriter（作曲家）。</p></li></ul><a id="more"></a><h2 id="骨架实现"><a href="#骨架实现" class="headerlink" title="骨架实现"></a>骨架实现</h2><p>在 Java 的 Collections Framework 中存在一组被称为&quot;骨架实现&quot;(skeletal implementation)的<strong>抽象类</strong>，如 AbstractCollection、AbstractSet 和 AbstractList 等。如果设计得当，骨架实现可以使程序员很容易的提供他们自己的接口实现。这种组合还可以让我们在设计自己的类时，根据实际情况选择是直接实现接口，还是扩展该抽象类。</p><p>和接口相比，骨架实现类还存在一个非常明显的优势，既如果今后为该骨架实现类提供新的方法，并提供了默认的实现，那么他的所有子类均不会受到影响，而接口则不同，由于接口不能提供任何方法实现，因此他所有的实现类必须进行修改，为接口中新增的方法提供自己的实现，否则将无法通过编译。</p><p>简而言之，接口通常是定义允许多个实现的类型的最佳途径。这条规则有个例外，即<strong>当演变的容易性比灵活性更为重要的时候</strong>。在这种情况下，应该使用抽象类来定义类型，但前提是必须理解并且可以接受这些局限性。<strong>如果你导出了一个重要的接口，就应该坚决考虑同时提供骨架实现类。</strong></p><h1 id="第19条：接口只用于定义类型"><a href="#第19条：接口只用于定义类型" class="headerlink" title="第19条：接口只用于定义类型"></a>第19条：接口只用于定义类型</h1><p>有一种接口称为<strong>常量接口</strong>，这种接口不包含任何方法，它只包含静态的 final 域，每个域都导出一个常量。使用这些常量的类实现这个接口，以避免用类名来修饰常量名：</p><pre><code class="java">public interface PhysicalConstants {    static final double AVOGADROS_NUMBER = 6.02214199e23;}</code></pre><p><strong>常量接口模式是对接口的不良使用</strong>。类在内部使用某些常量，这纯粹是实现细节。实现常量接口，会导致把这样的实现细节泄露到该类的导出 API 中。类实现常量接口没有什么价值。如果在将来的发行版本中，这个类被修改了，它不再需要使用这些常量了，它依然必须实现这个接口，以确保二制兼容性。如果非 final 类实现了常量接口，它的所有子类的命名空间也会被接口中的常量所“污染”。Java 平台类库中有几个常量接口，例如 java.io.ObjectStreamConstants，被认为是反面例子，不值得效仿。</p><p>如果要导出常量，可以有几种合理的方案。</p><ul><li>如果这些常量与某个现有的类或者接口紧密相关，就应该把这些常量添加到这个类或者接口。例如，在 Java 平台类库中所有的数值包装类，如 Integer 和 Double，都导出了 MIN_VALUE 和 MAX_VALUE 常量。</li><li>如果这些常量最好被看作枚举类型的成员，就应该使用枚举类型（见第30条）来导出这些常量。</li><li>否则，应该使用不可实例化的工具类（见第4条）来导出这些常量，下面是前面的 PhysicalConstants 例子的工具类翻版：</li></ul><pre><code class="java">public class PhysicalConstants {    private PhysicalConstants() { }  // 私有构造器    public static final double AVOGADROS_NUMBER = 6.02214199e23;}</code></pre><p>简而言之，接口应该只被用来定义类型，它们不应该被用来导出常量。</p><h1 id="第20条：类层次优于标签类"><a href="#第20条：类层次优于标签类" class="headerlink" title="第20条：类层次优于标签类"></a>第20条：类层次优于标签类</h1><p>有时候，可能会遇到带有两种甚至更多风格（功能）的实例的类，并包含表示实例风格的标签域，例如：</p><pre><code class="java">class Figure {    enum Shape {RECTANGLE, CIRCLE}    // 标签域 - 是圆形还是长方形    final Shape shape;    // 长方形    double length;    double width;    // 圆形    double radius;    // 圆形构造器    Figure(double radius) {        shape = Shape.CIRCLE;        this.radius = radius;    }    // 长方形构造器    Figure(double length, double width) {        shape = Shape.RECTANGLE;        this.length = length;        this.width = width;    }    // 面积    double area() {        switch (shape) {            case RECTANGLE:                return length * width;            case CIRCLE:                return Math.PI * (radius * radius);            default:                throw new AssertionError();        }    }}</code></pre><p>标签类的缺点非常明显，当你要表现的风格非常多样的时候，你需要写大量的判断语句，非常容易出错，而且当你需要修改某一个风格的时候，你需要在一大堆代码里找出你要改的地方，很有可能引入 bug，非常难以维护。</p><p>这个时候，将标签类转变成类层次就非常方便了：</p><pre><code class="java">abstract class Figure {    abstract double area();}class Circle extends Figure {    private final double radius;    Circle(double radius) {        this.radius = radius;    }    double area() {        return Math.PI * (radius * radius);    }}class Rectangle extends Figure {    private final double length;    private final double width;    Rectangle(double length, double width) {        this.length = length;        this.width = width;    }    double area() {        return length * width;    }}</code></pre><p>类层次的另一好处在于，它们可以用来反映类之间本质上的层次关系，有助于后期的扩充。假设现有加一个正方形有，标签类就需要修改源码，而利用类层次结构只需新加一个正方形类，并继承自长方形，</p><h1 id="第21条：用函数对象表示策略"><a href="#第21条：用函数对象表示策略" class="headerlink" title="第21条：用函数对象表示策略"></a>第21条：用函数对象表示策略</h1><p>Java 没有提供函数指针，但是可以用对象引用实现同样的功能。调用对象上的方法通常是执行该对象(that Object)上的某项操作。然而，我们也可能定义这样一种对象，它的方法执行其他对象(other Objects)上的操作。如果一个类仅仅导出这样的一个方法，它的实例实际上就等同于一个指向该方法的指针。这样的实例被称为<strong>函数对象</strong>(Function Object)，如 JDK 中 Comparator，我们可以将该对象看做是实现两个对象之间进行比较的<strong>&quot;具体策略对象&quot;</strong>，如：</p><pre><code class="java">public class StringLengthComparator {    public int comare(String s1, String s2) {        return s1.length() - s2.length();    }}</code></pre><p>作为典型的具体策略类，StringLengthComparator 类是无状态的：它没有域，所以，这个类的所有实例在功能上都是相互等价的。因此，它<strong>作一个 Singleton 是非常合适的</strong>，可以节省不必要的对象创建开销（见第3与第5条）：</p><pre><code class="java">public class StringLengthComparator {    private StringLengthComparator(){}    public static final StringLengthComparator INSTANCE = new StringLengthComparator();    public int comare(String s1, String s2) {        return s1.length() - s2.length();    }}</code></pre><p>为了把 StringLengthComparator 实例传递给方法，需要适当的参数类型，直接使用 StringLengthComparator 并不好，因为客户端将无法传递任何其他的比较策略，即不能随时动态的改变比较性为。此时，我们可以<strong>定义一个比较策略接口</strong>，这个接口在 java.util.Comparator 就已提供。</p><h2 id="使用匿名类"><a href="#使用匿名类" class="headerlink" title="使用匿名类"></a>使用匿名类</h2><p>具体的策略类往往使用匿名类（见第22条）来声明，下面的语句根据长度对一个字符串数组进行排序：</p><pre><code class="java">Arrays.sort(strArr, new Comparator&lt;String&gt;(){    public int compare(String s1, String s2) {        return s1.length() - s2.length();    }});</code></pre><p>但是注意，以这种方式使用匿名类时，将会在每次执行调用的时候创建一个新的实例。如果它被重复执行，考虑将函数对象存储到一个私有的静态 final 域时重复使用它。</p><h2 id="使用私有内部类"><a href="#使用私有内部类" class="headerlink" title="使用私有内部类"></a>使用私有内部类</h2><p>下面的例子使用静态成员类，而不是匿名类，这样允许我们的具体的策略类实现第二个接口 Serializable：</p><pre><code class="java">public class Outer {    private static class StrLenCmp implements Comparator&lt;String&gt;, Serializable {        public int compare(String s1, String s2) {            return s1.length() - s2.length();        }    }    public static final Comparator&lt;String&gt; STRING_LEN_CMP = new StrLenCmp();    //...}</code></pre><p>String 类利用这种模式，通过它的 CASE_INSENSITIVE_ORDER 域，实现了一个不区分大小写的字符串比较器。</p><pre><code class="java">public static final Comparator&lt;String&gt; CASE_INSENSITIVE_ORDER                                         = new CaseInsensitiveComparator();private static class CaseInsensitiveComparator        implements Comparator&lt;String&gt;, java.io.Serializable {    // use serialVersionUID from JDK 1.2.2 for interoperability    private static final long serialVersionUID = 8575799808933029326L;    public int compare(String s1, String s2) {        int n1 = s1.length();        int n2 = s2.length();        int min = Math.min(n1, n2);        for (int i = 0; i &lt; min; i++) {            char c1 = s1.charAt(i);            char c2 = s2.charAt(i);            if (c1 != c2) {                c1 = Character.toUpperCase(c1);                c2 = Character.toUpperCase(c2);                if (c1 != c2) {                    c1 = Character.toLowerCase(c1);                    c2 = Character.toLowerCase(c2);                    if (c1 != c2) {                        // No overflow because of numeric promotion                        return c1 - c2;                    }                }            }        }        return n1 - n2;    }    /** Replaces the de-serialized object. */    private Object readResolve() { return CASE_INSENSITIVE_ORDER; }}</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>简而言之，函数的主要用途就是实现策略模式。为了在 Java 中实现这种模式，要声明一个接口来表示该策略，并且为每个具体策略声明一个实现了该接口的策略类。</p><p>当一个具体策略只被使用一次时，通常使用匿名类来声明和实例化这个具体匿名策略类。</p><p>当一个具体策略是设计用来重复使用的时候，它的类通常要被实现为私有的静态成员类，并通过公有的静态 final 域被导出，其类型为该策略接口。</p><h1 id="第22条：优先考虑静态成员类（四种嵌套类中）"><a href="#第22条：优先考虑静态成员类（四种嵌套类中）" class="headerlink" title="第22条：优先考虑静态成员类（四种嵌套类中）"></a>第22条：优先考虑静态成员类（四种嵌套类中）</h1><p><strong>嵌套类</strong>（nested class）是指被定义在另一个类的内部的类。嵌套类存在的目的应该只是为了它的外围类提供服务。</p><h2 id="静态成员类"><a href="#静态成员类" class="headerlink" title="静态成员类"></a>静态成员类</h2><p>不称之为内部类（inner class）。可以看为普通的类，可以访问外围类的所有成员，和其他的静态成员一样，也遵循同样的可访问行规则（如果为私有，则只能在外围类的内部被访问）</p><p>如果嵌套类的实例可以在它外围类的实例之外独立存在，这个嵌套类就必须是静态成员类：在没有外围实例的情况下，要想创建非静态成员类的实例是不可能的。</p><h2 id="非静态成员类"><a href="#非静态成员类" class="headerlink" title="非静态成员类"></a>非静态成员类</h2><p>非静态成员类的实例都隐含持有一个外部类的实例（enclosing instance）</p><p>这不仅仅会消耗更多的空间，还可能会导致外部类的实例泄漏，内存泄漏，而静态成员类并不会。</p><h2 id="匿名类"><a href="#匿名类" class="headerlink" title="匿名类"></a>匿名类</h2><p>不能拥有任何静态成员，通常用于创建函数对象（见21条），比如 Thread，Runnable</p><h2 id="局部类"><a href="#局部类" class="headerlink" title="局部类"></a>局部类</h2><p>最少使用的类，在任何&quot;可以声明局部变量&quot;的地方，都可以声明局部类，并且局部类也遵守同样的作用域规则。</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>如果一个嵌套类需要在单个方法之外仍然是可见的，或者它太长了，不适合于放在方法内部，就该使用成员类。</p><p>如果成员类的每个实例都需要一个指向其外围实例的引用，就要把成员类做成非静态的，否则做成静态的。</p><p>假设这个嵌套类属于一个方法的内部，如果你只需要在一个地方创建实例，并且已经有了一个预置的类型接口可以说明这个类的特征，就要把它做成匿名类，否则，就做成局部类吧。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Effective Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Effective Java》笔记17：要么为继承而设计，并提供文档说明，要么就禁止继承</title>
      <link href="/2018/10/11/%E3%80%8AEffective%20Java%E3%80%8B%E7%AC%94%E8%AE%B017%EF%BC%9A%E8%A6%81%E4%B9%88%E4%B8%BA%E7%BB%A7%E6%89%BF%E8%80%8C%E8%AE%BE%E8%AE%A1%EF%BC%8C%E5%B9%B6%E6%8F%90%E4%BE%9B%E6%96%87%E6%A1%A3%E8%AF%B4%E6%98%8E%EF%BC%8C%E8%A6%81%E4%B9%88%E5%B0%B1%E7%A6%81%E6%AD%A2%E7%BB%A7%E6%89%BF/"/>
      <url>/2018/10/11/%E3%80%8AEffective%20Java%E3%80%8B%E7%AC%94%E8%AE%B017%EF%BC%9A%E8%A6%81%E4%B9%88%E4%B8%BA%E7%BB%A7%E6%89%BF%E8%80%8C%E8%AE%BE%E8%AE%A1%EF%BC%8C%E5%B9%B6%E6%8F%90%E4%BE%9B%E6%96%87%E6%A1%A3%E8%AF%B4%E6%98%8E%EF%BC%8C%E8%A6%81%E4%B9%88%E5%B0%B1%E7%A6%81%E6%AD%A2%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<p>所有为继承而设计的类都必须有文档来<strong>说明它可覆盖的方法的自用性</strong>。对于每个公有的或受保护的方法或者构造器，它的文档必须指明该方法或者构造器调用了哪些可覆盖的方法，是以什么顺序调用的，每个调用的结果以是如何影响后续的处理过程的。更一般地，类必须在文档中说明，在哪些情况下它会调用可覆盖方法。</p><p>类必须通过某种形式提供适当的钩子（hook），以便能够进行入到它的内部工作流程，这种形式可以是精心选择的受保护（protected）方法，也可以是受保护的域。例如， java.util.AbstractList 中的 protected void removeRange(int fromIndex, int toIndex) 方法。</p><a id="more"></a><h1 id="构造器决不能调用可被覆盖的方法"><a href="#构造器决不能调用可被覆盖的方法" class="headerlink" title="构造器决不能调用可被覆盖的方法"></a>构造器决不能调用可被覆盖的方法</h1><p>为了允许继承，类还必须遵守其他一些约束。<strong>构造器决不能调用可被覆盖的方法。</strong>因为超类的构造器在子类的构造器之前运行，所以，子类中覆盖版本的方法将会在子类的构造器运行之前就先被调用，如果该覆盖版本的方法依赖于子类构造器所执行的任何初始化工作，该方法将不会如预期般地执行。</p><p>由于超类的初始化早于子类的初始化，如果此时调用的方法被子类覆盖，而覆盖的方法中又引用了子类中的域字段，这将很容易导致 NullPointerException 异常被抛出，见下例：</p><pre><code class="java">public class SuperClass {    public SuperClass() {        overrideMe();    }    public void overrideMe() {    }}public final class SubClass extends SuperClass {    private final Date d;    SubClass() {        d = new Date();    }    @Override    public void overrideMe() {        System.out.println(dd.getDay());    }}public static void main(String[] args) {    SubClass sub = new SubClass();    sub.overrideMe();}</code></pre><h1 id="Cloneable-和-Serializable-接口"><a href="#Cloneable-和-Serializable-接口" class="headerlink" title="Cloneable 和 Serializable 接口"></a>Cloneable 和 Serializable 接口</h1><p>如果你决定在一个为了继承而设计的类中实现 Cloneable 或者 Serializable 接口，就应该意识到，因为 clone 和 readObject 方法在行为上非常类似于构造器，所以类似的限制规则也是适用的：<strong>无论是 clone 还是 readObject，都不可以调用可覆盖的方法。</strong>对于 readObject 方法，覆盖版本的方法将在子类的状态被反序列化前先被运行；而对于 clone 方法，覆盖版本的方法则在子类的 clone 方法调用来修正被克隆对象的状态之前先被运行（即父类的 clone 方法调用了覆盖的方法，而子类的 clone 却还没调用，这样就可能没有初始化这个覆盖方法所依赖的数据）。</p><p>如果你决定在一个为了继承而设计的类中实现 Serializable 接口，并且该类有一个 readResolve（Singleton 序列化时需要使用） 或者 writeReplace 方法，就必须使这两个方法成为被保护的方法，而不是私有的方法。</p><h1 id="禁止子类化"><a href="#禁止子类化" class="headerlink" title="禁止子类化"></a>禁止子类化</h1><p>对于普通的具体类应该怎么办?他们即不是 final 的，也不是为了子类化而设计和编写文档的，所以这种状况很危险。这个问题的最佳解决方案是，对于那些并不能安全进行子类化又没有编写文档的类，要禁止子类化。禁止子类化有两种方法，一种就是<strong>定义成 final 的</strong>，另一种就是<strong>私有构造器</strong>，交提供静态工厂方法，可参考第15条。</p><p>这条建议可能会引来争议，因为许多程序员已经习惯了对普通的具体类进行子类化，以便增加新的功能。如果这个普通类实现了某个接口，比如 Set、List 或者 Map，就完全可以禁止该普通类可子类化，因为即使禁止了，我们可以采第 16 条里的组合与转发即包装模式来提供一种更好的办法；如果具休的类并没有实现标准的接口，那么禁止继承可能会给有些程序员带来不便，如果认为必须允许从这样的类继承，一种合理的办法是确保这个类永远不会自己调用自已的任何可覆盖的方法，并在文档中说明这一点，换句话说，完全消除这个类中可覆盖方法的自用特性，这样做后就可以创建“能够安全地进行子类化”的类。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Effective Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python time 模块</title>
      <link href="/2018/10/11/Python%20time%20%E6%A8%A1%E5%9D%97/"/>
      <url>/2018/10/11/Python%20time%20%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<p><code>time</code> 模块暴露了底层 C 语言库中的时间相关函数。它包含了检索时钟时间（clock time）和处理器运行时间的函数，以及基本的解析工具和字符串格式化工具。</p><p><code>datetime</code> 模块为日期，时间，以及两者的结合提供了一个更高级的接口。datetime 中的类支持四则运算，大小比较，还有时区配置。</p><p><code>calendar</code> 模块创建了数周，数月，数年的的格式化表示。它也可以用来计算周期性的事件，计算给定日期是一周中的第几天，以及计算其他基于日历的值。</p><a id="more"></a><p>日期可以是实数（1970 年 1 月 1 日 0 点开始计算到现在的秒数），或者是包含有9的整数的<strong>元组</strong>。比如：<code>(2008, 1, 21, 12, 2, 56, 0, 21, 0)</code>，表示 2008 年 1 月 21 日 12 时 2 分 56 秒，星期一，并且是当年的第 21 天。</p><p>夏令时的数字是布尔值，如果使用了-1，mktime（将这样的元组转换为时间戳）就会工作正常。</p><h2 id="time-time"><a href="#time-time" class="headerlink" title="time.time()"></a>time.time()</h2><p>返回当前时间的秒数（以UTC为准），float 类型。</p><pre><code class="py">&gt;&gt;&gt; import time&gt;&gt;&gt; time.time()1539249629.6654336&gt;&gt;&gt; time.time_ns()  # 但返回当前时间的整数纳秒，New in version 3.7.1539250044424859600</code></pre><h2 id="time-struct-time-类型"><a href="#time-struct-time-类型" class="headerlink" title="time.struct_time 类型"></a>time.struct_time 类型</h2><p>time.struct_time 是 gmtime(), localtime(), strptime() 返回的时间值序列的类型。</p><p>它是一个具有命名元组接口的对象：可以通过索引和属性名访问值，存在如下索引和属性名：</p><table><thead><tr><th align="center">索引</th><th align="center">属性名</th><th align="center">字段</th><th align="center">值</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">tm_year</td><td align="center">年</td><td align="center">比如2001，2002等</td></tr><tr><td align="center">1</td><td align="center">tm_mon</td><td align="center">月</td><td align="center">1~12</td></tr><tr><td align="center">2</td><td align="center">tm_mday</td><td align="center">日</td><td align="center">1~31</td></tr><tr><td align="center">3</td><td align="center">tm_hour</td><td align="center">时</td><td align="center">0~23</td></tr><tr><td align="center">4</td><td align="center">tm_min</td><td align="center">分</td><td align="center">0~59</td></tr><tr><td align="center">5</td><td align="center">tm_sec</td><td align="center">秒</td><td align="center">0~61（闰秒，双闰秒）</td></tr><tr><td align="center">6</td><td align="center">tm_wday</td><td align="center">周</td><td align="center">周一为0，0~6，-1为一周中的某天，Python会自己计算</td></tr><tr><td align="center">7</td><td align="center">tm_yday</td><td align="center">儒历日（公历）</td><td align="center">1~366，-1为一年中的某天，Python会自己计算</td></tr><tr><td align="center">8</td><td align="center">tm_isdst</td><td align="center">夏令时（国内不使用）</td><td align="center">0，1，-1</td></tr><tr><td align="center">N/A</td><td align="center">tm_zone</td><td align="center">时区名称的缩写</td><td align="center">New in version 3.6</td></tr><tr><td align="center">N/A</td><td align="center">tm_gmtoff</td><td align="center">offset east of UTC in seconds</td><td align="center">New in version 3.6</td></tr></tbody></table><h2 id="time-time-与-time-struct-time-之间转换"><a href="#time-time-与-time-struct-time-之间转换" class="headerlink" title="time.time() 与 time.struct_time 之间转换"></a>time.time() 与 time.struct_time 之间转换</h2><p>time.gmtime() 函数返回 UTC （世界标准时间）中的当前时间。</p><p>time.gmtime() 和 calendar.timegm() 彼此相反</p><pre><code class="py">&gt;&gt;&gt; t = time.time()&gt;&gt;&gt; t1539251123.3449502&gt;&gt;&gt; time.gmtime(t)time.struct_time(tm_year=2018, tm_mon=10, tm_mday=11, tm_hour=9, tm_min=45, tm_sec=23, tm_wday=3, tm_yday=284, tm_isdst=0)&gt;&gt;&gt; import calendar&gt;&gt;&gt; t = time.time()&gt;&gt;&gt; calendar.timegm(time.gmtime(t))1547708725&gt;&gt;&gt; t1547708725.850669</code></pre><p>time.localtime() 函数返回的是与当前时区相对应的当前时间。</p><p>time.localtime() 和 time.mktime() 彼此相反</p><pre><code class="py">&gt;&gt;&gt; time.localtime()time.struct_time(tm_year=2018, tm_mon=10, tm_mday=11, tm_hour=17, tm_min=46, tm_sec=12, tm_wday=3, tm_yday=284, tm_isdst=0)&gt;&gt;&gt; time.localtime(1539251123.3449502)time.struct_time(tm_year=2018, tm_mon=10, tm_mday=11, tm_hour=17, tm_min=45, tm_sec=23, tm_wday=3, tm_yday=284, tm_isdst=0)&gt;&gt;&gt; time.mktime(time.localtime())1539251179.0&gt;&gt;&gt; time.mktime(time.gmtime(t))1539222323.0</code></pre><h2 id="时间元组与字符串之间转换"><a href="#时间元组与字符串之间转换" class="headerlink" title="时间元组与字符串之间转换"></a>时间元组与字符串之间转换</h2><p><code>time.asctime([tuple])</code> 函数，将时间元组转换为字符串</p><pre><code class="py">&gt;&gt;&gt; import time&gt;&gt;&gt; time.asctime()&#39;Sun Sep 25 13:56:57 2016&#39;&gt;&gt;&gt; time.asctime((2008, 1, 21, 12, 2, 56, 0, 21, 0))&#39;Mon Jan 21 12:02:56 2008&#39;</code></pre><p><code>time.strftime(format[, tuple])</code> 的使用格式为：</p><ul><li><code>%y</code> 两位数的年份表示（00-99）</li><li><code>%Y</code> 四位数的年份表示（000-9999）</li><li><code>%m</code> 月份（01-12）</li><li><code>%d</code> 月内中的一天（01-31）</li><li><code>%H</code> 24小时制小时数（0-23）</li><li><code>%I</code> 12小时制小时数（01-12）</li><li><code>%M</code> 分钟数（00=59）</li><li><code>%S</code> 秒（00-59）</li><li><code>%a</code> 本地简化星期名称</li><li><code>%A</code> 本地完整星期名称</li><li><code>%b</code> 本地简化的月份名称</li><li><code>%B</code> 本地完整的月份名称</li><li><code>%c</code> 本地相应的日期表示和时间表示</li><li><code>%j</code> 年内的一天（001-366）</li><li><code>%p</code> 本地A.M.或P.M.的等价符</li><li><code>%U</code> 一年中的星期数（00-53）星期天为星期的开始</li><li><code>%w</code> 星期（0-6），星期天为星期的开始</li><li><code>%W</code> 一年中的星期数（00-53）星期一为星期的开始</li><li><code>%x</code> 本地相应的日期表示</li><li><code>%X</code> 本地相应的时间表示</li><li><code>%Z</code> 当前时区的名称</li><li><code>%%</code> %号本身</li></ul><pre><code class="py">&gt;&gt;&gt; time.strftime(&#39;%y-%Y-%m-%d-%H-%I-%M-%S&#39;, (2008, 1, 21, 12, 2, 56, 0, 21, 0))&#39;08-2008-01-21-12-12-02-56&#39;&gt;&gt;&gt; time.strftime(&#39;%a-%A-%b-%B-%c-%j-%p-%U-%w-%W=%x-%X-%Z-%%&#39;, (2008, 1, 21, 12, 2, 56, 0, 21, 0))&#39;Mon-Monday-Jan-January-Mon Jan 21 12:02:56 2008-021-PM-03-1-03=01/21/08-12:02:56-中国标准时间-%&#39;&gt;&gt;&gt; time.strftime(&#39;%y-%Y-%m-%d-%H-%I-%M-%S&#39;)  # 默认使用 localtime() 返回的当前时间&#39;19-2019-01-17-16-04-19-44&#39;</code></pre><p><code>time.strptime(string[, format])</code> 函数，将 <code>asctime</code> 格式化过的字符串转换为日期元组（可选格式化参数和 <code>strftime</code> 的一样）</p><pre><code class="py">&gt;&gt;&gt; time.strptime(&#39;161010080808&#39;,&#39;%y%m%d%H%M%S&#39;)time.struct_time(tm_year=2016, tm_mon=10, tm_mday=10, tm_hour=8, tm_min=8, tm_sec=8, tm_wday=0, tm_yday=284, tm_isdst=-1)&gt;&gt;&gt; time.strptime(&#39;Sun Sep 25 13:56:57 2016&#39;)  # 默认使用 time.ctime() &quot;%a %b %d %H:%M:%S %Y&quot;time.struct_time(tm_year=2016, tm_mon=9, tm_mday=25, tm_hour=13, tm_min=56, tm_sec=57, tm_wday=6, tm_yday=269, tm_isdst=-1)&gt;&gt;&gt; time.ctime(1548566033)&#39;Sun Jan 27 13:13:53 2019&#39;</code></pre><h2 id="time-sleep-secs"><a href="#time-sleep-secs" class="headerlink" title="time.sleep(secs)"></a>time.sleep(secs)</h2><p><code>time.sleep(secs)</code> 函数，让解释器等待给定的时间。</p><h2 id="另请参阅"><a href="#另请参阅" class="headerlink" title="另请参阅"></a>另请参阅</h2><blockquote><p><a href="https://docs.python.org/3/library/time.html" target="_blank" rel="noopener">https://docs.python.org/3/library/time.html</a></p></blockquote><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="获取两个日期之间的所有日期的列表"><a href="#获取两个日期之间的所有日期的列表" class="headerlink" title="获取两个日期之间的所有日期的列表"></a>获取两个日期之间的所有日期的列表</h2><blockquote><p><a href="https://blog.csdn.net/zgljl2012/article/details/71636991" target="_blank" rel="noopener">https://blog.csdn.net/zgljl2012/article/details/71636991</a></p></blockquote><pre><code class="py">from datetime import datetime, timedeltadef gen_dates(b_date, days):    day = timedelta(days=1)    for i in range(days):        yield b_date + day * idef get_date_list(start=None, end=None):    &quot;&quot;&quot;    获取日期列表    :param start: 开始日期    :param end: 结束日期    :return:    &quot;&quot;&quot;    if start is None:        start = datetime.strptime(&quot;2019-01-01&quot;, &quot;%Y-%m-%d&quot;)    if end is None:        end = datetime.now()    data = []    for d in gen_dates(start, (end - start).days):        data.append(d)    return dataif __name__ == &quot;__main__&quot;:    print(get_date_list())&quot;&quot;&quot;[datetime.datetime(2019, 1, 1, 0, 0), datetime.datetime(2019, 1, 2, 0, 0), datetime.datetime(2019, 1, 3, 0, 0)]&quot;&quot;&quot;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python platform 模块查看系统版本信息</title>
      <link href="/2018/10/11/Python%20platform%20%E6%A8%A1%E5%9D%97%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E7%89%88%E6%9C%AC%E4%BF%A1%E6%81%AF/"/>
      <url>/2018/10/11/Python%20platform%20%E6%A8%A1%E5%9D%97%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E7%89%88%E6%9C%AC%E4%BF%A1%E6%81%AF/</url>
      
        <content type="html"><![CDATA[<p>Python 标准库 platform 模块。</p><pre><code class="py">import platform</code></pre><a id="more"></a><h1 id="Python-版本信息"><a href="#Python-版本信息" class="headerlink" title="Python 版本信息"></a>Python 版本信息</h1><pre><code class="py">&gt;&gt;&gt; platform.architecture()  # 查看 Python 是 32 位还是 64 位(&#39;64bit&#39;, &#39;WindowsPE&#39;)&gt;&gt;&gt; platform.python_build()  # Python 解释器构建的版本字符串(&#39;v3.6.6:4cf1f54eb7&#39;, &#39;Jun 27 2018 03:37:03&#39;)&gt;&gt;&gt; platform.python_compiler()  # 用于构建解释器的编译器&#39;MSC v.1900 64 bit (AMD64)&#39;&gt;&gt;&gt; platform.python_implementation()  # 返回标识Python实现的字符串。可能是：&#39;CPython&#39;, &#39;IronPython&#39;, &#39;Jython&#39;, &#39;PyPy&#39;&#39;CPython&#39;&gt;&gt;&gt; platform.python_version()  # 返回解释器版本&#39;3.6.6&#39;&gt;&gt;&gt; platform.python_version_tuple()  # 返回 tuple 形式的解释器版本(&#39;3&#39;, &#39;6&#39;, &#39;6&#39;)</code></pre><h1 id="硬件信息"><a href="#硬件信息" class="headerlink" title="硬件信息"></a>硬件信息</h1><pre><code class="py">&gt;&gt;&gt; platform.machine()  # 硬件类型标识符，例如 i386&#39;AMD64&#39;&gt;&gt;&gt; platform.node()  # 服务器的主机名，不完全合格的&#39;DESKTOP-K22Q7FD&#39;&gt;&gt;&gt; platform.processor()  # 处理器的真实标识符（Linux 下在很多情况下与 machine() 的值相同）&#39;Intel64 Family 6 Model 158 Stepping 9, GenuineIntel&#39;</code></pre><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><p><code>platform()</code> 函数返回一个包含通用平台标识符的字符串。 该函数接受两个可选的布尔参数。 如果 <code>aliased</code> 为 True ，则返回值中的名称将从正式名称转换为更常见的名称。 如果 <code>terse</code> 为 True ，则返回丢弃了某些部分的最小化值而不是完整字符串。</p><pre><code class="py">&gt;&gt;&gt; platform.platform()&#39;Windows-10-10.0.16299-SP0&#39;&gt;&gt;&gt; platform.platform(aliased=True)&#39;Windows-10-10.0.16299-SP0&#39;&gt;&gt;&gt; platform.platform(terse=True)&#39;Windows-10&#39;</code></pre><pre><code class="py">&gt;&gt;&gt; platform.release()  # 操作系统版本号&#39;10&#39;&gt;&gt;&gt; platform.version()  # 更详细的系统版本&#39;10.0.16299&#39;&gt;&gt;&gt; platform.system()  # 操作系统名称&#39;Windows&#39;&gt;&gt;&gt; platform.uname()  # 返回一个包含系统、节点、版本、版本、机器和处理器值的元组。uname_result(system=&#39;Windows&#39;, node=&#39;DESKTOP-K22Q7FD&#39;, release=&#39;10&#39;, version=&#39;10.0.16299&#39;, machine=&#39;AMD64&#39;, processor=&#39;Intel64 Family 6 Model 158 Stepping 9, GenuineIntel&#39;)</code></pre><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote><p><a href="https://docs.python.org/3/library/platform.html" target="_blank" rel="noopener">https://docs.python.org/3/library/platform.html</a><br><a href="https://pythoncaff.com/docs/pymotw/platform-system-version-information/199" target="_blank" rel="noopener">https://pythoncaff.com/docs/pymotw/platform-system-version-information/199</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Effective Java》笔记16：复合优先于继承</title>
      <link href="/2018/10/10/%E3%80%8AEffective%20Java%E3%80%8B%E7%AC%94%E8%AE%B016%EF%BC%9A%E5%A4%8D%E5%90%88%E4%BC%98%E5%85%88%E4%BA%8E%E7%BB%A7%E6%89%BF/"/>
      <url>/2018/10/10/%E3%80%8AEffective%20Java%E3%80%8B%E7%AC%94%E8%AE%B016%EF%BC%9A%E5%A4%8D%E5%90%88%E4%BC%98%E5%85%88%E4%BA%8E%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<p>继承是实现代码重用的有力手段，但它并非是最好的手段。</p><p>在包的内部使用继承是非常安全的，在那里，子类和超类的实现都处在同一个程序员的控制之下。对普通的具体类进行跨越包边界的继承，则是非常危险的，因为你一旦发布包之后，你就得要遵循你的接口，而不能轻易的去修改它而影响客户端已有的应用。</p><p>与方法调用不同的是，<strong>继承打破了封装性</strong>。换句话说，子类依赖于其超类中特定的功能的实现细节。超类的实现有可能会随着发行版本的不同而有所变化，如果真的发生了变化，子类可能会遭到破坏，即使它的代码完全没有改变。</p><p>这里的复合，可以理解为就是 Decorator 设计模式（<a href="/2018/07/08/《Head-First-设计模式》笔记3-装饰者模式/">装饰者模式</a>）</p><a id="more"></a><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>下面程序要使用 HashSet 功能，用来记录添加了多少个元素，直接采用了继承：</p><pre><code class="java">public class InstrumentedHashSet&lt;E&gt; extends HashSet&lt;E&gt; {    /*     * 用来记录添加了多少个元素，与 HashSet 的 size 是不一样的     * HashSet 的 size 会受到删除的影响，而这个只记录添加的元素个数     */    private int addCount = 0;    public InstrumentedHashSet() {}    @Override    //因为要记录我已放入的元素，所以重写了父类的方法    public boolean add(E e) {        addCount++;        return super.add(e);//最终还是调用 HashSet 的 add 方法将元素存入    }    /*     * super.addAll 是以调用 HashSet 的 add 方法来实现的，而 add 方法又被子类     * 重写了，所以该类的 add 方法也会被再次调用，即实质上调用 addAll     * 方法的时候，它也会去调用一下 add 方法，这在我们不调试的情况下     * 是很难发现的，这就是继承所带来的后果：因为我们依赖了父类的实现的细节。     */    @Override    public boolean addAll(Collection&lt;? extends E&gt; c) {        addCount += c.size();        return super.addAll(c);    }    public int getAddCount() {        return addCount;    }}</code></pre><p>我们只去掉被重写的 addAll 方法中的“addCount += c.size();”，就可以“修正”这个子类，但我们不能否认这样的实事：HashSet 的 addAll 方法是在它的 add 方法上实现的，<strong>这种“自用性（self-use）”是实现的细节，它不是承诺</strong>，所以不能保证在 Java 平台的所有实现中都保持不变，即不能保证随着发行版本的不同而不发生变化，这样得到的 InstrumentedHashSet 类将是非常脆弱的。</p><p>这里稍微好一点的做法是，在 InstrumentedHashSet 中重写 addAll 方法来遍历指定的集合，为每个元素调用一次 add 方法，这样做可以保证得到正确的结果 ，不管 HashSet 的 addAll 方法是否是以调用 add 方法来实现的，因为 HashSet 的 addAll 实现将不会再被调用。相当于重新实现了父类的方法，这种方法可能实现起来很麻烦。</p><p>导致子类脆弱的一个相关的原因就是，<strong>它们的超类在后续的版本中可能添加新的方法</strong>。假设我们的程序的有这样一个要求：所有被插入到某个集合中的元素都必须满足某个条件（比如上面在放入之前 addCount 会记录一下）。这样做是可以确保一点：对集合进行子类化，并覆盖所有能够添加元素的方法，以便确保在加入每个元素之前它是满足这个先决条件的。如果在后续的版本中，超类中没有增加能插入元素的新方法，这种做法是安全的。然而，一旦超类增加了这样的新方法，则很可能仅仅由于调用了这个未被覆盖的新的方法，而将“非法的”元素添加到子类的实例中。这不是纯粹的理念问题，在把 Hashtable 和 Vector 加入到集合框架中时，就修正了这几个类性质的安全漏洞。</p><p>上面的问题都是来源于覆盖动作。如果在继承一个类的时候，仅仅是添加新的方法，而没有覆盖现有的父类中的方法，你可能会认为是安全的，但是不然，比如你现在已继承了某个类，并扩展了父类，并添加了父类中没有方法，<strong>但是有可能将来父类也会添加同样签名的方法</strong>，但重写的条件不满足时，此时你设计的子类将不能编译，或者即使满足重写条件，这样又会有问题（如父类私有域状态的维护工作）。这样的问题不是不存在的，因为当你在编写子类方法时候，你肯定是不会知道将来父类会增加这样的名称的方法。</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>幸运的是，有一种办法可以避免前面提到的所有问题，不用继承现有类，<strong>而是在新的类中增加一个私有域，它引用现有类的一个实例</strong>。这种设计被称做为“复合”，因为现有类变成了新的类的一个组件。新类中的每个实例方法都可以调用被包含的现有类实例中对应的方法，并返回它的结果。这被称为“转发”，新类中的方法被称为转发方法。这样得到的类将会非常稳固，它不依赖于现有类的实现细节，即使现有的类添加了新的方法，也不会影响新的类。下面我们使用“复合”来修正前面的问题，注意这个实现分为两部分：类本身和可重用转发类，包含了所有的转发方法，没有其他方法。</p><pre><code class="java">public class ForwardingSet&lt;E&gt; implements Set&lt;E&gt; {    private final Set&lt;E&gt; s;//组合    public ForwardingSet(Set&lt;E&gt; s) { this.s = s; }    //下面全是转发方法(Set中的方法)    public void clear()               { s.clear();            }    public boolean contains(Object o) { return s.contains(o); }    // ...    //下面全是重写Object中的方法    @Override public boolean equals(Object o) { return s.equals(o);  }    @Override public int hashCode() { return s.hashCode(); }    @Override public String toString() { return s.toString(); }}public class InstrumentedSet&lt;E&gt; extends ForwardingSet&lt;E&gt; {    private int addCount = 0;    public InstrumentedSet(Set&lt;E&gt; s) {        super(s);    }    @Override    public boolean add(E e) {        addCount++;        return super.add(e);    }    @Override    public boolean addAll(Collection&lt;? extends E&gt; c) {        addCount += c.size();        return super.addAll(c);    }    public int getAddCount() {        return addCount;    }    public static void main(String[] args) {        // 包装        InstrumentedSet&lt;String&gt; s = new InstrumentedSet&lt;String&gt;(new HashSet&lt;String&gt;());        s.addAll(Arrays.asList(&quot;Snap&quot;, &quot;Crackle&quot;, &quot;Pop&quot;));        System.out.println(s.getAddCount());    }}</code></pre><p>Set 接口的存在使得 InstrumentedSet 类的设计成 Set 集合类成为可能，因为 Set 接口保存了 HashSet 类的功能特性，除了获得健壮性之外，这种设计也带来了格外灵活性。InstrumentedSet 类实现了 Set 接口，并且拥有单个构造器，它的参数也是 Set 类型，从本质上讲，这个类把一个 Set 转变成了另一个 Set，同时增加了计数器功能。</p><p>因为每一个 InstrumentedSet 实例都把另一个 Set 实例包装起来了，所以 InstrumentedSet 类被称做为<strong>包装类</strong>，这也正是 Decorator 装饰模式。InstrumentedSet 类对一个集合进行了装饰，为它增加了计数特性。有时，复合和转发的结合也被错误地称为“委托”，从技术的角度而言，这不是委托，除非包装对象（InstrumentedSet）把自身传递给被包装的对象（HashSet）。</p><p>包装类几乎没有缺点，但需要注意的一点是，包装类不适合用在回调框架中；在回调框架中，对象把自身的引用传递给其他的对象，所以它传递一个指向自身的引用（this），回调时避开了外面包装对象，这被称为 SELF 问题。</p><p>只有当子类真正是超类的子类型时，才适合用继承。换句话说，对于两个类 A 和 B，只有当两者之间确实存在“is-a”关系的时候，类B才应该扩展类 A。如果你打算让类 B 扩展类 A，就应该问问自己了：每个 B 确实也是 A 吗？如果不能确定，通常情况下，B 应该包含 A 的一个私有实例，并且暴露一个较小的、比较简单的 API：A 本质上不是 B 的一部分，只是它的实现细节而已。</p><p>在 Java 平台类库中，有许多明显违反这条原则的地方，例如，栈并不是向量，所以 Stack 不能继承 Vecotr；属性列表也不是散列，所以 Properties 不能继承 Hashtable，在这种情况下，复合模式才是恰当的。</p><p>如果在适合于使用组合的地方使用了继承，则会不必有地暴露实现细节（如暴露不必要的接口导致外界调用这些接口来非法改变实例的状态）。这样得到的 API 会把你限制在原始的实现上，永远限定了类的性能，更为严重的是，由于暴露了内部的细节或不必要的接口，客户端就有可能直接访问这些内部细节，从而破坏实现的内部状态。</p><p>继承机制会把超 API 中的所有缺陷传播到子类中，而复合则允许设计新的 API 来隐藏这些缺陷。</p><p>简而言之，继承的功能非常强大，但是也存在诸多的问题，因为它违背了封装的原则。只有当子类和超类之间确实存在子类型关系时，使用继承才是恰当的。即使如此，如果子类和超类外在不同的包中，并且超类并不是为了继承而设计的，那么继承将会脆弱性，为了避免这种脆弱性，可以用复合和转发机制来代替继承，尤其是当存在适当的接口可以实现包装类的时候。包装类不仅比子类更加健壮，而且功能也更加强大。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Effective Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python OS 模块文件目录常见操作</title>
      <link href="/2018/09/30/Python%20OS%20%E6%A8%A1%E5%9D%97%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/"/>
      <url>/2018/09/30/Python%20OS%20%E6%A8%A1%E5%9D%97%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="找到目录下最新的文件"><a href="#找到目录下最新的文件" class="headerlink" title="找到目录下最新的文件"></a>找到目录下最新的文件</h1><blockquote><p><a href="https://blog.csdn.net/liudinglong1989/article/details/78731754" target="_blank" rel="noopener">https://blog.csdn.net/liudinglong1989/article/details/78731754</a></p></blockquote><h2 id="方法一：找到最新的文件或文件夹"><a href="#方法一：找到最新的文件或文件夹" class="headerlink" title="方法一：找到最新的文件或文件夹"></a>方法一：找到最新的文件或文件夹</h2><pre><code class="py">def last_modify_file(path):    # 列出目录下所有的文件    file_list = os.listdir(path)    # 对文件修改时间进行升序排列    file_list.sort(key=lambda fn: os.path.getmtime(path + &#39;\\&#39; + fn))    # 获取最新修改时间的文件    filetime = datetime.datetime.fromtimestamp(os.path.getmtime(path + file_list[-1]))    # 获取文件所在目录    file_path = os.path.join(path, file_list[-1])    print(&quot;最新修改的文件(夹)：&quot; + file_list[-1])    print(&quot;时间：&quot; + filetime.strftime(&#39;%Y-%m-%d %H-%M-%S&#39;))    return file_path# 返回最新文件或文件夹名：print(last_modify_file(&quot;./&quot;))&#39;&#39;&#39;key=lambda fn: os.path.getmtime(path + &#39;\\&#39; + fn)类似于函数：def key(fn):    return os.path.getmtime(path + &#39;\\&#39; + fn)&#39;&#39;&#39;</code></pre><a id="more"></a><h2 id="方法二：找到最新的文件"><a href="#方法二：找到最新的文件" class="headerlink" title="方法二：找到最新的文件"></a>方法二：找到最新的文件</h2><pre><code class="py">file_dir = &quot;./&quot;file_list = os.listdir(file_dir)file_list.sort(key=lambda fn: os.path.getmtime(file_dir + fn) if not os.path.isdir(file_dir + fn) else 0)&#39;&#39;&#39;key=lambda fn: os.path.getmtime(file_dir + fn) if not os.path.isdir(file_dir + fn) else 0类似于函数：def mykey(fn):    if not os.path.isdir(file_dir + fn):        return os.path.getmtime(file_dir + fn)    else:        return 0file_list.sort(key=mykey)&#39;&#39;&#39;# 获取文件时间d = datetime.datetime.fromtimestamp(os.path.getmtime(file_dir + file_list[-1]))print(&#39;最后改动的文件是&#39; + file_list[-1] + &quot;，时间：&quot; + d.strftime(&quot;%Y-%m-%d %H-%M-%S&quot;))</code></pre><h1 id="递归遍历目录下所有文件"><a href="#递归遍历目录下所有文件" class="headerlink" title="递归遍历目录下所有文件"></a>递归遍历目录下所有文件</h1><blockquote><p><a href="https://www.cnblogs.com/dreamer-fish/p/3820625.html" target="_blank" rel="noopener">https://www.cnblogs.com/dreamer-fish/p/3820625.html</a></p></blockquote><h2 id="方法一：os-listdir"><a href="#方法一：os-listdir" class="headerlink" title="方法一：os.listdir"></a>方法一：os.listdir</h2><pre><code class="py">def gci(filepath):    # 遍历filepath下所有文件，包括子目录    files = os.listdir(filepath)    for fi in files:        fi_d = os.path.join(filepath, fi)        if os.path.isdir(fi_d):            gci(fi_d)        else:            print(os.path.join(filepath, os.path.basename(fi_d)))  # 不加 os.path.basename 的话，在传递相对路径时有错误# 递归遍历目录下所有文件gci(&#39;.&#39; + os.sep)</code></pre><h2 id="方法二：os-walk"><a href="#方法二：os-walk" class="headerlink" title="方法二：os.walk"></a>方法二：os.walk</h2><pre><code class="py">for fpathe, dirs, fs in os.walk(&#39;.&#39; + os.sep):    for f in fs:        print (os.path.join(fpathe, f))</code></pre><p>使用os.walk方法遍历：</p><pre><code class="py">import ospath=&quot;D:\\Temp_del\\a&quot;for i in os.walk(path):    print(i)# 返回结果：(&#39;D:\\Temp_del\\a&#39;, [&#39;AFA&#39;, &#39;x64&#39;], [&#39;AudioFilterAgent.INI&#39;, &#39;Setup.exe&#39;])(&#39;D:\\Temp_del\\a\\AFA&#39;, [&#39;222&#39;], [&#39;CAudioFilterAgent.exe&#39;, &#39;CAudioFilterAgent64.exe&#39;])(&#39;D:\\Temp_del\\a\\AFA\\222&#39;, [], [&#39;新建日记本文档 - 副本.jnt&#39;, &#39;新建日记本文档.jnt&#39;])(&#39;D:\\Temp_del\\a\\x64&#39;, [&#39;bbb&#39;], [&#39;AudioFilterAgent.INI&#39;, &#39;setup64.exe&#39;])(&#39;D:\\Temp_del\\a\\x64\\bbb&#39;, [], [&#39;CAudioFilterAgent.exe&#39;, &#39;CAudioFilterAgent64.exe&#39;])</code></pre><p>返回结果说明：</p><ol><li>返回的是一个三元 <code>tupple(dirpath, dirnames, filenames)</code></li><li>其中第一个为起始路径，第二个为起始路径下的文件夹，第三个是起始路径下的文件</li><li><code>dirpath</code> 是一个 string，代表目录的路径</li><li><code>dirnames</code> 是一个 list，包含了 dirpath 下所有子目录的名字</li><li><code>filenames</code> 是一个 list，包含了非目录文件的名字.这些名字不包含路径信息,如果需要得到全路径,需要使用 <code>os.path.join(dirpath, name)</code></li></ol><h1 id="列出所有-py-文件"><a href="#列出所有-py-文件" class="headerlink" title="列出所有 .py 文件"></a>列出所有 .py 文件</h1><h2 id="os-path-splitext-path"><a href="#os-path-splitext-path" class="headerlink" title="os.path.splitext(path)"></a>os.path.splitext(path)</h2><pre><code class="py">[i for i in os.listdir(&#39;.&#39;) if os.path.isfile(i) and os.path.splitext(i)[1] == &#39;.py&#39;]</code></pre><p>分隔文件路径和后缀名</p><pre><code class="py">&gt;&gt;&gt; os.path.splitext(&#39;Test.py&#39;)(&#39;Test&#39;, &#39;.py&#39;)&gt;&gt;&gt; os.path.splitext(&#39;Test&#39;)  # 不含后缀名(&#39;Test&#39;, &#39;&#39;)</code></pre><h2 id="glob"><a href="#glob" class="headerlink" title="glob"></a>glob</h2><blockquote><p><a href="https://blog.csdn.net/hjxu2016/article/details/79455315" target="_blank" rel="noopener">https://blog.csdn.net/hjxu2016/article/details/79455315</a></p></blockquote><p>glob 模块是最简单的模块之一，内容非常少。用它可以查找符合特定规则的文件路径名。跟使用 windows 下的文件搜索差不多。</p><p>查找文件只用到三个匹配符：<code>*</code>, <code>?</code>, <code>[]</code>。<code>*</code> 匹配 0 个或多个字符；<code>?</code> 匹配单个字符；<code>[]</code> 匹配指定范围内的字符，如：[0-9] 匹配数字。</p><pre><code class="py">import globWSI_MASK_PATH = &#39;/home/jpg/&#39;  # 存放图片的文件夹路径wsi_mask_paths = glob.glob(os.path.join(WSI_MASK_PATH, &#39;*.py&#39;))wsi_mask_paths.sort()# [&#39;F:\\python\\JTest.py&#39;, &#39;F:\\python\\__init__.py&#39;, &#39;F:\\python\\lcheck.py&#39;, &#39;F:\\python\\t.py&#39;, &#39;F:\\python\\tTest.py&#39;]</code></pre><h1 id="截取路径中的文件名"><a href="#截取路径中的文件名" class="headerlink" title="截取路径中的文件名"></a>截取路径中的文件名</h1><blockquote><p><a href="https://blog.csdn.net/igolang/article/details/8021258" target="_blank" rel="noopener">https://blog.csdn.net/igolang/article/details/8021258</a></p></blockquote><p>假设有一个文件的路径名为：“K:\Project\FilterDriver\DriverCodes\hello.txt”，而且路径和文件名都不是固定的。如何得到 hello.txt 这段字符串呢？</p><h2 id="字符串分割-split-函数"><a href="#字符串分割-split-函数" class="headerlink" title="字符串分割 split() 函数"></a>字符串分割 split() 函数</h2><pre><code class="py">path=&quot;K:/Project/FilterDriver/DriverCodes/hello.txt&quot;print (path.split(&quot;/&quot;)[-1])</code></pre><p>执行结果：hello.txt。</p><h2 id="使用-basename-函数"><a href="#使用-basename-函数" class="headerlink" title="使用 basename() 函数"></a>使用 basename() 函数</h2><pre><code class="py">import os.pathfilePath = &quot;K:/Project/FilterDriver/DriverCodes/hello.txt&quot;print (os.path.basename(filePath))</code></pre><p>执行的结果仍然是 hello.txt。</p><h1 id="简单实现同步文件夹操作"><a href="#简单实现同步文件夹操作" class="headerlink" title="简单实现同步文件夹操作"></a>简单实现同步文件夹操作</h1><pre><code class="py">def synDir(from_dir, to_dir):    &quot;&quot;&quot;    同步文件夹 from_dir 下的内容到文件夹 to_dir 下    &quot;&quot;&quot;    if not os.path.exists(to_dir):        os.makedirs(to_dir)    for filename in os.listdir(from_dir):        fromfile = os.path.join(from_dir, filename)        tofile = os.path.join(to_dir, filename)        if os.path.isdir(fromfile):            synDir(fromfile, tofile)        else:            if not os.path.exists(tofile):                shutil.copy2(fromfile, tofile)                continue            if os.path.getsize(fromfile) != os.path.getsize(tofile):                shutil.copy2(fromfile, tofile)</code></pre><h1 id="OS-模块"><a href="#OS-模块" class="headerlink" title="OS 模块"></a>OS 模块</h1><blockquote><p><a href="https://my.oschina.net/cuffica/blog/33579" target="_blank" rel="noopener">https://my.oschina.net/cuffica/blog/33579</a><br><a href="http://www.runoob.com/python3/python3-os-file-methods.html" target="_blank" rel="noopener">http://www.runoob.com/python3/python3-os-file-methods.html</a></p></blockquote><ul><li>os.getcwd() # 获取当前工作目录，即当前 python 脚本工作的目录路径</li><li>os.chdir(&quot;dirname&quot;) # 改变当前脚本工作目录到dirname</li><li>os.curdir # 返回当前目录: (&#39;.&#39;)</li></ul><pre><code class="py">import osos.getcwd()   #输出&#39;/Volumes/Leopard/Users/Caroline&#39;os.chdir(&#39;/Volumes&#39;)os.getcwd()   #输出&#39;/Volumes&#39;os.curdir     #输出&quot;.&quot;</code></pre><ul><li>os.makedirs() # 可生成多层递归目录</li><li>os.removedirs() # 可删除多层递归空目录，若目录不为空则无法删除</li><li>os.mkdir() # 生成单级目录</li><li>os.rmdir() # 删除单级空目录，若目录不为空则无法删除，报错</li><li>os.pardir() # 获取当前目录的父目录字符串名</li><li>os.listdir() # 列出指定目录下的所有文件和子目录，包括隐藏文件</li><li>os.remove() # 删除一个文件</li><li>os.unlink()  # 同 os.remove()</li><li>os.rename(&quot;oldname&quot;,&quot;newname&quot;) # 重命名文件</li><li>os.sep # 输出操作系统特定的路径分隔符。win下为&quot;\&quot;,macx下为&quot;/&quot;</li><li>os.linesep # 输出当前平台使用的行终止符</li><li>os.pathsep # 输出用于分割文件路径的字符串</li><li>os.name # 输出字符串指示当前使用平台。win-&gt;&#39;nt&#39;; mac-&gt;&#39;posix&#39;</li><li>os.environ # 获取系统环境变量</li></ul><pre><code class="py">import osos.sep     # 路径名中的分隔符，Linux：&quot;/&quot;，Windows：&quot;\&quot;os.altsep  # 可选的路径分隔符，Windows：&quot;/&quot;，Linux 无结果os.linesep  # 文本文件字符串分隔符，&quot;\n&quot;，&quot;\r\n&quot;os.pathsep  # Linux 输出&quot;:&quot;，Windows 下 &quot;;&quot;os.environ    # 输出{&#39;LANG&#39;: &#39;en_US.UTF-8&#39;, &#39;TERM&#39;: &#39;xterm-color&#39;, &#39;Apple_PubSub_Socket_Render&#39;: &#39;/tmp/launch-cQd0wl/Render&#39;, &#39;VERSIONER_PYTHON_PREFER_32_BIT&#39;: &#39;no&#39;, &#39;VERSIONER_PYTHON_VERSION&#39;: &#39;2.6&#39;, &#39;SHLVL&#39;: &#39;1&#39;, &#39;SSH_AUTH_SOCK&#39;: &#39;/tmp/launch-Wd5ZJI/Listeners&#39;, &#39;TERM_PROGRAM_VERSION&#39;: &#39;273&#39;, &#39;__CF_USER_TEXT_ENCODING&#39;: &#39;0x1F5:0:0&#39;, &#39;PWD&#39;: &#39;/Volumes/Leopard/Users/Caroline&#39;, &#39;SHELL&#39;: &#39;/bin/bash&#39;, &#39;LOGNAME&#39;: &#39;Caroline&#39;, &#39;USER&#39;: &#39;Caroline&#39;, &#39;HOME&#39;: &#39;/Volumes/Leopard/Users/Caroline&#39;, &#39;PATH&#39;: &#39;/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/usr/X11/bin&#39;, &#39;COMMAND_MODE&#39;: &#39;unix2003&#39;, &#39;_&#39;: &#39;/usr/bin/python&#39;, &#39;DISPLAY&#39;: &#39;/tmp/launch-VIFSmk/org.x:0&#39;, &#39;TMPDIR&#39;: &#39;/var/folders/Iy/IyQx9l7EHD0y+Z77k20XCU+++TI/-Tmp-/&#39;, &#39;TERM_PROGRAM&#39;: &#39;Apple_Terminal&#39;}os.environ.get(&#39;LOGNAME&#39;) # 输出&#39;Caroline&#39;</code></pre><ul><li>os.system(command) # 运行 shell 命令</li></ul><pre><code class="py"># 打开一个浏览器&gt;&gt;&gt; os.system(r&#39;&quot;C:\Program Files (x86)\Google\chrome.exe&quot;&#39;) # 注意引号&quot;&quot;0# windows下特有函数os.startfile(r&#39;&quot;C:\Program Files (x86)\Google\Chrome\Application\chrome.exe&quot;&#39;)# 更好的解决方案&gt;&gt;&gt; import webbrowser&gt;&gt;&gt; webbrowser.open(&#39;http://baidu.com&#39;)True</code></pre><ul><li><p>os.symlink(src, dst)  # 创建一个软链接 <code>os.symlink(&#39;D:\\src&#39;, &#39;D:\\symlink&#39;)</code>，需要管理员权限</p></li><li><p>os.link(src, dst)  # 创建硬链接 <code>os.link(&#39;D:\\a.jpg&#39;, &#39;D:\\link.jpg&#39;)</code></p></li><li><p>os.utime()  # 方法用于设置指定路径文件最后的修改和访问时间。<code>os.utime(&#39;D:\\aaa.jpg&#39;, (1330712280, 1330712292))</code></p></li></ul><h1 id="os-stat-path-dir-fd-None-follow-symlinks-True"><a href="#os-stat-path-dir-fd-None-follow-symlinks-True" class="headerlink" title="os.stat(path, *, dir_fd=None, follow_symlinks=True)"></a>os.stat(path, *, dir_fd=None, follow_symlinks=True)</h1><p>获取文件或文件描述符的状态。返回一个 stat_result 对象。</p><pre><code class="py">&gt;&gt;&gt; import os&gt;&gt;&gt; statinfo = os.stat(&#39;somefile.txt&#39;)&gt;&gt;&gt; statinfoos.stat_result(st_mode=33206, st_ino=10414574138694179, st_dev=504226, st_nlink=1, st_uid=0, st_gid=0, st_size=310, st_atime=1548311651, st_mtime=1548311651, st_ctime=1548311651)&gt;&gt;&gt; statinfo.st_size310</code></pre><p>class <strong>os.stat_result</strong></p><p>对象的属性大致对应于 stat 结构的成员。它用于 os.stat()，os.fstat() 和 os.lstat() 的结果。</p><ul><li>st_size：文件大小（以字节为单位），如果是常规文件或符号链接。符号链接的大小是它所包含的路径名的长度，而不是终止的空字节。</li><li>st_atime：最近访问的时间以秒表示。</li><li>st_mtime：最近的内容修改时间以秒表示。</li><li>st_ctime：取决于平台：Unix 上最新的元数据更改时间，在 Windows 上创建的时间，以秒表示。</li></ul><h1 id="os-path-常见的路径名操作"><a href="#os-path-常见的路径名操作" class="headerlink" title="os.path 常见的路径名操作"></a>os.path 常见的路径名操作</h1><blockquote><p><a href="https://docs.python.org/3/library/os.path.html" target="_blank" rel="noopener">https://docs.python.org/3/library/os.path.html</a></p></blockquote><ul><li><p>os.path.abspath(path)  # 返回 path 规范化的绝对路径。</p></li><li><p>os.path.basename(path)  # 返回路径名路径的基本名称，&#39;D:\test.txt&#39;，返回：&#39;test.txt&#39;</p></li><li><p>os.path.commonpath(paths)  # 获取共同路径</p></li><li><p>os.path.commonprefix(list)  # 返回列表中所有路径的前缀的最长路径前缀</p></li></ul><pre><code class="py"># 上面两个函数的区别&gt;&gt;&gt; os.path.commonprefix([&#39;/usr/lib&#39;, &#39;/usr/local/lib&#39;])&#39;/usr/l&#39;&gt;&gt;&gt; os.path.commonpath([&#39;/usr/lib&#39;, &#39;/usr/local/lib&#39;])&#39;/usr&#39;</code></pre><ul><li>os.path.dirname(path)  # 获取文件夹名，和 os.path.basename(path) 相反，&#39;D:\test.txt&#39;，&#39;D:\&#39;</li><li>os.path.exists(path)  # 判断路径或文件是否存在</li></ul><h2 id="获取文件相关信息"><a href="#获取文件相关信息" class="headerlink" title="获取文件相关信息"></a>获取文件相关信息</h2><ul><li>os.path.getatime(path)  # 最后访问时间，等同于 os.stat(path).st_atime</li><li>os.path.getmtime(path)  # 最后修改时间，等同于 os.stat(path).st_mtime</li><li>os.path.getctime(path)  # 取决于平台：Unix上最新的元数据更改时间，在Windows上创建的时间，以秒表示。，等同于 os.stat(path).st_ctime</li><li>os.path.getsize(path)  # 文件大小（字节），等同于 os.stat(path).st_size</li></ul><h2 id="对于路径的判断"><a href="#对于路径的判断" class="headerlink" title="对于路径的判断"></a>对于路径的判断</h2><ul><li>os.path.isabs(path)  # 是否为绝对路径</li><li>os.path.isfile(path)  # 是否文件</li><li>os.path.isdir(path)  # 是否文件夹</li><li>os.path.islink(path)  # 如果 path 引用作为符号链接的现有目录条目（软连接），则返回 True。如果 Python 运行时不支持符号链接，则始终为 False。</li><li>os.path.ismount(path)  # 如果路径名路径是装入点（挂载），则返回 True。</li><li>os.path.samefile(path1, path2)  # 如果两个路径名参数都引用相同的文件或目录，则返回 True。</li></ul><h1 id="范化路径名"><a href="#范化路径名" class="headerlink" title="范化路径名"></a>范化路径名</h1><ul><li>os.path.join(path, *paths)</li><li>os.path.normcase(path)  # 规范化路径名的大小写。在 Unix 和 Mac OS X 上，这将返回路径不变;在 Windows 上，它还将正斜杠转换为反斜杠。</li><li>os.path.normpath(path)  # 通过折叠冗余分隔符和上级引用来规范化路径名，<code>A//B</code>, <code>A/B/</code>, <code>A/./B</code>, <code>A/foo/../B</code> 都变为 <code>A/B</code>。</li></ul><h1 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径"></a>相对路径</h1><ul><li>os.path.relpath(path, start=os.curdir)  # 如何从 start 到达 path</li></ul><h1 id="路径分隔"><a href="#路径分隔" class="headerlink" title="路径分隔"></a>路径分隔</h1><p>os.path.split(path)   #从文件与文件夹分隔<br>os.path.splitdrive(path)  #从卷分隔<br>os.path.splitext(path)   #将文件后缀分隔</p><pre><code class="py">&gt;&gt;&gt; os.path.split(r&#39;D:\test\data\1 (1).jpg&#39;)(&#39;D:\\test\\data\&#39;, &#39;1 (1).jpg&#39;)&gt;&gt;&gt; os.path.splitdrive(r&#39;D:\test\data\1 (1).jpg&#39;)(&#39;D:&#39;, &#39;\\test\\data\\\1 (1).jpg&#39;)&gt;&gt;&gt; os.path.splitext(r&#39;D:\test\data\1 (1).jpg&#39;)(&#39;D:\\test\\data\\\1 (1)&#39;, &#39;.jpg&#39;)# linux 下# e.g. splitdrive(&quot;//host/computer/dir&quot;) returns (&quot;//host/computer&quot;, &quot;/dir&quot;)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 中 ctypes 的使用</title>
      <link href="/2018/09/28/Python%20%E4%B8%AD%20ctypes%20%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/09/28/Python%20%E4%B8%AD%20ctypes%20%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>文档：<a href="https://docs.python.org/3/library/ctypes.html" target="_blank" rel="noopener">https://docs.python.org/3/library/ctypes.html</a></p><p>Python 的 ctypes 要使用 C 函数，需要先将 C 编译成动态链接库的形式，即 Windows 下的 .dll 文件，或者 Linux 下的 .so 文件。先来看一下 ctypes 怎么使用 C 标准库。</p><p>Windows 系统下的 C 标准库动态链接文件为 msvcrt.dll (一般在目录 C:\Windows\System32 和 C:\Windows\SysWOW64 下分别对应 32-bit 和 64-bit，使用时不用刻意区分，Python 会选择合适的)</p><p>Linux 系统下的 C 标准库动态链接文件为 libc.so.6 (以 64-bit Ubuntu 系统为例， 在目录 /lib/x86_64-linux-gnu 下)</p><p>例如，以下代码片段导入 C 标准库，并使用 printf 函数打印一条消息，</p><pre><code class="py">import platformfrom ctypes import *# 导入 dll 文件的多种方式if platform.system() == &#39;Windows&#39;:    libc = cdll.LoadLibrary(&#39;msvcrt.dll&#39;)    #libc = windll.LoadLibrary(&#39;msvcrt.dll&#39;)  # Windows only    #libc = oledll.LoadLibrary(&#39;msvcrt.dll&#39;)  # Windows only    #libc = pydll.LoadLibrary(&#39;msvcrt.dll&#39;)    #libc = CDLL(&#39;msvcrt.dll&#39;)    #libc = WinDLL(&#39;msvcrt.dll&#39;)  # Windows only    #libc = OleDLL(&#39;msvcrt.dll&#39;)  # Windows only    #libc = PyDLL(&#39;msvcrt.dll&#39;)elif platform.system() ==&#39;Linux&#39;:    libc = cdll.LoadLibrary(&#39;libc.so.6&#39;)    #libc = pydll.LoadLibrary(&#39;libc.so.6&#39;)    #libc = CDLL(&#39;libc.so.6&#39;)    #libc = PyDLL(&#39;libc.so.6&#39;)libc.printf(&#39;Hello ctypes!\n&#39;)</code></pre><a id="more"></a><h1 id="ctypes-数据类型"><a href="#ctypes-数据类型" class="headerlink" title="ctypes 数据类型"></a>ctypes 数据类型</h1><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20181002142600.png" alt="ctypes 数据类型"></p><h1 id="定义结构体，调用-C-函数"><a href="#定义结构体，调用-C-函数" class="headerlink" title="定义结构体，调用 C 函数"></a>定义结构体，调用 C 函数</h1><pre><code class="py">class POINT_struct(Structure):    _fields_ = [(&#39;x&#39;, c_long), (&#39;y&#39;, c_long), (&#39;info&#39;, c_char*512), (&#39;Data&#39;, c_ubyte*2560)]</code></pre><p>这里使用 c_ubyte 类型，是因为使用 c_char 类似，将该结构体中的值赋给另一个结构体时，碰见 0 会停止，导致数据不完整。赋值时可以使用 <code>memmove(pStruct.Data, pData, 2560)</code>。</p><pre><code class="py">function = dll.function  # 要调用 C 的函数function.restype = c_int  # C 函数的返回值function.argtypes = (c_short, c_char_p, c_uint, c_int, c_void_p, c_void_p, c_void_p)  # C 函数参数p_struct = POINT_struct()p_struct.x = c_long(0)p_struct.y = c_long(0)res = function(byref(p_struct))  # 调用 C 的函数</code></pre><h1 id="调用-C-函数接口的字符串类型错误"><a href="#调用-C-函数接口的字符串类型错误" class="headerlink" title="调用 C 函数接口的字符串类型错误"></a>调用 C 函数接口的字符串类型错误</h1><blockquote><p><a href="https://blog.csdn.net/yuanlulu/article/details/79877305" target="_blank" rel="noopener">https://blog.csdn.net/yuanlulu/article/details/79877305</a></p></blockquote><p>python2 的源码直接在 python3.5 运行（出错）：</p><pre><code class="py">net = dn.load_net(&quot;cfg/yolov3.cfg&quot;, &quot;weights/yolov3.weights&quot;, 0)ctypes.ArgumentError: argument 1: &lt;class &#39;TypeError&#39;&gt;: wrong type</code></pre><p>使用类型转换（出错）：</p><pre><code class="py">net = dn.load_net(c_char_p(&quot;cfg/yolo.cfg&quot;), c_char_p(&quot;weights/yolov3.weights&quot;), c_int(0))TypeError: bytes or integer address expected instead of str instance</code></pre><p>utf8 转换（OK 了）：</p><pre><code class="py">net = dn.load_net(&quot;cfg/yolov3.cfg&quot;.encode(&quot;utf-8&quot;), &quot;weights/yolov3.weights&quot;.encode(&quot;utf-8&quot;), 0)</code></pre><h1 id="注册成-C-的回调函数"><a href="#注册成-C-的回调函数" class="headerlink" title="注册成 C 的回调函数"></a>注册成 C 的回调函数</h1><p>见：<a href="/2018/09/26/Python%20调用海康%20SDK/#设置报警回调函数">Python 调用海康 SDK</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote><p><a href="https://www.cnblogs.com/gaowengang/p/7919219.html" target="_blank" rel="noopener">https://www.cnblogs.com/gaowengang/p/7919219.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 调用海康 SDK</title>
      <link href="/2018/09/26/Python%20%E8%B0%83%E7%94%A8%E6%B5%B7%E5%BA%B7%20SDK/"/>
      <url>/2018/09/26/Python%20%E8%B0%83%E7%94%A8%E6%B5%B7%E5%BA%B7%20SDK/</url>
      
        <content type="html"><![CDATA[<p>海康 SDK 下载：<a href="https://www.hikvision.com/cn/download_61.html" target="_blank" rel="noopener">https://www.hikvision.com/cn/download_61.html</a></p><a id="more"></a><h1 id="调用-SDK，及导包"><a href="#调用-SDK，及导包" class="headerlink" title="调用 SDK，及导包"></a>调用 SDK，及导包</h1><pre><code class="py">import loggingimport sysimport threadingimport osfrom ctypes import *import datetimeimport timetemp_dir = &quot;temp_dir&quot;)path = &quot;HKLib/win64/&quot;so_list = []# 获取所有的库文件到一个列表def add_so(path, so_list):    files = os.listdir(path)    for file in files:        if not os.path.isdir(path + file):            if file.endswith(&quot;.dll&quot;):                so_list.append(path + file)        else:            add_so(path + file + &quot;/&quot;, so_list)add_so(path, so_list)# lUserID = 0  # 用户ID具有唯一性，后续对设备的操作都需要通过此ID实现。如果只连接一个摄像头可以写这里# m_lAlarmHandle = 0# 执行 dll 方法def callCpp(func_name, *args):    for so_lib in so_list:        try:            lib = cdll.LoadLibrary(so_lib)            try:                value = eval(&quot;lib.%s&quot; % func_name)(*args)                logging.info(&quot;调用的库：&quot; + so_lib)                logging.info(&quot;执行成功,返回值：&quot; + str(value))                return value            except:                continue        except:            logging.info(&quot;库文件载入失败：&quot; + so_lib)            continue    logging.error(&quot;没有找到接口！&quot;)    return False</code></pre><h1 id="定义结构体"><a href="#定义结构体" class="headerlink" title="定义结构体"></a>定义结构体</h1><pre><code class="py"># 设备参数结构体。class LPNET_DVR_DEVICEINFO_V30(Structure):    _fields_ = [        (&quot;sSerialNumber&quot;, c_byte * 48),        (&quot;byAlarmInPortNum&quot;, c_byte),        (&quot;byAlarmOutPortNum&quot;, c_byte),        (&quot;byDiskNum&quot;, c_byte),        (&quot;byDVRType&quot;, c_byte),        (&quot;byChanNum&quot;, c_byte),        (&quot;byStartChan&quot;, c_byte),        (&quot;byAudioChanNum&quot;, c_byte),        (&quot;byIPChanNum&quot;, c_byte),        (&quot;byZeroChanNum&quot;, c_byte),        (&quot;byMainProto&quot;, c_byte),        (&quot;bySubProto&quot;, c_byte),        (&quot;bySupport&quot;, c_byte),        (&quot;bySupport1&quot;, c_byte),        (&quot;bySupport2&quot;, c_byte),        (&quot;wDevType&quot;, c_uint16),        (&quot;bySupport3&quot;, c_byte),        (&quot;byMultiStreamProto&quot;, c_byte),        (&quot;byStartDChan&quot;, c_byte),        (&quot;byStartDTalkChan&quot;, c_byte),        (&quot;byHighDChanNum&quot;, c_byte),        (&quot;bySupport4&quot;, c_byte),        (&quot;byLanguageType&quot;, c_byte),        (&quot;byVoiceInChanNum&quot;, c_byte),        (&quot;byStartVoiceInChanNo&quot;, c_byte),        (&quot;byRes3&quot;, c_byte * 2),        (&quot;byMirrorChanNum&quot;, c_byte),        (&quot;wStartMirrorChanNo&quot;, c_uint16),        (&quot;byRes2&quot;, c_byte * 2)]# 报警设备信息结构体class NET_DVR_ALARMER(Structure):    _fields_ = [        (&quot;byUserIDValid&quot;, c_byte),        (&quot;bySerialValid&quot;, c_byte),        (&quot;byVersionValid&quot;, c_byte),        (&quot;byDeviceNameValid&quot;, c_byte),        (&quot;byMacAddrValid&quot;, c_byte),        (&quot;byLinkPortValid&quot;, c_byte),        (&quot;byDeviceIPValid&quot;, c_byte),        (&quot;bySocketIPValid&quot;, c_byte),        (&quot;lUserID&quot;, c_long),        (&quot;sSerialNumber&quot;, c_byte * 48),        (&quot;dwDeviceVersion&quot;, c_uint32),        (&quot;sDeviceName&quot;, c_char * 32),        (&quot;byMacAddr&quot;, c_char * 6),        (&quot;wLinkPort&quot;, c_uint16),        (&quot;sDeviceIP&quot;, c_char * 128),        (&quot;sSocketIP&quot;, c_char * 128),        (&quot;byIpProtocol&quot;, c_byte),        (&quot;byRes2&quot;, c_byte * 11)    ]# 布防class NET_DVR_SETUPALARM_PARAM(Structure):    _fields_ = [        (&quot;dwSize&quot;, c_uint32),        (&quot;beLevel&quot;, c_byte),        (&quot;byAlarmInfoType&quot;, c_byte),        (&quot;byRetAlarmTypeV40&quot;, c_byte),        (&quot;byRetDevInfoVersion&quot;, c_byte),        (&quot;byRetVQDAlarmType&quot;, c_byte),        (&quot;byFaceAlarmDetection&quot;, c_byte),        (&quot;bySupport&quot;, c_byte),        (&quot;byBrokenNetHttp&quot;, c_byte),        (&quot;wTaskNo&quot;, c_uint16),        (&quot;byDeployType&quot;, c_byte),        (&quot;byRes1&quot;, c_byte * 3),        (&quot;byAlarmTypeURL&quot;, c_byte),        (&quot;byCustomCtrl&quot;, c_byte)    ]# 区域框参数结构体。class NET_VCA_RECT(Structure):    _fields_ = [        (&quot;fX&quot;, c_float),        (&quot;fY&quot;, c_float),        (&quot;fWidth&quot;, c_float),        (&quot;fHeight&quot;, c_float)    ]# 报警目标信息结构体。class NET_VCA_TARGET_INFO(Structure):    _fields_ = [        (&quot;dwID&quot;, c_uint32),        (&quot;struRect&quot;, NET_VCA_RECT),        (&quot;byRes&quot;, c_byte*4)    ]# IP地址结构体。class NET_DVR_IPADDR(Structure):    _fields_ = [        (&quot;sIpV4&quot;, c_char*16),        (&quot;sIpV6&quot;, c_byte*128)    ]# 前端设备信息结构体。class NET_VCA_DEV_INFO(Structure):    _fields_ = [        (&quot;struDevIP&quot;, NET_DVR_IPADDR),        (&quot;wPort&quot;, c_uint16),        (&quot;byChannel&quot;, c_byte),        (&quot;byIvmsChannel&quot;, c_byte)    ]# 人体属性参数结构体。class NET_VCA_HUMAN_FEATURE(Structure):    _fields_ = [        (&quot;byAgeGroup&quot;, c_byte),        (&quot;bySex&quot;, c_byte),        (&quot;byEyeGlass&quot;, c_byte),        (&quot;byAge&quot;, c_byte),        (&quot;byAgeDeviation&quot;, c_byte),        (&quot;byRes&quot;, c_byte*11)    ]# 人脸抓拍结果结构体。class NET_VCA_FACESNAP_RESULT(Structure):    _fields_ = [        (&quot;dwSize&quot;, c_uint32),        (&quot;dwRelativeTime&quot;, c_uint32),        (&quot;dwAbsTime&quot;, c_uint32),        (&quot;dwFacePicID&quot;, c_uint32),        (&quot;dwFaceScore&quot;, c_uint32),        (&quot;struTargetInfo&quot;, NET_VCA_TARGET_INFO),        (&quot;struRect&quot;, NET_VCA_RECT),        (&quot;struDevInfo&quot;, NET_VCA_DEV_INFO),        (&quot;dwFacePicLen&quot;, c_uint32),        (&quot;dwBackgroundPicLen&quot;, c_uint32),        (&quot;bySmart&quot;, c_byte),        (&quot;byAlarmEndMark&quot;, c_byte),        (&quot;byRepeatTimes&quot;, c_byte),        (&quot;byUploadEventDataType&quot;, c_byte),        (&quot;struFeature&quot;, NET_VCA_HUMAN_FEATURE),        (&quot;fStayDuration&quot;, c_float),        (&quot;sStorageIP&quot;, c_char*16),        (&quot;wStoragePort&quot;, c_uint16),        (&quot;wDevInfoIvmsChannelEx&quot;, c_uint16),        (&quot;byRes1&quot;, c_byte*15),        (&quot;byBrokenNetHttp&quot;, c_byte),        (&quot;pBuffer1&quot;, c_void_p),        (&quot;pBuffer2&quot;, c_void_p)    ]</code></pre><h1 id="SDK-初始化"><a href="#SDK-初始化" class="headerlink" title="SDK 初始化"></a>SDK 初始化</h1><pre><code class="py">def NET_DVR_Init():    init_res = callCpp(&quot;NET_DVR_Init&quot;)  # SDK初始化    if init_res:        logging.info(&quot;SDK初始化成功&quot;)        return True    else:        error_info = callCpp(&quot;NET_DVR_GetLastError&quot;)        logging.error(&quot;SDK初始化错误：&quot; + str(error_info))        return False</code></pre><h1 id="用户注册设备，设置超时时间"><a href="#用户注册设备，设置超时时间" class="headerlink" title="用户注册设备，设置超时时间"></a>用户注册设备，设置超时时间</h1><pre><code class="py">def NET_DVR_Login_V30(sDVRIP = &quot;192.168.1.1&quot;,wDVRPort = 8000,sUserName = &quot;admin&quot;,sPassword = &quot;admin&quot;):    set_overtime = callCpp(&quot;NET_DVR_SetConnectTime&quot;, 5000, 4)  # 设置超时    if set_overtime:        logging.info(sDVRIP + &quot;, 设置超时时间成功&quot;)    else:        error_info = callCpp(&quot;NET_DVR_GetLastError&quot;)        logging.error(sDVRIP + &quot;, 设置超时错误信息：&quot; + str(error_info))        return False    # c++传递进去的是byte型数据，需要转成byte型传进去，否则会乱码    sDVRIP_bytes = bytes(sDVRIP, &quot;ascii&quot;)    sUserName = bytes(sUserName, &quot;ascii&quot;)    sPassword = bytes(sPassword, &quot;ascii&quot;)    DeviceInfo = LPNET_DVR_DEVICEINFO_V30()    DeviceInfoRef = byref(DeviceInfo)    lUserID = callCpp(&quot;NET_DVR_Login_V30&quot;, sDVRIP_bytes, wDVRPort, sUserName, sPassword, DeviceInfoRef)    logging.info(sDVRIP + &quot;, 登录结果：&quot; + str(lUserID))    if lUserID == -1:  # -1表示失败，其他值表示返回的用户ID值。        error_info = callCpp(&quot;NET_DVR_GetLastError&quot;)        logging.error(sDVRIP + &quot;, 登录错误信息：&quot; + str(error_info))    return lUserID</code></pre><h1 id="设置报警回调函数"><a href="#设置报警回调函数" class="headerlink" title="设置报警回调函数"></a>设置报警回调函数</h1><pre><code class="py"># 回调函数接口def MsgCallback(lCommand, net_dvr_alarm, pAlarmInfo, dwBufLen, pUser):    # logging.info(&quot;回调函数执行，lcommand的值：&quot;+str(lCommand))    if lCommand == 0x1112:  # 人脸抓拍结果，NET_VCA_FACESNAP_RESULT 人脸抓拍结果结构体。        ip = str(net_dvr_alarm.contents.sDeviceIP, &quot;utf-8&quot;)        timestamp = time.time()        datetime_struct = datetime.datetime.fromtimestamp(timestamp)        format_time = datetime_struct.strftime(&#39;%Y%m%d%H%M%S%f&#39;)        struFaceSnap = NET_VCA_FACESNAP_RESULT()        memmove(pointer(struFaceSnap), pAlarmInfo, sizeof(struFaceSnap))        face = (c_ubyte*struFaceSnap.dwFacePicLen)()        memmove(face, struFaceSnap.pBuffer1, struFaceSnap.dwFacePicLen)        # print(ip+&quot;_&quot; + format_time+&quot;, dwFacePicID:&quot;+str(struFaceSnap.dwFacePicID))  # 人脸图ID        # print(ip+&quot;_&quot; + format_time+&quot;, byAlarmEndMark:&quot;+str(struFaceSnap.byAlarmEndMark))        if struFaceSnap.byAlarmEndMark == 1:  # 报警结束标记：0- 保留，1- 结束标记（该字段结合人脸ID字段使用，表示该ID对应的下报警结束，用于判断报警结束，提取识别图片数据中，清晰度最高的图片）            with open(os.path.join(temp_dir, ip + &quot;_01_&quot; + format_time + &quot;_face.jpg&quot;), &quot;wb&quot;) as f:                f.write(face)            if struFaceSnap.pBuffer2:                back = (c_ubyte*struFaceSnap.dwBackgroundPicLen)()                memmove(back, struFaceSnap.pBuffer2, struFaceSnap.dwBackgroundPicLen)                with open(os.path.join(temp_dir, ip + &quot;_01_&quot; + format_time + &quot;_back.jpg&quot;), &quot;wb&quot;) as f:                    f.write(back)    # print(&quot;结构体中的变量，byUserIDValid输出：&quot;+str(net_dvr_alarm.contents.byUserIDValid))    return Truedef NET_DVR_SetDVRMessageCallBack_V31(sDVRIP, callBack):    if callCpp(&quot;NET_DVR_SetDVRMessageCallBack_V31&quot;, callBack, None):        logging.info(sDVRIP + &quot;, 设置回调函数成功！&quot;)        return True    else:        logging.error(sDVRIP + &quot;, 回调函数设置错误：&quot; + str(callCpp(&quot;NET_DVR_GetLastError&quot;)))        return False    # iListenHandle = callCpp(&quot;NET_DVR_StartListen_V30&quot;, sLocalIP,wLocalPort,CALLFUNC(MSGCallBack),pUserData)# 设置回调，# MYCALLFUNC = CFUNCTYPE(c_bool, c_long, POINTER(NET_DVR_ALARMER),  c_void_p, c_uint32, c_void_p)# callBack = MYCALLFUNC(MsgCallback)</code></pre><blockquote><p><a href="https://blog.csdn.net/sweibd/article/details/52679213" target="_blank" rel="noopener">https://blog.csdn.net/sweibd/article/details/52679213</a><br>一个大坑：需要注意 <code>CMPRESULTFUNC(OnPyVideoAnalyzeResultCallback)</code> 这个指针函数是有自己的生存空间的，如果生存空间已过，会被释放，C 代码再回调的时候，就会使用一个过期指针。</p><p>这里建议使用一个全局的 python 指针。</p></blockquote><h1 id="布防"><a href="#布防" class="headerlink" title="布防"></a>布防</h1><pre><code class="py">def NET_DVR_SetupAlarmChan_V41(sDVRIP, lUserID):    struAlarmParam = NET_DVR_SETUPALARM_PARAM()    struAlarmParamSize = sizeof(struAlarmParam)    logging.info(sDVRIP + &quot;, 结构体大小：&quot; + str(struAlarmParamSize))    struAlarmParam.dwSize = struAlarmParamSize  # 结构体大小    struAlarmParam.beLevel = 1  # 0 一级布防，1 二级布防    # struAlarmParam.byAlarmInfoType = 1  # 智能交通设备有效    struAlarmParam.byFaceAlarmDetection = 0  # 人脸侦测报警（人脸抓拍模块需要设置为 0）    struAlarmParam_p = byref(struAlarmParam)    m_lAlarmHandle = callCpp(&quot;NET_DVR_SetupAlarmChan_V41&quot;, lUserID, struAlarmParam_p)    logging.info(sDVRIP + &quot;, 布防结果：&quot; + str(m_lAlarmHandle))    if m_lAlarmHandle == -1:        logging.error(sDVRIP + &quot;, 错误信息：&quot; + str(callCpp(&quot;NET_DVR_GetLastError&quot;)))    else:        logging.info(sDVRIP + &quot;, 布防成功&quot;)    return m_lAlarmHandle</code></pre><h1 id="撤防，释放-SDK-资源，用户注销"><a href="#撤防，释放-SDK-资源，用户注销" class="headerlink" title="撤防，释放 SDK 资源，用户注销"></a>撤防，释放 SDK 资源，用户注销</h1><pre><code class="py"># 撤防def NET_DVR_CloseAlarmChan_V30(sDVRIP, m_lAlarmHandle):    res = callCpp(&quot;NET_DVR_CloseAlarmChan_V30&quot;, m_lAlarmHandle)    if res &lt; 0:        logging.error(sDVRIP + &quot;, 撤防失败:&quot; + str(callCpp(&quot;NET_DVR_GetLastError&quot;)))        return False    else:        logging.info(sDVRIP + &quot;, 撤防成功&quot;)        return True# 释放 SDK 资源def NET_DVR_Cleanup():    res = callCpp(&quot;NET_DVR_Cleanup&quot;)    if res &lt; 0:        print(&quot;SDK资源释放失败:&quot;+str(callCpp(&quot;NET_DVR_GetLastError&quot;)))    else:        print(&quot;SDK资源成功释放！！&quot;)# 用户注销def NET_DVR_Logout_V30(sDVRIP, lUserID):    if callCpp(&quot;NET_DVR_Logout_V30&quot;, lUserID):        logging.info(sDVRIP + &quot;, 用户已经成功注销&quot;)    else:        logging.error(sDVRIP + &quot;, 用户注销失败：&quot; + str(callCpp(&quot;NET_DVR_GetLastError&quot;)))</code></pre><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><pre><code class="py">from queue import QueuepicQueue = Queue()  # 阻塞线程用class FACESNAP_RESULT_Thread (threading.Thread):    def __init__(self, sDVRIP, wDVRPort, sUserName, sPassword):        threading.Thread.__init__(self)        self.sDVRIP = sDVRIP        self.wDVRPort = wDVRPort        self.sUserName = sUserName        self.sPassword = sPassword    def run(self):        lUserID = NET_DVR_Login_V30(self.sDVRIP, self.wDVRPort, self.sUserName, self.sPassword)        global threadsNum        if lUserID != -1:            # 设置回调            MYCALLFUNC = CFUNCTYPE(c_bool, c_long, POINTER(NET_DVR_ALARMER),  c_void_p, c_uint32, c_void_p)            callBack = MYCALLFUNC(MsgCallback)            if NET_DVR_SetDVRMessageCallBack_V31(self.sDVRIP, callBack):                m_lAlarmHandle = NET_DVR_SetupAlarmChan_V41(self.sDVRIP, lUserID)                if m_lAlarmHandle != -1:                    picQueue.get()                    NET_DVR_CloseAlarmChan_V30(self.sDVRIP, m_lAlarmHandle)                    NET_DVR_Logout_V30(self.sDVRIP, lUserID)                    global lock                    lock.acquire()                    threadsNum -= 1                    if threadsNum == 0:                        picQueue.put(1)  # 主线程退出                    else:                        picQueue.put(2)  # 子线程退出                    lock.release()                    return        threadsNum -= 1        if threadsNum &lt; 1:            picQueue.put(1)threadsNum = 0  # 相机数，子线程数lock = threading.Lock()def main():    NET_DVR_Init()  # 初始化 SDK    cameraTableValues=[[&quot;ip&quot;,&quot;port&quot;,&quot;username&quot;,&quot;password&quot;], [&quot;ip&quot;,&quot;port&quot;,&quot;username&quot;,&quot;password&quot;]]    threadsNum = len(cameraTableValues)    threads = []  # 每个相机不同的线程    for camera in cameraTableValues:        t = FACESNAP_RESULT_Thread(camera[0], camera[1], camera[2], camera[3])        threads.append(t)    for th in threads:        th.start()    # 可以在回调函数中加入一定的逻辑，退出线程，picQueue.put(2)    while 1:  # 阻塞线程，可以一直抓拍        if picQueue.get() == 1:  # 代表子线程结束，可以退出了            NET_DVR_Cleanup()            break        else:            picQueue.put(2)if __name__ == &#39;__main__&#39;:    main()</code></pre><h1 id="抓图"><a href="#抓图" class="headerlink" title="抓图"></a>抓图</h1><pre><code class="py"># 抓图数据结构体class NET_DVR_JPEGPARA(ctypes.Structure):    _fields_ = [        (&quot;wPicSize&quot;, ctypes.c_ushort),        (&quot;wPicQuality&quot;, ctypes.c_ushort)]# jpeg抓图hPlayWnd显示窗口能为none，存在缺点采集图片速度慢def Get_JPEGpicture():    sJpegPicFileName = bytes(&quot;pytest.jpg&quot;, &quot;ascii&quot;)    lpJpegPara=NET_DVR_JPEGPARA()    lpJpegPara.wPicSize=0    lpJpegPara.wPicQuality=0    if (callCpp(&quot;NET_DVR_CaptureJPEGPicture&quot;, lUserID, lChannel, ctypes.byref(lpJpegPara), sJpegPicFileName)== False):        error_info = callCpp(&quot;NET_DVR_GetLastError&quot;)        print(&quot;抓图失败：&quot; + str(error_info))    else:        print(&quot;抓图成功&quot;)</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>该程序使用的海康 SDK 版本为：CH-HCNetSDKV5.3.5.46_build20180518_Win64。主要是实现了【<a href="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20180929095748.png" target="_blank" rel="noopener">人脸抓拍模块流程</a>】，获得人脸图及背景图。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote><p><a href="https://blog.csdn.net/weixin_40851278/article/details/80949594" target="_blank" rel="noopener">Windows64下通过python调用海康SDK实现登入、预览、抓图、光学变倍、相机激活、区域聚焦、区域曝光功能</a><br><a href="https://blog.csdn.net/caobin0825/article/details/79667442" target="_blank" rel="noopener">python 调用海康SDK，登录，设置回调，布防，撤防，注销以及释放SDK</a><br><a href="https://blog.csdn.net/sweibd/article/details/52679213" target="_blank" rel="noopener">python如何调用C, 如何注册成C的回调函数(python后台程序常用方法)</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 常见错误</title>
      <link href="/2018/09/21/MySQL%20%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/"/>
      <url>/2018/09/21/MySQL%20%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="MYSQL-ERROR-1862-HY000-Your-password-has-expired"><a href="#MYSQL-ERROR-1862-HY000-Your-password-has-expired" class="headerlink" title="MYSQL ERROR 1862 (HY000): Your password has expired."></a>MYSQL ERROR 1862 (HY000): Your password has expired.</h2><p>密码过期，需重新修改下密码即可：</p><pre><code class="shell"># 修改原密码（继续使用原密码也可以的）,输入命令：SET PASSWORD for root@localhost = PASSWORD(&#39;123456&#39;);# 修改当前用户密码SET PASSWORD = PASSWORD(&#39;root&#39;);# 修改root密码永不过期，输入命令：alter user &#39;root&#39;@&#39;localhost&#39; password expire never;# 或者SET GLOBAL default_password_lifetime = 0;  # -- never 全局用户# 或者ALTER USER &#39;root&#39;@&#39;localhost&#39; PASSWORD EXPIRE INTERVAL 90 DAY; # -- 90 days</code></pre><a id="more"></a><p>配置文件中修改：</p><pre><code class="ini">[mysqld]default_password_lifetime=0</code></pre><h2 id="ERROR-1206-HY000-The-total-number-of-locks-exceeds-the-lock-table-size"><a href="#ERROR-1206-HY000-The-total-number-of-locks-exceeds-the-lock-table-size" class="headerlink" title="ERROR 1206 (HY000): The total number of locks exceeds the lock table size"></a>ERROR 1206 (HY000): The total number of locks exceeds the lock table size</h2><blockquote><p><a href="https://blog.csdn.net/github_36326955/article/details/54970808" target="_blank" rel="noopener">https://blog.csdn.net/github_36326955/article/details/54970808</a></p></blockquote><p>InnoDB 表执行大批量数据的更新，插入，删除操作时会出现这个问题，需要调整 InnoDB 全局的 <code>innodb_buffer_pool_size</code> 的值来解决这个问题，并且重启 mysql 服务。</p><p>默认的 <code>innodb_buffer_pool_size=8M</code></p><pre><code class="sql">mysql&gt; show variables like &quot;%_buffer%&quot;;+-------------------------------------+----------------+| Variable_name                       | Value          |+-------------------------------------+----------------+| bulk_insert_buffer_size             | 8388608        || innodb_buffer_pool_chunk_size       | 8388608        || innodb_buffer_pool_dump_at_shutdown | ON             || innodb_buffer_pool_dump_now         | OFF            || innodb_buffer_pool_dump_pct         | 25             || innodb_buffer_pool_filename         | ib_buffer_pool || innodb_buffer_pool_instances        | 1              || innodb_buffer_pool_load_abort       | OFF            || innodb_buffer_pool_load_at_startup  | ON             || innodb_buffer_pool_load_now         | OFF            || innodb_buffer_pool_size             | 8388608        || innodb_change_buffer_max_size       | 25             || innodb_change_buffering             | all            || innodb_log_buffer_size              | 1048576        || innodb_sort_buffer_size             | 1048576        || join_buffer_size                    | 262144         || key_buffer_size                     | 8388608        || myisam_sort_buffer_size             | 159383552      || net_buffer_length                   | 16384          || preload_buffer_size                 | 32768          || read_buffer_size                    | 65536          || read_rnd_buffer_size                | 262144         || sort_buffer_size                    | 262144         || sql_buffer_result                   | OFF            |+-------------------------------------+----------------+24 rows in set</code></pre><p>修改 <code>innodb_buffer_pool_size</code> 的值为 <code>3G（3*1024*1024*1024）</code>：</p><pre><code class="sql">SET GLOBAL innodb_buffer_pool_size=67108864;</code></pre><h2 id="1114-The-table-39-xxxx-39-is-full"><a href="#1114-The-table-39-xxxx-39-is-full" class="headerlink" title="1114 - The table &#39;xxxx&#39; is full"></a>1114 - The table &#39;xxxx&#39; is full</h2><p>这是由于内存表的大小超过了规定的范围。</p><pre><code class="ini">[mysqld]## 内存表容量，默认为 16777216（字节，16M）max_heap_table_size=1024M## 临时表容量tmp_table_size=1024M</code></pre><h2 id="MySQL-8-0版本连接报错：Could-not-create-connection-to-database-server"><a href="#MySQL-8-0版本连接报错：Could-not-create-connection-to-database-server" class="headerlink" title="MySQL 8.0版本连接报错：Could not create connection to database server."></a>MySQL 8.0版本连接报错：Could not create connection to database server.</h2><blockquote><p><a href="https://blog.csdn.net/qq_22076345/article/details/81952035" target="_blank" rel="noopener">https://blog.csdn.net/qq_22076345/article/details/81952035</a></p></blockquote><p>MySQL8.0 版本需要更换驱动为 <code>com.mysql.cj.jdbc.Driver</code>，之前的 <code>com.mysql.jdbc.Driver</code> 已经不能在MySQL 8.0 版本使用了，官方文档链接：<a href="https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-api-changes.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-api-changes.html</a></p><p>另外 <code>mysql-connector-java</code> 也推荐更新到8.0的版本（<a href="https://dev.mysql.com/downloads/connector/j/）。" target="_blank" rel="noopener">https://dev.mysql.com/downloads/connector/j/）。</a></p><p>综上修改以下两点：</p><ol><li><p>更新 <code>mysql-connector-java</code> 版本：</p><pre><code class="xml"> &lt;dependency&gt;     &lt;groupId&gt;mysql&lt;/groupId&gt;     &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;     &lt;version&gt;8.0.11&lt;/version&gt; &lt;/dependency&gt;</code></pre></li><li><p>更换驱动：</p><pre><code class="xml"> &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;</code></pre></li></ol><p>报时区错误</p><p>Failed to execute goal org.mybatis.generator:mybatis-generator-maven-plugin:1.3.5:generate (default-cli) on project songci-serv: The server time zone value &#39;ÖÐ¹ú±ê×¼Ê±¼ä&#39; is unrecognized or represents more than one time zone. You must configure either the server or JDBC driver (via the serverTimezone configuration property) to use a more specifc time zone value if you want to utilize time zone support. -&gt; [Help 1]</p><p>解决方法执行命令给 MySQL 服务器设置时区为东八区，这个是 <code>com.mysql.cj.jdbc.Driver</code> 需要指定的：</p><pre><code class="sql">mysql&gt; set global time_zone=&#39;+8:00&#39;;Query OK, 0 rows affected</code></pre><p>或者在数据库连接配置中加上 <code>serverTimezone=GMT%2B8</code>（代表东八区，或者 <code>serverTimezone=Asia/Shanghai</code>），如下：</p><pre><code class="ini">connectionURL=&quot;jdbc:mysql://127.0.0.1:3306/songci?useUnicode=true&amp;amp;characterEncoding=utf8&amp;amp;useSSL=false&amp;amp;serverTimezone=GMT%2B8&quot;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 字符串与二进制转换</title>
      <link href="/2018/09/20/Python%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/"/>
      <url>/2018/09/20/Python%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="字符串转16进制"><a href="#字符串转16进制" class="headerlink" title="字符串转16进制"></a>字符串转16进制</h1><p>python 2.7</p><pre><code class="py">&gt;&gt;&gt; &quot;hello&quot;.encode(&#39;hex&#39;)&#39;68656c6c6f&#39;&gt;&gt;&gt; import binascii&gt;&gt;&gt; binascii.hexlify(&#39;hello&#39;.encode(&#39;utf8&#39;))  # 不加 encode 也行&#39;68656c6c6f&#39;&gt;&gt;&gt; binascii.b2a_hex(&#39;hello&#39;)  # 同样加不加 encode 都行，返回结果是 str 类型&#39;68656c6c6f&#39;&gt;&gt;&gt; import codecs&gt;&gt;&gt; codecs.getencoder(&#39;hex_codec&#39;)(b&#39;hello&#39;)[0]  # hex_codec，hex 均可，以下有没有 b 均可&#39;68656c6c6f&#39;&gt;&gt;&gt; codecs.getencoder(&#39;hex&#39;)(b&#39;hello&#39;)[0]&#39;68656c6c6f&#39;&gt;&gt;&gt; codecs.encode(b&quot;hello&quot;, &#39;hex_codec&#39;)  # 同样 hex_codec，hex 均可&#39;68656c6c6f&#39;</code></pre><a id="more"></a><p>python 3</p><pre><code class="py">&gt;&gt;&gt; &quot;hello&quot;.encode(&#39;hex&#39;)  # 不可用Traceback (most recent call last):  File &quot;&lt;pyshell#6&gt;&quot;, line 1, in &lt;module&gt;    &quot;hello&quot;.encode(&#39;hex&#39;)LookupError: &#39;hex&#39; is not a text encoding; use codecs.encode() to handle arbitrary codecs&gt;&gt;&gt; s = &quot;hello&quot;.encode(&quot;utf-8&quot;).hex()&gt;&gt;&gt; s&#39;68656c6c6f&#39;&gt;&gt;&gt; bytes(s, &quot;utf-8&quot;)b&#39;68656c6c6f&#39;&gt;&gt;&gt; b&#39;hello&#39;.hex()&#39;68656c6c6f&#39;&gt;&gt;&gt; import binascii&gt;&gt;&gt; binascii.hexlify(&#39;hello&#39;.encode(&#39;utf8&#39;))  # 参数必须是 bytes 类型b&#39;68656c6c6f&#39;&gt;&gt;&gt; binascii.b2a_hex(&#39;hello&#39;.encode(&#39;utf8&#39;))  # 参数必须是 bytes 类型b&#39;68656c6c6f&#39;&gt;&gt;&gt; import codecs&gt;&gt;&gt; codecs.getencoder(&#39;hex_codec&#39;)(b&#39;hello&#39;)[0]  # hex_codec，hex 均可，必须是 bytes 类型b&#39;68656c6c6f&#39;&gt;&gt;&gt; codecs.getencoder(&#39;hex&#39;)(b&#39;hello&#39;)[0]b&#39;68656c6c6f&#39;&gt;&gt;&gt; codecs.encode(b&quot;hello&quot;, &#39;hex_codec&#39;)  # 同样 hex_codec，hex 均可b&#39;68656c6c6f&#39;</code></pre><h1 id="16进制转字符串"><a href="#16进制转字符串" class="headerlink" title="16进制转字符串"></a>16进制转字符串</h1><p>python 2.7</p><pre><code class="py">&gt;&gt;&gt; binascii.unhexlify(&#39;68656c6c6f&#39;)&#39;hello&#39;&gt;&gt;&gt; binascii.unhexlify(b&#39;68656c6c6f&#39;)&#39;hello&#39;&gt;&gt;&gt; import codecs&gt;&gt;&gt; codecs.decode(b&quot;68656c6c6f&quot;, &#39;hex&#39;)  # hex_codec，hex 均可，有没有 b 均可&#39;hello&#39;</code></pre><p>python 3</p><pre><code class="py">&gt;&gt;&gt; bytes.fromhex(&#39;68656c6c6f&#39;)b&#39;hello&#39;&gt;&gt;&gt; binascii.unhexlify(&#39;68656c6c6f&#39;)b&#39;hello&#39;&gt;&gt;&gt; binascii.unhexlify(b&#39;68656c6c6f&#39;)b&#39;hello&#39;&gt;&gt;&gt; import codecs&gt;&gt;&gt; codecs.decode(b&quot;68656c6c6f&quot;, &#39;hex&#39;)  # hex_codec，hex 均可，必须是 bytes 类型&#39;hello&#39;</code></pre><h1 id="bytearray-和-string-之间转换"><a href="#bytearray-和-string-之间转换" class="headerlink" title="bytearray 和 string 之间转换"></a>bytearray 和 string 之间转换</h1><pre><code class="py">&gt;&gt;&gt; bytearray.fromhex(&quot;68656c6c6f&quot;)bytearray(b&#39;hello&#39;)&gt;&gt;&gt; bytearray(b&#39;hello&#39;)bytearray(b&#39;hello&#39;)&gt;&gt;&gt; str(bytearray(b&#39;hello&#39;))  # 2.7&#39;hello&#39;&gt;&gt;&gt; str(bytearray(b&#39;hello&#39;), &#39;utf-8&#39;)  # 3&#39;hello&#39;</code></pre><blockquote><p><a href="https://stackoverflow.com/questions/2340319/python-3-1-1-string-to-hex" target="_blank" rel="noopener">https://stackoverflow.com/questions/2340319/python-3-1-1-string-to-hex</a><br><a href="https://stackoverflow.com/questions/6624453/whats-the-correct-way-to-convert-bytes-to-a-hex-string-in-python-3" target="_blank" rel="noopener">https://stackoverflow.com/questions/6624453/whats-the-correct-way-to-convert-bytes-to-a-hex-string-in-python-3</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python list 常见操作</title>
      <link href="/2018/09/19/Python%20list%20%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/"/>
      <url>/2018/09/19/Python%20list%20%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="将列表分成均匀大小的块"><a href="#将列表分成均匀大小的块" class="headerlink" title="将列表分成均匀大小的块"></a>将列表分成均匀大小的块</h1><blockquote><p><a href="https://stackoverflow.com/questions/312443/how-do-you-split-a-list-into-evenly-sized-chunks" target="_blank" rel="noopener">https://stackoverflow.com/questions/312443/how-do-you-split-a-list-into-evenly-sized-chunks</a></p></blockquote><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><pre><code class="py">import pprintdef chunks(li, n):    &quot;&quot;&quot;Yield successive n-sized chunks from li.&quot;&quot;&quot;    for i in range(0, len(li), n):        yield li[i:i + n]pprint.pprint(list(chunks(list(range(10, 75)), 10)))&#39;&#39;&#39;[[10, 11, 12, 13, 14, 15, 16, 17, 18, 19],[20, 21, 22, 23, 24, 25, 26, 27, 28, 29],[30, 31, 32, 33, 34, 35, 36, 37, 38, 39],[40, 41, 42, 43, 44, 45, 46, 47, 48, 49],[50, 51, 52, 53, 54, 55, 56, 57, 58, 59],[60, 61, 62, 63, 64, 65, 66, 67, 68, 69],[70, 71, 72, 73, 74]]&#39;&#39;&#39;</code></pre><p>也可以使用列表生成器</p><pre><code class="py">[li[i:i + n] for i in range(0, len(li), n)]</code></pre><a id="more"></a><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><pre><code class="py"># from itertools import izip_longest as zip_longest # for Python 2.xfrom itertools import zip_longest # for Python 3.x#from six.moves import zip_longest # for both (uses the six compat library)def grouper(n, iterable, padvalue=None):    return zip_longest(*[iter(iterable)]*n, fillvalue=padvalue)for i in (grouper(3, &#39;abcdefg&#39;)):    print(i)&#39;&#39;&#39;(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)(&#39;d&#39;, &#39;e&#39;, &#39;f&#39;)(&#39;g&#39;, None, None)&#39;&#39;&#39;</code></pre><h1 id="将列表分成一共有-m-块（尽可能平均）"><a href="#将列表分成一共有-m-块（尽可能平均）" class="headerlink" title="将列表分成一共有 m 块（尽可能平均）"></a>将列表分成一共有 m 块（尽可能平均）</h1><h2 id="方法一-1"><a href="#方法一-1" class="headerlink" title="方法一"></a>方法一</h2><blockquote><p><a href="https://www.coder4.com/archives/2089" target="_blank" rel="noopener">https://www.coder4.com/archives/2089</a></p></blockquote><pre><code class="py">import mathdef chunks(arr, m):    n = int(math.ceil(len(arr) / float(m)))    return [arr[i:i + n] for i in range(0, len(arr), n)]pprint.pprint(chunks(list(range(50)), 4))&#39;&#39;&#39;[[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], [13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25], [26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38], [39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49]]&#39;&#39;&#39;</code></pre><h2 id="方法二-1"><a href="#方法二-1" class="headerlink" title="方法二"></a>方法二</h2><blockquote><p><a href="https://stackoverflow.com/questions/312443/how-do-you-split-a-list-into-evenly-sized-chunks/16935535#16935535" target="_blank" rel="noopener">https://stackoverflow.com/questions/312443/how-do-you-split-a-list-into-evenly-sized-chunks/16935535#16935535</a></p></blockquote><pre><code class="py">import numpylst = range(50)for i in (numpy.array_split(lst, 4)):    print(list(i))&#39;&#39;&#39;[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12][13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25][26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37][38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49]&#39;&#39;&#39;</code></pre><h1 id="判断一个集合是否为另一个集合的子集"><a href="#判断一个集合是否为另一个集合的子集" class="headerlink" title="判断一个集合是否为另一个集合的子集"></a>判断一个集合是否为另一个集合的子集</h1><p><code>set</code> 的 <code>issubset()</code> 方法用于判断集合的所有元素是否都包含在<strong>指定</strong>集合中，如果是则返回 True，否则返回 False。</p><p>或者，<code>set</code> 的 <code>issuperset()</code> 方法用于判断指定集合的所有元素是否都包含在<strong>原始</strong>的集合中，如果是则返回 True，否则返回 False。</p><pre><code class="py">a = [1,2,3,4]b = set([1,2])b.issubset(a)  # Trueset(a).issuperset(b)  # True</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sublime 使用</title>
      <link href="/2018/09/17/sublime%20%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/09/17/sublime%20%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="sublime-中分号替换成换行"><a href="#sublime-中分号替换成换行" class="headerlink" title="sublime 中分号替换成换行"></a>sublime 中分号替换成换行</h1><blockquote><p><a href="https://blog.csdn.net/hjw199089/article/details/52786879" target="_blank" rel="noopener">https://blog.csdn.net/hjw199089/article/details/52786879</a></p></blockquote><p>Ctrl Shift F 或 Ctrl H</p><p>在 replace 中输入 Ctrl Shift Enter</p><p>点击 replaceall</p><a id="more"></a><h1 id="同时快速编辑多行内容"><a href="#同时快速编辑多行内容" class="headerlink" title="同时快速编辑多行内容"></a>同时快速编辑多行内容</h1><blockquote><p><a href="https://blog.csdn.net/sinat_34719507/article/details/53891927" target="_blank" rel="noopener">https://blog.csdn.net/sinat_34719507/article/details/53891927</a></p></blockquote><p>1，鼠标选中多行，按下 Ctrl Shift L (Command Shift L) 即可同时编辑这些行；<br>2，鼠标选中文本，反复按 CTRL D (Command D) 即可继续向下同时选中下一个相同的文本进行同时编辑；<br>3，鼠标选中文本，按下 Alt F3 (Win) 或 Ctrl Command G(Mac) 即可一次性选择全部的相同文本进行同时编辑；<br>4，Shift 鼠标右键 (Win) 或 Option 鼠标左键 (Mac) 或使用鼠标中键可以用鼠标进行竖向多行选择；（鼠标要长按）<br>5，Ctrl 鼠标左键(Win) 或 Command 鼠标左键(Mac) 可以手动选择同时要编辑。如果按错可以按 Ctrl + U 撤销。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sublime </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MQTT--Python进行发布、订阅测试</title>
      <link href="/2018/09/16/MQTT--Python%E8%BF%9B%E8%A1%8C%E5%8F%91%E5%B8%83%E3%80%81%E8%AE%A2%E9%98%85%E6%B5%8B%E8%AF%95/"/>
      <url>/2018/09/16/MQTT--Python%E8%BF%9B%E8%A1%8C%E5%8F%91%E5%B8%83%E3%80%81%E8%AE%A2%E9%98%85%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="安装-paho-mqtt"><a href="#安装-paho-mqtt" class="headerlink" title="安装 paho-mqtt"></a>安装 paho-mqtt</h1><pre><code class="cmd">pip install paho-mqtt</code></pre><a id="more"></a><h1 id="发布并订阅"><a href="#发布并订阅" class="headerlink" title="发布并订阅"></a>发布并订阅</h1><pre><code class="py"># -*- coding: utf-8 -*-import sysimport loggingimport jsonimport randomimport zlibimport timeimport tracebackimport paho.mqtt.client as mqttimport configparserfrom logging.handlers import RotatingFileHandlerimport tracebackimport commonconfig = configparser.ConfigParser()config.read(&quot;config.ini&quot;)logging.basicConfig(level=logging.INFO,                    format=&#39;%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s&#39;,                    stream=sys.stdout)Rthandler = RotatingFileHandler(sys.path[0] + &#39;/log/log.log&#39;, maxBytes=10 * 1024 * 1024, backupCount=10)Rthandler.setLevel(logging.INFO)formatter = logging.Formatter(&#39;%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s&#39;)Rthandler.setFormatter(formatter)logging.getLogger(&#39;&#39;).addHandler(Rthandler)class MqttClient():    &quot;&quot;&quot;Mqtt处理类&quot;&quot;&quot;    def __init__(self):        logging.info(&quot;socket MQTT connect......&quot;)        self.ip = config.get(&quot;config&quot;, &quot;mqtt_ip&quot;)        self.port = int(config.get(&quot;config&quot;, &quot;mqtt_port&quot;))        self.clientId = &#39;alertserver&#39;+ str(random.randint(20, 20000000000))    def start(self):        try:            self.mqttc = mqtt.Client(self.clientId)            self.mqttc.on_connect = self.on_connect            self.mqttc.on_message = self.on_message            self.mqttc.on_disconnect = self.on_disconnect            self.mqttc.username_pw_set(config.get(&quot;config&quot;, &quot;mqtt_username&quot;), config.get(&quot;config&quot;, &quot;mqtt_password&quot;))            self.mqttc.connect(self.ip, self.port, 20)            self.mqttc.loop_forever()        except (Exception) as  e:            logging.info(e)            logging.info(traceback.format_exc())            time.sleep(20)            self.start()    def on_connect(self, client, userdata, flags, rc):        # client.subscribe(&quot;alert&quot;)        # 请求初始数据        try:            topic = &quot;alert&quot;            # 发送数据            msg={}            msg[&quot;alert&quot;]=1            z1=json.dumps(msg)            z2=zlib.compress(z1,9)            z3=bytearray(z2)            client.publish(topic, z3, 2)            logs = (u&quot;Publish topic:&quot; + topic)            logging.info(logs)        except (Exception) as  e:            logging.info(e)        logging.info(u&quot;MQTT 连接成功！:&quot; + str(rc))        client.subscribe(topic) # 订阅自己的消息    # 接收数据    def on_message(self, client, userdata, msg):        logging.info(msg.topic + &quot; &quot; + str(msg.payload))        # self.get_msg(client, userdata, msg)    def on_disconnect(self, client, userdata, rc):        logging.info(u&quot;MQTT 断开连接！&quot;)        if rc != 0:            logging.info(u&quot;MQTT 异常断开!&quot;)    def get_msg(self, client, userdata, msg):        if (msg.topic == &quot;alert&quot; ):            try:                z1 = msg.payload                z2 = str(z1)  # 转字符串                z3 = zlib.decompress(z2)  # 解压缩                alertMsg = json.loads(z3)  # json转字典                # init = json.loads(msg.payload)                logging.info(alertMsg)            except (Exception) as  e:                logging.info(e)# mqtt 线程class MqttThread (threading.Thread):    def __init__(self, client):        threading.Thread.__init__(self)        self.client = client    def run(self):        self.client.start()if __name__ == &#39;__main__&#39;:    client = MqttClient()    t = MqttThread(client)    t.start()    msg = time.time()    common.mqttc.publish(&quot;alert&quot;, msg, 2)</code></pre><p>这里引了一个 <code>import common</code>，common 的内容只有一行 <code>global mqttc</code>，是为了方便主线程调用发布，如果直接在主线程文件中写入 <code>global mqttc</code>，却不起作用，不理解为什么。</p><p>发布主要是 <code>client.publish(topic, z3, 2)</code>，z3 也可以是字符串。如果不需要发布把这里的去掉即可。</p><p>订阅主要是 <code>client.subscribe(topic)</code>。同样如果不需要订阅把这些去掉即可。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> MQTT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 运行时隐藏窗口</title>
      <link href="/2018/09/16/Python%20%E8%BF%90%E8%A1%8C%E6%97%B6%E9%9A%90%E8%97%8F%E7%AA%97%E5%8F%A3/"/>
      <url>/2018/09/16/Python%20%E8%BF%90%E8%A1%8C%E6%97%B6%E9%9A%90%E8%97%8F%E7%AA%97%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="Python-运行时隐藏窗口"><a href="#Python-运行时隐藏窗口" class="headerlink" title="Python 运行时隐藏窗口"></a>Python 运行时隐藏窗口</h1><blockquote><p><a href="https://blog.csdn.net/qcyfred/article/details/77529016" target="_blank" rel="noopener">https://blog.csdn.net/qcyfred/article/details/77529016</a></p></blockquote><pre><code class="py">import ctypeswhnd = ctypes.windll.kernel32.GetConsoleWindow()if whnd != 0:    ctypes.windll.user32.ShowWindow(whnd, 0)    ctypes.windll.kernel32.CloseHandle(whnd)</code></pre><a id="more"></a><h1 id="使用-bat-隐藏窗口"><a href="#使用-bat-隐藏窗口" class="headerlink" title="使用 bat 隐藏窗口"></a>使用 bat 隐藏窗口</h1><pre><code class="bat">@echo offif &quot;%1&quot;==&quot;h&quot; goto beginstart mshta vbscript:createobject(&quot;wscript.shell&quot;).run(&quot;&quot;&quot;%~nx0&quot;&quot; h&quot;,0)(window.close)&amp;&amp;exit:begincd F:\pythonF:python test.py</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 获取本机 IP 地址</title>
      <link href="/2018/09/15/Python%20%E8%8E%B7%E5%8F%96%E6%9C%AC%E6%9C%BA%20IP%20%E5%9C%B0%E5%9D%80/"/>
      <url>/2018/09/15/Python%20%E8%8E%B7%E5%8F%96%E6%9C%AC%E6%9C%BA%20IP%20%E5%9C%B0%E5%9D%80/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://blog.csdn.net/u013314786/article/details/78962103" target="_blank" rel="noopener">https://blog.csdn.net/u013314786/article/details/78962103</a></p></blockquote><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>通常使用 socket.gethostbyname() 方法即可获取本机IP地址，<strong>但有时候获取不到</strong>(比如没有正确设置主机名称)，示例代码如下：</p><pre><code class="py">import socket# 获取本机计算机名称hostname = socket.gethostname()# 获取本机ipip = socket.gethostbyname(hostname)print(ip)</code></pre><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>可正确获取IP地址</p><pre><code class="py">import socketdef get_host_ip():    &quot;&quot;&quot;    查询本机ip地址    :return: ip    &quot;&quot;&quot;    try:        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)        s.connect((&#39;8.8.8.8&#39;, 80))        ip = s.getsockname()[0]    finally:        s.close()    return ipif __name__ == &#39;__main__&#39;:    print(get_host_ip())</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MQTT 介绍</title>
      <link href="/2018/09/14/MQTT%20%E4%BB%8B%E7%BB%8D/"/>
      <url>/2018/09/14/MQTT%20%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="MQTT-协议介绍"><a href="#MQTT-协议介绍" class="headerlink" title="MQTT 协议介绍"></a>MQTT 协议介绍</h1><p>MQTT（Message Queuing Telemetry Transport，消息队列遥测传输）是IBM开发的一个即时通讯协议，它是一种轻量级的、基于代理的“发布/订阅”模式的<strong>消息传输协议</strong>。其具有协议<strong>简洁、小巧、可扩展性强、省流量、省电</strong>等优点，而且已经有 PHP，JAVA，Python，C，C#，Go 等多个语言版本，还有<a href="https://github.com/tennessine/paho.mqtt.wxapp" target="_blank" rel="noopener">微信小程序版</a>，基本可以使用在任何平台上，几乎可以把所有联网物品和外部连接起来，所以特别适合用来当做物联网的通信协议，实用的场景有遥感数据、汽车、智能家居、智慧城市、医疗医护等等。</p><a id="more"></a><h1 id="MQTT-特点"><a href="#MQTT-特点" class="headerlink" title="MQTT 特点"></a>MQTT 特点</h1><p>MQTT 协议是为大量计算能力有限，且工作在低带宽、不可靠的网络的远程传感器和控制设备通讯而设计的协议，它具有以下主要的几项特性：</p><ol><li><p>使用发布/订阅消息模式，提供一对多的消息发布，解除应用程序耦合；</p></li><li><p>对负载内容屏蔽的消息传输；</p></li><li><p>使用 TCP/IP 提供网络连接；</p></li><li><p>有三种消息发布服务质量：</p><ul><li>“至多一次”（qos = 0），消息发布完全依赖底层 TCP/IP 网络。会发生消息丢失或重复。这一级别可用于如下情况，环境传感器数据，丢失一次读记录无所谓，因为不久后还会有第二次发送。</li><li>“至少一次”（qos = 1），确保消息到达，但消息重复可能会发生。</li><li>“只有一次”（qos = 2），确保消息到达一次。这一级别可用于如下情况，在计费系统中，消息重复或丢失会导致不正确的结果。</li></ul></li><li><p>小型传输，开销很小（固定长度的头部是 2 字节），协议交换最小化，以降低网络流量；</p></li><li><p>使用 Last Will （遗嘱）和 Testament 特性通知有关各方客户端异常中断的机制；</p></li></ol><h1 id="消息模型"><a href="#消息模型" class="headerlink" title="消息模型"></a>消息模型</h1><p>MQTT 是一种基于代理的发布/订阅的消息协议。与请求/回答这种同步模式不同，发布/订阅模式解耦了发布消息的客户（发布者）与订阅消息的客户（订阅者）之间的关系，这意味着发布者和订阅者之间并不需要直接建立联系。一个发布者可以对应多个订阅者，当发布者发生变化的时候，他可以将消息一一通知给所有的订阅者。这种模式提供了更大的网络扩展性和更动态的网络拓扑</p><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/5210585-2f3b0a8548472bb2.png" alt="消息模型"></p><h1 id="主题与通配符"><a href="#主题与通配符" class="headerlink" title="主题与通配符"></a>主题与通配符</h1><p>主题名称（Topic name）用来标识已发布消息的信息的渠道。订阅者用它来确定接收到所关心的信息。它是一个分层的结构，用斜线“/”作为分隔符（这个有点类似于restful风格）。主题还可以通过通配符进行过滤。其中，+可以过滤一个层级，而#只能出现在主题最后表示过滤任意级别的层级。值得注意的是MQTT允许使用通配符订阅主题，但是并不允许使用通配符广播。</p><p>举个例子：</p><pre><code>`building-b/floor-5`：代表B楼5层的设备。`+/floor-5`：代表任何一个楼的5层的设备。`building-b/#`：代表B楼所有的设备。</code></pre><h1 id="遗嘱"><a href="#遗嘱" class="headerlink" title="遗嘱"></a>遗嘱</h1><p>当一个客户端断开连接的时候，它希望客户端可以发送它指定的消息。该消息和普通消息的结构相同。通过设置该位并填入和信息相关的内容即可（<a href="https://www.jianshu.com/p/3d5b487c6860" target="_blank" rel="noopener">后面会有介绍</a>）。</p><h1 id="消息类型"><a href="#消息类型" class="headerlink" title="消息类型"></a>消息类型</h1><table><thead><tr><th align="center">消息类型</th><th align="center">类型</th><th align="center">编码说明</th></tr></thead><tbody><tr><td align="center">reserved</td><td align="center">0</td><td align="center">保留</td></tr><tr><td align="center">connect</td><td align="center">1</td><td align="center">客户端到服务端的连接请求</td></tr><tr><td align="center">connACK</td><td align="center">2</td><td align="center">服务端对连接请求的响应</td></tr><tr><td align="center">publish</td><td align="center">3</td><td align="center">发布消息</td></tr><tr><td align="center">puback</td><td align="center">4</td><td align="center">新发布消息确认，是 QoS 1 给 PUBLISH 消息的回复</td></tr><tr><td align="center">pubRec</td><td align="center">5</td><td align="center">QoS 2 消息流的第一部分，表示消息发布已记录</td></tr><tr><td align="center">pubRel</td><td align="center">6</td><td align="center">QoS 2 消息流的第二部分，表示消息发布已释放</td></tr><tr><td align="center">pubComp</td><td align="center">7</td><td align="center">QoS 2 消息流的第三部分，表示消息发布完</td></tr><tr><td align="center">subscribe</td><td align="center">8</td><td align="center">客户端订阅某个主题</td></tr><tr><td align="center">subBack</td><td align="center">9</td><td align="center">对于 SUBSCRIBE 消息的确认</td></tr><tr><td align="center">unsubscribe</td><td align="center">10</td><td align="center">客户端终止订阅的消息</td></tr><tr><td align="center">unsubBack</td><td align="center">11</td><td align="center">对于 UNSUBSCRIBE 消息的确认</td></tr><tr><td align="center">pingReq</td><td align="center">12</td><td align="center">心跳</td></tr><tr><td align="center">pingResp</td><td align="center">13</td><td align="center">确认心跳</td></tr><tr><td align="center">disconnect</td><td align="center">14</td><td align="center">客户端终止连接前通知 MQTT 代理</td></tr><tr><td align="center">reserved</td><td align="center">15</td><td align="center">保留</td></tr></tbody></table><h1 id="MQTT-服务端-mosquito"><a href="#MQTT-服务端-mosquito" class="headerlink" title="MQTT 服务端-mosquito"></a>MQTT 服务端-mosquito</h1><p>MQTT 服务端还有，<a href="https://activemq.apache.org/apollo/" target="_blank" rel="noopener">Apache Apollo</a> 是一个代理服务器，其是在 ActiveMQ 基础上发展而来的，可以支持多种协议，如： STOMP、AMQP、MQTT、SSL 等。查看<a href="https://www.jianshu.com/p/3d5b487c6860" target="_blank" rel="noopener">原文</a>可看到介绍。</p><p><a href="https://mosquitto.org/" target="_blank" rel="noopener">Mosquitto</a> 是一款实现了 MQTT v3.1 协议的开源消息代理软件，提供轻量级的，支持发布/订阅的的消息推送模式，使设备对设备之间的短消息通信简单易用。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>windows 下安装可参考这篇文章：<a href="http://www.steves-internet-guide.com/install-mosquitto-broker/" target="_blank" rel="noopener">How to Install The Mosquitto MQTT Broker on Windows</a></p><p>主要问题是：缺少 Win32OpenSSL 的 SSLEAY32.dll，LIBEAY32.dll，在其提供的<a href="http://slproweb.com/products/Win32OpenSSL.html" target="_blank" rel="noopener">下载链接</a>，也没有找到这两个文件。最后在电脑中其他文件夹（如 QQ 的文件夹）中找到这两个文件，并把这两个文件的文件名改成大写，放在 Mosquitto 的安装目录中，并重新安装解决了问题。</p><p>因为下文中需要使用 mosquitto_sub.exe，mosquitto_pub.exe，进行发布接收测试，所以这里需要下载 <a href="ftp://sources.redhat.com/pub/pthreads-win32/dll-latest/dll/x86/" target="_blank" rel="noopener">pthreadVC2.dll</a></p><p>安装完成后，在 windows 服务中找到 mosquitto 并启动 mosquitto 服务，可以将起设置为自动启动。也可以使用命令 <code>sc start mosquitto</code> 启动服务。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="订阅主题"><a href="#订阅主题" class="headerlink" title="订阅主题"></a>订阅主题</h3><pre><code class="cmd">mosquitto_sub -v -t topicTest01</code></pre><p>-v：打印更多调试信息</p><p>-t：指定主题，此处为 topicTest01</p><h3 id="发布内容"><a href="#发布内容" class="headerlink" title="发布内容"></a>发布内容</h3><p>新打开一个 cmd 窗口</p><pre><code class="cmd">mosquitto_pub -t topicTest01 -m TestMessage</code></pre><p>-t：指定主题</p><p>-m：指定消息内容</p><h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><p>发布消息后，在订阅主题的窗口中订阅这收到了主题为 topicTest01 的 TestMessage 消息。</p><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>如果不想让 mosquitto 作为 windows 服务启动，可以手动启动。</p><p>使用 <code>mosquitto -h</code> 命令查看帮助</p><pre><code class="cmd">PS D:\mosquitto&gt; .\mosquitto -hmosquitto version 1.4.15 (build date 23/03/2018 10:26:57.31)mosquitto is an MQTT v3.1.1/v3.1 broker.Usage: mosquitto [-c config_file] [-d] [-h] [-p port] -c : specify the broker config file. -d : put the broker into the background after starting. -h : display this help. -p : start the broker listening on the specified port.      Not recommended in conjunction with the -c option. -v : verbose mode - enable all logging types. This overrides      any logging options given in the config file.可以查看到更多的日志信息See http://mosquitto.org/ for more information.</code></pre><h2 id="配置文件-mosquitto-conf"><a href="#配置文件-mosquitto-conf" class="headerlink" title="配置文件 mosquitto.conf"></a>配置文件 mosquitto.conf</h2><p>默认配置文件 mosquitto.conf，在启动时可以使用命令 <code>mosquitto -c 配置文件</code> 更改要使用的配置文件。</p><p>配置文件里面有很多配置项，基本只用修改以下两个，其余默认即可。</p><pre><code class="conf"># 服务绑定的 IP 地址bind_address 127.0.0.1# 服务绑定的端口号port 1883</code></pre><h2 id="设置帐号和密码"><a href="#设置帐号和密码" class="headerlink" title="设置帐号和密码"></a>设置帐号和密码</h2><blockquote><p><a href="https://www.jianshu.com/p/4b545332b495" target="_blank" rel="noopener">https://www.jianshu.com/p/4b545332b495</a></p></blockquote><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><pre><code class="conf"># 禁止匿名登录allow_anonymous false# 设置帐号密码文件password_file 帐号密码文件全路径（pwfile.example）# 设置a cl 文件acl_file acl文件路径（aclfile.example）</code></pre><h3 id="帐号密码文件编写（pwfile-example）"><a href="#帐号密码文件编写（pwfile-example）" class="headerlink" title="帐号密码文件编写（pwfile.example）"></a>帐号密码文件编写（pwfile.example）</h3><pre><code class="example">admin:123</code></pre><p>编写格式:用户名:密码(可以多行)上图例子就是帐号 admin,密码 123</p><p>编写完毕后,需要执行命令 <code>mosquitto_passwd -U</code> 帐号密码文件全路径，对帐号密码进行TLS加密才会生效</p><h3 id="cal-文件编写（aclfile-example）"><a href="#cal-文件编写（aclfile-example）" class="headerlink" title="cal 文件编写（aclfile.example）"></a>cal 文件编写（aclfile.example）</h3><pre><code class="example"># ACL权限配置，常用语法如下：# 用户限制：user# 话题限制：topic [read|write]# 正则限制：pattern write sensor/%u/data# This affects access control for clients with no username.topic read $SYS/## This only affects clients with username &quot;roger&quot;.user rogertopic foo/baruser admintopic write chat/#user admintopic read chat/## This affects all clients.pattern write $SYS/broker/connection/%c/state</code></pre><p>编写格式: <code>user 用户名 topic read/write 具体的主题(可使用通配符)</code></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote><p><a href="https://www.jianshu.com/p/3d5b487c6860" target="_blank" rel="noopener">https://www.jianshu.com/p/3d5b487c6860</a><br><a href="https://www.jianshu.com/p/4b545332b495" target="_blank" rel="noopener">https://www.jianshu.com/p/4b545332b495</a><br><a href="http://www.steves-internet-guide.com/install-mosquitto-broker/" target="_blank" rel="noopener">How to Install The Mosquitto MQTT Broker on Windows</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQTT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows 常用 bat 脚本</title>
      <link href="/2018/09/14/Windows%20%E5%B8%B8%E7%94%A8%20bat%20%E8%84%9A%E6%9C%AC/"/>
      <url>/2018/09/14/Windows%20%E5%B8%B8%E7%94%A8%20bat%20%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h1 id="Windows-bat-脚本获取-administrator-权限"><a href="#Windows-bat-脚本获取-administrator-权限" class="headerlink" title="Windows bat 脚本获取 administrator 权限"></a>Windows bat 脚本获取 administrator 权限</h1><blockquote><p><a href="https://blog.csdn.net/ssshen14/article/details/77815950" target="_blank" rel="noopener">https://blog.csdn.net/ssshen14/article/details/77815950</a></p></blockquote><pre><code class="bat">@echo offecho 获取Administrator权限cacls.exe &quot;%SystemDrive%/System Volume Information&quot; &gt;nul 2&gt;nulif %errorlevel%==0 goto Adminset vbsFile=&quot;%temp%\getadmin.vbs&quot;IF EXIST %vbsFile%  (del /f /q %vbsFile%)echo Set RequestUAC = CreateObject^(&quot;Shell.Application&quot;^) &gt; %vbsFile%echo RequestUAC.ShellExecute &quot;%~s0&quot;,&quot;&quot;,&quot;&quot;,&quot;runas&quot;,1 &gt;&gt; %vbsFile%echo WScript.Quit &gt;&gt; %vbsFile%%vbsFile%  /fIF EXIST %vbsFile%  (del /f /q %vbsFile%)exit:Adminecho 成功取得Administrator权限:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::     以下为需要运行的批处理文件代码     :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::@echo oncd /d %~dp0sc delete Face_MasterControl</code></pre><a id="more"></a><h1 id="使用-bat-隐藏窗口"><a href="#使用-bat-隐藏窗口" class="headerlink" title="使用 bat 隐藏窗口"></a>使用 bat 隐藏窗口</h1><pre><code class="bat">@echo offif &quot;%1&quot;==&quot;h&quot; goto beginstart mshta vbscript:createobject(&quot;wscript.shell&quot;).run(&quot;&quot;&quot;%~nx0&quot;&quot; h&quot;,0)(window.close)&amp;&amp;exit:begincd F:\pythonF:python test.py</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 常用 SQL</title>
      <link href="/2018/09/13/MySQL%20%E5%B8%B8%E7%94%A8%20SQL/"/>
      <url>/2018/09/13/MySQL%20%E5%B8%B8%E7%94%A8%20SQL/</url>
      
        <content type="html"><![CDATA[<h2 id="使用-mysql-的-replace-函数替换字符串"><a href="#使用-mysql-的-replace-函数替换字符串" class="headerlink" title="使用 mysql 的 replace 函数替换字符串"></a>使用 mysql 的 replace 函数替换字符串</h2><p>比如你要将 表 tb1 里面的 f1 字段的 abc 替换为 def</p><pre><code class="sql">UPDATE tb1 SET f1=REPLACE(f1, &#39;abc&#39;, &#39;def&#39;);</code></pre><a id="more"></a><h2 id="把一张表插入到另一张表"><a href="#把一张表插入到另一张表" class="headerlink" title="把一张表插入到另一张表"></a>把一张表插入到另一张表</h2><p>如果2张表的字段一致，并且希望插入全部数据，可以用这种方法：</p><pre><code class="sql">insert into insertTest select * from insertTest2;</code></pre><p>如果只希望导入指定字段，可以用这种方法，注意字段的顺序必须一致：</p><pre><code class="sql">insert into insertTest2(id) select id from insertTest2;</code></pre><p>如果您需要只导入目标表中不存在的记录，可以使用这种方法：</p><pre><code class="sql">INSERT INTO insertTest2 (id, NAME) SELECT    id,    NAMEFROM    insertTestWHERE    NOT EXISTS (        SELECT            *        FROM            insertTest2        WHERE            insertTest2.id = insertTest.id    );</code></pre><h2 id="强制-MySQL-使用某个索引"><a href="#强制-MySQL-使用某个索引" class="headerlink" title="强制 MySQL 使用某个索引"></a>强制 MySQL 使用某个索引</h2><blockquote><p><a href="https://stackoverflow.com/questions/11731822/how-to-hint-the-index-to-use-in-a-mysql-select-query" target="_blank" rel="noopener">https://stackoverflow.com/questions/11731822/how-to-hint-the-index-to-use-in-a-mysql-select-query</a></p></blockquote><pre><code class="sql">SELECT * FROM your_table USE INDEX (i_iln) WHERE ....</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 常见错误</title>
      <link href="/2018/09/13/Python%20%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/"/>
      <url>/2018/09/13/Python%20%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="ValueError-too-many-values-to-unpack"><a href="#ValueError-too-many-values-to-unpack" class="headerlink" title="ValueError: too many values to unpack"></a>ValueError: too many values to unpack</h1><p>这种错误是指一个 tuple 值赋给一个 tuple 变量时，变量个数不够造成的。如：</p><pre><code class="py">a, b = (1, 2, 3)</code></pre><a id="more"></a><h1 id="RuntimeError-dictionary-changed-size-during-iteration"><a href="#RuntimeError-dictionary-changed-size-during-iteration" class="headerlink" title="RuntimeError: dictionary changed size during iteration"></a>RuntimeError: dictionary changed size during iteration</h1><blockquote><p><a href="https://stackoverflow.com/questions/11941817/how-to-avoid-runtimeerror-dictionary-changed-size-during-iteration-error/11941855#11941855" target="_blank" rel="noopener">https://stackoverflow.com/questions/11941817/how-to-avoid-runtimeerror-dictionary-changed-size-during-iteration-error/11941855#11941855</a></p></blockquote><pre><code class="py">d = {&#39;a&#39;: [1], &#39;b&#39;: [1, 2], &#39;c&#39;: [], &#39;d&#39;:[]}for i in d:    if not d[i]:        d.pop(i)Traceback (most recent call last):  File &quot;F:/python/testtwisted/test/t.py&quot;, line 6, in &lt;module&gt;    for i in d:RuntimeError: dictionary changed size during iteration</code></pre><p>Python 2.x:</p><pre><code class="py">for i in d.keys():</code></pre><p>Python 3.x:</p><p>Python 3.x 中 keys 返回一个迭代器而不是列表，所以不能使用 keys 方法。可以使用 list 来强制生成 key 的副本。</p><pre><code class="py">for i in list(d):</code></pre><h1 id="json-decoder-JSONDecodeError-Expecting-property-name-enclosed-in-double-quotes-line-1-column-2-char-1"><a href="#json-decoder-JSONDecodeError-Expecting-property-name-enclosed-in-double-quotes-line-1-column-2-char-1" class="headerlink" title="json.decoder.JSONDecodeError: Expecting property name enclosed in double quotes: line 1 column 2 (char 1)"></a>json.decoder.JSONDecodeError: Expecting property name enclosed in double quotes: line 1 column 2 (char 1)</h1><pre><code class="py">import jsonstring = &quot;{&#39;lat&#39;: 61.190495, &#39;lng&#39;: -149.86884}&quot;dic = json.loads(string)</code></pre><p>报错，类型的错误，就是由于JSON中，标准语法中，不支持单引号，属性或者属性值，都必须是双引号括起来的。</p><pre><code class="py">import jsonstring = &#39;{&quot;lat&quot;: 61.190495, &quot;lng&quot;: -149.86884}&#39;dic = json.loads(string)</code></pre><h1 id="TypeError-not-enough-arguments-for-format-string"><a href="#TypeError-not-enough-arguments-for-format-string" class="headerlink" title="TypeError: not enough arguments for format string"></a>TypeError: not enough arguments for format string</h1><p>后面给的参数，不能是 set，要是元组或列表的形式</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL any all操作符</title>
      <link href="/2018/09/12/mysql%20any%20all%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
      <url>/2018/09/12/mysql%20any%20all%E6%93%8D%E4%BD%9C%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="ANY-SOME-ALL"><a href="#ANY-SOME-ALL" class="headerlink" title="ANY, SOME, ALL"></a>ANY, SOME, ALL</h1><p>用法：</p><pre><code class="sql">operand comparison_operator ANY (子查询)operand comparison_operator SOME (子查询)operand comparison_operator ALL (子查询)</code></pre><p>comparison_operator 是这些中的一个 <code>=  &gt;  &lt;  &gt;=  &lt;=  &lt;&gt;  !=</code></p><a id="more"></a><h1 id="ANY-SOME"><a href="#ANY-SOME" class="headerlink" title="ANY, SOME"></a>ANY, SOME</h1><p>some 关键字和 any 关键字是一样的功能</p><p>假设 any 内部的查询语句返回的结果个数是三个，如：result1,result2,result3，那么，</p><pre><code class="sql">select ...from ... where a &gt; any(...);-&gt;select ...from ... where a &gt; result1 or a &gt; result2 or a &gt; result3;</code></pre><p>语句 <code>in</code> 与 <code>=any</code> 是相同的。</p><p><code>not in</code> 是 <code>&lt;&gt;all</code> 的别名，用法相同。</p><blockquote><p><a href="https://dev.mysql.com/doc/refman/8.0/en/any-in-some-subqueries.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/8.0/en/any-in-some-subqueries.html</a></p></blockquote><h1 id="ALL"><a href="#ALL" class="headerlink" title="ALL"></a>ALL</h1><p>ALL 关键字与 any 关键字类似，只不过上面的 or 改成 and。即：</p><pre><code class="sql">select ...from ... where a &gt; all(...);-&gt;select ...from ... where a &gt; result1 and a &gt; result2 and a &gt; result3;</code></pre><blockquote><p><a href="https://dev.mysql.com/doc/refman/8.0/en/all-subqueries.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/8.0/en/all-subqueries.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IntelliJ IDEA 快捷键</title>
      <link href="/2018/09/09/IntelliJ%20IDEA%20%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/2018/09/09/IntelliJ%20IDEA%20%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="创建-main-函数快捷"><a href="#创建-main-函数快捷" class="headerlink" title="创建 main 函数快捷"></a>创建 main 函数快捷</h1><p><code>**psvm**</code> 也就是 <code>public static void main</code> 的首字母。</p><p>其他相关快捷键</p><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20180703210706.png" alt=""></p><ul><li><code>psf</code>：public static final</li><li><code>psfi</code>：public static final int</li><li><code>psfs</code>：public static final String</li></ul><a id="more"></a><h1 id="for-循环，foreach"><a href="#for-循环，foreach" class="headerlink" title="for 循环，foreach"></a>for 循环，foreach</h1><pre><code class="shell">fori    for 循环iter    Iterate (for each..in)itli    Iterate over a Listitar    Iterate elements of arrayritar   Iterate elements of array 倒序</code></pre><p>使用 <code>变量名.for</code> 更方便</p><pre><code class="java">List&lt;String&gt; ss = new ArrayList&lt;&gt;();ss.for  // for eachss.fori  // for (int i = 0; i &lt; ss.size(); i++) { }ss.forr  // for (int i = ss.size() - 1; i &gt;= 0; i--) { }100.fori  // for (int i = 0; i &lt; 100; i++) { }100.forr  // for (int i = 100; i &gt; 0; i--) { }</code></pre><h1 id="打印控制台"><a href="#打印控制台" class="headerlink" title="打印控制台"></a>打印控制台</h1><pre><code class="java">souf     System.out.printf(&quot;&quot;);sout     System.out.println();soutm    System.out.println(&quot;T.main&quot;);soutp    System.out.println(&quot;args = [&quot; + args + &quot;]&quot;);soutv    System.out.println(&quot;args = &quot; + args);</code></pre><p><strong>更多的提示可以 <code>Ctrl + j</code> 可以查看。</strong></p><h1 id="自动补全返回值，自动补全变量名称和属性名称"><a href="#自动补全返回值，自动补全变量名称和属性名称" class="headerlink" title="自动补全返回值，自动补全变量名称和属性名称"></a>自动补全返回值，自动补全变量名称和属性名称</h1><blockquote><p><a href="https://blog.csdn.net/u010372981/article/details/78360730" target="_blank" rel="noopener">https://blog.csdn.net/u010372981/article/details/78360730</a></p></blockquote><p>Ctrl + Alt + v</p><h1 id="从接口跳转到-Java-中的实现类"><a href="#从接口跳转到-Java-中的实现类" class="headerlink" title="从接口跳转到 Java 中的实现类"></a>从接口跳转到 Java 中的实现类</h1><blockquote><p><a href="https://stackoverflow.com/questions/5051766/intellij-idea-jump-from-interface-to-implementing-class-in-java" target="_blank" rel="noopener">https://stackoverflow.com/questions/5051766/intellij-idea-jump-from-interface-to-implementing-class-in-java</a></p></blockquote><p>Ctrl + Alt + B</p><h1 id="跳到父类接口"><a href="#跳到父类接口" class="headerlink" title="跳到父类接口"></a>跳到父类接口</h1><p>Ctrl + U</p><h1 id="清除无效-import"><a href="#清除无效-import" class="headerlink" title="清除无效 import"></a>清除无效 import</h1><p>Ctrl + Alt + O</p><h1 id="格式化代码"><a href="#格式化代码" class="headerlink" title="格式化代码"></a>格式化代码</h1><p>Ctrl + Alt + L</p><h1 id="大小写切换"><a href="#大小写切换" class="headerlink" title="大小写切换"></a>大小写切换</h1><p>Ctrl + Shift + U</p><h1 id="生成返回值对象"><a href="#生成返回值对象" class="headerlink" title="生成返回值对象"></a>生成返回值对象</h1><p>Ctrl + Alt + V</p><p>把光标移动到需要生成返回值变量的语句之前，右键 Refactor --&gt; Extract --&gt; Variable</p><h1 id="移动窗口分隔线"><a href="#移动窗口分隔线" class="headerlink" title="移动窗口分隔线"></a>移动窗口分隔线</h1><p>某个类的名字在 project 视图里被挡住了某一部分。</p><p>想完整的看到类的名字，一般都是使用鼠标来移动分割线，但是这样子效率太低了。可以使用 <code>Alt + 1</code> 把鼠标焦点定位到 project 视图里，然后直接使用 <code>Ctrl + Shift + 左右箭头</code> 来移动分割线。</p><h1 id="Complete-Current-Statement-完成当前语句"><a href="#Complete-Current-Statement-完成当前语句" class="headerlink" title="Complete Current Statement 完成当前语句"></a>Complete Current Statement 完成当前语句</h1><p>Ctrl + Shift + Enter</p><p>比如会自动添加分号，输入 if 后按下 <code>Ctrl + Shift + Enter</code>，会自动生成</p><pre><code class="java">if () {}</code></pre><h1 id="快速查看类定义"><a href="#快速查看类定义" class="headerlink" title="快速查看类定义"></a>快速查看类定义</h1><p>在类上面按下 <code>Ctrl + Shift + i</code>，会弹出小窗口</p><h1 id="列出变量在哪些地方被使用"><a href="#列出变量在哪些地方被使用" class="headerlink" title="列出变量在哪些地方被使用"></a>列出变量在哪些地方被使用</h1><p>Alt + f7</p><h1 id="智能提示"><a href="#智能提示" class="headerlink" title="智能提示"></a>智能提示</h1><p>Ctrl + Shift + Space</p><p>例如：<code>User user = new</code>，按下 <code>Ctrl + Shift + Space</code>，将自动补全 <code>User user = new User();</code></p><h1 id="参数提示"><a href="#参数提示" class="headerlink" title="参数提示"></a>参数提示</h1><p>Ctrl + P</p><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20190613143334.png" alt="参数提示"></p><h1 id="快捷键使用频率"><a href="#快捷键使用频率" class="headerlink" title="快捷键使用频率"></a>快捷键使用频率</h1><p>Help | Productivity Guide 打开。</p><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20190613152029.png" alt="Productivity Guide"></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IntelliJ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IntelliJ IDEA 使用记录</title>
      <link href="/2018/09/06/IntelliJ%20IDEA%20%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/"/>
      <url>/2018/09/06/IntelliJ%20IDEA%20%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="快速定位当前文件路径"><a href="#快速定位当前文件路径" class="headerlink" title="快速定位当前文件路径"></a>快速定位当前文件路径</h1><blockquote><p><a href="https://www.cnblogs.com/apollo-shen/p/7619805.html" target="_blank" rel="noopener">https://www.cnblogs.com/apollo-shen/p/7619805.html</a></p></blockquote><p>点击项目工程上的“狙击”图标，自动定位到文件所在位置</p><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/928339-20171002105517927-12623078.png" alt=""></p><p>方法二：</p><p>可以先使用 alt+F1，弹出 Select in 视图，然后选择 Project View 中的 Project，回车，就可以立刻定位到类的位置了。</p><a id="more"></a><h1 id="IDEA-打开带-SVN-信息的项目不显示-SVN-信息"><a href="#IDEA-打开带-SVN-信息的项目不显示-SVN-信息" class="headerlink" title="IDEA 打开带 SVN 信息的项目不显示 SVN 信息"></a>IDEA 打开带 SVN 信息的项目不显示 SVN 信息</h1><blockquote><p><a href="https://blog.csdn.net/machao0903/article/details/73369055" target="_blank" rel="noopener">https://blog.csdn.net/machao0903/article/details/73369055</a></p></blockquote><p>在 <code>VCS 菜单</code>中有个开关，叫 <code>Enabled Version Control Integration</code>，在打开的窗口的选项中选择 <code>Subversion</code> 即可</p><h1 id="IDEA-自动清除无效-import"><a href="#IDEA-自动清除无效-import" class="headerlink" title="IDEA 自动清除无效 import"></a>IDEA 自动清除无效 import</h1><blockquote><p><a href="https://blog.csdn.net/u012883534/article/details/79801829" target="_blank" rel="noopener">https://blog.csdn.net/u012883534/article/details/79801829</a></p></blockquote><p>快捷键: <code>ctrl + alt + o</code></p><p>自动清除的配置方法: 可以 <code>settings --&gt; general --&gt; auto import --&gt; java</code> 项，勾选 <code>optimize imports on the fly</code>，在当前项目下会自动清除无效的 import，而且这个是随时自动清除的。</p><h1 id="IDEA-修改默认的全局设置"><a href="#IDEA-修改默认的全局设置" class="headerlink" title="IDEA 修改默认的全局设置"></a>IDEA 修改默认的全局设置</h1><p>File菜单 --&gt; Other Settings --&gt; Settings for New Projects...</p><h1 id="maven"><a href="#maven" class="headerlink" title="maven"></a>maven</h1><h2 id="IDEA-中修改-maven-为国内镜像（阿里）"><a href="#IDEA-中修改-maven-为国内镜像（阿里）" class="headerlink" title="IDEA 中修改 maven 为国内镜像（阿里）"></a>IDEA 中修改 maven 为国内镜像（阿里）</h2><blockquote><p><a href="https://blog.csdn.net/liangyihuai/article/details/57406870" target="_blank" rel="noopener">https://blog.csdn.net/liangyihuai/article/details/57406870</a></p></blockquote><p>File --&gt; Settings --&gt; Build, Execution, Deployment --&gt; Build Tools --&gt; Maven</p><p>修改 <code>User settings file</code> 并 选中 Override</p><p>可以新建一个，<code>settings.xml</code> 文件下的内容是</p><pre><code class="xml">&lt;settings xmlns=&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;      xsi:schemaLocation=&quot;http://maven.apache.org/SETTINGS/1.0.0                          https://maven.apache.org/xsd/settings-1.0.0.xsd&quot;&gt;      &lt;mirrors&gt;        &lt;mirror&gt;            &lt;id&gt;alimaven&lt;/id&gt;            &lt;name&gt;aliyun maven&lt;/name&gt;            &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;            &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;        &lt;/mirror&gt;      &lt;/mirrors&gt;&lt;/settings&gt;</code></pre><h2 id="设置-maven-自动下载源码"><a href="#设置-maven-自动下载源码" class="headerlink" title="设置 maven 自动下载源码"></a>设置 maven 自动下载源码</h2><p>File --&gt; Setting --&gt; Build, Execution, Deployment --&gt; Build Tools --&gt; Maven --&gt; Importing</p><h2 id="丢失代码源文件夹下配置文件"><a href="#丢失代码源文件夹下配置文件" class="headerlink" title="丢失代码源文件夹下配置文件"></a>丢失代码源文件夹下配置文件</h2><p>使用 MyBatis 时，发现编译后的 classes 文件夹（或者 war 包）对应的目录根本没有相应的 xml 配置文件。</p><p><a href="https://blog.csdn.net/Quincylk/article/details/51539628" target="_blank" rel="noopener">解决方式</a>是，在 pom.xml 文件中的 build 节点中，添加如下代码：</p><pre><code class="xml">&lt;build&gt;  &lt;resources&gt;    &lt;resource&gt;      &lt;directory&gt;src/main/java&lt;/directory&gt;        &lt;includes&gt;          &lt;include&gt;**/*.properties&lt;/include&gt;          &lt;include&gt;**/*.xml&lt;/include&gt;        &lt;/includes&gt;      &lt;filtering&gt;true&lt;/filtering&gt;    &lt;/resource&gt;  &lt;/resources&gt;&lt;/build&gt;</code></pre><!-- more --><h2 id="MalformedByteSequenceException-3-字节的-UTF-8-序列的字节-3-无效。"><a href="#MalformedByteSequenceException-3-字节的-UTF-8-序列的字节-3-无效。" class="headerlink" title="MalformedByteSequenceException:3 字节的 UTF-8 序列的字节 3 无效。"></a>MalformedByteSequenceException:3 字节的 UTF-8 序列的字节 3 无效。</h2><p><a href="https://blog.csdn.net/cherrycheng_/article/details/51242149" target="_blank" rel="noopener">解决办法</a>：</p><ol><li>检查 xml 的头文件和右键属性里面的编码是否一致</li><li>尝试在 pom.xml 加入如下配置：</li></ol><pre><code class="xml">&lt;build&gt;  &lt;resources&gt;    &lt;resource&gt;        &lt;directory&gt;src/main/resources&lt;/directory&gt;        &lt;filtering&gt;true&lt;/filtering&gt;    &lt;/resource&gt;  &lt;/resources&gt;  &lt;plugins&gt;    &lt;plugin&gt;      &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;      &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;      &lt;configuration&gt;        &lt;encoding&gt;UTF-8&lt;/encoding&gt;      &lt;/configuration&gt;    &lt;/plugin&gt;  &lt;/plugins&gt;&lt;/build&gt;</code></pre><h1 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h1><h2 id="IDEA-提示找不到符号，或程序包不存在"><a href="#IDEA-提示找不到符号，或程序包不存在" class="headerlink" title="IDEA 提示找不到符号，或程序包不存在"></a>IDEA 提示找不到符号，或程序包不存在</h2><blockquote><p><a href="https://blog.csdn.net/A_Runner/article/details/79296757" target="_blank" rel="noopener">https://blog.csdn.net/A_Runner/article/details/79296757</a></p></blockquote><p>快捷键：<code>ctrl + shift +alt + s</code> 打开 <code>Project Structure</code></p><p>点击 <code>Project Structure–&gt; Modules</code> 选中你的项目的包文件，<code>Marks as Sources</code> 即可。</p><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20180801211504.png" alt=""></p><h2 id="IDEA-编译报错：Error-java-Compilation-failed-internal-java-compiler-error"><a href="#IDEA-编译报错：Error-java-Compilation-failed-internal-java-compiler-error" class="headerlink" title="IDEA 编译报错：Error:java: Compilation failed: internal java compiler error"></a>IDEA 编译报错：Error:java: Compilation failed: internal java compiler error</h2><blockquote><p><a href="https://blog.csdn.net/qq_27093465/article/details/53261939" target="_blank" rel="noopener">https://blog.csdn.net/qq_27093465/article/details/53261939</a></p></blockquote><p>报错内容：</p><pre><code class="java">Information:Using javac 1.8.0_73 to compile java sourcesInformation:java: javacTask: 源发行版 1.8 需要目标发行版 1.8Information:java: Errors occurred while compiling module &#39;EZSonar&#39;Information:Module &quot;EZSonar&quot; was fully rebuilt due to project configuration/dependencies changesInformation:2016/11/21 14:08 - Compilation completed with 1 error and 0 warnings in 5s 242msError:java: Compilation failed: internal java compiler error</code></pre><p>解决方法：设置 --&gt; Build, Execution, Deployment --&gt; Compiler --&gt; Java Compiler --&gt; Target bytecode version</p><p>要是 Module 下没有项目，就点击右边的把自己项目的模块添加上，选择自己项目需要的 jdk 对应版本。再次编译就可以啦。</p><h2 id="URI-is-not-registered-Setting-Project-Settings-Schemas-and-DTDs"><a href="#URI-is-not-registered-Setting-Project-Settings-Schemas-and-DTDs" class="headerlink" title="URI is not registered ( Setting | Project Settings | Schemas and DTDs )"></a>URI is not registered ( Setting | Project Settings | Schemas and DTDs )</h2><blockquote><p><a href="http://www.cnblogs.com/ttflove/p/6341469.html" target="_blank" rel="noopener">http://www.cnblogs.com/ttflove/p/6341469.html</a></p></blockquote><p>File --&gt; Settings --&gt; Languages &amp; Frameworks --&gt; Schemas and DTDs</p><p>在 Ignored Schemas and DTDs 中添加 URI。</p><p>也可以用快捷键。鼠标放到出错的的地方，alt+enter，选择 &quot;Ignored ...&quot; 。</p><h1 id="运行单个-main-方法，不编译整个工程"><a href="#运行单个-main-方法，不编译整个工程" class="headerlink" title="运行单个 main 方法，不编译整个工程"></a>运行单个 main 方法，不编译整个工程</h1><blockquote><p><a href="https://blog.csdn.net/m0_37355951/article/details/84798307" target="_blank" rel="noopener">https://blog.csdn.net/m0_37355951/article/details/84798307</a></p></blockquote><h1 id="去除-idea-中-xml-黄色背景"><a href="#去除-idea-中-xml-黄色背景" class="headerlink" title="去除 idea 中 xml 黄色背景"></a>去除 idea 中 xml 黄色背景</h1><p>在编写 mybatis 的 xml 中会出现大面积黄色背景提示。</p><ol><li>使用 idea 快捷键 <code>ctrl + alt+ s</code> 打开 Settings。找到 <code>Editor -&gt; Inspections</code> 的配置页面，去掉 <code>SQL</code> 中 <code>No data sources configured</code>（没有配置数据源） 选项 和 <code>SQL dialect detection</code>（SQL 方言检测） 选项，点击 OK。</li><li>继续打开 Settings。找到 <code>Editor -&gt; Colors &amp; Fonts -&gt; General</code> 的配置页面，选择 <code>Injected language fragment</code>，去掉 <code>Background</code> 选项，点击 OK。</li></ol><blockquote><p><a href="https://blog.csdn.net/u010318957/article/details/72459183" target="_blank" rel="noopener">https://blog.csdn.net/u010318957/article/details/72459183</a></p></blockquote><h1 id="自动生成-serialVersionUID"><a href="#自动生成-serialVersionUID" class="headerlink" title="自动生成 serialVersionUID"></a>自动生成 serialVersionUID</h1><p>File --&gt; Setting --&gt; Editor --&gt; Inspections --&gt; Serialization issues --&gt; Serializable class without &#39;serialVersionUID&#39; --&gt; 勾选操作</p><p>设置之后，当创建一个类并实现 Serializable 之后，在你的类名上：Alt+Enter 就会提示自动创建 serialVersionUID。</p><blockquote><p><a href="https://www.jianshu.com/p/d43d9acf949f" target="_blank" rel="noopener">https://www.jianshu.com/p/d43d9acf949f</a></p></blockquote><h1 id="自动生成-not-null-判断语句"><a href="#自动生成-not-null-判断语句" class="headerlink" title="自动生成 not null 判断语句"></a>自动生成 not null 判断语句</h1><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20190613133629.png" alt="自动生成 not null 判断语句"></p><p>变量. 后，直接输入 notnull 并回车，IDEA 就好自动生成 if 判断了。</p><pre><code class="java">if (user != null) {}</code></pre><h1 id="IntelliJ-IDEA-修改-Output-输出缓存区大小"><a href="#IntelliJ-IDEA-修改-Output-输出缓存区大小" class="headerlink" title="IntelliJ IDEA 修改 Output 输出缓存区大小"></a>IntelliJ IDEA 修改 Output 输出缓存区大小</h1><blockquote><p><a href="https://www.cnblogs.com/jeffen/p/6021149.html" target="_blank" rel="noopener">https://www.cnblogs.com/jeffen/p/6021149.html</a></p></blockquote><p>修改 <code>Override console cycle buffer size</code>（Settings --&gt; Editor --&gt; General --&gt; Console），单位为 KB</p><p>如果需要禁用缓存区大小限制就需要修改配置文件 <code>idea.properties</code></p><p>配置文件中原有设置：</p><pre><code class="ini">#---------------------------------------------------------------------# This option controls console cyclic buffer: keeps the console output size not higher than the specified buffer size (Kb).# Older lines are deleted. In order to disable cycle buffer use idea.cycle.buffer.size=disabled#---------------------------------------------------------------------idea.cycle.buffer.size=1024</code></pre><p>修改配置如下所示：</p><pre><code class="ini">idea.cycle.buffer.size=disabled</code></pre><h1 id="Tomcat-项目目录"><a href="#Tomcat-项目目录" class="headerlink" title="Tomcat 项目目录"></a>Tomcat 项目目录</h1><blockquote><p><a href="https://blog.csdn.net/HughGilbert/article/details/56424137" target="_blank" rel="noopener">https://blog.csdn.net/HughGilbert/article/details/56424137</a></p></blockquote><h2 id="CATALINA-HOME-与-CATALINA-BASE-的区别"><a href="#CATALINA-HOME-与-CATALINA-BASE-的区别" class="headerlink" title="CATALINA_HOME 与 CATALINA_BASE 的区别"></a>CATALINA_HOME 与 CATALINA_BASE 的区别</h2><ul><li><code>CATALINA_HOME</code> 即 Tomcat 的安装目录，<code>CATALINA_BASE</code> 是 Tomcat 的工作目录。如果同时运行多个 Tomcat 实例，通常会配置多个工作目录。每个 Tomcat 实例独占一个工作目录，但是共享一个安装目录。</li><li>Tomcat 每个运行实例需要使用自己的 conf、logs、temp、webapps、work 和 shared 目录，因此 <code>CATALINA_BASE</code> 就指向这些目录。而其他目录主要包括了 Tomcat 的二进制文件和脚本，<code>CATALINA_HOME</code> 就指向这些目录。IDEA 在每次重新启动 Tomcat 的时候都会重新建立或者说更新 Tomcat 工作目录的内容。</li></ul><p>IDEA 在每次启动Tomcat服务器的时候都会修改 CATALINA_BASE</p><pre><code class="log">Using CATALINA_BASE:   &quot;C:\Users\Administrator\.IntelliJIdea2018.3\system\tomcat\projectname&quot;Using CATALINA_HOME:   &quot;C:\Tomcat\apache-tomcat-8.0.9.1&quot;Using CATALINA_TMPDIR: &quot;C:\Tomcat\apache-tomcat-8.0.9.1\temp&quot;Using JRE_HOME:        &quot;C:\Program Files\Java\jdk1.7.0_80&quot;Using CLASSPATH:       &quot;C:\Tomcat\apache-tomcat-8.0.9.1\bin\bootstrap.jar;C:\Tomcat\apache-tomcat-8.0.9.1\bin\tomcat-juli.jar&quot;</code></pre><h2 id="Tomcat-服务器是如何找到-localhost-8080-页面的"><a href="#Tomcat-服务器是如何找到-localhost-8080-页面的" class="headerlink" title="Tomcat 服务器是如何找到 localhost:8080 页面的"></a>Tomcat 服务器是如何找到 localhost:8080 页面的</h2><ul><li><p>IDEA 根据CATALINA_HOME的启动Tomcat服务器</p></li><li><p>IDEA 在CATALINA_BASE指定的目录下生成项目独有的 conf、logs、work 等文件夹。</p></li><li><p>在 CATALINA_BASE 中的 conf 文件夹下，文件 <code>server.xml</code> 的 Host 标签指定了 Tomcat 的根目录（通常为 CATALINA_HOME\webapps），即在浏览器中显示的 localhost:8080 定位的就是此处。name 属性和 appBase 属性起到了一个映射的作用</p><pre><code class="xml">  &lt;Host name=&quot;localhost&quot; appBase=&quot;C:\Tomcat\apache-tomcat-8.0.9.1\webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot; deployOnStartup=&quot;false&quot; deployIgnore=&quot;^(?!(manager)|(tomee)$).*&quot;&gt;      &lt;Valve className=&quot;org.apache.catalina.valves.AccessLogValve&quot; directory=&quot;logs&quot; prefix=&quot;localhost_access_log&quot; suffix=&quot;.txt&quot; pattern=&quot;%h %l %u %t &amp;quot;%r&amp;quot; %s %b&quot; /&gt;  &lt;/Host&gt;</code></pre></li><li><p>conf 的子目录 Catalina\localhost\ 下的 XML 文件（以虚拟路径命名）</p><pre><code class="xml">  &lt;Context path=&quot;/ROOT&quot; docBase=&quot;C:\Java\projectname\classes\artifacts\ROOT\ROOT.war&quot; /&gt;  &lt;!-- 或者如下： --&gt;  &lt;!-- &lt;Context path=&quot;/ROOT&quot; docBase=&quot;C:\projectname\target\projectname&quot; /&gt; --&gt;</code></pre></li></ul><h1 id="视图模式"><a href="#视图模式" class="headerlink" title="视图模式"></a>视图模式</h1><p>View 菜单下</p><h2 id="Presentation-Mode"><a href="#Presentation-Mode" class="headerlink" title="Presentation Mode"></a>Presentation Mode</h2><p>演示模式</p><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20190613112517.png" alt="演示模式"></p><p>可以更加专注，因为只能看到特定某个类的代码。进入这个模式后，就要考验快捷键的熟练程度了。可以使用 <code>CTRL+E</code> 弹出最近使用的文件。又或者使用 <code>CTRL+N</code> 和 <code>CTRL+SHIFT+N</code> 定位文件。</p><h2 id="Distraction-Free-Mode"><a href="#Distraction-Free-Mode" class="headerlink" title="Distraction Free Mode"></a>Distraction Free Mode</h2><p>无干扰模式，免打扰模式</p><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20190613112023.png" alt="Distraction Free Mode"></p><h2 id="Full-Screen"><a href="#Full-Screen" class="headerlink" title="Full Screen"></a>Full Screen</h2><p>全屏模式</p><h1 id="Settings-Repository"><a href="#Settings-Repository" class="headerlink" title="Settings Repository"></a>Settings Repository</h1><p>同步设置，File --&gt; Settings Repository</p><p>在 GitHub 中新建项目，使用 <a href="https://help.github.com/en/articles/creating-a-personal-access-token-for-the-command-line" target="_blank" rel="noopener">访问令牌</a> 进行 GitHub 身份验证。</p><p>在 Settings Repository 中输入项目地址，选择 “覆盖本地”，“合并”（如果检测到冲突，将显示一个对话框，可以解决这些冲突），“覆盖远程”（使用本地设置覆盖远程设置）。</p><p>再输入访问令牌，即可同步。</p><blockquote><p><a href="https://www.jetbrains.com/help/idea/sharing-your-ide-settings.html#settings-repository" target="_blank" rel="noopener">https://www.jetbrains.com/help/idea/sharing-your-ide-settings.html#settings-repository</a></p></blockquote><h1 id="用引号或大括号括起所选内容"><a href="#用引号或大括号括起所选内容" class="headerlink" title="用引号或大括号括起所选内容"></a>用引号或大括号括起所选内容</h1><p>Surround a selection with a quote or brace：输入双引号引用选中字符</p><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20190613143334.png" alt="Setting|Smart keys"></p><p>Jump outside the closing bracket or quote with Tab：输入完引号或括号之后，使用 Tab 快速跳出到外面。</p><h1 id="set-background-image"><a href="#set-background-image" class="headerlink" title="set background image"></a>set background image</h1><p>俩下 shift，搜 background，选 set background image，设置好就行。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IntelliJ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 操作 MySQL</title>
      <link href="/2018/09/06/Python%20%E6%93%8D%E4%BD%9CMySQL/"/>
      <url>/2018/09/06/Python%20%E6%93%8D%E4%BD%9CMySQL/</url>
      
        <content type="html"><![CDATA[<h1 id="常见类库安装"><a href="#常见类库安装" class="headerlink" title="常见类库安装"></a>常见类库安装</h1><h2 id="MySQLdb"><a href="#MySQLdb" class="headerlink" title="MySQLdb"></a>MySQLdb</h2><p>只支持 Python2，windows 版本下载地址 <a href="http://sourceforge.net/projects/mysql-python" target="_blank" rel="noopener">http://sourceforge.net/projects/mysql-python</a> ，或使用 <code>pip install MySQL-python</code> 安装。</p><h2 id="PyMySQL"><a href="#PyMySQL" class="headerlink" title="PyMySQL"></a>PyMySQL</h2><pre><code class="shell">pip install PyMysql</code></pre><h2 id="mysql-connector"><a href="#mysql-connector" class="headerlink" title="mysql.connector"></a>mysql.connector</h2><pre><code class="shell">pip install mysql-connector</code></pre><a id="more"></a><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>PyMySQL，mysql.connector，使用方式类似</p><pre><code class="py">import pymysqlimport mysql.connector</code></pre><h1 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h1><pre><code class="py"># pymysql port 必须是整数类型conn = mysql.connector.connect(host=&quot;127.0.0.1&quot;, port=3306, user=&quot;root&quot;, password=&quot;123456&quot;, database=&quot;test&quot;)# 使用cursor()方法获取操作游标cursor = conn.cursor()</code></pre><h1 id="增删改"><a href="#增删改" class="headerlink" title="增删改"></a>增删改</h1><pre><code class="py"># 使用execute方法执行SQL语句cursor.execute(&#39;insert into user (id, name) values (%s, %s)&#39;, [&#39;1&#39;, &#39;Michael&#39;])# 使用executemany方法 插入多条语句names = ((&#39;Geert&#39;, info, 30), (&#39;Jan&#39;, info, 31), (&#39;Michel&#39;, info, 32))stmt_insert = &quot;INSERT INTO names (name, info, age) VALUES (%s, %s, %s)&quot;cursor.executemany(stmt_insert, names)# 影响行数cursor.rowcount# 获得自增id，多条时返回第一个，pymysql 使用 cursor.lastrowidcursor._last_insert_id</code></pre><p><code>%s</code> 是 MySQL 的 SQL 占位符，实际参数可以接受多种类型，例如二进制类型 <code>open(&quot;2.jpg&quot;, &#39;rb&#39;).read()</code>。</p><p>插入操作必须提交事务。</p><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><pre><code class="py"># 提交事务conn.commit()# 自动提交事务，mysql.connector 报错 TypeError: &#39;bool&#39; object is not callableconn.autocommit(True)# 回滚conn.rollback()</code></pre><h1 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h1><pre><code class="py">cursor.execute(&#39;select * from user where name = %s&#39;, (&#39;z&#39;,))values = cursor.fetchall()print(values)  # [(&#39;1&#39;, &#39;z&#39;), (&#39;2&#39;, &#39;z&#39;)]for row in values:    id = row[0]    name = row[1]    # 打印结果    print &quot;id=%s,name=%s&quot; % (id, name )# 获取下一个查询结果集cursor.execute(&quot;select * from user&quot;)values = c.fetchone()print(values)  # (&#39;1&#39;, &#39;z&#39;)values = c.fetchone()print(values)  # (&#39;2&#39;, &#39;z&#39;)</code></pre><h1 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h1><pre><code class="py"># 关闭 Cursor 和 Connectioncursor.close()  # Trueconn.close()</code></pre><h1 id="pymysql-err-InterfaceError-0-39-39"><a href="#pymysql-err-InterfaceError-0-39-39" class="headerlink" title="pymysql.err.InterfaceError: (0, &#39;&#39;)"></a>pymysql.err.InterfaceError: (0, &#39;&#39;)</h1><p>这个错是在多线程下或 MySQL 断线需要重新连接。</p><pre><code class="py">try:    conn.ping(reconnect=True)  # 如果发现断线会自动重连，可不加 reconnect=True 默认就是。except:    logging.error(traceback.format_exc())</code></pre><p>多线程情况下，建议使用数据库连接池 <a href="https://cito.github.io/DBUtils/UsersGuide.html" target="_blank" rel="noopener">DBUtils</a>，安装 <code>pip install DButils</code>。</p><pre><code class="py">from DBUtils.PooledDB import PooledDBpool = PooledDB(pymysql,1,host=mysql_ip,user=mysql_username,passwd=mysql_password,db=db,port=int(mysql_port),charset=&quot;utf8&quot;)  # 第二个参数为连接池里的最少连接数def fetchall(sql, *parameters):    &quot;&quot;&quot;得到全部列表&quot;&quot;&quot;    conn = pool.connection()    cursor = conn.cursor(cursor = pymysql.cursors.DictCursor)    try:        i = cursor.execute(sql, *parameters)        returnData = cursor.fetchall()        return returnData    except (Exception) as  e:        logging.info(e)        logging.info(sql)    finally:        cursor.close()        conn.close()def execute(sql, *parameters):    &quot;&quot;&quot;执行数据更新、插入&quot;&quot;&quot;    i = -1    conn = pool.connection()    # conn.autocommit(1)    cursor = conn.cursor()    try:        i = cursor.execute(sql, *parameters)        conn.commit()    except (Exception) as  e:        logging.info(e)        logging.info(sql)        logging.info(*parameters)    finally:        cursor.close()        conn.close()    return i</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解 Python 的 With 语句</title>
      <link href="/2018/09/05/%E7%90%86%E8%A7%A3%20Python%20%E7%9A%84%20With%20%E8%AF%AD%E5%8F%A5/"/>
      <url>/2018/09/05/%E7%90%86%E8%A7%A3%20Python%20%E7%9A%84%20With%20%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="With-语句是什么？"><a href="#With-语句是什么？" class="headerlink" title="With 语句是什么？"></a>With 语句是什么？</h1><p>有一些任务，可能事先需要设置，事后做清理工作。对于这种场景，Python 的 with 语句提供了一种非常方便的处理方式。一个很好的例子是文件处理，你需要获取一个文件句柄，从文件中读取数据，然后关闭文件句柄。</p><p>如果不用 with 语句，代码如下：</p><pre><code class="py">file = open(&quot;/tmp/foo.txt&quot;)data = file.read()file.close()</code></pre><a id="more"></a><p>这里有两个问题。一是可能忘记关闭文件句柄；二是文件读取数据发生异常，没有进行任何处理。下面是处理异常的加强版本：</p><pre><code class="py">file = open(&quot;/tmp/foo.txt&quot;)try:    data = file.read()finally:    file.close()</code></pre><p>虽然这段代码运行良好，但是太冗长了。这时候就是 with 一展身手的时候了。除了有更优雅的语法，with 还可以很好的处理上下文环境产生的异常。下面是 with 版本的代码：</p><pre><code class="py">with open(&quot;/tmp /foo.txt&quot;) as file:    data = file.read()</code></pre><p>这看起来充满魔法，但不仅仅是魔法，Python 对 with 的处理还很聪明。基本思想是 with 所求值的对象必须有一个 <code>__enter__()</code> 方法，一个 <code>__exit__()</code> 方法。</p><p>紧跟 with 后面的语句被求值后，返回对象的 <code>__enter__()</code> 方法被调用，这个方法的返回值将被赋值给 as 后面的变量。当 with 后面的代码块全部被执行完之后，将调用前面返回对象的 <code>__exit__()</code> 方法。</p><p>下面例子可以具体说明 with 如何工作：</p><pre><code class="py">#!/usr/bin/env python# with_example01.pyclass Sample:    def __enter__(self):        print &quot;In __enter__()&quot;        return &quot;Foo&quot;    def __exit__(self, type, value, trace):        print &quot;In __exit__()&quot;def get_sample():    return Sample()with get_sample() as sample:    print &quot;sample:&quot;, sample</code></pre><p>输出如下：</p><pre><code class="shell">bash-3.2$ ./with_example01.pyIn __enter__()sample: FooIn __exit__()</code></pre><p>正如你看到的，</p><ul><li><code>__enter__()</code> 方法被执行</li><li><code>__enter__()</code> 方法返回的值 - 这个例子中是“Foo”，赋值给变量‘sample’</li><li>执行代码块，打印变量“sample” 的值为 “Foo”</li><li><code>__exit__()</code> 方法被调用</li></ul><h1 id="处理异常"><a href="#处理异常" class="headerlink" title="处理异常"></a>处理异常</h1><p>with 真正强大之处是它可以处理异常。可能你已经注意到 Sample 类的 <code>__exit__</code> 方法有三个参数 - val, type 和 trace。 这些参数在异常处理中相当有用。我们来改一下代码，看看具体如何工作的。</p><pre><code class="py">#!/usr/bin/env python# with_example02.pyclass Sample:    def __enter__(self):        return self    def __exit__(self, type, value, trace):        print &quot;type:&quot;, type        print &quot;value:&quot;, value        print &quot;trace:&quot;, trace    def do_something(self):        bar = 1/0        return bar + 10with Sample() as sample:    sample.do_something()</code></pre><p>这个例子中，with 后面的 get_sample() 变成了 Sample()。这没有任何关系，只要紧跟 with 后面的语句所返回的对象有 <code>__enter__()</code> 和 <code>__exit__()</code> 方法即可。此例中，Sample() 的 <code>__enter__()</code> 方法返回新创建的 Sample 对象，并赋值给变量 sample。</p><p>代码执行结果：</p><pre><code class="py">bash-3.2$ ./with_example02.pytype: &lt;type &#39;exceptions.ZeroDivisionError&#39;&gt;value: integer division or modulo by zerotrace: &lt;traceback object at 0x1004a8128&gt;Traceback (most recent call last):  File &quot;./with_example02.py&quot;, line 19, in &lt;module&gt;    sample.do_somet hing()  File &quot;./with_example02.py&quot;, line 15, in do_something    bar = 1/0ZeroDivisionError: integer division or modulo by zero</code></pre><p>实际上，在 with 后面的代码块抛出任何异常时，<code>__exit__()</code> 方法被执行。正如例子所示，异常抛出时，与之关联的 type，value 和 stack trace 传给 <code>__exit__()</code> 方法，因此抛出的 ZeroDivisionError 异常被打印出来了。开发库时，清理资源，关闭文件等等操作，都可以放在 <code>__exit__</code> 方法当中。</p><p>因此，Python 的 with 语句是提供一个有效的机制，让代码更简练，同时在异常产生时，清理工作更简单。</p><p>示例代码可以在 <a href="https://github.com/sdqali/python_dojo/blob/master/with/" target="_blank" rel="noopener">Github</a> 上面找到。</p><h1 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h1><p>译注：<a href="http://blog.sdqali.in/blog/2012/07/09/understanding-pythons-with/" target="_blank" rel="noopener">本文原文见</a></p><p><a href="http://linbo.github.io/2013/01/08/python-with" target="_blank" rel="noopener">译文原文见</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 内置模块 enumerate</title>
      <link href="/2018/09/04/Python%20%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97%20enumerate/"/>
      <url>/2018/09/04/Python%20%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97%20enumerate/</url>
      
        <content type="html"><![CDATA[<h1 id="enumerate-iterable-start-0"><a href="#enumerate-iterable-start-0" class="headerlink" title="enumerate(iterable, start=0)"></a>enumerate(iterable, start=0)</h1><p><a href="https://docs.python.org/3/library/functions.html#enumerate" target="_blank" rel="noopener">https://docs.python.org/3/library/functions.html#enumerate</a></p><p>Return an enumerate object. iterable must be a sequence, an iterator, or some other object which supports iteration. The <code>__next__()</code> method of the iterator returned by enumerate() returns a tuple containing a count (from start which defaults to 0) and the values obtained from iterating over iterable.</p><p>返回一个枚举对象。iterable 必须是一个序列，一个迭代器或一些支持迭代的对象。</p><p>enumerate() 返回的迭代器的 <code>__next__()</code> 方法返回一个包含数组下标（从start开始，默认为0）和迭代迭代得到的值。</p><pre><code class="py">&gt;&gt;&gt;&gt;&gt;&gt; seasons = [&#39;Spring&#39;, &#39;Summer&#39;, &#39;Fall&#39;, &#39;Winter&#39;]&gt;&gt;&gt; list(enumerate(seasons))[(0, &#39;Spring&#39;), (1, &#39;Summer&#39;), (2, &#39;Fall&#39;), (3, &#39;Winter&#39;)]&gt;&gt;&gt; list(enumerate(seasons, start=1))[(1, &#39;Spring&#39;), (2, &#39;Summer&#39;), (3, &#39;Fall&#39;), (4, &#39;Winter&#39;)]</code></pre><p>相当于：</p><pre><code class="py">def enumerate(sequence, start=0):    n = start    for elem in sequence:        yield n, elem        n += 1</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows 下 MySQL 免安装版安装配置</title>
      <link href="/2018/09/03/Windows%20%E4%B8%8B%20MySQL%20%E5%85%8D%E5%AE%89%E8%A3%85%E7%89%88%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
      <url>/2018/09/03/Windows%20%E4%B8%8B%20MySQL%20%E5%85%8D%E5%AE%89%E8%A3%85%E7%89%88%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL-安装配置"><a href="#MySQL-安装配置" class="headerlink" title="MySQL 安装配置"></a>MySQL 安装配置</h1><p>在 MySQL 文件夹的目录下新建 my.ini 文件，含中文的话，可能会出错。</p><pre><code class="ini">[mysql]# 设置mysql客户端默认字符集default-character-set=utf8[mysqld]#设置3306端口port = 3306# 设置mysql的安装目录basedir=E:\project\MySQL# 设置mysql数据库的数据的存放目录datadir=E:\project\MySQL\data# 允许最大连接数max_connections=200# 服务端使用的字符集默认为8比特编码的latin1字符集character-set-server=utf8# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB</code></pre><p>在 cmd 中，切换到 mysql 解压文件的 bin 目录，输入 <code>mysqld  install</code>，回车运行：出现 “Service successfully installed.”表示安装成功。</p><a id="more"></a><h1 id="启动-MySQL-服务"><a href="#启动-MySQL-服务" class="headerlink" title="启动 MySQL 服务"></a>启动 MySQL 服务</h1><p>在 mysql 的安装目录下输入命令：<code>net start mysql</code> 启动服务；或是选择手动启动 mysql 服务（在运行框中输入 <code>services.msc</code> 调出服务对话框，找到 mysql 服务，右击属性，启动）</p><h1 id="出现的问题"><a href="#出现的问题" class="headerlink" title="出现的问题"></a>出现的问题</h1><p><a href="https://blog.csdn.net/Shauna_/article/details/59124021" target="_blank" rel="noopener">本地计算机上的mysql服务启动后停止，某些服务在未由其他服务或程序使用时将自动停止</a></p><p>进入安装 mysql 时的 bin 目录，执行一下初始化 <code>mysqld --initialize</code>，再次 <code>net start MySQL</code> 就解决了</p><p>由于找不到 msvcp140.dll，无法继续执行代码。下载安装 <a href="https://www.microsoft.com/zh-cn/download/confirmation.aspx?id=48145" target="_blank" rel="noopener">https://www.microsoft.com/zh-cn/download/confirmation.aspx?id=48145</a></p><h1 id="随机密码"><a href="#随机密码" class="headerlink" title="随机密码"></a>随机密码</h1><blockquote><p><a href="https://blog.csdn.net/wxyfennie/article/details/50656457" target="_blank" rel="noopener">https://blog.csdn.net/wxyfennie/article/details/50656457</a></p></blockquote><p>在 initialize 命令下生成的那个 data 文件，中找到 <code>你的计算机名.err</code> 文件，找到类似下面的内容：</p><pre><code class="shell">2018-08-27T08:48:25.665787Z 5 [Note] [MY-010454] [Server] A temporary password is generated for root@localhost: =oUnvQr&gt;q4)l</code></pre><p><code>=oUnvQr&gt;q4)l</code> 就是随机生成的密码。</p><p>使用 <code>mysql -u root -p</code> 命令，并输入密码后就可以连接 MySQL 了。</p><h1 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h1><pre><code class="sql">mysql&gt; ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;新的密码&#39;;</code></pre><h1 id="Navicat-for-MySQL-连接-Mysql-8-0-11-出现1251-Client-does-not-support-authentication-protocol-错误"><a href="#Navicat-for-MySQL-连接-Mysql-8-0-11-出现1251-Client-does-not-support-authentication-protocol-错误" class="headerlink" title="Navicat for MySQL 连接 Mysql 8.0.11 出现1251- Client does not support authentication protocol 错误"></a>Navicat for MySQL 连接 Mysql 8.0.11 出现1251- Client does not support authentication protocol 错误</h1><blockquote><p><a href="https://blog.csdn.net/seventopalsy/article/details/80195246" target="_blank" rel="noopener">解决Navicat for MySQL 连接 Mysql 8.0.11 出现1251- Client does not support authentication protocol 错误</a></p></blockquote><p>mysql8 之前的版本中加密规则是 <code>mysql_native_password</code>，而在 mysql8 之后，加密规则是 <code>caching_sha2_password</code></p><p>解决问题方法有两种：</p><ul><li>方法1.升级 navicat 驱动；</li><li>方法2.把 mysql 用户登录密码加密规则还原成 <code>mysql_native_password</code>。<pre><code class="sql">  ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;新的密码&#39;; # 更新一下用户的密码  FLUSH PRIVILEGES; # 刷新权限</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 读取写入配置文件 ConfigParser</title>
      <link href="/2018/09/02/Python%20%E8%AF%BB%E5%8F%96%E5%86%99%E5%85%A5%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%20ConfigParser/"/>
      <url>/2018/09/02/Python%20%E8%AF%BB%E5%8F%96%E5%86%99%E5%85%A5%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%20ConfigParser/</url>
      
        <content type="html"><![CDATA[<h1 id="configparser-简介"><a href="#configparser-简介" class="headerlink" title="configparser 简介"></a>configparser 简介</h1><p>python2 下该模块名为 ConfigParser，到 3 才改为 configparser，可以看官方 configparser 模块的说明</p><p><a href="https://docs.python.org/3/library/configparser.html" target="_blank" rel="noopener">https://docs.python.org/3/library/configparser.html</a></p><h1 id="ini-文件结构"><a href="#ini-文件结构" class="headerlink" title="ini 文件结构"></a>ini 文件结构</h1><p><a href="https://docs.python.org/3/library/configparser.html#supported-ini-file-structure" target="_blank" rel="noopener">https://docs.python.org/3/library/configparser.html#supported-ini-file-structure</a></p><p>ini 文件结构需要注意一下几点：</p><ol><li>键值对可用 <code>=</code> 或者 <code>:</code> 进行分隔</li><li>section 的名字是区分大小写的,而 key 的名字是不区分大小写的</li><li>键值对中头部和尾部的空白符会被去掉</li><li>值可以为多行</li><li>配置文件可以包含注释，注释以 <code>#</code> 或者 <code>;</code> 为前缀</li></ol><p>不一定要以 ini 为扩展名。</p><a id="more"></a><h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><p>为了创建如下 ini 文件：</p><pre><code class="ini">[DEFAULT]ServerAliveInterval = 45Compression = yesCompressionLevel = 9ForwardX11 = yes[bitbucket.org]User = hg[topsecret.server.com]Port = 50022ForwardX11 = no</code></pre><h2 id="创建-ini-文件"><a href="#创建-ini-文件" class="headerlink" title="创建 ini 文件"></a>创建 ini 文件</h2><pre><code class="py">&gt;&gt;&gt; import configparser&gt;&gt;&gt; config = configparser.ConfigParser()&gt;&gt;&gt; config[&#39;DEFAULT&#39;] = {&#39;ServerAliveInterval&#39;: &#39;45&#39;,...                      &#39;Compression&#39;: &#39;yes&#39;,...                      &#39;CompressionLevel&#39;: &#39;9&#39;}&gt;&gt;&gt; config[&#39;bitbucket.org&#39;] = {}&gt;&gt;&gt; config[&#39;bitbucket.org&#39;][&#39;User&#39;] = &#39;hg&#39;&gt;&gt;&gt; config[&#39;topsecret.server.com&#39;] = {}&gt;&gt;&gt; topsecret = config[&#39;topsecret.server.com&#39;]&gt;&gt;&gt; topsecret[&#39;Port&#39;] = &#39;50022&#39;     # mutates the parser&gt;&gt;&gt; topsecret[&#39;ForwardX11&#39;] = &#39;no&#39;  # same here&gt;&gt;&gt; config[&#39;DEFAULT&#39;][&#39;ForwardX11&#39;] = &#39;yes&#39;&gt;&gt;&gt; with open(&#39;example.ini&#39;, &#39;w&#39;) as configfile:...   config.write(configfile)...</code></pre><h2 id="读取-ini-文件"><a href="#读取-ini-文件" class="headerlink" title="读取 ini 文件"></a>读取 ini 文件</h2><pre><code class="py">&gt;&gt;&gt; config = configparser.ConfigParser()&gt;&gt;&gt; config.sections()[]&gt;&gt;&gt; config.read(&#39;example.ini&#39;)[&#39;example.ini&#39;]&gt;&gt;&gt; config.sections()[&#39;bitbucket.org&#39;, &#39;topsecret.server.com&#39;]&gt;&gt;&gt; &#39;bitbucket.org&#39; in configTrue&gt;&gt;&gt; &#39;bytebong.com&#39; in configFalse&gt;&gt;&gt; config[&#39;bitbucket.org&#39;][&#39;User&#39;]&#39;hg&#39;&gt;&gt;&gt; config[&#39;DEFAULT&#39;][&#39;Compression&#39;]&#39;yes&#39;&gt;&gt;&gt; topsecret = config[&#39;topsecret.server.com&#39;]&gt;&gt;&gt; topsecret[&#39;ForwardX11&#39;]&#39;no&#39;&gt;&gt;&gt; topsecret[&#39;Port&#39;]&#39;50022&#39;&gt;&gt;&gt; for key in config[&#39;bitbucket.org&#39;]:...     print(key)usercompressionlevelserveraliveintervalcompressionforwardx11&gt;&gt;&gt; config[&#39;bitbucket.org&#39;][&#39;ForwardX11&#39;]&#39;yes&#39;</code></pre><p>如果想要获取指定类型的数据，可以使用如下的几个方法:</p><ul><li>getint()</li><li>getfloat()</li><li>getboolean()</li></ul><p>同时需要注意 getboolean() 方法能判断 True/False 的值有： <code>&#39;yes&#39;/&#39;no&#39;</code>, <code>&#39;on&#39;/&#39;off&#39;</code>, <code>&#39;true&#39;/&#39;false&#39;</code> 和 <code>&#39;1&#39;/&#39;0&#39;</code>。例如：</p><pre><code class="py">&gt;&gt;&gt; topsecret.getboolean(&#39;ForwardX11&#39;)False&gt;&gt;&gt; config[&#39;bitbucket.org&#39;].getboolean(&#39;ForwardX11&#39;)True&gt;&gt;&gt; config.getboolean(&#39;bitbucket.org&#39;, &#39;Compression&#39;)True</code></pre><h1 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h1><pre><code class="py">&gt;&gt;&gt; topsecret.get(&#39;Port&#39;)&#39;50022&#39;&gt;&gt;&gt; topsecret.get(&#39;CompressionLevel&#39;) # &#39;DEFAULT&#39; section 中默认值&#39;9&#39;&gt;&gt;&gt; topsecret.get(&#39;Cipher&#39;)&gt;&gt;&gt; topsecret.get(&#39;Cipher&#39;, &#39;3des-cbc&#39;) # 自行提供默认值&#39;3des-cbc&#39;&gt;&gt;&gt; topsecret.get(&#39;CompressionLevel&#39;, &#39;3&#39;) # 如果在 &#39;DEFAULT&#39; section 中存在，自行提供的无效&#39;9&#39;</code></pre><h2 id="fallback-参数"><a href="#fallback-参数" class="headerlink" title="fallback 参数"></a>fallback 参数</h2><p>解析器级别的 get() 方法</p><pre><code class="py">&gt;&gt;&gt; config.get(&#39;bitbucket.org&#39;, &#39;monster&#39;, fallback=&#39;No such things as monsters&#39;)&#39;No such things as monsters&#39;</code></pre><p>fallback 参数 也可以和 getint()，getfloat()，getboolean() 方法一起使用:</p><pre><code class="py">&gt;&gt;&gt; &#39;BatchMode&#39; in topsecretFalse&gt;&gt;&gt; topsecret.getboolean(&#39;BatchMode&#39;, fallback=True)True&gt;&gt;&gt; config[&#39;DEFAULT&#39;][&#39;BatchMode&#39;] = &#39;no&#39;&gt;&gt;&gt; topsecret.getboolean(&#39;BatchMode&#39;, fallback=True)False</code></pre><h1 id="Interpolation"><a href="#Interpolation" class="headerlink" title="Interpolation"></a>Interpolation</h1><p>创建 ConfigParser() 类的时候可以指定 interpolation 参数，如果将 interpolation 设置为 BasicInterpolation()，则配置文件中的 <code>%(key)s</code> 结构会被解析，如，比如 example.ini 文件内容如下：</p><pre><code class="ini">[Paths]home_dir: /Usersmy_dir: %(home_dir)s/lumberjackmy_pictures: %(my_dir)s/Pictures</code></pre><pre><code class="py">&gt;&gt;&gt; import configparser&gt;&gt;&gt; config = configparser.ConfigParser(interpolation=configparser.BasicInterpolation())&gt;&gt;&gt; config.read(r&#39;F:\coding\python\example.ini&#39;)[&#39;F:\\coding\\python\\example.ini&#39;]&gt;&gt;&gt; config[&#39;Paths&#39;][&#39;my_dir&#39;]&#39;/Users/lumberjack&#39;</code></pre><p>可以看到 <code>%(home_dir)s</code> 被解析成了 <code>/Users</code>，说白了，相当于配置文件中的变量</p><h2 id="ExtendedInterpolation"><a href="#ExtendedInterpolation" class="headerlink" title="ExtendedInterpolation"></a>ExtendedInterpolation</h2><p>创建 ConfigParser() 类的时候指定 interpolation 参数为 ExtendedInterpolation()，那么解析器会解析 ${section:key} 结构，那么上面的ini文件应该写成如下的格式:</p><pre><code class="ini">[Paths]home_dir: /Usersmy_dir: ${home_dir}/lumberjackmy_pictures: ${my_dir}/Pictures</code></pre><p>并且 ExtendedInterpolation() 也能解析更复杂的，像下面这样的 ini 文件:</p><pre><code class="ini">[Common]home_dir: /Userslibrary_dir: /Librarysystem_dir: /Systemmacports_dir: /opt/local[Frameworks]Python: 3.2path: ${Common:system_dir}/Library/Frameworks/[Arthur]nickname: Two Shedslast_name: Jacksonmy_dir: ${Common:home_dir}/twoshedsmy_pictures: ${my_dir}/Picturespython_dir: ${Frameworks:path}/Python/Versions/${Frameworks:Python}</code></pre><h1 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h1><ul><li>add_section(section)</li><li>has_section(section)</li><li>options(section)</li><li>has_option(section, option)</li><li>remove_option(section, option)</li><li>remove_section(section)</li></ul><p>都很常用，具体就不介绍了，看名字就知道是干什么的了</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Effective Java》笔记15：使可变性最小化</title>
      <link href="/2018/08/25/%E3%80%8AEffective%20Java%E3%80%8B%E7%AC%94%E8%AE%B015%EF%BC%9A%E4%BD%BF%E5%8F%AF%E5%8F%98%E6%80%A7%E6%9C%80%E5%B0%8F%E5%8C%96/"/>
      <url>/2018/08/25/%E3%80%8AEffective%20Java%E3%80%8B%E7%AC%94%E8%AE%B015%EF%BC%9A%E4%BD%BF%E5%8F%AF%E5%8F%98%E6%80%A7%E6%9C%80%E5%B0%8F%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>不可变类是其实例不能被修改的类（不只是类前加上了 final 就可以了）。每个实例中包含的所有信息都必须在创建该实例时候就提供，并在对象的整个生命周期内固定不变。</p><p>Java 平台类库上有很多不可变的类，其中有 String、基本类型的包装类、BigInteger 和 BigDecimal。</p><p>存在不可变内的许多理由：不可变类比可变类更加易于设计、实现和使用。它们不容易出错，且更加安全。</p><a id="more"></a><h1 id="不可变规则"><a href="#不可变规则" class="headerlink" title="不可变规则"></a>不可变规则</h1><p>为使类成为不可变，要遵循以下5条规则：</p><ol><li><strong>不要提供任何会修改对象状态（属性）的方法。</strong></li><li><strong>保证类不会被扩展</strong>。防止子类化。一般做法是使这个类成为 final 的，另外作法就是让类所有构造器都变成私有的或者是包级私有的。</li><li><strong>使用有的域都是 final 的</strong>（一般是针对非静态变量）。通过这种加上 final 修饰的强制方式，这可以清楚地表明你的意图：确保该域在使用前得到正确的初始化。而且，如果一个指向新创建的实例的引用在缺乏同步机制（一般不可变对象的访问是不需要同步的，因为状态一旦确定，就不会再更改）的情况下，从一个线程切换另一个线程就必需确保实例的正确状态，正如果内存模型中所述那样[JLS 17.5]。</li><li><strong>使用所有的域都成为私有的</strong>。这样可以防止客户端获得访问被域引用的可变对象的权限，并防止客户端直接修改这些对象。虽然从技术上讲，允许不可变的类具有公有的 final 域，只要这些域包含基本类型的值或都指向不可变对象的引用，但是不建议这样做，因为这样会使得在以后的版本中无法以再改变内部的表示法。</li><li><strong>确保对于任何可变域的互斥访问</strong>。如果类具有指向可变对象域，则必须确保该类的客户端无法获得指向这些对象的引用。并且，永远不要用客户端提供的对象引用来初始化这样的域，也不要从任何访问方法中返回该对象的引用（即进出都不行）。在构造器、访问方法、readObject 方法（见76条）中请使用保护性拷贝技术（见第39条）。</li></ol><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>下面是一个不可变复数（具有实部和虚部）类的例子：</p><pre><code class="java">//复数public final class Complex {    private final double re;//实部    private final double im;//虚部    // 私有的，让它无法扩展    private Complex(double re, double im) {        this.re = re;        this.im = im;    }    //静态工厂方法    public static Complex valueOf(double re, double im) {        return new Complex(re, im);    }    public static Complex valueOfPolar(double r, double theta) {        return new Complex(r * Math.cos(theta), r * Math.sin(theta));    }    public static final Complex ZERO = new Complex(0, 0);    public static final Complex ONE = new Complex(1, 0);    public static final Complex I = new Complex(0, 1);    // 可以直接返回基本类型的值    public double realPart() {        return re;    }    public double imaginaryPart() {        return im;    }    //每次加减乘除都返回一个新的对象    public Complex add(Complex c) {        return new Complex(re + c.re, im + c.im);    }    public Complex subtract(Complex c) {        return new Complex(re - c.re, im - c.im);    }    public Complex multiply(Complex c) {        return new Complex(re * c.re - im * c.im, re * c.im + im * c.re);    }    public Complex divide(Complex c) {        double tmp = c.re * c.re + c.im * c.im;        return new Complex((re * c.re + im * c.im) / tmp, (im * c.re - re * c.im) / tmp);    }    public boolean equals(Object o) {        if (o == this)            return true;        if (!(o instanceof Complex))            return false;        Complex c = (Complex) o;        // 浮点数的比较要使用Double.compare，而不能直接使用==比较        return Double.compare(re, c.re) == 0 &amp;&amp; Double.compare(im, c.im) == 0;    }    public int hashCode() {        int result = 17 + hashDouble(re);        result = 31 * result + hashDouble(im);        return result;    }    private int hashDouble(double val) {        long longBits = Double.doubleToLongBits(re);        return (int) (longBits ^ (longBits &gt;&gt;&gt; 32));    }    public String toString() {        return &quot;(&quot; + re + &quot; + &quot; + im + &quot;i)&quot;;    }}</code></pre><p>不可变对象只有一种状态，即被创建时的状态。<strong>不可变对象本质上是线程安全的，它们不要求同步，可以被自由的共享</strong>。不可变类应该充分利用这种优势，鼓励客户端尽可能地重用现有的实例，要做到这一点，一个很简便的办法就是，对于频繁用到的值，为它们提供公有的静态 final 常量，例如上面的常量：</p><pre><code class="java">public static final Complex ZERO = new Complex(0, 0);public static final Complex ONE = new Complex(1, 0);public static final Complex I = new Complex(0, 1);</code></pre><p>这种方法可以被进一步的扩展，不可变以的类可以提供一些静态工厂，它们把频繁请求主的实例缓存起来，在请求合适的对象时候，就不必要创建新的实例。所有的基本类型的包装类和 BigInteger 都有这样的静态工厂。使得实例可以共享，从而降低内存与垃圾回收成本。在设计类时，选择用静态工厂代替公有的构造器可以让你以后有缓存的灵活性，而不必影响客户端。</p><p>“不可变对象可以被自由地共享”，我们永远也不需要，也不应该为不可变对的类提供 clone 方法或者拷贝构造器。这一点在 Java 平台早期的版本中做得并不好，所以 String 类仍然具有拷贝构造器，但是应该尽量少用它。</p><p><strong>不仅可以共享不可变对象，甚至也可以共享它们的内部信息</strong>。如 BigInteger 的 negate 方法产生一个新的 BigInteger，其中数组是一样的，符号则是相反的，它并不需要拷贝数组；新建的 BigInteger 也指向原始实例中的同一个内部数组。</p><p><strong>不可变类真正唯一的缺点是，对于每个不同的值都需要一个单独的对象</strong>，创建这种对象的代价可能很高，特别是对于大型对象的情形。</p><p>如果你选择让自己的不可变实现 Serializable 接口，并具它包含一个或者多个指向可变对象的域，就必须提供一个显示的 readObject 或者 readResolve 方法，或者使用 ObjectOutputStream.writeUnshared 和 ObjectInputStream.readUnshared 方法，否则攻击者或能从不可变的类创建可变的实例。这个话题详细请参见 76 条。</p><p><strong>除非有很好的理由要让类成为可变的类，否则就应该是不可变的</strong>。不可变的类优点有很多，唯一缺点是在特定的情况下存在潜在的性能问题。你应该总是使用一些小的值对象（如 Complex），成为不可变的。但你也应该认真考虑把一些较大的值对象做成不可变的（String、BigInteger），只有当你确认有性能问题时，才应该为不可变的类提供一个公有的可变配套类（如 String 的配套类 StringBuffer、StringBuilder；还有 BigInteger 的配套类为 BitSet）。</p><p>对于有些类而言，基不可变性是不切实际的。如果为不能被做成是不可变的，仍然应该尽可能地限制它的可变性。除非有使人信服的理由要使域变成是非 final 的，否则要使每个域都是 final 的。</p><p>构造器应该创建完全初始化的对象，并建立起所有的约束关系。不要在构造器或者静态工厂之外再提供公有的初始化方法，除非有使人信服的理由。同样也不应该提供“重新初始化”方法（比如 TimerTask 类，它是可变的，一旦完成或被取消，就不可能再对它重新调度），与所增加的复杂性相比，通常并没有带来太多的性能。</p><p>总之，新的内存模型中，以前不可变对象与 final 域的可变问题得到了修复，可以放心的使用了(为了确保 String 的安全初始化，1.5 中 String 的 value[]、offset、count 三个字段前都已加上了 final 修饰符，这样新的 Java 内存模型会确认 final 字段的初始化安全)。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Effective Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Effective Java》笔记14：在公有类中使用访问方法而非公有域</title>
      <link href="/2018/08/25/%E3%80%8AEffective%20Java%E3%80%8B%E7%AC%94%E8%AE%B014%EF%BC%9A%E5%9C%A8%E5%85%AC%E6%9C%89%E7%B1%BB%E4%B8%AD%E4%BD%BF%E7%94%A8%E8%AE%BF%E9%97%AE%E6%96%B9%E6%B3%95%E8%80%8C%E9%9D%9E%E5%85%AC%E6%9C%89%E5%9F%9F/"/>
      <url>/2018/08/25/%E3%80%8AEffective%20Java%E3%80%8B%E7%AC%94%E8%AE%B014%EF%BC%9A%E5%9C%A8%E5%85%AC%E6%9C%89%E7%B1%BB%E4%B8%AD%E4%BD%BF%E7%94%A8%E8%AE%BF%E9%97%AE%E6%96%B9%E6%B3%95%E8%80%8C%E9%9D%9E%E5%85%AC%E6%9C%89%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<p>如果类可以在它所在的包的外部进行访问，就将域设为私有的并提供域的访问与设置公有方法，以保留将来改变该类的内部表示法的灵活性。如果公有类暴露了它的数据域，要想在将来改变其内部表示法是不可能的，因为公有类的客户端已经遍布各处了。另外，如果不采取这种方式，则当域被访问的时候，无法彩任何辅助的行动。</p><a id="more"></a><p>如果类是包级私有的（虽然将域暴露了，但也只仅限于包含该类的包中，还在你可控的范围之内），或者是私有的嵌套类，直接暴露它的数据域并没有本质的错误——假设这些数据域确实描述了该类所提供的抽象。比如LinkedList中的Entry静态内部类，就暴露了所有的成员给外类了，这样用起来更简洁方便：</p><pre><code class="java">public class LinkedList{    private static class Entry {        Object element;        Entry next;        Entry previous;    }}</code></pre><p>让公有类直接暴露域虽然从来都不是种好办法，但是<strong>如果域是不可变的，这种做法危害就比较小一些</strong>。如果不改变类的API，就无法改变这种类的表示法，当域被读取的时候，你也无法采取辅助的行动。</p><p>使用 getter setter 方法可以在方法中添加必要的验证逻辑，以避免非法数据。</p><pre><code class="java">public &lt;T&gt; boolean setXxx(int index, T value) {    if (index &gt; myArray.length)        return false;    if (!(value instanceof LegalClass))        return false;    ...    return true;}</code></pre><p>总之，公有类永远不应该暴露可变的域。虽然还是有问题，但是让公有类暴露不可变域其危害比较小。但是，有时候会需要使包级私有的或者私有的嵌套灰来暴露域，无论这个类是可变还是不可变的。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Effective Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Effective Java》笔记13：使类和成员的可访问性最小化</title>
      <link href="/2018/08/25/%E3%80%8AEffective%20Java%E3%80%8B%E7%AC%94%E8%AE%B013%EF%BC%9A%E4%BD%BF%E7%B1%BB%E5%92%8C%E6%88%90%E5%91%98%E7%9A%84%E5%8F%AF%E8%AE%BF%E9%97%AE%E6%80%A7%E6%9C%80%E5%B0%8F%E5%8C%96/"/>
      <url>/2018/08/25/%E3%80%8AEffective%20Java%E3%80%8B%E7%AC%94%E8%AE%B013%EF%BC%9A%E4%BD%BF%E7%B1%BB%E5%92%8C%E6%88%90%E5%91%98%E7%9A%84%E5%8F%AF%E8%AE%BF%E9%97%AE%E6%80%A7%E6%9C%80%E5%B0%8F%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>要区别设计良好的模块与设计不好的模块，最后重要的因素在于，这个模块对于外部的其他模块而言，是否隐藏其内部了数据和其他实现细节。设计良好的模块会隐藏所有的实现细节，把它的API与它的实现清晰地隔离开来。然后，模块之间只通过它们的API进行通信，一个模块不要知道其他模块的内部工作情况。这个概念被称为<strong>信息隐藏或封装</strong>，也是软件设计的基本原则之一。</p><p>封装有效地解除组成系统的各模块之间的耦合关系，使得这些模块可以独立地开发、测试与维护，还提高了软件的可重用性。</p><a id="more"></a><p>Java里的封装是通过访问控制符来加以限制的。</p><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p>规则很简单：<strong>尽可能地使每个类或者成员不被外界访问</strong>，即使用尽可能最小的访问级别。</p><p>对于顶层类（非嵌套的）类和接口，只有两种可能的访问级别：包级私有的和公有的。如果使用 pulbic 修饰符声明了顶层类或者接口，那它就是公有的；否则，它将是包级私有的。如果顶层类或者接口能够被做成包级私有的，它就应该被做成包级私有，这样类或者是接口就成了这个包的实现的一部分，而不是该包导出的API的一部分，在以后的版本中，可以对它进行修改、替换、或者删除，而无需担心会影响到现有的客户端程序。</p><p>如果一个包级私有的顶层类（或者接口）只是在某一个类的内部用到，就应该考虑使它成为唯一使用它的那个类的私有嵌套类。这样可以将它的可访问范围从包中的所有类缩小到了使用它的那个类。然而，降低不必要公有类的可访问性，比降低包级私有的顶层类的更重要得多：因为公有类是包的API的一部分，而包级私有的顶层类只是这个包的实现的一部分，包级是我们可以掌控的一部分。</p><h1 id="成员"><a href="#成员" class="headerlink" title="成员"></a>成员</h1><p>对于成员（域、方法、嵌套类和嵌套接口）有四种可能的访问级别，下面按照可访问性的递增顺序罗列出来：</p><ol><li>私有的（private）：只有在声明该成员的顶层类内部才可以访问这个成员。</li><li>包级私有的：声明该成员的包内部的任何的任何类都可以访问这个成员。这也是“缺省”访问级别，如果没有为成员指定访问修饰符，就采用这个访问级别。</li><li>受保护的（protected）：声明该成员的类的子类可以访问这个成员（但有一些限制[JLS,6.6.2]），并且声明该成员的包内部的任何类也可以访问这个成员。</li><li>公有的（public）：在任何地方都可以访问该成员。</li></ol><p>只有当同一个包内的另一个类真正需要访问一个成员的时候，你才应该删除 private 修饰符，使该成员变成包私有的。</p><p>私有成员和包级私有成员都是一个类的实现中的一部分，一般不会影响它的导出的 API。然而，如果这个类实现了 Serializable 接口，这些域就有可能会被“泄漏”到导出的 API 中。</p><p>对于公有类的成员，当访问级别从包级私有变成保护级别时，会大大增强可访问性。受保护的成员是类的导出的 API 的一部分，必须永远得到支持。导出的类的受保护成员也代表了该类对于某个实现细节的公开承诺。<strong>受保护的成员应该尽量少用</strong>。</p><p>如果方法覆盖了超类中的一个方法，<strong>子类中的访问级别就不允许低于超类中的访问级别</strong>。这样就可以确保任何可使用超类的实例的地方也都可以使用子类的实例。</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>如果一个类实现了一个接口，那么接口中所有的类方法在这个类中也都<strong>必须被声明为公有的</strong>。之所以如此，是因为接口中的所有方法都隐含着公有访问级别。</p><h2 id="实例域"><a href="#实例域" class="headerlink" title="实例域"></a>实例域</h2><p><strong>实例域决不能是公有的</strong>。如果域是非 final 的，或者即是 final 但指向的却是可变对象，那么一旦使这个域成为公有的，就放弃了对存储在这个域中的值进行限制的能力；这意味着，你也放弃了强制这个域不可变的能力。因此，包含公有可变域的类并不是线程安全的。即使域是 final 的，并且引用不可变的对象，当把这个域变成公有的时候，也就放弃了“切换换到一种新的内部了数据表示法”（比如将这个字段删除掉，或者使用多个字段来表示等）的灵活性。</p><h2 id="public-final"><a href="#public-final" class="headerlink" title="public final"></a>public final</h2><p>public final 修饰的域要么包含基本类型的值，<strong>要么包含指向不可变对象的引用</strong>（同样的建议也适用于静态域）。如果<strong>final 域包含可变对象的引用，它更具有非 final 域的所有缺点</strong>，虽然引用本身不能被修改，但是它所引用的对象却可以被修改。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>长度非零的数组总是可变的，所以，类具有公有的静态 final 数组域，或者返回这种域的访问方法（这与方法返回的是局部数组是不一样的，因为这个是共享的，而返回的局部数组是单个线程共享的），这几乎总是错误的。如果类具有这样的域或者访问方法，客户端将能够修改数组中的内容，这是安全漏洞的一个常见根源：</p><pre><code class="java">public static final Thing[] VALUES={…};</code></pre><p>修正这个问题有两种方法，可以使公有数组变成私有的，并增加一个公有的不可变列表：</p><pre><code class="java">private static final Thing[] PRIVATE_VALUES={…};public static final LIST VALUES = Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));</code></pre><p>另一种方法是，可以使用数组变成私有的，并添加一个公有方法，它返回私有的数组的一个备份：</p><pre><code class="java">private static final Thing[] PRIVATE_VALUES ={…};public static final Thing[] values(){    return PRIVATE_VALUES.clone();}</code></pre><p>但依我个人看，上面的克隆还是不起根本作用（如果数组元素是基本类型的，就没有问题）：虽然各个元素引用已被复制，但是它们所引用的对象却是同一份，如果指向的对象是可变的，则还是可以通过引用去修改它们所指向对象的问题，所以上面的修改也有潜在的问题。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>从上面分析来看 public static final 最好修改的是基本类型的变量，或者是不可变的类。</p><p>总而言之，你应该始终尽量可能地降低可访问性。除了公有静态 final 域的特殊情形之外，公有类都不应该包含公有域。并且要确保公有静态 final 域所引用的对象都是不可变的。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Effective Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 定位程序性能瓶颈</title>
      <link href="/2018/08/09/Python%20%E5%AE%9A%E4%BD%8D%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88/"/>
      <url>/2018/08/09/Python%20%E5%AE%9A%E4%BD%8D%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88/</url>
      
        <content type="html"><![CDATA[<p>对代码优化的前提是需要了解性能瓶颈在什么地方，程序运行的主要时间是消耗在哪里，对于比较复杂的代码可以借助一些工具来定位，python 内置了丰富的性能分析工具，如 profile, cProfile 与 hotshot 等。其中 Profiler 是 python 自带的一组程序，能够描述程序运行时候的性能，并提供各种统计帮助用户定位程序的性能瓶颈。Python 标准模块提供三种 profilers:cProfile, profile 以及 hotshot。</p><h1 id="profile"><a href="#profile" class="headerlink" title="profile"></a>profile</h1><p>profile 的使用非常简单，只需要在使用之前进行 import 即可。具体实例如下：</p><pre><code class="py">import profiledef profileTest():    for i in range(20000):        sent = &quot;a sentence for measuring a find function&quot;        print(sent[16:])if __name__ == &quot;__main__&quot;:   profile.run(&quot;profileTest()&quot;)</code></pre><a id="more"></a><p>运行结果：</p><pre><code class="shell">         20005 function calls in 0.047 seconds   Ordered by: standard name   ncalls  tottime  percall  cumtime  percall filename:lineno(function)        1    0.000    0.000    0.047    0.047 :0(exec)    20000    0.031    0.000    0.031    0.000 :0(print)        1    0.000    0.000    0.000    0.000 :0(setprofile)        1    0.000    0.000    0.047    0.047 &lt;string&gt;:1(&lt;module&gt;)        1    0.000    0.000    0.047    0.047 profile:0(profileTest())        0    0.000             0.000          profile:0(profiler)        1    0.016    0.016    0.047    0.047 writefile.py:38(profileTest)</code></pre><p>其中输出每列的具体解释如下：</p><ul><li>ncalls：表示函数调用的次数；</li><li>tottime：表示指定函数的总的运行时间，除掉函数中调用子函数的运行时间；</li><li>percall：（第一个 percall）等于 tottime/ncalls；</li><li>cumtime：表示该函数及其所有子函数的调用运行的时间，即函数开始调用到返回的时间；</li><li>percall：（第二个 percall）即函数运行一次的平均时间，等于 cumtime/ncalls；</li><li>filename:lineno(function)：每个函数调用的具体信息；</li></ul><p>如果需要将输出<strong>以日志的形式保存</strong>，只需要在调用的时候加入另外一个参数。如 <code>profile.run(&quot;profileTest()&quot;, &quot;testprof&quot;)</code>。</p><h1 id="pstats"><a href="#pstats" class="headerlink" title="pstats"></a>pstats</h1><p>对于 <code>profile</code> 的剖析数据，如果以二进制文件的时候保存结果的时候，可以通过 pstats 模块进行文本报表分析，它支持多种形式的报表输出，是文本界面下一个较为实用的工具。使用非常简单：</p><pre><code class="py">import pstatsp = pstats.Stats(&#39;testprof&#39;)p.sort_stats(&quot;name&quot;).print_stats()</code></pre><p>显示结果类似上文。</p><p>其中 sort_stats() 方法能够对剖分数据进行排序， 可以接受多个排序字段，如 sort_stats(&#39;name&#39;, &#39;file&#39;) 将首先按照函数名称进行排序，然后再按照文件名进行排序。常见的排序字段有 calls( 被调用的次数 )，time（函数内部运行时间），cumulative（运行的总时间）等。此外 pstats 也提供了命令行交互工具，执行 python – m pstats 后可以通过 help 了解更多使用方式。</p><p>对于大型应用程序，如果能够将性能分析的结果以图形的方式呈现，将会非常实用和直观，常见的可视化工具有 Gprof2Dot，visualpytune，KCacheGrind 等。</p><blockquote><p><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-python-optim/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/l-cn-python-optim/index.html</a></p></blockquote><h1 id="使用-timeit"><a href="#使用-timeit" class="headerlink" title="使用 timeit"></a>使用 timeit</h1><pre><code class="py">from timeit import timeitimport redef find(string, text):    if string.find(text) &gt; -1:        passdef re_find(string, text):    if re.match(text, string):        passdef best_find(string, text):    if text in string:       passprint timeit(&quot;find(string, text)&quot;, &quot;from __main__ import find; string=&#39;lookforme&#39;; text=&#39;look&#39;&quot;)print timeit(&quot;re_find(string, text)&quot;, &quot;from __main__ import re_find; string=&#39;lookforme&#39;; text=&#39;look&#39;&quot;)print timeit(&quot;best_find(string, text)&quot;, &quot;from __main__ import best_find; string=&#39;lookforme&#39;; text=&#39;look&#39;&quot;)</code></pre><p>运行结果：</p><pre><code class="shell">0.257950710953857740.81581247623113820.10521701806419292</code></pre><p>因此，字符串搜索，应该使用 in 运算符，因为它更容易阅读，但因为它也更快。</p><blockquote><p><a href="https://stackoverflow.com/questions/4901523/whats-a-faster-operation-re-match-search-or-str-find/4901653#4901653" target="_blank" rel="noopener">https://stackoverflow.com/questions/4901523/whats-a-faster-operation-re-match-search-or-str-find/4901653#4901653</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 读写文件</title>
      <link href="/2018/08/09/Python%20%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6/"/>
      <url>/2018/08/09/Python%20%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="读写常用模式"><a href="#读写常用模式" class="headerlink" title="读写常用模式"></a>读写常用模式</h1><ul><li><code>r</code>：只读</li><li><code>+</code>：读写</li><li><code>w</code>：新建(会覆盖原有文件)，写入</li><li><code>a</code>：追加</li><li><code>b</code>：二进制文件</li><li><code>t</code>：文本</li><li><code>x</code>：进行独占创建，如果文件已存在则失败</li></ul><a id="more"></a><h1 id="读写文本数据"><a href="#读写文本数据" class="headerlink" title="读写文本数据"></a>读写文本数据</h1><p>使用带有 <code>rt</code> 模式的 open() 函数读取文本文件。如下所示：</p><pre><code class="py"># 将整个文件作为单个字符串读取with open(&#39;somefile.txt&#39;, &#39;rt&#39;) as f:    data = f.read()# 一行一行的读取with open(&#39;somefile.txt&#39;, &#39;rt&#39;) as f:    for line in f:        # process line        ...</code></pre><p>类似的，为了写入一个文本文件，使用带有 <code>wt</code> 模式的 open() 函数， 如果之前文件内容存在则清除并覆盖掉。如下所示：</p><pre><code class="py"># 写入文本数据with open(&#39;somefile.txt&#39;, &#39;wt&#39;) as f:    f.write(text1)    f.write(text2)    ...# 重定向 printwith open(&#39;somefile.txt&#39;, &#39;wt&#39;) as f:    print(line1, file=f)    print(line2, file=f)    ...</code></pre><p>如果是在已存在文件中<strong>追加内容</strong>，使用模式为 <code>at</code> 的 open() 函数。</p><h1 id="读写字节数据"><a href="#读写字节数据" class="headerlink" title="读写字节数据"></a>读写字节数据</h1><p>使用模式为 <code>rb</code> 或 <code>wb</code> 或者 <code>ab 追加</code>的 open() 函数来读取或写入二进制数据。比如：</p><pre><code class="py"># Read the entire file as a single byte stringwith open(&#39;somefile.bin&#39;, &#39;rb&#39;) as f:    data = f.read()# Write binary data to a filewith open(&#39;somefile.bin&#39;, &#39;wb&#39;) as f:    f.write(b&#39;Hello World&#39;)    text = &#39;Hello World&#39;    f.write(text.encode(&#39;utf-8&#39;))</code></pre><p>在读取二进制数据时，需要指明的是所有返回的数据都是字节字符串格式的，而不是文本字符串。 类似的，在写入的时候，必须保证参数是以字节形式对外暴露数据的对象(比如字节字符串，字节数组对象等)。</p><p>二进制I/O还有一个鲜为人知的特性就是数组和 C 结构体类型能直接被写入，而不需要中间转换为自己对象。比如：</p><pre><code class="py">import arraynums = array.array(&#39;i&#39;, [1, 2, 3, 4])with open(&#39;data.bin&#39;,&#39;wb&#39;) as f:    f.write(nums)</code></pre><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote><p><a href="https://python3-cookbook-personal.readthedocs.io/zh_CN/latest/c05/p01_read_write_text_data.html" target="_blank" rel="noopener">https://python3-cookbook-personal.readthedocs.io/zh_CN/latest/c05/p01_read_write_text_data.html</a><br><a href="https://docs.python.org/3/library/functions.html#open" target="_blank" rel="noopener">https://docs.python.org/3/library/functions.html#open</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PIL 基本用法2</title>
      <link href="/2018/08/09/PIL-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%952/"/>
      <url>/2018/08/09/PIL-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%952/</url>
      
        <content type="html"><![CDATA[<p><a href="/2017/12/17/PIL-基本用法/">PIL 基本用法</a></p><h1 id="PIL-Image-转-byte-数组"><a href="#PIL-Image-转-byte-数组" class="headerlink" title="PIL Image 转 byte 数组"></a>PIL Image 转 byte 数组</h1><blockquote><p><a href="https://stackoverflow.com/questions/33101935/convert-pil-image-to-byte-array" target="_blank" rel="noopener">https://stackoverflow.com/questions/33101935/convert-pil-image-to-byte-array</a></p></blockquote><pre><code class="py">import ioimport base64from PIL import Imageimg = Image.open(&quot;1.jpg&quot;, mode=&#39;r&#39;)imgByteArr = io.BytesIO()# 重新保存为 jpg 会再次有压缩，大小可能与原图不同# quality 设置图像的品质，默认为75roiImg.save(imgByteArr, format=&#39;JPEG&#39;, quality=90)imgByteArr = imgByteArr.getvalue()base64_str = base64.b64encode(imgByteArr)  # 可转为 base64</code></pre><a id="more"></a><h1 id="剪切、粘贴、合并图像"><a href="#剪切、粘贴、合并图像" class="headerlink" title="剪切、粘贴、合并图像"></a>剪切、粘贴、合并图像</h1><blockquote><p><a href="https://lizonghang.github.io/2016/07/05/快速入门PIL/" target="_blank" rel="noopener">https://lizonghang.github.io/2016/07/05/快速入门PIL/</a></p></blockquote><h2 id="从图像中复制出一个矩形选区"><a href="#从图像中复制出一个矩形选区" class="headerlink" title="从图像中复制出一个矩形选区"></a>从图像中复制出一个矩形选区</h2><pre><code class="py">print(im.size)  # (500, 750)box = (100, 100, 400, 400)region = im.crop(box)region.show()</code></pre><p>矩形选区有一个四元元组定义，分别表示左上、右下的坐标。这个库以左上角为坐标原点，单位是 px，所以上述代码复制了一个 300x300 pixels 的矩形选区。这个选区现在可以被处理并且粘贴到原图。</p><h2 id="处理复制的矩形选区并粘贴到原图"><a href="#处理复制的矩形选区并粘贴到原图" class="headerlink" title="处理复制的矩形选区并粘贴到原图"></a>处理复制的矩形选区并粘贴到原图</h2><pre><code class="py">region = region.transpose(Image.ROTATE_180)im.paste(region, box)im.show()</code></pre><p>当粘贴矩形选区的时候必须保证尺寸一致。此外，矩形选区不能在图像外。然而不必保证矩形选区和原图的颜色模式一致，因为矩形选区会被自动转换颜色。</p><h2 id="分离和合并颜色通道"><a href="#分离和合并颜色通道" class="headerlink" title="分离和合并颜色通道"></a>分离和合并颜色通道</h2><pre><code class="py">im = Image.open(&#39;lena.jpg&#39;)r, g, b = im.split()</code></pre><p>如果是单色通道的图片，使用 <code>split()</code> 之后会返回图片本身。你可以使用 <code>r.show()</code> 来查看分离颜色通道后的图片。</p><p>将分离的颜色合并为 RGB 可用 <code>merge()</code> 方法:</p><pre><code class="py">img = Image.merge(&#39;RGB&#39;, (b, g, r)) # 以 b,g,r 顺序合并img.show()</code></pre><h1 id="几何变换"><a href="#几何变换" class="headerlink" title="几何变换"></a>几何变换</h1><p><code>PIL.Image.Image</code> 类包含了设置图像大小 <code>resize()</code> 和旋转图像 <code>rotate()</code> 的方法。</p><p>resize() 接收一个元组来指定新大小。rotate() 接收一个逆时针的角度值。</p><h2 id="简单的几何变换"><a href="#简单的几何变换" class="headerlink" title="简单的几何变换"></a>简单的几何变换</h2><pre><code class="py">print(im.size)  # (500, 750)im_resize = im.resize((250, 250)) # 设置图像大小im_resize.show()im_rotate = im.rotate(45) # 旋转图像im_rotate.show()</code></pre><h2 id="旋转图像"><a href="#旋转图像" class="headerlink" title="旋转图像"></a>旋转图像</h2><p>如果要将图片旋转 90° 的整数倍，可以使用 rotate() 方法或者 <code>transpose()</code> 方法。transpose() 还可以将图片按照其竖直或水平边缘翻转。</p><pre><code class="py">out = im.transpose(Image.FLIP_LEFT_RIGHT)out = im.transpose(Image.FLIP_TOP_BOTTOM)out = im.transpose(Image.ROTATE_90)out = im.transpose(Image.ROTATE_180)out = im.transpose(Image.ROTATE_270)</code></pre><p><strong>使用 transpose(ROTATE) 和 rotate() 是没有区别的</strong>。更普遍的方法是使用 transform() 方法。</p><h1 id="颜色模式变换"><a href="#颜色模式变换" class="headerlink" title="颜色模式变换"></a>颜色模式变换</h1><pre><code class="py">im.convert(&#39;L&#39;).show()</code></pre><p>PIL 库支持各种不同模式之间的转换，比如 <code>L</code> 和 <code>RGB</code> 模式。为了转成其他的模式，需要用一张中间模式图像，典型的为 RGB 图片。</p><h1 id="读取图像"><a href="#读取图像" class="headerlink" title="读取图像"></a>读取图像</h1><p>Image.open() 方法是用来打开一个图片文件的。大多数情况下可以简单的将图像文件名作参数传入:</p><pre><code class="py">im = Image.open(&#39;lena.jpg&#39;)</code></pre><p>正常返回结果是一个 PIL.Image.Image 实例。否则会抛出 IOErro r错误。</p><p>你可以传入一个类文件代替文件名。这个类文件必须实现 read()，seek()，tell() 方法，并且以二进制模式打开。</p><h2 id="从文件读取"><a href="#从文件读取" class="headerlink" title="从文件读取"></a>从文件读取</h2><pre><code class="py">fp = open(&#39;lena.jpg&#39;, &#39;rb&#39;)im = Image.open(fp)</code></pre><h2 id="从-base64-中读取"><a href="#从-base64-中读取" class="headerlink" title="从 base64 中读取"></a>从 base64 中读取</h2><blockquote><p><a href="https://stackoverflow.com/questions/26070547/decoding-base64-from-post-to-use-in-pil/26079673#26079673" target="_blank" rel="noopener">https://stackoverflow.com/questions/26070547/decoding-base64-from-post-to-use-in-pil/26079673#26079673</a></p></blockquote><pre><code class="py">from PIL import Imagefrom io import BytesIOimport base64data[&#39;img&#39;] = &#39;&#39;&#39;R0lGODlhDwAPAKECAAAAzMzM/////wAAACwAAAAADwAPAAACIISPeQHsrZ5ModrLlN48CXF8m2iQ3YmmKqVlRtW4MLwWACH+H09wdGltaXplZCBieSBVbGVhZCBTbWFydFNhdmVyIQAAOw==&#39;&#39;&#39;im = Image.open(BytesIO(base64.b64decode(data)))im.show()</code></pre><h2 id="从网络中读取"><a href="#从网络中读取" class="headerlink" title="从网络中读取"></a>从网络中读取</h2><pre><code class="py"># import StringIO  # Python 2 可以使用from PIL import Imageimport requestsimport ior = requests.get(&#39;https://blog-1252208501.cos.ap-beijing.myqcloud.com/20180703210706.png&#39;)im = Image.open(io.BytesIO(r.content))# im = Image.open(StringIO.StringIO(r.content))  # Python 2 可以使用im.show()</code></pre><h2 id="从压缩包读取"><a href="#从压缩包读取" class="headerlink" title="从压缩包读取"></a>从压缩包读取</h2><p>为示范，先将一些文件例如“lena.jpg”和“niko.gif”打包，压缩包名假设为“Imaging.tar”。从压缩包中读取“lena.jpg”可使用 <code>TarIO.TarIO()</code> 方法获取图片，并交由 Image.open() 处理。</p><pre><code class="py">from PIL import Image, TarIOfp = TarIO.TarIO(&#39;Imaging.tar&#39;, &#39;lena.jpg&#39;)im = Image.open(fp)</code></pre><p>注意：对 zip 压缩包进行操作时可能会出现解码错误。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Effective Java》笔记10-14：所有对象的通用方法</title>
      <link href="/2018/08/08/%E3%80%8AEffective%20Java%E3%80%8B%E7%AC%94%E8%AE%B010-14%EF%BC%9A%E6%89%80%E6%9C%89%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%80%9A%E7%94%A8%E6%96%B9%E6%B3%95/"/>
      <url>/2018/08/08/%E3%80%8AEffective%20Java%E3%80%8B%E7%AC%94%E8%AE%B010-14%EF%BC%9A%E6%89%80%E6%9C%89%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%80%9A%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="第10条：覆盖-equals-时请遵守通用约定"><a href="#第10条：覆盖-equals-时请遵守通用约定" class="headerlink" title="第10条：覆盖 equals 时请遵守通用约定"></a>第10条：覆盖 equals 时请遵守通用约定</h1><!-- date: 2017-03-16 16:42:22 --><p>如果没有遵守通用约定，可能会导致错误，最容易避免这类问题的方法就是不覆盖 equals 方法，在这种情况下，类的每个实例都只与它自身相等。如果<strong>满足以下任何一个条件，则不要覆盖 equals 方法</strong>：</p><ol><li>类的每一个实例本质上都是唯一的。<br> 如 Thread，他本身并不具备更多逻辑比较的必要性。</li><li>不关心类是否提供了 “逻辑相等” 的测试功能。<br> 如 Random 类，开发者在使用过程中并不关心两个 Random 对象是否可以生成同样随机数的值，对于一些工具类亦是如此，如 NumberFormat 和 DateFormat 等。</li><li>超类已经覆盖了 equals，从超类继承过来的行为对于子类也是合适的。<br> 如 Set 实现都从 AbstractSet 中继承了 equals 实现。</li><li>类是私有的或是包级别私有的，（并且您）可以确定它的 equals 方法永远不会被调用。（<a href="https://www.zhihu.com/question/24310255/answer/240152455" target="_blank" rel="noopener">这里翻译有点问题</a>）</li></ol><a id="more"></a><h2 id="什么时候应该覆盖-equals"><a href="#什么时候应该覆盖-equals" class="headerlink" title="什么时候应该覆盖 equals"></a>什么时候应该覆盖 equals</h2><p>如果类具有自己特定的 “逻辑相等” 概念（不同于对象等同概念），而且超类还没有覆盖 equals 以实现期望的行为，这时我们就需要覆盖 equals 方法，这通常属于 “值类” 的情形，例如 Integer 或者是 Data，程序员在利用 equals 方法来比较值对象的引用时，希望知道它们在逻辑上是否相等，而不是想了解它们是否指向同一个对象。</p><h2 id="通用约定"><a href="#通用约定" class="headerlink" title="通用约定"></a>通用约定</h2><p>重写 equals 的时候就必须要遵守它的通用约定。</p><p>equals 方法实现了等价关系 (equivalence relation):</p><h3 id="自反性"><a href="#自反性" class="headerlink" title="自反性"></a>自反性</h3><p>自反性 (reflexive) 对于任何非 null 的引用值 x，x.equals(x) 必须返回 true。</p><h3 id="对称性"><a href="#对称性" class="headerlink" title="对称性"></a>对称性</h3><p>对称性 (symmetric) 对于任何非 null 的引用值 x 和 y，当且仅当 y.equals(x) 返回 true 时，x.equals(y)必须返回 true。</p><pre><code class="java">// 违反例子public final class CaseInsensitiveString {    private final String s;    public CaseInsensitiveString(String s) {        this.s = s;    }    @Override    public boolean equals(Object o) {        if (o instanceof CaseInsensitiveString)            return s.equalsIgnoreCase((CaseInsensitiveString)o).s);        if (o instanceof String)            return s.equalsIgnoreCase((String)o);        return false;    }}CaseInsensitiveString cis = new CaseInsensitiveString(&quot;Polish&quot;);String s = &quot;polish&quot;;</code></pre><p><code>cis.equals(s)</code> 返回 true，而 <code>s.equals(cis)</code> 返回 false。</p><p>为解决这个问题，可以把与 String 互操作的这段代码从 equals 方法中去掉。</p><pre><code class="java">@Overridepublic boolean equals(Object o) {    return (o instanceof CaseInsensitiveString) &amp;&amp;        ((CaseInsensitiveString)o).s.equalsIgnoreCase(s));}</code></pre><h3 id="传递性"><a href="#传递性" class="headerlink" title="传递性"></a>传递性</h3><p>传递性 (transitive) 对于任何非 null 的引用值，x,y,z，如果 x.equals(y) 为 true，并且 y.equals(z)也返回 true，那么 x.equals(z) 也必须返回 true。</p><p>我们无法在扩展可实例化的类的同时，即增加新的值组件，同时又保留 equals 约定。为解决这个问题，可以使用复合。也可以只要不能直接创建超类的实例，这个问题也不会发生。</p><p>java.sql.Timestamp 对 java.util.Date 进行了扩展，Timestamp 的 equals 实现违发了对称性，Timestamp 有个免责声明，不要混合使用 Date 和 Timestamp 对象，只要不混合在一起，就不会有问题。Timestamp 类的这种行为是错误的。</p><pre><code class="java">public class Point {    private final int x;    private final int y;    public Point(int x,int y) {        this.x = x;        this.y = y;    }    @Override    public boolean equals(Object o) {        if (o == null || o.getClass() == getClass())            return false;        Point p = (Point)o;        return p.x == x &amp;&amp; p.y == y;    }}class MyTest {    private static final Set&lt;Point&gt; unitCircle;    static {        unitCircle = new HashSet&lt;Point&gt;();        unitCircle.add(new Point(1,0));        unitCircle.add(new Point(0,1));        unitCircle.add(new Point(-1,0));        unitCircle.add(new Point(0,-1));    }    public static boolean onUnitCircle(Point p) {        return unitCircle.contains(p);    }}// 如果此时我们测试的不是 Point 类本身，而是 ColorPoint(Point 的子类)，// 那么按照目前 Point.equals(getClass 方式) 的实现逻辑，ColorPoint 对象在被传入 onUnitCircle 方法后，将永远不会返回 true，// 这样的行为违反了 &quot;里氏替换原则&quot;(敏捷软件开发一书中给出了很多的解释)，既一个类型的任何重要属性也将适用于它的子类型。因此该类型编写的任何方法，在它的子类型上也应该同样运行的很好。</code></pre><h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p>一致性 (consistent) 对于任何非 null 的引用值 x 和 y，只要 equals 的比较操作在对象中所用的信息没有被修改，多次调用 x.equals(y) 就会一致地返回 true，或者 false。</p><p>不要使用 equals 方法依赖于不可靠资源。如，java.net.URL 的 equals 方法依赖于对 URL 中主机 IP 地址的比较，IP 地址可能会更改。</p><h3 id="非空性"><a href="#非空性" class="headerlink" title="非空性"></a>非空性</h3><p>对于任何非 null 的引用值 x，x.equals(null) 必须返回 false。</p><pre><code class="java">@Overridepublic boolean equals(Object o) {    if (o == null)        return false;    ...}</code></pre><p>书中说，<strong>这样的测试是不必要的</strong>，因为 equals 方法会使用 instanceof 操作符检查其参数是否为正确的类型：<code>if (!(o instanceof MyType)) return false;</code>，如果把 null 传给 equals 方法，类型检查就会返回 false，所以不需要单独的 null 检查。</p><p>但是，常见的 IDE 自动生成 equals 方法，都是使用的如下方法：</p><pre><code class="java">if (this == o) return true;if (o == null || getClass() != o.getClass()) return false;MyType myType = (MyType) o;...</code></pre><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20180808211452.png" alt="IDEA 生成 equals 方法"></p><p>在上图，IDEA 生成 equals 方法，多种选择模版的方法，均是如此。</p><p>这种方法，根据上文中<strong>传递性</strong>的介绍中，可能会损失传递性。</p><h2 id="高质量的-equals"><a href="#高质量的-equals" class="headerlink" title="高质量的 equals"></a>高质量的 equals</h2><ol><li>使用 <code>==</code> 操作符检查 &quot;参数是否为这个对象的引用&quot; 如果是，则返回 true。<code>if (this == o) return true;</code>，这只不过是一种性能优化，如果比较操作有可能很昂贵，就值得这么做。</li><li>使用 <code>instanceof</code> 操作符检查 &quot;参数是否为正确的类型&quot; 如果不是，则返回 false。</li><li>把参数装换成正确的类型。（这个比较好理解，instanceof 检测后，一般都会强转成所需类型）</li><li>对于该类中的每个『关键』域，检查参数中的域是否与对象中对应的域相配。(比如学生类有学号，班级，姓名这些重要的属性，我们都需要去比对)。<br>习惯用法：<code>return (a == b) || (a != null &amp;&amp; a.equals(b));</code>（JDK 7 新增的 java.util.Objects 类中 equals 方法就是这么实现的）。<br>对应 float 可以使用 Float.compare 方法，double 可以使用 Double.compare 方法，因为这样可以考虑到精度、Double.NaN、Float.NaN 和 -0.0f 等问题。<br>对于数组可以使用 Arrays.equals 方法。</li><li>当你编写完成了 equals 方法之后，应该问自己是哪个问题: 它是否是对称的、传递的、一致的？</li></ol><p>对于类型为非 <code>float</code> 或 <code>double</code> 的基本类型，使用 == 运算符进行比较；对于对象引用属性，递归地调用 equals 方法；对于 float 基本类型的属性，使用静态 <code>Float.compare(float, float)</code> 方法；对于 double 基本类型的属性，使用 <code>Double.compare(double, double)</code> 方法。由于存在 <code>Float.NaN</code>，<code>-0.0f</code> 和类似的 double 类型的值，所以需要对 float 和 double 属性进行特殊的处理；有关详细信息，请参阅 <code>Float.equals</code> 方法的详细文档。 虽然你可以使用静态方法 <code>Float.equals</code> 和 <code>Double.equals</code> 方法对 float 和 double 基本类型的属性进行比较，这会导致每次比较时发生自动装箱，引发非常差的性能。 对于数组属性，将这些准则应用于每个元素。 如果数组属性中的每个元素都很重要，请使用其中一个重载的 <code>Arrays.equals</code> 方法。</p><p>　　某些对象引用的属性可能合法地包含 null。 为避免出现 <code>NullPointerException</code> 异常，请使用静态方法 <code>Objects.equals(Object, Object)</code> 检查这些属性是否相等。</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol><li>覆盖 equals 时总要覆盖 hashCode</li><li>不要让 equals 方法过于智能。（比如讲别名的形式考虑到等价范围内）</li><li><strong>不要将 equals 声明中的 Object 对象替换为其他的类型</strong>，可以会导致并没有覆盖 Object.equals 方法，只是重载。在方法名的前面加上 @Override 注释标签，可以避免这个问题。</li></ol><h1 id="第11条：覆盖-equals-时总要覆盖-hashCode"><a href="#第11条：覆盖-equals-时总要覆盖-hashCode" class="headerlink" title="第11条：覆盖 equals 时总要覆盖 hashCode"></a>第11条：覆盖 equals 时总要覆盖 hashCode</h1><!-- date: 2018-08-08 21:42:22 --><p>在每个覆盖了 equals 方法的类中，也必须覆盖 hashCode 方法。如果不这样做的话，就会违反 Object.hashCode 的能用约定，从而导致该类无法结合所有基于散列的集合一起正常动作，这些集合包括 HashMap、HashSet、Hashtable 等。</p><p>Object 通用约定：</p><ul><li>在应用程序的执行期间，只要对象的 equals 方法的比较操作所用到的信息没有被修改，那么对这同一个对象调用多次，hashCode 方法都必须始终如一地返回同一个整数。在同一个应用程序的多次执行过程中，每次执行所返回的整数可以不一致。</li><li>如果两个对象根据 equals 方法比较是相等的，那么调用这两个对象中任意一个对象的 hashCode 方法都必须产生同样的整数结果。(<strong>即 equals 相等，那么 hashCode 一定相等，需要注意的是，反过来不一定成立</strong>，即 hashCode 相等不代表 equals 相等)</li><li>如果两个对象根据 equals 方法比较是不相等的，那么调用这两个对象中任意一个对象的 hashCode 方法，则不一定要产生不同的整数结果。但是程序员应该知道，给不相等的对象产生截然不同的证书结果，有可能提高散列表 (hash table) 的性能。</li></ul><h2 id="不重写-hashCode-带来的问题"><a href="#不重写-hashCode-带来的问题" class="headerlink" title="不重写 hashCode 带来的问题"></a>不重写 hashCode 带来的问题</h2><p>正如之前提到的, HashMap 会把相同的 hashCode 的对象放在同一个散列桶 (hash bucket) 中, 那么即使 equals 相同而 hashCode 不相等, 那么跟 HashMap 一起使用, 则会得到与预期不相同的结果.</p><p>HashMap 查找某个键是否存在时，采用取了优化方式，它们<strong>先比较的是两者的 hashcode</strong>，如果不同，则直接返回 false（因为放入合希集合的过程中元素的 hashcode 就已计算出并存 Entry 里的 hash 域中了，所以先比较这哈希值很快），否则再比较内容，源码部分如下：<code>if (e.hash == hash &amp;&amp; (x == y || x.equals(y)))</code> 。</p><h2 id="如何重写-hashCode"><a href="#如何重写-hashCode" class="headerlink" title="如何重写 hashCode"></a>如何重写 hashCode</h2><ol><li><p>把某个非零的常数值，比如说 17（值 17 是任选的），保存在一个名为 result 的 int 的类型变量中。</p></li><li><p>对于对象中每个键域 f（指 equals 方法中涉及的每个域），完成以下步骤：<br> 1) 为该域计算 int 类型的散列码 c：</p><pre><code> 1. 如果该域是 boolean 类型，则计算 (f ? 1 : 0)。 2. 如果该域是 byte、char、short 或者 int 类型，则计算 (int)f。 3. 如果该域是 long 类型，则计算 (int)(f ^ (f &gt;&gt;&gt; 32))。 4. 如果该域是 float 类型，则计算 Float.floatToIntBits(f)，即将内存中的浮点数二进制位看作是整型的二进制，并将返回整型结果。 5. 如果该域是 dobule 类型，则计算 Double.doubleToLongBits(f)，然后按照步骤 2.1.III。 6. 如果该域是一个对象引用，并且该类的 equals 方法通过递归地调用 equals 方式来比较这个域，则同样为这个域递归地调用 hashCode。如果这个域的值为 null，则返回 0。 7. 如果该域是一个数组，则要把每一个元素当做单独的域来处理。也就是说，递归地应用上述规则，对每个重要的元素计算一个散列码，然后根据步骤 2.b 中的做法把这些散列值组合起来。如果数组的每个元素都需要求，则可以使用 1.5 版本发行的 Arrays.hashCode 方法。</code></pre><p> 2) 按照下面的公式，把步骤 2.1 中计算得到的散列码 c 合并到 result 中：</p><pre><code> result = 31 * result + c;</code></pre><p> 步骤 2.2 中的乘法部分使得散列值依赖于域的顺序，如果一个类包含多个包含多个相似的域，这样的乘法运算就会产生一个更好的散列函数。例如，如果 String 散列函数省略了这个乘法部分，那么只要组成该字符串的字符是一样的，而不管它们的排列的顺序。</p><p> 之所以选择 31，是因为它是一个奇素数。31 还有个很好的特性，即用移位和减法来代替乘法，可以得到更好的性能：31 * i = i ^32 - i =  (i &lt;&lt; 5) – i，现代的 VM 可以自动完成这种优化。</p></li><li><p>返回 result。</p></li><li><p>写完了 hashCode 方法后，问问自己 “相等的实例是否都具有相等的散列码”。</p></li></ol><p>在散列码计算的过程中，可以把冗余域排除在外，换句话说，如果一个域的值可以根据参与计算的其他域值计算出来，则可以把这样的域排除在外。但必须排除 equals 比较计算中没有用到的所有域，否则很有可能违反 hashCode 约定的第二条。</p><p>不要试图从散列码计算中排除掉一个对象的关键部分来提高性能。虽然这样得到的散列函数运行起来可能更快，但是它的效果不见得会好，可能会导致散列表慢到根本无法使用。如早期版本的 String，为了提高计算哈希值的效率，只是挑选其中 16 个字符参与 hashCode 的计算，这样将会导致大量的 String 对象具有重复的 hashCode，从而极大的降低了哈希集合的存取效率。</p><pre><code class="java">@Override public int hashCode() {    int result = 17;    result = 31 * result + areaCode;    result = 31 * result + prefix;    result = 31 * result + lineNumber;    return result;}</code></pre><p>对于有些不可变对象，如果需要被频繁的存取于哈希集合，<strong>不要试图从哈希码计算中排除重要的属性来提高性能</strong>。为了提高效率，可以在对象构造的时候就已经计算出其 hashCode 值，或者使用<strong>延迟初始化</strong>散列码，直到 hashCode 被第一次调用的时候才初始化，如：</p><pre><code class="java">private volatile int hashCode;@Override public int hashCode() {  int result = hashCode;  if (result == 0) {      result = 17;      result = 31 * result + areaCode;      result = 31 * result + prefix;      result = 31 * result + lineNumber;      hashCode = result;  }  return result;}</code></pre><h2 id="类库"><a href="#类库" class="headerlink" title="类库"></a>类库</h2><p>虽然在这个项目的方法产生相当好的哈希函数，但并不是最先进的。 它们的质量与 Java 平台类库的值类型中找到的哈希函数相当，对于大多数用途来说都是足够的。 如果真的需要哈希函数而不太可能产生碰撞，请参阅 Guava 框架的的 <code>com.google.common.hash.Hashing</code> 方法。</p><p>Objects 类有一个静态方法，它接受任意数量的对象并为它们返回一个哈希码。这个名为 hash 的方法可以让你编写一行 hashCode 方法，其质量与根据这个项目中的上面编写的方法相当。不幸的是，它们的运行速度更慢，因为它们需要创建数组以传递可变数量的参数，以及如果任何参数是基本类型，则进行装箱和取消装箱。这种哈希函数的风格建议仅在性能不重要的情况下使用：</p><pre><code class="java">@Overridepublic int hashCode() {   return Objects.hash(lineNum, prefix, areaCode);}</code></pre><h1 id="第12条：始终要覆盖-toString"><a href="#第12条：始终要覆盖-toString" class="headerlink" title="第12条：始终要覆盖 toString"></a>第12条：始终要覆盖 toString</h1><!-- date: 2018-08-08 22:42:22 --><p>Object 类默认 toString 的实现方法是这样的：</p><pre><code class="java">public String toString() {    return getClass().getName() + &#39;@&#39; + Integer.toHexString(hashCode());}</code></pre><p>它只有类名 +&#39;@&#39;+ 散列值，toString 方法应该返回对象中包含的所有值得关注的信息。建议所有的子类都覆盖这个方法。</p><p>尽量不要固定格式，这样会给今后添加新的字段信息带来一定的束缚，因为必须要考虑到格式的兼容性问题</p><p>如果指定了格式，可以提供一个相匹配的静态工厂或者构造器，可以利用 toString 返回的字符串作为该类的构造函数参数来实例化该类的对象，如 BigDecimal 和 BigInteger 和绝大多数的基本类型包装类。</p><h1 id="第13条：谨慎地覆盖-clone"><a href="#第13条：谨慎地覆盖-clone" class="headerlink" title="第13条：谨慎地覆盖 clone"></a>第13条：谨慎地覆盖 clone</h1><!-- date: 2018-08-16 20:21:22 --><p>Object 中 clone 方法的定义是：</p><pre><code class="java">protected native Object clone() throws CloneNotSupportedException;</code></pre><p>如果需要调用 clone 方法，需先实现 Cloneable 接口，Cloneable 是一个标识性接口，没有任何方法。</p><!-- more --><p>如果某个类中每个成员域是一个基本类型的值，或者是指向一个不可变对象的引用，那么我们直接调用 Object 中的 clone 方法就是我们要返回的拷贝对象了，而不需要对这个对象再做进一步的处理：</p><pre><code class="java">// 注，这里返回的是 PhoneNumber 而不是 Object，1.5版本后支持参数有协变：覆盖方法的返回值可以是被覆盖方法的返回类型的子类。这样不用在客户端强转了。@Overridepublic PhoneNumber clone() {    try {        return (PhoneNumber) super.clone();    } catch(CloneNotSupportedException e) {        throw new AssertionError();  // Can&#39;t happen    }}</code></pre><p>使用 Object 中的默认 clone 对某个类进行克隆时，任何类型的数组属性成员都只是浅复制，即克隆出来的数组与原来类中的数组指向同一存储空间，其他引用也是这样，只有基本类型才深复制。</p><h2 id="代替方法"><a href="#代替方法" class="headerlink" title="代替方法"></a>代替方法</h2><p>提供某些其他途径来代替对象拷贝，或干脆不提供这样的能力。一个好的代替方法是“拷贝构造函数”</p><pre><code class="java">public MyClass(MyClass myClass){};// 或另一种微小变形——静态工厂方法public static MyClass newInstance(MyClass myClass){};</code></pre><p>实践中比较实用的 clone 的替代品：</p><ol><li>如果一个类是可序列化的，那么可以将其先序列化，然后再反序列化已得到其副本。如果对象很大，甚至可以序列化到磁盘上。</li><li>如果是JavaBean，可以使用 <code>org.apache.commons.beanutils.BeanUtils.cloneBean</code> 静态方法。经查明该方法是浅复制 <a href="https://stackoverflow.com/questions/9264066/beanutils-clonebean-deep-copy" target="_blank" rel="noopener">https://stackoverflow.com/questions/9264066/beanutils-clonebean-deep-copy</a></li><li><code>org.apache.commons.lang3.SerializationUtils.clone(T)</code>，同样也是序列化原理。</li></ol><h1 id="第14条：考虑实现-Comparable-接口"><a href="#第14条：考虑实现-Comparable-接口" class="headerlink" title="第14条：考虑实现 Comparable 接口"></a>第14条：考虑实现 Comparable 接口</h1><!-- date: 2018-08-16 22:06:22 --><p>如果一个类实现了 Comparabler 接口，就表明它的实例具有内在的自然排序规则了。事实上，Java 平台类库中的所有值类都实现了 Comparable 接口。<strong>如果你正在编写一个值类</strong>，它具有非常的内在排序关系，比如按字母顺序、按数值顺序或按年代，那你就应该考虑实现这个接口：</p><pre><code class="java">public interface Comparable&lt;T&gt;{    int compareTo(T t);}</code></pre><p>比较整型基本类型的域，可以使用关系操作符 == 、&lt; 和 &gt;。但浮点域要使用 Double.compare 或者 Float.comprae，而不是用关系操作符。</p><p>compareTo 具有和 equals 相似的约定：</p><ol><li>自反性：x.compareTo(x) 一定为 true</li><li>对称性：当且仅当 x.compareTo(y) 为 0；那么 y.compareTo(x) 也必须为 0</li><li>传递性：如果 x.compareTo(y) == 0，sgn(x.compareTo(z)) == sgn(y.compareTo(z)) 必须成立 （sgn 代表表达式）<br>如果x.compareTo(y) &lt; 0，y.compareTo(z) &lt; 0；那么 x.compareTo(z) 也必须 &lt; 0</li><li>一致性：对于任意引用值 x 和 y，如果用于 compareTo 比较的对象信息没有被修改的话，那么多次调用 x.compareTo(y) 返回的值是一致的</li><li><strong>强力建议</strong>：(x.compareTo(y) == 0) == (x.equals(y))，但这并不是严格要求。一般而言，任何实现了 Comarable 接口的类，若违反了这个条件，应该明确予以说明。推荐这样的说法：“注意：该类具有内在的排序能力，但是与 equals 不一致。”</li></ol><p>类似于 equals 方法（传递性），无法在用新的组件扩展可实例化的类时，同时保持 comparTo 约定。</p><p>如果想为一个实现了 Comparable 接口的类增加值组件，请不要扩展此类；而是要编写一个新的类，其中包含第一个类的一个实例。然后提供一个“视图（view）”方法返回这个实例。这样既可以让你自由地在第二个类上实现 compareTo 方法，同时也允许它的客户端在必要的时候，把第二个类的实例视同第一个类的实例。</p><h2 id="强力建议-x-compareTo-y-0-x-equals-y"><a href="#强力建议-x-compareTo-y-0-x-equals-y" class="headerlink" title="强力建议 (x.compareTo(y) == 0) == (x.equals(y))"></a>强力建议 (x.compareTo(y) == 0) == (x.equals(y))</h2><p>推荐 compareTo 方法施加的等同性测试，在通常情况下应该返回和 equals 方法同样的结果，考虑如下情况：</p><pre><code class="java">public static void main(String[] args) {    HashSet&lt;BigDecimal&gt; hs = new HashSet&lt;BigDecimal&gt;();    BigDecimal bd1 = new BigDecimal(&quot;1.0&quot;);    BigDecimal bd2 = new BigDecimal(&quot;1.00&quot;);    hs.add(bd1);    hs.add(bd2);    System.out.println(&quot;The count of the HashSet is &quot; + hs.size());    TreeSet&lt;BigDecimal&gt; ts = new TreeSet&lt;BigDecimal&gt;();    ts.add(bd1);    ts.add(bd2);    System.out.println(&quot;The count of the TreeSet is &quot; + ts.size());} /* output:The count of the HashSet is 2The count of the TreeSet is 1*/</code></pre><p>BigDecimal，这是一个没有满足这一条件的类。</p><p>我们实例化 2 个对象：new BigDecimal(&quot;1.0&quot;) 和 new BigDecimal(&quot;1.00&quot;)，若把这 2 个对象放入 HashSet 中，HashSet 将有 2 个元素，而放入 TreeSet，则这个 TreeSet 中仅有 1 个元素。原因是，HashSet 是依赖 hashCode 和 equals 来判断的；而 <strong>TreeSet 是依赖 compareTo 来判断的</strong>。</p><h2 id="Comparator"><a href="#Comparator" class="headerlink" title="Comparator"></a>Comparator</h2><p>如果一个域并没有实现 Comparable 接口，或者你需要使用一个非标准的排序关系，就可以使用一个显式的 Comparable 来代替：</p><pre><code class="java">public interface Comparator&lt;T&gt; {    int compare(T o1, T o2);}</code></pre><p>或者也可以使用已有的 Comparator，如 String.CASE_INSENSITIVE_ORDER</p><h2 id="第二版实例"><a href="#第二版实例" class="headerlink" title="第二版实例"></a>第二版实例</h2><pre><code class="java">// 本书第二版public int compareTo(PhoneNumer pn) {    int areaCodeDiff = areaCode - pn.areaCode;    if (areaCodeDiff != 0)        return areaCodeDiff;    int prefixDiff = prefix - pn.prefix;    if (prefixDiff != 0)        return prefixDiff;    int lineNumberDiff = lineNumber - pn.lineNumber;    if (lineNumberDiff != 0)        return lineNumberDiff;    return 0;}</code></pre><h2 id="第三版"><a href="#第三版" class="headerlink" title="第三版"></a>第三版</h2><p>在 Java 7 中，静态比较方法被添加到 Java 的所有包装类中。在 compareTo 方法中使用关系运算符 <strong>「&lt;」和「&gt;」是冗长且容易出错的，不再推荐</strong>。</p><p>如果一个类有多个重要的属性，那么比较他们的顺序是至关重要的。从最重要的属性开始，逐步比较所有的重要属性。如果比较结果不是零（零表示相等），则表示比较完成; 只是返回结果。如果最重要的字段是相等的，比较下一个重要的属性，依此类推，直到找到不相等的属性或比较剩余不那么重要的属性。PhoneNumber 类的 compareTo 方法，演示了这种方法：</p><pre><code class="java">public int compareTo(PhoneNumber pn) {    int result = Short.compare(areaCode, pn.areaCode);    if (result == 0)  {        result = Short.compare(prefix, pn.prefix);        if (result == 0)            result = Short.compare(lineNum, pn.lineNum);    }    return result;}</code></pre><p>　　在 Java 8 中 Comparator 接口提供了一系列比较器方法，可以使比较器流畅地构建。 这些比较器可以用来实现 compareTo 方法，就像 Comparable 接口所要求的那样。 许多程序员更喜欢这种方法的简洁性，尽管它的性能并不出众：在我的机器上排序 PhoneNumber 实例的数组速度慢了大约 10％。 在使用这种方法时，考虑使用 Java 的静态导入，以便可以通过其简单名称来引用比较器静态方法，以使其清晰简洁。 以下是 PhoneNumber 的 compareTo 方法的使用方法：</p><pre><code class="java">private static final Comparator&lt;PhoneNumber&gt; COMPARATOR =        comparingInt((PhoneNumber pn) -&gt; pn.areaCode)          .thenComparingInt(pn -&gt; pn.prefix)          .thenComparingInt(pn -&gt; pn.lineNum);public int compareTo(PhoneNumber pn) {    return COMPARATOR.compare(this, pn);}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Effective Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python random 模块</title>
      <link href="/2018/08/07/Python%20random%20%E6%A8%A1%E5%9D%97/"/>
      <url>/2018/08/07/Python%20random%20%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<p>Python 中的 random 模块用于生成伪随机数。所产生的数字都是伪随机数，如果需要真的随机性，可以使用 <code>os</code> 模块中的 <code>urandom</code> 函数。random 模块内的 SystemRandom 类也是基于同种功能。</p><pre><code class="py">&gt;&gt;&gt; os.urandom(2)b&#39;\xe8\xc8&#39;</code></pre><h1 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h1><h2 id="random-randrange"><a href="#random-randrange" class="headerlink" title="random.randrange"></a>random.randrange</h2><p>random.randrange(stop)</p><p>random.randrange(start, stop[, step])</p><p>从 <code>range(start, stop, step)</code> 中返回随机选择的元素</p><pre><code class="py">&gt;&gt;&gt; import random&gt;&gt;&gt; random.randrange(10)3&gt;&gt;&gt; random.randrange(0, 10, 2)4</code></pre><a id="more"></a><h2 id="random-randint-a-b"><a href="#random-randint-a-b" class="headerlink" title="random.randint(a, b)"></a>random.randint(a, b)</h2><p>返回随机整数 N，<code>a &lt;= N &lt;= b</code>，相当于 <code>randrange(a, b+1)</code></p><pre><code class="py">&gt;&gt;&gt; random.randint(0, 10)3</code></pre><h1 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h1><h2 id="random-choice-seq"><a href="#random-choice-seq" class="headerlink" title="random.choice(seq)"></a>random.choice(seq)</h2><p>从非空序列 seq 中返回一个随机元素。</p><pre><code class="py">&gt;&gt;&gt; s = []&gt;&gt;&gt; random.choice(s)Traceback (most recent call last):  File &quot;&lt;pyshell#8&gt;&quot;, line 1, in &lt;module&gt;    random.choice(s)  File &quot;C:\Python36\lib\random.py&quot;, line 257, in choice    raise IndexError(&#39;Cannot choose from an empty sequence&#39;) from NoneIndexError: Cannot choose from an empty sequence&gt;&gt;&gt; s = [1,2,3,4,]&gt;&gt;&gt; random.choice(s)2</code></pre><h2 id="random-choices-population-weights-None-cum-weights-None-k-1"><a href="#random-choices-population-weights-None-cum-weights-None-k-1" class="headerlink" title="random.choices(population, weights=None, *, cum_weights=None, k=1)"></a>random.choices(population, weights=None, *, cum_weights=None, k=1)</h2><p>New in version 3.6.</p><p>如果 population 为空序列，抛出异常 IndexError。</p><ul><li>参数 <code>k</code> 大小的元素列表，列表中元素可重复，列表元素来自于参数 population。</li><li>参数 <code>weights</code> 为相对权重列表，<strong>weights 列表中的元素个数与参数 population 相同</strong>，参数 weights 中元素数值大小<strong>决定参数 population 中相同位置元素的权重</strong>，权重越高随机出现概率越大。</li><li>参数 <code>cum_weights</code> 是累积权重列表，累积权重通过相对权重计算，例如相对权重 <code>[1,5,1]</code> 等同于累积权重 <code>[1,6,7]</code>，即 <code>[(0+1),(1+5),(1+5+1)]</code>。使用累积权重有更高的执行效率。</li></ul><p>weights 或 cum_weights 可以使用任何与 random() 返回的数字类型（包括整数，浮点数和分数）。</p><pre><code class="py">&gt;&gt;&gt; random.choices([1, 2, 3], cum_weights=[1, 6, 7], k=2)[2, 2]&gt;&gt;&gt; random.choices([1, 2, 3], [1, 5, 1], k=2)[3, 2]&gt;&gt;&gt; random.choices([1, 2, 3],  k=2) # 未指定，以相等的概率进行选择[2, 1]</code></pre><h2 id="random-shuffle-x-random"><a href="#random-shuffle-x-random" class="headerlink" title="random.shuffle(x[, random])"></a>random.shuffle(x[, random])</h2><p>用于将一个列表中的元素打乱。random 默认是 <code>random.random()</code>。</p><p>如果对不可变序列重新随机排序，可以使用 <code>random.sample(x, k=len(x))</code>。</p><pre><code class="py">&gt;&gt;&gt; random.shuffle(s)&gt;&gt;&gt; s = [1,2,3,4,][3, 4, 1, 2]</code></pre><h2 id="random-sample-population-k"><a href="#random-sample-population-k" class="headerlink" title="random.sample(population, k)"></a>random.sample(population, k)</h2><p>从指定序列中随机获取指定长度 k 的元素序列。sample 函数不会修改原有序列。如果 population 包含重复的，则取出的子序列也是可能包含重复的。</p><p>要从一系列整数中选择样本，请使用 <code>range()</code> 对象作为参数。这尤其快速且节省空间：<code>random.sample(range(10000000), k = 60)</code>。</p><p>如果子序列大小大于总体大小，则会引发 ValueError。</p><pre><code class="py">&gt;&gt;&gt; s = [1,2,3,4,4]&gt;&gt;&gt; random.sample(s,4)[2, 1, 4, 4]</code></pre><h1 id="特定值分布"><a href="#特定值分布" class="headerlink" title="特定值分布"></a>特定值分布</h1><h2 id="random-random"><a href="#random-random" class="headerlink" title="random.random()"></a>random.random()</h2><p>返回下一个随机浮点数 range(0.0, 1.0)。</p><pre><code class="py">&gt;&gt;&gt; random.random()0.7790151001888421</code></pre><h2 id="random-uniform-a-b"><a href="#random-uniform-a-b" class="headerlink" title="random.uniform(a, b)"></a>random.uniform(a, b)</h2><p>返回一个随机浮点数 N，两个参数其中一个是上限，一个是下限。如果 <code>a &gt; b</code>，则生成的随机数 N: <code>a &lt;= N &lt;= b</code>。如果 <code>a &lt;b</code>， 则 <code>b &lt;= N &lt;= a</code>。</p><pre><code class="py">&gt;&gt;&gt; random.uniform(10, 20)19.85832989416698&gt;&gt;&gt; random.uniform(20, 10)18.467114459490777</code></pre><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p><a href="https://docs.python.org/3/library/random.html" target="_blank" rel="noopener">https://docs.python.org/3/library/random.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Head First 设计模式》笔记25-访问者模式</title>
      <link href="/2018/08/06/%E3%80%8AHead-First-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E7%AC%94%E8%AE%B025-%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/08/06/%E3%80%8AHead-First-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E7%AC%94%E8%AE%B025-%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>访问者模式即表示一个作用于某对象结构中的各元素的操作，它使我们可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</p><p>首先我们要明确一点就是访问者模式适用于数据结构相对稳定的系统。它是将数据的操作与数据结构进行分离了，如果某个系统的数据结构相对稳定，但是操作算法易于变化的话，就比较适用适用访问者模式，因为访问者模式使得算法操作的增加变得比较简单了。</p><a id="more"></a><h1 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h1><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20180806215315.jpg" alt=""></p><p>访问者模式主要包含如下几个角色：</p><ul><li>Vistor: 抽象访问者。为该对象结构中的 ConcreteElement 的每一个类声明的一个操作。</li><li>ConcreteVisitor: 具体访问者。实现 Visitor 申明的每一个操作，每一个操作实现算法的一部分。</li><li>Element: 抽象元素。定义一个 Accept 操作，它以一个访问者为参数。</li><li>ConcreteElement: 具体元素 。实现 Accept 操作。</li><li>ObjectStructure: 对象结构。能够枚举它的元素，可以提供一个高层的接口来允许访问者访问它的元素。</li></ul><p>在访问者模式中对象结构存储了不同类型的对象，以便不同的访问者来访问。从上面的 UML 结构图中我们可以看出，访问者模式主要分为两个层次结构，一个是访问者层次结构，提供了抽象访问者和具体访问者，主要用于什么一些操作。一个是元素层次结构，提供了抽象元素和具体元素，主要用于声明 Accept 操作。</p><p>在访问者模式中相同的访问者可以以不同的方式访问不同的元素，所以在访问者模式中增加新的访问者无需修改现有代码，可扩展行强。</p><p>同时在访问者模式用到了一种双分派的技术，<strong>所谓双分派技术就是在选择一个方法的时候，不仅仅要根据消息接收者（receiver）的运行时区别（Run time type），还要根据参数的运行时区别</strong>。在访问者模式中，客户端将具体状态当做参数传递给具体访问者，这里完成第一次分派，然后具体访问者作为参数的 “具体状态” 中的方法，同时也将自己 this 作为参数传递进去，这里就完成了第二次分派。<strong>双分派意味着得到的执行操作决定于请求的种类和接受者的类型</strong>。</p><h1 id="模式实现"><a href="#模式实现" class="headerlink" title="模式实现"></a>模式实现</h1><p>以在医院付费、取药为实例。在这个实例中划价员和药房工作者作为访问者，药品作为访问元素、处方单作为对象结构。</p><p>抽象访问者：Visitor.java</p><pre><code class="java">public abstract class Visitor {    protected String name;    public void setName(String name) {        this.name = name;    }    public abstract void visitor(MedicineA a);    public abstract void visitor(MedicineB b);}</code></pre><p>具体访问者：划价员、Charger.java</p><pre><code class="java">public class Charger extends Visitor{    public void visitor(MedicineA a) {        System.out.println(&quot;划价员：&quot; + name +&quot;给药&quot; + a.getName() +&quot;划价:&quot; + a.getPrice());    }    public void visitor(MedicineB b) {        System.out.println(&quot;划价员：&quot; + name +&quot;给药&quot; + b.getName() +&quot;划价:&quot; + b.getPrice());    }}</code></pre><p>具体访问者：药房工作者、WorkerOfPharmacy.java</p><pre><code class="java">public class WorkerOfPharmacy extends Visitor{    public void visitor(MedicineA a) {        System.out.println(&quot;药房工作者：&quot; + name + &quot;拿药 ：&quot; + a.getName());    }    public void visitor(MedicineB b) {        System.out.println(&quot;药房工作者：&quot; + name + &quot;拿药 ：&quot; + b.getName());    }}</code></pre><p>抽象元素：Medicine.java</p><pre><code class="java">public abstract class Medicine {    protected String name;    protected double price;    public Medicine (String name,double price){        this.name = name;        this.price = price;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public double getPrice() {        return price;    }    public void setPrice(double price) {        this.price = price;    }    public abstract void accept(Visitor visitor);}</code></pre><p>具体元素：MedicineA.java</p><pre><code class="java">public class MedicineA extends Medicine{    public MedicineA(String name, double price) {        super(name, price);    }    public void accept(Visitor visitor) {        visitor.visitor(this);    }}</code></pre><p>具体元素：MedicineB.java</p><pre><code class="java">public class MedicineB extends Medicine{    public MedicineB(String name, double price) {        super(name, price);    }    public void accept(Visitor visitor) {        visitor.visitor(this);    }}</code></pre><p>药单：Presciption.java</p><pre><code class="java">public class Presciption {    List&lt;Medicine&gt; list = new ArrayList&lt;Medicine&gt;();    public void accept(Visitor visitor){        Iterator&lt;Medicine&gt; iterator = list.iterator();        while (iterator.hasNext()) {            iterator.next().accept(visitor);        }    }    public void addMedicine(Medicine medicine){        list.add(medicine);    }    public void removeMedicien(Medicine medicine){        list.remove(medicine);    }}</code></pre><p>客户端：Client.java</p><pre><code class="java">public class Client {    public static void main(String[] args) {        Medicine a = new MedicineA(&quot;板蓝根&quot;, 11.0);        Medicine b = new MedicineB(&quot;感康&quot;, 14.3);        Presciption presciption = new Presciption();        presciption.addMedicine(a);        presciption.addMedicine(b);        Visitor charger = new Charger();        charger.setName(&quot;张三&quot;);        Visitor workerOfPharmacy = new WorkerOfPharmacy();        workerOfPharmacy.setName(&quot;李四&quot;);        presciption.accept(charger);        System.out.println(&quot;-------------------------------------&quot;);        presciption.accept(workerOfPharmacy);    }}</code></pre><h1 id="模式优缺点"><a href="#模式优缺点" class="headerlink" title="模式优缺点"></a>模式优缺点</h1><p>优点</p><ol><li>使得新增新的访问操作变得更加简单。</li><li>能够使得用户在不修改现有类的层次结构下，定义该类层次结构的操作。</li><li>将有关元素对象的访问行为集中到一个访问者对象中，而不是分散搞一个个的元素类中。</li><li>符合单一职责原则。</li></ol><p>缺点</p><ol><li>增加新的元素类很困难。在访问者模式中，每增加一个新的元素类都意味着要在抽象访问者角色中增加一个新的抽象操作，并在每一个具体访问者类中增加相应的具体操作，违背了 “开闭原则” 的要求。</li><li>破坏封装。当采用访问者模式的时候，就会打破组合类的封装。</li><li>比较难理解。貌似是最难的设计模式了。</li></ol><h1 id="模式适用场景"><a href="#模式适用场景" class="headerlink" title="模式适用场景"></a>模式适用场景</h1><ol><li>对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。</li><li>需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作 “污染” 这些对象的类，也不希望在增加新操作时修改这些类。</li></ol><blockquote><p><a href="https://blog.csdn.net/chenssy/article/details/12029633" target="_blank" rel="noopener">https://blog.csdn.net/chenssy/article/details/12029633</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Head First 设计模式》笔记23-原型模式</title>
      <link href="/2018/08/05/%E3%80%8AHead-First-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E7%AC%94%E8%AE%B023-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/08/05/%E3%80%8AHead-First-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E7%AC%94%E8%AE%B023-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><p>浅拷贝：使用一个已知实例对新创建实例的成员变量逐个赋值，这个方式被称为浅拷贝。</p><p>深拷贝：当一个类的拷贝构造方法，不仅要复制对象的所有非引用成员变量值，还要为引用类型的成员变量创建新的实例，并且初始化为形式参数实例值。</p><a id="more"></a><h1 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h1><p>原型模式主要包含如下三个角色：</p><ul><li>Prototype：抽象原型类。声明克隆自身的接口。</li><li>ConcretePrototype：具体原型类。实现克隆的具体操作。</li><li>Client：客户类。让一个原型克隆自身，从而获得一个新的对象。</li></ul><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20180805223344.png" alt=""></p><p>所有的 Java 类都继承至 Object，而 Object 类提供了一个 clone() 方法，该方法可以将一个 java 对象复制一份，因此在 java 中可以直接使用 clone() 方法来复制一个对象。但是需要实现 clone 的 Java 类必须要实现一个接口: Cloneable. 该接口表示该类能够复制且具体复制的能力，如果不实现该接口而直接调用 clone() 方法会抛出 CloneNotSupportedException 异常。如下：</p><pre><code class="java">public class PrototypeDemo implements Cloneable{　　public Object clone(){　　　　Object object = null;　　　　try {　　　　　　object = super.clone();　　　　} catch (CloneNotSupportedException exception) {　　　　　　System.err.println(&quot;Not support cloneable&quot;);　　　　}　　　　return object;    }    //……}</code></pre><p>Java 中任何实现了 Cloneable 接口的类都可以通过调用 clone() 方法来复制一份自身然后传给调用者。一般而言，clone() 方法满足：</p><ul><li>对任何的对象 x，都有 x.clone() !=x，即克隆对象与原对象不是同一个对象。</li><li>对任何的对象 x，都有 x.clone().getClass()==x.getClass()，即克隆对象与原对象的类型一样。</li><li>如果对象 x 的 equals() 方法定义恰当，那么 x.clone().equals(x) 应该成立。</li></ul><h1 id="模式实现"><a href="#模式实现" class="headerlink" title="模式实现"></a>模式实现</h1><p>简历：Resume.java</p><pre><code class="java">public class Resume implements Cloneable {    private String name;    private File file;    /**     * 构造函数：初始化简历     */    public Resume(String name, File file){        this.name = name;        this.file = file;    }    /**     * 克隆该实例     */    public Object clone() {        Resume resume = null;        try {            resume = (Resume) super.clone();        } catch (CloneNotSupportedException e) {            e.printStackTrace();        }        return resume;    }    public void display(){        System.out.println(&quot;简历名：&quot; + name + &quot;，简历文件：&quot; + file);    }}</code></pre><p>客户端: Client.java</p><pre><code class="java">public class Client {    public static void main(String[] args) {        //原型A对象        Resume a = new Resume(&quot;小李子&quot;, &quot;1.pdf&quot;);        //克隆B对象        Resume b = (Resume) a.clone();        //输出A和B对象        System.out.println(&quot;----------------A--------------&quot;);        a.display();        System.out.println(&quot;----------------B--------------&quot;);        b.display();    }}</code></pre><p>打印结果：A，B相同，因为 clone() 是浅复制。</p><p>修改 clone() 方法</p><pre><code class="java">public Object clone() {    Resume resume = null;    try {        resume = (Resume) super.clone();        resume.field = this.field.clone();    } catch (CloneNotSupportedException e) {        e.printStackTrace();    }    return resume;}</code></pre><p>这样如果字段很多，会比较麻烦。所以可以使用序列化。</p><pre><code class="java">/* 深复制 */public Object deepClone() throws IOException, ClassNotFoundException {    /* 写入当前对象的二进制流 */    ByteArrayOutputStream bos = new ByteArrayOutputStream();    ObjectOutputStream oos = new ObjectOutputStream(bos);    oos.writeObject(this);    /* 读出二进制流产生的新对象 */    ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());    ObjectInputStream ois = new ObjectInputStream(bis);    return ois.readObject();}</code></pre><h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><p>优点</p><ol><li>如果创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程，同时也能够提高效率。</li><li>可以使用深克隆保持对象的状态。</li><li>原型模式提供了简化的创建结构。</li></ol><p>缺点</p><ol><li>在实现深克隆的时候可能需要比较复杂的代码。</li><li>需要为每一个类配备一个克隆方法，而且这个克隆方法需要对类的功能进行通盘考虑，这对全新的类来说不是很难，但对已有的类进行改造时，不一定是件容易的事，必须修改其源代码，违背了 “开闭原则”。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Head First 设计模式》笔记22-备忘录模式</title>
      <link href="/2018/08/05/%E3%80%8AHead-First-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E7%AC%94%E8%AE%B022-%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/08/05/%E3%80%8AHead-First-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E7%AC%94%E8%AE%B022-%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>所谓备忘录模式就是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。</p><p>备忘录模式将要保存的细节给封装在备忘录中，就是要改变保存的细节也不会影响到客户端。</p><a id="more"></a><p>备忘录模式有两个目标：</p><ul><li>储存系统关键对象的重要状态；</li><li>维护关键对象的封装。</li></ul><p>单一职责原则告诉我们，设计时不要把保持状态的工作和关键对象混在一起。这个专门掌握状态的对象，就称为备忘录。</p><p>备忘录模式提供了一种状态恢复的实现机制，使得用户可以方便地回到一个特定的历史步骤，当新的状态无效或者存在问题时，可以使用存储起来的备忘录将状态复原，当前很多软件都提供了Undo（撤销）操作功能，就使用了备忘录模式。</p><h1 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h1><ul><li>Originator: 原发器。负责创建一个备忘录，用以记录当前对象的内部状态，通过也可以使用它来利用备忘录恢复内部状态。同时原发器还可以根据需要决定 Memento 存储 Originator 的那些内部状态。</li><li>Memento: 备忘录。用于存储 Originator 的内部状态，并且可以防止 Originator 以外的对象访问 Memento。在备忘录 Memento 中有两个接口，其中 Caretaker 只能看到备忘录中的窄接口，它只能将备忘录传递给其他对象。Originator 可以看到宽接口，允许它访问返回到先前状态的所有数据。</li><li>Caretaker: 负责人。负责保存好备忘录，不能对备忘录的内容进行操作和访问，只能够将备忘录传递给其他对象。</li></ul><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20180805215748.jpg" alt=""></p><p>在备忘录模式中，最重要的就是备忘录 Memento 了。我们都是备忘录中存储的就是原发器的部分或者所有的状态信息，而这些状态信息是不能够被其他对象所访问了，也就是说我们是不可能在备忘录之外的对象来存储这些状态信息，如果暴漏了内部状态信息就违反了封装的原则，故备忘录是除了原发器外其他对象都是不可以访问的。</p><p>所以为了实现备忘录模式的封装，我们需要对备忘录的访问做些控制：</p><pre><code>对原发器：可以访问备忘录里的所有信息。对负责人：不可以访问备忘录里面的数据，但是他可以保存备忘录并且可以将备忘录传递给其他对象。其他对象：不可访问也不可以保存，它只负责接收从负责人那里传递过来的备忘录同时恢复原发器的状态。</code></pre><p>所以就备忘录模式而言理想的情况就是只允许生成该备忘录的那个原发器访问备忘录的内部状态。</p><h1 id="模式实现"><a href="#模式实现" class="headerlink" title="模式实现"></a>模式实现</h1><p>实现场景：我们就以游戏挑战 BOSS 为实现场景，在挑战 BOSS 之前，角色的血量、蓝量都是满值，然后存档，在大战 BOSS 时，由于操作失误导致血量和蓝量大量损耗，所以只好恢复到刚刚开始的存档点，继续进行大战 BOSS 了。这里使用备忘录模式来实现。</p><p>首先是游戏角色类：Role.java</p><pre><code class="java">public class Role {    private int bloodFlow;    private int magicPoint;    public Role(int bloodFlow,int magicPoint){        this.bloodFlow = bloodFlow;        this.magicPoint = magicPoint;    }    public int getBloodFlow() {        return bloodFlow;    }    public void setBloodFlow(int bloodFlow) {        this.bloodFlow = bloodFlow;    }    public int getMagicPoint() {        return magicPoint;    }    public void setMagicPoint(int magicPoint) {        this.magicPoint = magicPoint;    }    /**     * @desc 展示角色当前状态     * @return void     */    public void display() {        System.out.println(&quot;用户当前状态:&quot;);        System.out.println(&quot;血量:&quot; + getBloodFlow() + &quot;;蓝量:&quot; + getMagicPoint());    }    /**     * @desc 保持存档、当前状态     * @return     * @return Memento     */    public Memento saveMemento() {        return new Memento(getBloodFlow(), getMagicPoint());    }    /**     * @desc 恢复存档     * @param memento     * @return void     */    public void restoreMemento(Memento memento) {        this.bloodFlow = memento.getBloodFlow();        this.magicPoint = memento.getMagicPoint();    }}</code></pre><p>备忘录：Memento.java</p><pre><code class="java">class Memento {    private int bloodFlow;    private int magicPoint;    public int getBloodFlow() {        return bloodFlow;    }    public void setBloodFlow(int bloodFlow) {        this.bloodFlow = bloodFlow;    }    public int getMagicPoint() {        return magicPoint;    }    public void setMagicPoint(int magicPoint) {        this.magicPoint = magicPoint;    }    public Memento(int bloodFlow,int magicPoint){        this.bloodFlow = bloodFlow;        this.magicPoint = magicPoint;    }}</code></pre><p>负责人：Caretaker.java</p><pre><code class="java">public class Caretaker {    Memento memento;    public Memento getMemento() {        return memento;    }    public void setMemento(Memento memento) {        this.memento = memento;    }}</code></pre><p>客户端：Client.java</p><pre><code class="java">public class Client {    public static void main(String[] args) {        //打BOSS之前：血、蓝全部满值        Role role = new Role(100, 100);        System.out.println(&quot;----------大战BOSS之前----------&quot;);        role.display();        //保持进度        Caretaker caretaker = new Caretaker();        caretaker.memento = role.saveMemento();        //大战BOSS，快come Over了        role.setBloodFlow(20);        role.setMagicPoint(20);        System.out.println(&quot;----------大战BOSS----------&quot;);        role.display();        //恢复存档        role.restoreMemento(caretaker.getMemento());        System.out.println(&quot;----------恢复----------&quot;);        role.display();    }}</code></pre><h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><p>优点</p><pre><code>1. 给用户提供了一种可以恢复状态的机制。可以是用户能够比较方便地回到某个历史的状态。2. 实现了信息的封装。使得用户不需要关心状态的保存细节。3. 将被存储的状态放在外面，不要和关键对象混在一起，这可以帮助维护内聚。</code></pre><p>缺点</p><pre><code>1. 消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。2. 在 Java 系统中，可以使用序列化机制存储系统的状态。</code></pre><h1 id="模式适用场景"><a href="#模式适用场景" class="headerlink" title="模式适用场景"></a>模式适用场景</h1><ol><li><p>需要保存一个对象在某一个时刻的状态或部分状态。</p></li><li><p>如果用一个接口来让其他对象得到这些状态，将会暴露对象的实现细节并破坏对象的封装性，一个对象不希望外界直接访问其内部状态，通过负责人可以间接访问其内部状态。</p></li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote><p><a href="https://blog.csdn.net/chenssy/article/details/12068363" target="_blank" rel="noopener">https://blog.csdn.net/chenssy/article/details/12068363</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Head First 设计模式》笔记21-中介者模式</title>
      <link href="/2018/08/04/%E3%80%8AHead-First-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E7%AC%94%E8%AE%B021-%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/08/04/%E3%80%8AHead-First-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E7%AC%94%E8%AE%B021-%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>中介者模式(Mediator Pattern)定义：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。中介者模式又称为调停者模式，它是一种对象行为型模式。</p><a id="more"></a><h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20180805210431.png" alt=""></p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20180805210617.png" alt=""></p><h1 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h1><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/Mediator.jpg" alt=""></p><p>它主要包含如下几个角色：</p><ul><li>Mediator: 抽象中介者。定义了同事对象到中介者对象之间的接口。</li><li>ConcreteMediator: 具体中介者。实现抽象中介者的方法，它需要知道所有的具体同事类，同时需要从具体的同事类那里接收信息，并且向具体的同事类发送信息。</li><li>Colleague: 抽象同事类。</li><li>ConcreteColleague: 具体同事类。每个具体同事类都只需要知道自己的行为即可，但是他们都需要认识中介者。</li></ul><p>在中介者模式中中介者对象处于核心地位，因为它定义了整个系统中所有具体同事类之间的关系。在整个系统中它主要承担两个方面的责任。</p><ol><li><p>结构上起到<strong>中转作用</strong>。通过中介者对象对关系的封装，使得具体的同事类不再需要显示的引用其他对象，它只需要通过中介者就可以完成与其他同事类之间的通信。</p></li><li><p>行为上起到<strong>协作作用</strong>。中介者对同事类之间的关系进行封装，同事类在不需要知道其他对象的情况下通过中介者与其他对象完成通信。在这个过程中同事类是不需要指明中介者该如何做，中介者可以根据自身的逻辑来进行协调，对同事的请求进一步处理，将同事成员之间的关系行为进行分离和封装。</p></li></ol><p>同时由于中介者对对象的关系进行了封装，使得各个同事类之间的耦合减少了，使得他们可以独立改变和复用。</p><h1 id="模式实现"><a href="#模式实现" class="headerlink" title="模式实现"></a>模式实现</h1><p>这里我们就以租房为例，这里中介机构充当租房者与房屋所有者之间的中介者。</p><p>首先是抽象中介者: Mediator.java</p><pre><code class="java">public abstract class Mediator {    //申明一个联络方法    public abstract void constact(String message,Person person);}</code></pre><p>然后是抽象同事对象: Person.java</p><pre><code class="java">public abstract class Person {    protected String name;    protected Mediator mediator;    Person(String name,Mediator mediator) {        this.name = name;        this.mediator = mediator;    }}</code></pre><p>两个具体同事类：HouseOwner.java</p><pre><code class="java">public class HouseOwner extends Person {    HouseOwner(String name, Mediator mediator) {        super(name, mediator);    }    /**     * @desc 与中介者联系     * @param message     * @return void     */    public void constact(String message) {        mediator.constact(message, this);    }    /**     * @desc 获取信息     * @param message     * @return void     */    public void getMessage(String message) {        System.out.println(&quot;房主:&quot; + name +&quot;,获得信息：&quot; + message);    }}</code></pre><p>租房者 Tenant.java</p><pre><code class="java">public class Tenant extends Person {    Tenant(String name, Mediator mediator) {        super(name, mediator);    }    /**     * @desc 与中介者联系     * @param message     * @return void     */    public void constact(String message) {        mediator.constact(message, this);    }    /**     * @desc 获取信息     * @param message     * @return void     */    public void getMessage(String message){        System.out.println(&quot;租房者:&quot; + name +&quot;,获得信息：&quot; + message);    }}</code></pre><p>具体中介者对象：中介结构、MediatorStructure.java</p><pre><code class="java">public class MediatorStructure extends Mediator {    //首先中介结构必须知道所有房主和租房者的信息    private HouseOwner houseOwner;    private Tenant tenant;    public HouseOwner getHouseOwner() {        return houseOwner;    }    public void setHouseOwner(HouseOwner houseOwner) {        this.houseOwner = houseOwner;    }    public Tenant getTenant() {        return tenant;    }    public void setTenant(Tenant tenant) {        this.tenant = tenant;    }    public void constact(String message, Person person) {        if(person == houseOwner){          //如果是房主，则租房者获得信息            tenant.getMessage(message);        } else{       //反正则是房主获得信息            houseOwner.getMessage(message);        }    }}</code></pre><p>客户端：Client.java</p><pre><code class="java">public class Client {    public static void main(String[] args) {        //一个房主、一个租房者、一个中介机构        MediatorStructure mediator = new MediatorStructure();        //房主和租房者只需要知道中介机构即可        HouseOwner houseOwner = new HouseOwner(&quot;张三&quot;, mediator);        Tenant tenant = new Tenant(&quot;李四&quot;, mediator);        //中介结构要知道房主和租房者        mediator.setHouseOwner(houseOwner);        mediator.setTenant(tenant);        tenant.constact(&quot;听说你那里有三室的房主出租.....&quot;);        houseOwner.constact(&quot;是的!请问你需要租吗?&quot;);    }}</code></pre><p>运行结果：</p><pre><code>房主: 张三, 获得信息：听说你那里有三室的房主出租.....租房者: 李四, 获得信息：是的! 请问你需要租吗?</code></pre><h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><p>优点</p><ol><li>简化了对象之间的交互。</li><li>将各同事解耦。</li><li>减少子类生成。</li><li>可以简化各同事类的设计和实现。</li></ol><p>缺点</p><ol><li>在具体中介者类中包含了同事之间的交互细节，可能会导致具体中介者类非常复杂，使得系统难以维护。</li></ol><h1 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h1><p>在以下情况下可以使用中介者模式：</p><ol><li>系统中对象之间存在复杂的引用关系，产生的相互依赖关系结构混乱且难以理解。</li><li>一个对象由于引用了其他很多对象并且直接和这些对象通信，导致难以复用该对象。</li><li>想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。可以通过引入中介者类来实现，在中介者中定义对象。</li><li>交互的公共行为，如果需要改变行为则可以增加新的中介者类。</li></ol><h1 id="模式应用"><a href="#模式应用" class="headerlink" title="模式应用"></a>模式应用</h1><p>MVC架构中控制器</p><p>Controller 作为一种中介者，它负责控制视图对象View和模型对象Model之间的交互。如在Struts中，Action就可以作为JSP页面与业务对象之间的中介者。</p><h1 id="模式扩展"><a href="#模式扩展" class="headerlink" title="模式扩展"></a>模式扩展</h1><p>中介者模式与迪米特法则</p><ul><li>在中介者模式中，通过创造出一个中介者对象，将系统中有关的对象所引用的其他对象数目减少到最少，使得一个对象与其同事之间的相互作用被这个对象与中介者对象之间的相互作用所取代。因此，中介者模式就是迪米特法则的一个典型应用。</li></ul><p>中介者模式与GUI开发</p><ul><li>中介者模式可以方便地应用于图形界面(GUI)开发中，在比较复杂的界面中可能存在多个界面组件之间的交互关系。</li><li>对于这些复杂的交互关系，有时候我们可以引入一个中介者类，将这些交互的组件作为具体的同事类，将它们之间的引用和控制关系交由中介者负责，在一定程度上简化系统的交互，这也是中介者模式的常见应用之一。</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote><p><a href="http://design-patterns.readthedocs.io/zh_CN/latest/behavioral_patterns/mediator.html" target="_blank" rel="noopener">http://design-patterns.readthedocs.io/zh_CN/latest/behavioral_patterns/mediator.html</a><br><a href="https://blog.csdn.net/chenssy/article/details/18443883" target="_blank" rel="noopener">https://blog.csdn.net/chenssy/article/details/18443883</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Head First 设计模式》笔记20-解释器模式</title>
      <link href="/2018/08/04/%E3%80%8AHead-First-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E7%AC%94%E8%AE%B020-%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/08/04/%E3%80%8AHead-First-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E7%AC%94%E8%AE%B020-%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>解释器模式（Interpreter Pattern）提供了评估语言的语法或表达式的方式，它属于行为型模式。这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在 SQL 解析、正则表达式、符号处理引擎等。</p><a id="more"></a><h1 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h1><p>解释器模式主要包含如下几个角色：</p><ul><li><p>AbstractExpression: 抽象表达式。声明一个抽象的解释操作，该接口为抽象语法树中所有的节点共享。</p></li><li><p>TerminalExpression: 终结符表达式。实现与文法中的终结符相关的解释操作。实现抽象表达式中所要求的方法。文法中每一个终结符都有一个具体的终结表达式与之相对应。</p></li><li><p>NonterminalExpression: 非终结符表达式。为文法中的非终结符相关的解释操作。</p></li><li><p>Context: 环境类。包含解释器之外的一些全局信息。</p></li><li><p>Client: 客户类。</p></li></ul><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20180805203013.png" alt=""></p><p>抽象语法树描述了如何构成一个复杂的句子，通过对抽象语法树的分析，可以识别出语言中的终结符和非终结符类。 在解释器模式中由于每一种终结符表达式、非终结符表达式都会有一个具体的实例与之相对应，所以系统的扩展性比较好。</p><h1 id="模式实现"><a href="#模式实现" class="headerlink" title="模式实现"></a>模式实现</h1><p> 现在我们用解释器模式来实现一个基本的加、减、乘、除和求模运算。例如用户输入表达式 <code>3 * 4 / 2 % 4</code>，输出结果为 2。下图为该实例的 UML 结构图：</p><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20180805203303.png" alt=""></p><p>抽象表达式：Node.java。</p><pre><code class="java">public interface Node {    public int interpret();}</code></pre><p>非终结表达式：ValueNode.java。主要用解释该表达式的值。</p><pre><code class="java">public class ValueNode implements Node {    private int value;    public ValueNode(int value) {        this.value=value;    }    public int interpret() {        return this.value;    }}</code></pre><p>终结表达式抽象类，由于该终结表达式需要解释多个运算符号，同时用来构建抽象语法树：</p><pre><code class="java">public abstract class SymbolNode implements Node {    protected Node left;    protected Node right;    public SymbolNode(Node left,Node right) {        this.left=left;        this.right=right;    }}</code></pre><p>MulNode.java</p><pre><code class="java">public class MulNode extends SymbolNode {    public MulNode(Node left,Node right) {        super(left,right);    }    public int interpret() {        return left.interpret() * right.interpret();    }}</code></pre><p>ModNode.java</p><pre><code class="java">public class ModNode extends SymbolNode {    public ModNode(Node left,Node right) {        super(left,right);    }    public int interpret() {        return super.left.interpret() % super.right.interpret();    }}</code></pre><p>DivNode.java</p><pre><code class="java">public class DivNode extends SymbolNode {    public DivNode(Node left,Node right) {        super(left,right);    }    public int interpret() {        return super.left.interpret() / super.right.interpret();    }}</code></pre><p>Calculator.java</p><pre><code class="java">public class Calculator{    private String statement;    private Node node;    public void build(String statement){        Node left=null,right=null;        Stack stack=new Stack();        String[] statementArr=statement.split(&quot; &quot;);        for (int i=0; i&lt;statementArr.length; i++) {            if (statementArr[i].equalsIgnoreCase(&quot;*&quot;)) {                left=(Node)stack.pop();                int val=Integer.parseInt(statementArr[++i]);                right=new ValueNode(val);                stack.push(new MulNode(left,right));            } else if (statementArr[i].equalsIgnoreCase(&quot;/&quot;)) {                left=(Node)stack.pop();                int val=Integer.parseInt(statementArr[++i]);                right=new ValueNode(val);                stack.push(new DivNode(left,right));            } else if(statementArr[i].equalsIgnoreCase(&quot;%&quot;)) {                left=(Node)stack.pop();                int val=Integer.parseInt(statementArr[++i]);                right=new ValueNode(val);                stack.push(new ModNode(left,right));            } else {                stack.push(new ValueNode(Integer.parseInt(statementArr[i])));            }        }        this.node=(Node)stack.pop();    }    public int compute()        return node.interpret();    }}</code></pre><p>客户端：Client.java</p><pre><code class="java">public class Client{    public static void main(String args[]){        String statement = &quot;3 * 2 * 4 / 6 % 5&quot;;        Calculator calculator = new Calculator();        calculator.build(statement);        int result = calculator.compute();        System.out.println(statement + &quot; = &quot; + result);    }}</code></pre><p>运行结果：<code>3 * 2 * 4 / 6 % 5 = 4</code></p><h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><p>优点</p><ol><li>可扩展性比较好，灵活。</li><li>增加了新的解释表达式的方式。</li><li>易于实现文法。</li></ol><p>缺点</p><ol><li>执行效率比较低，可利用场景比较少。</li><li>解释器模式为文法中的每一条规则至少定义了一个类，因此包含了许多规则的文法可能难以管理和维护。建议当文法非常复杂时，使用其它的技术如语法分析程序或编译器生成器来处理。</li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote><p><a href="https://blog.csdn.net/chenssy/article/details/12719973" target="_blank" rel="noopener">https://blog.csdn.net/chenssy/article/details/12719973</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Head First 设计模式》笔记19-享元模式</title>
      <link href="/2018/08/02/%E3%80%8AHead-First-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E7%AC%94%E8%AE%B019-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/08/02/%E3%80%8AHead-First-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E7%AC%94%E8%AE%B019-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>享元模式(Flyweight Pattern)：运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。</p><p>由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为轻量级模式（蝇量模式），它是一种对象结构型模式。</p><p>在了解享元模式之前我们先要了解两个概念：<strong>内部状态、外部状态</strong>。</p><p><strong>内部状态</strong>：在享元对象内部不随外界环境改变而改变的共享部分。</p><p><strong>外部状态</strong>：随着环境的改变而改变，不能够共享的状态就是外部状态。</p><p>由于享元模式区分了内部状态和外部状态，所以我们可以通过设置不同的外部状态使得相同的对象可以具备一些不同的特性，而内部状态设置为相同部分。在我们的程序设计过程中，我们可能会需要大量的细粒度对象来表示对象，如果这些对象除了几个参数不同外其他部分都相同，这个时候我们就可以利用享元模式来大大减少应用程序当中的对象。如何利用享元模式呢？这里我们只需要将他们少部分的不同的部分当做参数移动到类实例的外部去，然后再方法调用的时候将他们传递过来就可以了。这里也就说明了一点：<strong>内部状态存储于享元对象内部，而外部状态则应该由客户端来考虑</strong>。</p><a id="more"></a><h1 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h1><p>享元模式存在如下几个角色：</p><ul><li>Flyweight: 抽象享元类。所有具体享元类的超类或者接口，通过这个接口，Flyweight 可以接受并作用于外部状态。</li><li>ConcreteFlyweight: 具体享元类。指定内部状态，为内部状态增加存储空间。</li><li>UnsharedConcreteFlyweight: 非共享具体享元类。指出那些不需要共享的 Flyweight 子类。</li><li>FlyweightFactory: 享元工厂类。用来创建并管理 Flyweight 对象，它主要用来确保合理地共享 Flyweight，当用户请求一个 Flyweight 时，FlyweightFactory 就会提供一个已经创建的 Flyweight 对象或者新建一个（如果不存在）。</li></ul><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/Flyweight.jpg" alt=""></p><h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><p>场景：假如我们有一个绘图的应用程序，通过它我们可以出绘制各种各样的形状、颜色的图形，那么这里形状和颜色就是内部状态了，通过享元模式我们就可以实现该属性的共享了。如下：</p><p>首先是形状类：Shape.java。它是抽象类，只有一个绘制图形的抽象方法。</p><pre><code class="java">public abstract class Shape {    public abstract void draw();}</code></pre><p>然后是绘制圆形的具体类。Circle.java</p><pre><code class="java">public class Circle extends Shape{    private String color;    public Circle(String color){        this.color = color;    }    public void draw() {        System.out.println(&quot;画了一个&quot; + color +&quot;的圆形&quot;);    }}</code></pre><p>再是享元工厂类。FlyweightFactory</p><pre><code class="java">public class FlyweightFactory{    static Map&lt;String, Shape&gt; shapes = new HashMap&lt;String, Shape&gt;();    public static Shape getShape(String key){        Shape shape = shapes.get(key);        //如果shape==null,表示不存在,则新建,并且保持到共享池中        if(shape == null){            shape = new Circle(key);            shapes.put(key, shape);        }        return shape;    }    public static int getSum(){        return shapes.size();    }}</code></pre><p>最后是客户端程序：Client.java</p><pre><code class="java">public class Client {    public static void main(String[] args) {        Shape shape1 = FlyweightFactory.getShape(&quot;红色&quot;);        shape1.draw();        Shape shape2 = FlyweightFactory.getShape(&quot;灰色&quot;);        shape2.draw();        Shape shape3 = FlyweightFactory.getShape(&quot;灰色&quot;);        shape3.draw();        System.out.println(&quot;一共绘制了&quot;+FlyweightFactory.getSum()+&quot;中颜色的圆形&quot;);    }}</code></pre><h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><p>优点</p><ol><li>享元模式的优点在于它可以极大减少内存中对象的数量，使得相同对象或相似对象在内存中只保存一份。</li><li>享元模式的外部状态相对独立，而且不会影响其内部状态，从而使得享元对象可以在不同的环境中被共享。</li></ol><p>缺点</p><ol><li>享元模式使得系统更加复杂，需要分离出内部状态和外部状态，这使得程序的逻辑复杂化。</li><li>为了使对象可以共享，享元模式需要将享元对象的状态外部化，而读取外部状态使得运行时间变长。</li></ol><h1 id="模式扩展"><a href="#模式扩展" class="headerlink" title="模式扩展"></a>模式扩展</h1><p>单纯享元模式和复合享元模式</p><ul><li>单纯享元模式：在单纯享元模式中，所有的享元对象都是可以共享的，即所有抽象享元类的子类都可共享，不存在非共享具体享元类。</li><li>复合享元模式：将一些单纯享元使用组合模式加以组合，可以形成复合享元对象，这样的复合享元对象本身不能共享，但是它们可以分解成单纯享元对象，而后者则可以共享。</li></ul><p>享元模式与其他模式的联用</p><ul><li>在享元模式的享元工厂类中通常提供一个静态的工厂方法用于返回享元对象，使用简单工厂模式来生成享元对象。</li><li>在一个系统中，通常只有唯一一个享元工厂，因此享元工厂类可以使用单例模式进行设计。</li><li>享元模式可以结合组合模式形成复合享元模式，统一对享元对象设置外部状态。</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote><p><a href="http://design-patterns.readthedocs.io/zh_CN/latest/structural_patterns/flyweight.html" target="_blank" rel="noopener">http://design-patterns.readthedocs.io/zh_CN/latest/structural_patterns/flyweight.html</a><br><a href="https://blog.csdn.net/chenssy/article/details/11850107" target="_blank" rel="noopener">https://blog.csdn.net/chenssy/article/details/11850107</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Head First 设计模式》笔记18-责任链模式</title>
      <link href="/2018/08/02/%E3%80%8AHead-First-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E7%AC%94%E8%AE%B018-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/08/02/%E3%80%8AHead-First-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E7%AC%94%E8%AE%B018-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>责任链模式(ChainOfResponsibility)： 有多个对象，每个对象持有下一个对象的引用，形成一条链，请求在这条链上传递，直到某一对象决定处理该请求，但是发出者并不清楚最终哪个对象会处理该请求。</p><p>当你想要让一个以上的对象有机会能够处理某个请求的时候，就使用责任链模式。又称职责链。</p><a id="more"></a><h1 id="如何使用责任链模式"><a href="#如何使用责任链模式" class="headerlink" title="如何使用责任链模式"></a>如何使用责任链模式</h1><p>责任链包含三个角色：</p><ul><li>Handler: 抽象处理者。定义了一个处理请求的方法。所有的处理者都必须实现该抽象类。</li><li>ConcreteHandler: 具体处理者。处理它所负责的请求，同时也可以访问它的后继者。如果它能够处理该请求则处理，否则将请求传递到它的后继者。</li><li>Client: 客户类。</li></ul><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20180805145837.png" alt=""></p><h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><p>Handler: 抽象处理者。</p><pre><code class="java">public abstract class Chain {    public static int One = 1;    public static int Two = 2;    public static int Three = 3;    protected int Threshold;    protected Chain next;    public void setNext(Chain chain) {        next = chain;    }    public void message(String msg, int priority) {        // 如果优先级小于阈值则处理        if (priority &lt;= Threshold) {            writeMessage(msg);        }        if (next != null) {            next.message(msg, priority);        }    }    abstract protected void writeMessage(String msg);}</code></pre><p>具体处理者</p><pre><code class="java">public class A extends Chain {    public A(int threshold) {        this.Threshold = threshold;    }    protected void writeMessage(String msg) {        System.out.println(&quot;A: &quot; + msg);    }}public class B extends Chain {    public B(int threshold) {        this.Threshold = threshold;    }    protected void writeMessage(String msg) {        System.out.println(&quot;B: &quot; + msg);    }}public class C extends Chain {    public C(int threshold) {        this.Threshold = threshold;    }    protected void writeMessage(String msg) {        System.out.println(&quot;C: &quot; + msg);    }}</code></pre><p>测试，Client</p><pre><code class="java">public class Example {    private static Chain createChain() {        // 建立责任链        Chain chain1 = new A(Chain.Three);        Chain chain2 = new B(Chain.Two);        chain1.setNext(chain2);        Chain chain3 = new C(Chain.One);        chain2.setNext(chain3);        return chain1;    }    public static void main(String[] args) {        Chain chain = createChain();        chain.message(&quot;level 3&quot;, Chain.Three);        chain.message(&quot;level 2&quot;, Chain.Two);        chain.message(&quot;level 1&quot;, Chain.One);    }}</code></pre><p>打印结果</p><pre><code class="shell">A: level 3A: level 2B: level 2A: level 1B: level 1C: level 1</code></pre><h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><p>优点</p><ol><li><p>降低耦合度。它将请求的发送者和接受者解耦。</p></li><li><p>简化了对象。使得对象不需要知道链的结构。</p></li><li><p>增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。</p></li><li><p>增加新的请求处理类很方便。</p></li></ol><p>缺点</p><ol><li><p>不能保证请求一定被接收。</p></li><li><p>系统性能将受到一定影响，而且在进行代码调试时不太方便；可能会造成循环调用。</p></li><li><p>可能不容易观察运行时的特征，有碍于除错。</p></li></ol><h1 id="模式适用场景"><a href="#模式适用场景" class="headerlink" title="模式适用场景"></a>模式适用场景</h1><ol><li>有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。</li><li>在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。</li><li>可动态指定一组对象处理请求。</li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote><p><a href="https://blog.csdn.net/chenssy/article/details/11881377" target="_blank" rel="noopener">https://blog.csdn.net/chenssy/article/details/11881377</a><br><a href="https://www.programcreek.com/2013/02/java-design-pattern-chain-of-responsibility" target="_blank" rel="noopener">https://www.programcreek.com/2013/02/java-design-pattern-chain-of-responsibility</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Head First 设计模式》笔记17-建造者模式</title>
      <link href="/2018/08/01/%E3%80%8AHead-First-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E7%AC%94%E8%AE%B017-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/08/01/%E3%80%8AHead-First-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E7%AC%94%E8%AE%B017-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>建造者模式(Builder Pattern)：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。也叫生成器模式。</p><p>建造者模式的关键特性是它将一个建造过程分解成很多步骤，也可以说，每个产品的建造会遵循同样的流程，不过流程内的每一个步骤都不尽相同。</p><a id="more"></a><h1 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h1><p>建造者模式包含如下角色：</p><ul><li>Builder：抽象建造者。它声明为创建一个 Product 对象的各个部件指定的抽象接口。</li><li>ConcreteBuilder：具体建造者。实现抽象接口，构建和装配各个部件。</li><li>Director：指挥者。构建一个使用 Builder 接口的对象。它主要是用于创建一个复杂的对象，它主要有两个作用，一是：隔离了客户与对象的生产过程，二是：负责控制产品对象的生产过程。</li><li>Product：产品角色。一个具体的产品对象。</li></ul><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/Builder.jpg" alt=""></p><h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><p> KFC 里面一般都有好几种可供客户选择的套餐，它可以根据客户所点的套餐，然后在后面做这些套餐，返回给客户的事一个完整的、美好的套餐。下面我们将会模拟这个过程，我们约定套餐主要包含汉堡、薯条、可乐、鸡腿等等组成部分，使用不同的组成部分就可以构建出不同的套餐。</p><p>首先是套餐类：Meal.java</p><pre><code class="java">public class Meal {    private String food;    private String drink;    public String getFood() {        return food;    }    public void setFood(String food) {        this.food = food;    }    public String getDrink() {        return drink;    }    public void setDrink(String drink) {        this.drink = drink;    }}</code></pre><p>然后是套餐构造器：MealBuilder.java</p><pre><code class="java">public abstract class MealBuilder {    Meal meal = new Meal();    public abstract void buildFood();    public abstract void buildDrink();    public Meal getMeal(){        return meal;    }}</code></pre><p>然后是套餐 A、套餐 B。这个两个套餐都是实现抽象套餐类。</p><pre><code class="java">public class MealA extends MealBuilder{    public void buildDrink() {        meal.setDrink(&quot;一杯可乐&quot;);    }    public void buildFood() {        meal.setFood(&quot;一盒薯条&quot;);    }}</code></pre><pre><code class="java">public class MealB extends MealBuilder{    public void buildDrink() {        meal.setDrink(&quot;一杯柠檬果汁&quot;);    }    public void buildFood() {        meal.setFood(&quot;三个鸡翅&quot;);    }}</code></pre><p>最后是 KFC 的服务员，它相当于一个指挥者，它决定了套餐是的实现过程，然后给你一个完美的套餐。</p><pre><code class="java">public class KFCWaiter {    private MealBuilder mealBuilder;    public void setMealBuilder(MealBuilder mealBuilder) {        this.mealBuilder = mealBuilder;    }    public Meal construct(){        //准备食物        mealBuilder.buildFood();        //准备饮料        mealBuilder.buildDrink();        //准备完毕，返回一个完整的套餐给客户        return mealBuilder.getMeal();    }}</code></pre><p>测试类</p><pre><code class="java">public class Client {    public static void main(String[] args) {        //服务员        KFCWaiter waiter = new KFCWaiter();        //套餐A        MealA a = new MealA();        //服务员准备套餐A        waiter.setMealBuilder(a);        //获得套餐        Meal mealA = waiter.construct();        System.out.print(&quot;套餐A的组成部分:&quot;);        System.out.println(mealA.getFood()+&quot;---&quot;+mealA.getDrink());    }}</code></pre><p>运行结果：</p><pre><code class="shell">套餐 A 的组成部分: 一盒薯条 --- 一杯可乐</code></pre><h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><p>优点</p><ol><li>将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，使得我们能够更加精确的控制复杂对象的产生过程。</li><li>将产品的创建过程与产品本身分离开来，可以使用相同的创建过程来得到不同的产品。也就说细节依赖抽象。</li><li>每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，用户使用不同的具体建造者即可得到不同的产品对象。</li></ol><p>缺点</p><ol><li>建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。</li><li>如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。</li></ol><h1 id="建造者模式与抽象工厂模式的比较"><a href="#建造者模式与抽象工厂模式的比较" class="headerlink" title="建造者模式与抽象工厂模式的比较"></a>建造者模式与抽象工厂模式的比较</h1><ul><li>与抽象工厂模式相比，<strong>建造者模式返回一个组装好的完整产品 ，而抽象工厂模式返回一系列相关的产品，这些产品位于不同的产品等级结构，构成了一个产品族</strong>。</li><li>在抽象工厂模式中，客户端实例化工厂类，然后调用工厂方法获取所需产品对象，而在建造者模式中，客户端可以不直接调用建造者的相关方法，而是通过指挥者类来指导如何生成对象，包括对象的组装过程和建造步骤，它侧重于一步步构造一个复杂对象，返回一个完整的对象。</li><li>如果将抽象工厂模式看成<strong>汽车配件生产工厂</strong>，生产一个产品族的产品，那么建造者模式就是一个<strong>汽车组装工厂</strong>，通过对部件的组装可以返回一辆完整的汽车。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Head First 设计模式》笔记16-桥接模式</title>
      <link href="/2018/08/01/%E3%80%8AHead-First-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E7%AC%94%E8%AE%B016-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/08/01/%E3%80%8AHead-First-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E7%AC%94%E8%AE%B016-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>桥接模式(Bridge Pattern)：将抽象部分与它的实现部分分离，使它们都可以独立地变化。</p><p>使用桥接模式（Bridge Pattern）不只改变你的实现，也改变你的抽象。</p><p>设想如果要绘制矩形、圆形、椭圆、正方形，我们至少需要4个形状类，但是如果绘制的图形需要具有不同的颜色，如红色、绿色、蓝色等，此时至少有如下两种设计方案：</p><ul><li>第一种设计方案是为每一种形状都提供一套各种颜色的版本。</li><li>第二种设计方案是根据实际需要对形状和颜色进行组合</li></ul><p>对于有两个变化维度（即两个变化的原因）的系统，采用方案二来进行设计系统中类的个数更少，且系统扩展更为方便。设计方案二即是<strong>桥接模式</strong>的应用。桥接模式将继承关系转换为关联关系，从而降低了类与类之间的耦合，减少了代码编写量。</p><p>有了桥接模式，就可以独立地改变这两个层次。</p><a id="more"></a><h1 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h1><p>桥接模式包含如下角色：</p><ul><li>Abstraction：抽象类</li><li>RefinedAbstraction：扩充抽象类</li><li>Implementor：实现类接口</li><li>ConcreteImplementor：具体实现类</li></ul><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/Bridge.jpg" alt=""></p><h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><p>首先定义电视机的接口：ITV</p><pre><code class="java">public interface ITV {    public void on();    public void off();    public void switchChannel(int channel);}</code></pre><p>实现三星的 ITV 接口。</p><pre><code class="java">public class SamsungTV implements ITV {    @Override    public void on() {        System.out.println(&quot;Samsung is turned on.&quot;);    }    @Override    public void off() {        System.out.println(&quot;Samsung is turned off.&quot;);    }    @Override    public void switchChannel(int channel) {        System.out.println(&quot;Samsung: channel - &quot; + channel);    }}</code></pre><p>再实现索尼的 ITV 接口。</p><pre><code class="java">public class SonyTV implements ITV {    @Override    public void on() {        System.out.println(&quot;Sony is turned on.&quot;);    }    @Override    public void off() {        System.out.println(&quot;Sony is turned off.&quot;);    }    @Override    public void switchChannel(int channel) {        System.out.println(&quot;Sony: channel - &quot; + channel);    }}</code></pre><p>遥控器要包含对 TV 的引用。</p><pre><code class="java">public abstract class AbstractRemoteControl {    /**     * @uml.property  name=&quot;tv&quot;     * @uml.associationEnd     */    private ITV tv;    public AbstractRemoteControl(ITV tv){        this.tv = tv;    }    public void turnOn(){        tv.on();    }    public void turnOff(){        tv.off();    }    public void setChannel(int channel){        tv.switchChannel(channel);    }}</code></pre><p>定义遥控器的具体类。</p><pre><code class="java">public class LogitechRemoteControl extends AbstractRemoteControl {    public LogitechRemoteControl(ITV tv) {        super(tv);    }    public void setChannelKeyboard(int channel){        setChannel(channel);        System.out.println(&quot;Logitech use keyword to set channel.&quot;);    }    public static void main(String[] args){        ITV tv = new SonyTV();        LogitechRemoteControl lrc = new LogitechRemoteControl(tv);        lrc.setChannelKeyboard(100);    }}</code></pre><p>输出如下:</p><pre><code class="shell">Sony: channel – 100Logitech use keyword to set channel.</code></pre><h1 id="桥接模式与策略模式"><a href="#桥接模式与策略模式" class="headerlink" title="桥接模式与策略模式"></a>桥接模式与策略模式</h1><ol><li><p>首先，在形式上，两者还是有一定区别的，对比两幅结构图，我们可以发现，在桥接模式中不仅 Implementor 具有变化（ConcreateImplementior），而且 Abstraction 也可以发生变化（RefinedAbstraction），而且两者的变化是完全独立的，RefinedAbstraction 与 ConcreateImplementior 之间松散耦合，它们仅仅通过 Abstraction 与 Implementor 之间的关系联系起来。而在策略模式中，并不考虑 Context 的变化，只有算法的可替代性。</p></li><li><p>其次在语意上，桥接模式强调 Implementor 接口仅提供基本操作，而 Abstraction 则基于这些基本操作定义更高层次的操作。而策略模式强调 Strategy 抽象接口的提供的是一种算法，一般是无状态、无数据的，而 Context 则简单调用这些算法完成其操作。</p></li><li><p>桥接模式中不仅定义 Implementor 的接口而且定义 Abstraction 的接口，Abstraction 的接口不仅仅是为了与 Implementor 通信而存在的，这也反映了结构型模式的特点：通过继承、聚合的方式组合类和对象以形成更大的结构。在策略模式中，Startegy 和 Context 的接口都是两者之间的协作接口，并不涉及到其它的功能接口，所以它是行为模式的一种。行为模式的主要特点就是处理的是对象之间的通信方式，往往是通过引入中介者对象将通信双方解耦，在这里实际上就是将 Context 与实际的算法提供者解耦。</p></li></ol><p>所以相对策略模式，桥接模式要表达的内容要更多，结构也更加复杂。桥接模式表达的主要意义其实是接口隔离的原则，即把本质上并不内聚的两种体系区别开来，使得它们可以松散的组合，而策略在解耦上还仅仅是某一个算法的层次，没有到体系这一层次。从结构图中可以看到，策略的结构是包容在桥接结构中的，桥接中必然存在着策略模式，Abstraction 与 Implementor 之间就可以认为是策略模式，但是桥接模式一般 Implementor 将提供一系列的成体系的操作，而且 Implementor 是具有状态和数据的静态结构。而且桥接模式 Abstraction 也可以独立变化。</p><h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><p>桥接模式的优点:</p><ul><li>分离抽象接口及其实现部分。</li><li>桥接模式有时类似于多继承方案，但是多继承方案违背了类的单一职责原则（即一个类只有一个变化的原因），复用性比较差，而且多继承结构中类的个数非常庞大，桥接模式是比多继承方案更好的解决方法。</li><li>桥接模式提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统。</li><li>实现细节对客户透明，可以对用户隐藏实现细节。</li></ul><p>桥接模式的缺点:</p><ul><li>桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。</li><li>桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性。</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote><p><a href="http://design-patterns.readthedocs.io/zh_CN/latest/structural_patterns/bridge.html" target="_blank" rel="noopener">http://design-patterns.readthedocs.io/zh_CN/latest/structural_patterns/bridge.html</a><br><a href="http://www.importnew.com/6857.html" target="_blank" rel="noopener">http://www.importnew.com/6857.html</a><br><a href="http://www.blogjava.net/wangle/archive/2007/04/25/113545.html" target="_blank" rel="noopener">http://www.blogjava.net/wangle/archive/2007/04/25/113545.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Head-First-设计模式》笔记15-代理模式</title>
      <link href="/2018/07/24/%E3%80%8AHead-First-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E7%AC%94%E8%AE%B015-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/07/24/%E3%80%8AHead-First-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E7%AC%94%E8%AE%B015-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>代理模式(Proxy Pattern) ：为另一个对象提供一个替身或占位符以控制对这个对象的访问。</p><p>在某些情况下，一个客户不想或者不能直接引用一个对 象，此时可以通过一个称之为“代理”的第三者来实现 间接引用。代理对象可以在客户端和目标对象之间起到 中介的作用，并且可以通过代理对象去掉客户不能看到 的内容和服务或者添加客户需要的额外服务。</p><a id="more"></a><h1 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h1><p>所谓静态代理，就是代理类是由程序员自己编写的，在编译期就确定好了的</p><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p>代理模式包含如下角色：</p><ul><li>Subject: 抽象主题角色</li><li>Proxy: 代理主题角色</li><li>RealSubject: 真实主题角色</li></ul><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/Proxy.jpg" alt="静态代理模式"></p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>抽象主题</p><pre><code class="java">public interface HelloSerivice {    public void say();}</code></pre><p>真实主题</p><pre><code class="java">public class HelloSeriviceImpl implements HelloSerivice{    @Override    public void say() {        System.out.println(&quot;hello world&quot;);    }}</code></pre><p>代理主题</p><pre><code class="java">public class HelloSeriviceProxy implements HelloSerivice {    private HelloSerivice target;    public HelloSeriviceProxy(HelloSerivice target) {        this.target = target;    }    @Override    public void say() {        System.out.println(&quot;记录日志&quot;);        target.say();        System.out.println(&quot;清理数据&quot;);    }}</code></pre><p>测试</p><pre><code class="java">public class Test {    public static void main(String[] args) {        //目标对象        HelloSerivice target = new HelloSeriviceImpl();        //代理对象        HelloSeriviceProxy proxy = new HelloSeriviceProxy(target);        proxy.say();    }}/*output:记录日志hello world清理数据*/</code></pre><h2 id="静态代理的用途"><a href="#静态代理的用途" class="headerlink" title="静态代理的用途"></a>静态代理的用途</h2><p><strong>控制真实对象的访问权限</strong>：通过代理对象控制对真实对象的使用权限。</p><p><strong>避免创建大对象</strong>：通过使用一个代理小对象来代表一个真实的大对象，可以减少系统资源的消耗，对系统进行优化并提高运行速度。</p><p><strong>增强真实对象的功能</strong>：这个比较简单，通过代理可以在调用真实对象的方法的前后增加额外功能。</p><h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><p>虽然静态代理模式很好用，但是静态代理还是存在一些局限性的，比如使用静态代理模式需要程序员手写很多代码，这个过程是比较浪费时间和精力的。一旦需要代理的类中方法比较多，或者需要同时代理多个对象的时候，这无疑会增加很大的复杂度。</p><p>动态代理中的代理类并不要求在编译期就确定，而是可以在运行期动态生成，从而实现对目标对象的代理功能。</p><p>Java中，<strong>实现动态代理有两种方式</strong>：</p><ul><li><p><strong>JDK 动态代理</strong>：java.lang.reflect 包中的 Proxy 类和 InvocationHandler 接口提供了生成动态代理类的能力。</p></li><li><p><strong>Cglib 动态代理</strong>：Cglib (Code Generation Library )是一个第三方代码生成类库，运行时在内存中动态生成一个子类对象从而实现对目标对象功能的扩展。</p></li></ul><h2 id="动态代理和静态代理的区别"><a href="#动态代理和静态代理的区别" class="headerlink" title="动态代理和静态代理的区别"></a>动态代理和静态代理的区别</h2><ul><li>静态代理类：由程序员创建或由特定工具自动生成源代码，再对其编译。在程序运行前，代理类的 .class 文件就已经存在了。</li><li>动态代理类：在程序运行时，运用反射机制动态创建而成。</li><li>静态代理通常只代理一个类，动态代理是代理一个接口下的多个实现类。</li><li>静态代理事先知道要代理的是什么，而动态代理不知道要代理什么东西，只有在运行时才知道。</li><li>动态代理是实现 JDK 里的 InvocationHandler 接口的 invoke 方法，但注意的是代理的是接口，也就是你的业务类必须要实现接口，通过 Proxy 里的 newProxyInstance 得到代理对象。</li><li>还有一种动态代理 CGLIB，代理的是类，不需要业务类继承接口，通过派生的子类来实现代理。通过在运行时，动态修改字节码达到修改类的目的。</li></ul><h2 id="JDK-动态代理和-Cglib-动态代理的区别"><a href="#JDK-动态代理和-Cglib-动态代理的区别" class="headerlink" title="JDK 动态代理和 Cglib 动态代理的区别"></a>JDK 动态代理和 Cglib 动态代理的区别</h2><p>Cglib 与动态代理最大的区别就是：</p><ul><li>使用动态代理的对象必须实现一个或多个接口</li><li>使用 cglib 代理的对象则无需实现接口，达到代理类无侵入。</li></ul><p>Cglib 是一个强大的高性能的代码生成包，它可以在运行期扩展 Java 类与实现 Java 接口。它广泛的被许多 AOP 的框架使用，例如 Spring AOP 和 dynaop，为他们提供方法的 interception（拦截）。</p><p>Cglib 包的底层是通过使用一个小而快的字节码处理框架 ASM，来转换字节码并生成新的类。不鼓励直接使用 ASM，因为它需要你对 JVM 内部结构包括 class 文件的格式和指令集都很熟悉。</p><h2 id="动态代理的用途"><a href="#动态代理的用途" class="headerlink" title="动态代理的用途"></a>动态代理的用途</h2><p>Java 的动态代理，在日常开发中可能并不经常使用，但是并不代表他不重要。Java 的动态代理的最主要的用途就是应用在各种框架中。因为使用动态代理可以很方便的运行期生成代理类，通过代理类可以做很多事情，比如 AOP，比如过滤器、拦截器等。</p><p>在我们平时使用的框架中，像 servlet 的 filter、包括 spring 提供的 aop 以及 struts2 的拦截器都使用了动态代理功能。我们日常看到的 mybatis 分页插件，以及日志拦截、事务拦截、权限拦截这些几乎全部由动态代理的身影。</p><h2 id="JDK-动态代理"><a href="#JDK-动态代理" class="headerlink" title="JDK 动态代理"></a>JDK 动态代理</h2><h3 id="类图-1"><a href="#类图-1" class="headerlink" title="类图"></a>类图</h3><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20180724221741.png" alt="JDK 动态代理"></p><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><p>需要你去实现一个 InvocationHandler 接口，并且调用 Proxy 的静态方法去产生代理类。</p><p>代理类</p><pre><code class="java">public class HelloInvocationHandler implements InvocationHandler {    private HelloSerivice target;    public HelloInvocationHandler(HelloSerivice target) {        this.target = target;    }    @Override    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {        //将代理对象生成字节码到F盘上，方便反编译出java文件查看，实际动态代理是不需要自己生成的        addClassToDisk(proxy.getClass().getName(), ProxyClassImpl.class,&quot;F:/$Proxy0.class&quot;);        if (&quot;say&quot;.equals(method.getName())) {            System.out.println(&quot;记录日志&quot;);            Object result = method.invoke(target, args);            System.out.println(&quot;清理数据&quot;);            return result;        }        return null;    }    public Object newProxyInstance() {        return Proxy.newProxyInstance(                DynamicTest.class.getClassLoader(), // 1. 类加载器                new Class&lt;?&gt;[]{HelloSerivice.class}, // 2. 代理需要实现的接口，可以有多个                new HelloInvocationHandler(new HelloSeriviceImpl()));// 3. 方法调用的实际处理者    }    /**     * 用于生产代理对象的字节码，并将其保存到硬盘上     * @param className     * @param cl     * @param path     */    private void addClassToDisk(String className, Class&lt;?&gt; cl, String path) {        //用于生产代理对象的字节码        byte[] classFile = ProxyGenerator.generateProxyClass(className, cl.getInterfaces());        FileOutputStream out = null;        try {            out = new FileOutputStream(path);            //将代理对象的class字节码写到硬盘上            out.write(classFile);            out.flush();        } catch (Exception e) {            e.printStackTrace();        } finally {            try {                out.close();            } catch (IOException e) {                e.printStackTrace();            }        }    }}</code></pre><p>测试</p><pre><code class="java">public class DynamicTest {    public static void main(String[] args) {        HelloSeriviceImpl h = new HelloSeriviceImpl();        HelloInvocationHandler handler = new HelloInvocationHandler(h);        HelloSerivice helloSerivice = (HelloSerivice) handler.newProxyInstance();        System.out.println(helloSerivice.getClass().getName());        helloSerivice.say();    }}/*output:com.sun.proxy.$Proxy0记录日志hello world清理数据*/</code></pre><p>从结果我们可以看到 proxyHandler.newProxyInstance(); 实际返回的是 com.sun.proxy.$Proxy0，我们把生成的 $Proxy0.class 文件，可以使用反编译工具查看，具体可查看<a href="http://rejoy.iteye.com/blog/1627405" target="_blank" rel="noopener">JDK动态代理实现原理</a>。</p><ul><li>代理对象是在程序运行时产生的，而不是编译期；</li><li>对代理对象的所有接口方法调用都会转发到 InvocationHandler.invoke() 方法，在 invoke() 方法里我们可以加入任何逻辑，比如修改方法参数，加入日志功能、安全检查功能等；之后我们通过某种方式执行真正的方法体，示例中通过反射调用了 Hello 对象的相应方法，还可以通过RPC调用远程方法。</li></ul><p><strong>注意</strong>：对于从 Object 中继承的方法，JDK Proxy 会把 hashCode()、equals()、toString() 这三个非接口方法转发给 InvocationHandler，其余的 Object 方法则不会转发。</p><h2 id="使用-Cglib-实现动态代理"><a href="#使用-Cglib-实现动态代理" class="headerlink" title="使用 Cglib 实现动态代理"></a>使用 Cglib 实现动态代理</h2><p><a href="https://github.com/cglib/cglib" target="_blank" rel="noopener">CGLIB</a>(Code Generation Library)是一个基于 ASM 的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。<a href="https://github.com/cglib/cglib/tree/master/cglib-sample/src/main/java/net/sf/cglib/samples" target="_blank" rel="noopener">官方示例</a>。</p><p>引入 jar 包</p><pre><code class="xml">&lt;!-- https://mvnrepository.com/artifact/cglib/cglib --&gt;&lt;dependency&gt;    &lt;groupId&gt;cglib&lt;/groupId&gt;    &lt;artifactId&gt;cglib&lt;/artifactId&gt;    &lt;version&gt;3.2.7&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.ow2.asm/asm --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.ow2.asm&lt;/groupId&gt;    &lt;artifactId&gt;asm&lt;/artifactId&gt;    &lt;version&gt;6.2&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>实现 MethodInterceptor 接口</p><pre><code class="java">public class CglibProxy implements MethodInterceptor{    private Enhancer enhancer = new Enhancer();    /**     *     * @param o 是被代理对象     * @param method 调用方法的Method对象     * @param args 方法参数     * @param methodProxy     * @return cglib生成用来代替Method对象的一个对象，使用MethodProxy比调用JDK自身的Method直接执行方法效率会有提升     * @throws Throwable     */    @Override    public Object intercept(Object o, Method method, Object[] args,            MethodProxy methodProxy) throws Throwable {        System.out.println(&quot;before &quot; + methodProxy.getSuperName());        System.out.println(method.getName());        Object o1 = methodProxy.invokeSuper(o, args);        //Object o2 = method.invoke(o, args); 使用这种方式会发生死循环，因为方法会被拦截        System.out.println(&quot;after &quot; + methodProxy.getSuperName());        return o1;    }    public  Object newProxyInstance(Class&lt;?&gt; c) {        //设置产生的代理对象的父类。        enhancer.setSuperclass(c);        //设置CallBack接口的实例        enhancer.setCallback(this);        //使用默认无参数的构造函数创建目标对象        return enhancer.create();    }}</code></pre><p>被代理对象和测试类</p><pre><code class="java">class Do{    public int doSomething(int num){        System.out.println(&quot;方法执行中。。。。。。&quot;);        return num;    }}public class CglibDemo {    public static void main(String[] args) {        CglibProxy cglibProxy = new CglibProxy();        Do o = (Do)cglibProxy.newProxyInstance(Do.class);        System.out.println(o.doSomething(5));    }}/*output:before CGLIB$doSomething$0doSomething方法执行中。。。。。。after CGLIB$doSomething$05*/</code></pre><p>上述代码中，我们通过 CGLIB 的 Enhancer 来指定要代理的目标对象、实际处理代理逻辑的对象，最终通过调用 create() 方法得到代理对象，对这个对象<strong>所有非 final 方法</strong>的调用都会转发给 MethodInterceptor.intercept() 方法，在 intercept() 方法里我们可以加入任何逻辑，比如修改方法参数，加入日志功能、安全检查功能等；通过调用 MethodProxy.invokeSuper() 方法，我们将调用转发给原始对象，具体到本例，就是 Do 的具体方法。CGLIG 中 MethodInterceptor 的作用跟 JDK 代理中的 InvocationHandler 很类似，都是方法调用的中转站。</p><p><strong>注意</strong>：对于从 Object 中继承的方法，CGLIB 代理也会进行代理，如 hashCode()、equals()、toString() 等，但是 getClass()、wait() 等方法不会，<strong>因为它是 final 方法，CGLIB 无法代理</strong>。</p><p>更多 CGLIB 内容：<a href="http://www.cnblogs.com/shijiaqi1066/p/3429691.html" target="_blank" rel="noopener">http://www.cnblogs.com/shijiaqi1066/p/3429691.html</a></p><h1 id="正向代理和反向代理"><a href="#正向代理和反向代理" class="headerlink" title="正向代理和反向代理"></a>正向代理和反向代理</h1><h2 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h2><p>正向代理（forward proxy）：是一个位于客户端和目标服务器之间的服务器(代理服务器)，为了从目标服务器取得内容，客户端向代理服务器发送一个请求并指定目标，然后代理服务器向目标服务器转交请求并将获得的内容返回给客户端。客户端必须要进行一些特别的配置才能使用正向代理。一般情况下，如果没有特别说明，代理技术默认是指正向代理技术。</p><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20180726203334.png" alt="正向代理"></p><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p>反向代理（reverse proxy）：是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</p><p>对于常用的场景，就是我们在Web开发中用到的负载均衡服务器，客户端发送请求到负载均衡服务器上，负载均衡服务器再把请求转发给一台真正的服务器来执行，再把执行结果返回给客户端。</p><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20180726203551.png" alt="反向代理"></p><p>前面我们说过，通过正向代理服务器访问目标服务器，目标服务器是不知道真正的客户端是谁的，甚至不知道访问自己的是一个代理。而通过反向代理服务器访问目标服务器时，客户端是不知道真正的目标服务器是谁的，甚至不知道自己访问的是一个代理。这也是<strong>正向代理和反向代理的区别</strong>。</p><p>反向代理的用途</p><ul><li>隐藏服务器真实 IP：使用反向代理，可以对客户端隐藏服务器的IP地址。</li><li>负载均衡：反向代理服务器可以做负载均衡，根据所有真实服务器的负载情况，将客户端请求分发到不同的真实服务器上。</li><li>提高访问速度：反向代理服务器可以对于静态内容及短时间内有大量访问请求的动态内容提供缓存服务，提高访问速度。</li><li>提供安全保障：反向代理服务器可以作为应用层防火墙，为网站提供对基于 Web 的攻击行为（例如DoS/DDoS）的防护，更容易排查恶意软件等。还可以为后端服务器统一提供加密和 SSL 加速（如 SSL 终端代理），提供 HTTP 访问认证等。</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote><p><a href="http://design-patterns.readthedocs.io/zh_CN/latest/structural_patterns/proxy.html" target="_blank" rel="noopener">http://design-patterns.readthedocs.io/zh_CN/latest/structural_patterns/proxy.html</a><br><a href="https://mp.weixin.qq.com/s/kycTUCtgmjtdAA4f_KpFFg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/kycTUCtgmjtdAA4f_KpFFg</a><br><a href="https://www.cnblogs.com/CarpenterLee/p/8241042.html" target="_blank" rel="noopener">https://www.cnblogs.com/CarpenterLee/p/8241042.html</a><br><a href="https://brightloong.github.io/2017/03/17/Java静态代理-动态代理笔记/" target="_blank" rel="noopener">https://brightloong.github.io/2017/03/17/Java静态代理-动态代理笔记/</a></p></blockquote><br>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Head-First-设计模式》笔记14-状态模式</title>
      <link href="/2018/07/15/%E3%80%8AHead-First-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E7%AC%94%E8%AE%B014-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/07/15/%E3%80%8AHead-First-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E7%AC%94%E8%AE%B014-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>状态模式(State Pattern) ：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。其别名为状态对象(Objects for States)，状态模式是一种对象行为型模式。</p><p>在很多情况下，一个对象的行为取决于一个或多个动态变化的属性，这样的属性叫做状态，这样的对象叫做有状态的(stateful)对象，这样的对象状态是从事先定义好的一系列值中取出的。当一个这样的对象与外部事件产生互动时，其内部状态就会改变，从而使得系统的行为也随之发生变化。</p><p>在有些情况下多个环境对象需要共享同一个状态，如果希望在系统中实现多个环境对象实例共享一个或多个状态对象，那么需要将这些状态对象定义为环境的静态成员对象。</p><a id="more"></a><h1 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h1><ul><li>Context: 环境类</li><li>State: 抽象状态类</li><li>ConcreteState: 具体状态类</li></ul><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20180715150221.png" alt="状态模式"></p><h1 id="State-抽象状态类"><a href="#State-抽象状态类" class="headerlink" title="State 抽象状态类"></a>State 抽象状态类</h1><p>这里使用了接口，如果有共同的功能可以使用抽象类。</p><pre><code class="java">public interface State {    /**     * 状态对应的处理     */    public void handle(String sampleParameter);}</code></pre><h1 id="Context-环境类"><a href="#Context-环境类" class="headerlink" title="Context 环境类"></a>Context 环境类</h1><pre><code class="java">public class Context {    private State stateA; // 所有状态    private State stateB;    // 持有一个 State 类型的对象实例，当前状态    private State state;    public Context() {        stateA = new ConcreteStateA(this);        stateB = new ConcreteStateB(this);        state = stateA;    }    public void setState(State state) {        this.state = state;    }    /**     * 用户感兴趣的接口方法     */    public void request(String sampleParameter) {        // 转调state来处理        state.handle(sampleParameter);    }    public State getStateA() {        return stateA;    }    public State getStateB() {        return stateB;    }}</code></pre><h1 id="第一个状态"><a href="#第一个状态" class="headerlink" title="第一个状态"></a>第一个状态</h1><pre><code class="java">public class ConcreteStateA implements State {    Context context;    public ConcreteStateA(Context context) {        this.context = context;    }    @Override    public void handle(String sampleParameter) {        System.out.println(&quot;具体状态A 处理 ：&quot; + sampleParameter);        context.setState(context.getStateB()); // 完成操作后，切换状态    }}</code></pre><h1 id="第二个状态"><a href="#第二个状态" class="headerlink" title="第二个状态"></a>第二个状态</h1><pre><code class="java">public class ConcreteStateB implements State {    Context context;    public ConcreteStateB(Context context) {        this.context = context;    }    @Override    public void handle(String sampleParameter) {        System.out.println(&quot;具体状态B 处理 ：&quot; + sampleParameter);        context.setState(context.getStateA()); // 完成操作后，切换状态    }}</code></pre><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><pre><code class="java">public class Client {    public static void main(String[] args){        Context context = new Context();        context.request(&quot;测试参数&quot;);        context.request(&quot;测试参数&quot;);        context.request(&quot;测试参数&quot;);    }}/*output:具体状态A 处理 ：测试参数具体状态B 处理 ：测试参数具体状态A 处理 ：测试参数*/</code></pre><h1 id="状态模式和策略模式的区别"><a href="#状态模式和策略模式的区别" class="headerlink" title="状态模式和策略模式的区别"></a>状态模式和策略模式的区别</h1><p><strong>状态模式</strong>：我们将一群行为封装在状态对象中，context 的行为随时可委托到那些状态对象中的一个。随着时间的流失，当前状态在状态对象集合中游走改变，以反映出 context 内部的状态，因此，context 的行为也会跟着改变；</p><p><strong>策略模式</strong>：客户通常主动指定 Context 所要组合的策略对象是哪一个。现在，固然策略模式让我们具有弹性，能够在运行时改变策略。但对于某个 context 对象来说，通常都只有一个 最适当的策略对象。</p><p>一般而言，我们把策略模式想成是除了继承外的一种弹性替代方案。如果你使用继承定义了一个类的行为，你将被这个行为所困住，甚至要修改他都很难。有了策略模式，你可以通过组合不同对象来改变行为；</p><p>我们把状态模式想成是不用在 context 中放置许多条件判断的替代方案。通过将行为包装进状态对象中，你可以通过 context 内简单地修改状态对象来改变 context 的行为；</p><h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><ul><li>封装了转换规则。</li><li>枚举可能的状态，在枚举状态之前需要确定状态种类。</li><li>将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。</li><li>允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。</li><li>可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。</li></ul><h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><ul><li>状态模式的使用必然会增加系统类和对象的个数。</li><li>状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。</li><li>状态模式对“开闭原则”的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态；而且修改某个状态类的行为也需修改对应类的源代码。</li></ul><h1 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h1><ul><li>对象的行为依赖于它的状态（属性）并且可以根据它的状态改变而改变它的相关行为。</li><li>代码中包含大量与对象状态有关的条件语句，这些条件语句的出现，会导致代码的可维护性和灵活性变差，不能方便地增加和删除状态，使客户类与类库之间的耦合增强。在这些条件语句中包含了对象的行为，而且这些条件对应于对象的各种状态。</li></ul><br>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Head-First-设计模式》笔记13-组合模式</title>
      <link href="/2018/07/15/%E3%80%8AHead-First-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E7%AC%94%E8%AE%B013-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/07/15/%E3%80%8AHead-First-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E7%AC%94%E8%AE%B013-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>组合模式允许你将对象组合成树形结构来表现“整体/部分”层次结构。组合能够让客户以一致的方式处理个别对象以及对象组合。</p><p>使用组合结构，我们能把相同的操作应用在组合和个别对象上。换句话说，在大多数情况下，我们可以忽略对象组合和个别对象之间的差别。</p><a id="more"></a><h1 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h1><ul><li>Component：为组合中的对象声明接口。</li><li>Leaf：在组合中表示没有子节点的叶节点。</li><li>Composite：定义有枝节点行为，用来存储子部件，在 Component 接口中实现与子部件有关操作，如增加(add)和删除(remove)等。</li></ul><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20180715102525.png" alt="组合模式"></p><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>文件系统，文件系统里有文件和文件夹，文件夹里又有文件夹和文件...</p><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20180715103611.png" alt=""></p><h2 id="定义-Directory-基类"><a href="#定义-Directory-基类" class="headerlink" title="定义 Directory 基类"></a>定义 Directory 基类</h2><p>所有组件必须实现 Directory 接口，然而叶节点和组合节点的角色不同，所有有些方法并不适用。面对这种情况，有时候最好是抛出运行时异常。</p><pre><code class="java">public abstract class Directory {    String name;    String description;    /**     * 添加指定文件/文件夹到该目录下     * @param dir 将要添加的文件/文件夹     * @return 添加成功/失败     */    public boolean add(Directory dir){        throw new UnsupportedOperationException();//默认抛出操作异常    }    /**     * 删除该目录下的指定文件/文件夹     * @param dir 将要删除的文件/文件夹     * @return 删除成功/失败     */    public boolean remove(Directory dir){        throw new UnsupportedOperationException();//默认抛出操作异常    }    /**     * 清空该目录下所有文件和文件夹     * @return 清空成功/失败     */    public boolean clear(){        throw new UnsupportedOperationException();//默认抛出操作异常    }    public abstract void print();    public String getName() {        return name;    }    public String getDescription() {        return description;    }    public String toString(){        return name + description;    }}</code></pre><h2 id="MyFile-类"><a href="#MyFile-类" class="headerlink" title="MyFile 类"></a>MyFile 类</h2><p>由于基类中对 MyFile 不支持的操作都做了默认实现（抛出异常），所以 MyFile 变得相当苗条。</p><pre><code class="java">public class MyFile extends Directory{    public MyFile(String name, String desc) {        this.name = name;        this.description = desc;    }    @Override    public void print() {        System.out.print(this.toString());//输出文件自身信息    }}</code></pre><h2 id="Folder-类"><a href="#Folder-类" class="headerlink" title="Folder 类"></a>Folder 类</h2><pre><code class="java">public class Folder extends Directory{    ArrayList&lt;Directory&gt; files;    public Folder(String name, String desc){        this.name = name;        this.description = desc;        this.files = new ArrayList&lt;Directory&gt;();    }    @Override    public void print() {        //打印该Folder自身信息        System.out.print(this.toString() + &quot;(&quot;);        //打印该目录下所有文件及子文件//        for(Directory dir : files){//            dir.print();//            System.out.print(&quot;, &quot;);//        }        Iterator&lt;Directory&gt; iter = getFiles().iterator();        while(iter.hasNext()){            Directory dir = iter.next();            dir.print();            if(iter.hasNext()){                System.out.print(&quot;,&quot;);            }        }        System.out.print(&quot;)&quot;);    }    @Override    public boolean add(Directory dir){        if(files.add(dir))            return true;        else            return false;    }    @Override    public boolean remove(Directory dir){        if(files.remove(dir))            return true;        else            return false;    }    @Override    public boolean clear(){        files.clear();        return true;    }    public ArrayList&lt;Directory&gt; getFiles() {        return files;    }}</code></pre><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><pre><code class="java">public class Test {    public static void main(String[] args){        /*构造文件树*/        /*        C            a.txt            b.txt            system                sys.dat            windows                win32                    settings                    log.txt                win32.config        */        Directory dir = new Folder(&quot;C&quot;, &quot;&quot;);        dir.add(new MyFile(&quot;a.txt&quot;, &quot;&quot;));        dir.add(new MyFile(&quot;b.txt&quot;, &quot;&quot;));        Directory subDir = new Folder(&quot;system&quot;, &quot;&quot;);        subDir.add(new MyFile(&quot;sys.dat&quot;, &quot;&quot;));        dir.add(subDir);        Directory subDir2 = new Folder(&quot;windows&quot;, &quot;&quot;);        Directory subDir3 = new Folder(&quot;win32&quot;, &quot;&quot;);        subDir3.add(new Folder(&quot;settings&quot;, &quot;&quot;));        subDir3.add(new MyFile(&quot;log.txt&quot;, &quot;&quot;));        subDir2.add(subDir3);        subDir2.add(new MyFile(&quot;win32.config&quot;, &quot;&quot;));        dir.add(subDir2);        dir.print();//打印输出文件树    }}/* output:C(a.txt, b.txt, system(sys.dat, ), windows(win32(settings(), log.txt, ), win32.config, ), )*/</code></pre><h2 id="关于是否抛出异常"><a href="#关于是否抛出异常" class="headerlink" title="关于是否抛出异常"></a>关于是否抛出异常</h2><p>有些时候我们可以选择返回 null，返回 false，返回错误码等等而不是抛出异常，这些方式或许更和谐一些，但抛出异常在有些时候是对事实最贴切的表达。</p><p>举个例子，假设我们的 Folder 类有一个 add 方法，表示是否存在与之关联的应用程序，而 MyFile 不支持 add 方法，同时该属性又是从父类继承得到的，我们无法删除它。</p><p>此时我们可以选择返回 false 或者抛出异常：</p><p>返回 false：表示 MyFile 没有与之关联的应用程序<br>抛出异常：表示 MyFile 不支持该操作<br>显然，抛出异常的含义才是我们真正想要表达的</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>组合模式提供一个结构，可同时包容个别对象和组合对象。</li><li>组合模式允许客户对个别对象以及组合对象一视同仁。</li><li>组合结构内的任意对象称为组件，组件可以是组合，也可以是叶节点。</li><li>在实现组合模式时，有许多设计上的折中。你要根据需要平衡透明性和安全性。</li></ol><br>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Head-First-设计模式》笔记12-迭代器模式</title>
      <link href="/2018/07/14/%E3%80%8AHead-First-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E7%AC%94%E8%AE%B012-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/07/14/%E3%80%8AHead-First-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E7%AC%94%E8%AE%B012-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p><strong>迭代器模式</strong>提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。</p><p>把游走的任务放在迭代器上，而不是聚合上，这样简化了聚合的接口和实现，也让责任各得其所。</p><a id="more"></a><h1 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h1><ul><li>Iterator：定义访问和遍历元素的接口</li><li>Concretelterator：具体迭代器，实现迭代器接口，对该聚合遍历时跟踪当前位置。</li><li>Aggregate：聚合，定义创建相应迭代器对象的接口。</li><li>ConcreteAggregate：具体聚合，其工作是实现相应迭代器的接口，返回具体迭代器的一个适当的实例。</li></ul><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20180714222010.png" alt="迭代器模式"></p><h1 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h1><p>　　<br>餐厅和煎饼屋要合并，要把煎饼屋的菜单作为早餐菜单，餐厅的菜单作为午餐菜单。</p><p>但是对于菜单项的记录，前者用的是 ArrayList，后者用的是数组，两者都不愿意改变代码实现。</p><p>所以在女招待处理的时候，需要用不同的方法分别处理这两个菜单，毕竟菜单项的返回值一个是 ArrayList，一个是数组，遍历的时候也要分别遍历。</p><h1 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h1><h2 id="菜单项"><a href="#菜单项" class="headerlink" title="菜单项"></a>菜单项</h2><pre><code class="java">public class MenuItem {    String name;    String description;    boolean vegetarian;    double price;    public MenuItem(String name, String description, boolean vegetarian, double price) {        this.name = name;        this.description = description;        this.vegetarian = vegetarian;        this.price = price;    }    public String getName() {        return name;    }    public String getDescription() {        return description;    }    public boolean isVegetarian() {        return vegetarian;    }    public double getPrice() {        return price;    }}</code></pre><h2 id="共同接口"><a href="#共同接口" class="headerlink" title="共同接口"></a>共同接口</h2><p>让客户能够取得一个菜单项迭代器</p><pre><code class="java">public interface Menu {    Iterator createIterator();}</code></pre><h2 id="餐厅（数组）"><a href="#餐厅（数组）" class="headerlink" title="餐厅（数组）"></a>餐厅（数组）</h2><p>使用数据聚合 MenuItem</p><pre><code class="java">public class DinerMenu implements Menu {    static final int MAX_ITEMS = 6;    int numberOfItems = 0;    MenuItem[] menuItems;    public DinerMenu() {        menuItems = new MenuItem[MAX_ITEMS];        addItem(&quot;11&quot;, &quot;11&quot;, true, 1.11);        addItem(&quot;22&quot;, &quot;22&quot;, true, 1.22);        addItem(&quot;33&quot;, &quot;33&quot;, false, 1.33);        addItem(&quot;44&quot;, &quot;44&quot;, false, 1.44);    }    public void addItem(String name, String description, boolean vegetarian, double price) {        MenuItem menuItem = new MenuItem(name, description, vegetarian, price);        if (numberOfItems &gt;= MAX_ITEMS) {            System.err.println(&quot;menu full!&quot;);        } else {            menuItems[numberOfItems] = menuItem;            numberOfItems++;        }    }    public MenuItem[] getMenuItems() {        return menuItems;    }    @Override    public Iterator createIterator() {        return new DinerMenuIterator(menuItems);    }}</code></pre><h2 id="煎饼屋（List）"><a href="#煎饼屋（List）" class="headerlink" title="煎饼屋（List）"></a>煎饼屋（List）</h2><pre><code class="java">public class PancakeHouseMenu implements Menu {    ArrayList menuItems;    public PancakeHouseMenu() {        menuItems = new ArrayList();        addItem(&quot;1&quot;, &quot;1&quot;, true, 1.1);        addItem(&quot;2&quot;, &quot;2&quot;, true, 1.2);        addItem(&quot;3&quot;, &quot;3&quot;, false, 1.3);        addItem(&quot;4&quot;, &quot;4&quot;, false, 1.4);    }    @Override    public Iterator createIterator() {        return menuItems.iterator(); // List 提供了迭代器    }    public void addItem(String name, String description, boolean vegetarian, double price) {        MenuItem menuItem = new MenuItem(name, description, vegetarian, price);        menuItems.add(menuItem);    }    public ArrayList getMenuItems() {        return menuItems;    }}</code></pre><h2 id="餐厅菜单迭代器"><a href="#餐厅菜单迭代器" class="headerlink" title="餐厅菜单迭代器"></a>餐厅菜单迭代器</h2><pre><code class="java">public class DinerMenuIterator implements Iterator {    MenuItem[] items;    int position = 0;    public DinerMenuIterator(MenuItem[] items) {        this.items = items;    }    @Override    public boolean hasNext() {        if (position &gt;= items.length || items[position] == null) {            return false;        }        return true;    }    @Override    public Object next() {        MenuItem menuItem = items[position];        position++;        return menuItem;    }    @Override    public void remove() {        if (position &lt;= 0) {            throw new IllegalStateException(&quot;null&quot;);        }        if (items[position - 1] == null) {            for (int i = position - 1; i &lt; (items.length - 1); i++) {                items[i] = items[i + 1];            }            items[items.length - 1] = null;        }    }}</code></pre><h2 id="服务员"><a href="#服务员" class="headerlink" title="服务员"></a>服务员</h2><p>服务员遍历菜单实现解耦。</p><pre><code class="java">public class Waitress {    Menu pancakeHouseMenu;    Menu dinerMenu;    public Waitress(Menu pancakeHouseMenu, Menu dinerMenu) {        this.pancakeHouseMenu = pancakeHouseMenu;        this.dinerMenu = dinerMenu;    }    public void printMenu() {        Iterator pancekeIterator = pancakeHouseMenu.createIterator();        Iterator dinerIterator = dinerMenu.createIterator();        printMenu(pancekeIterator);        printMenu(dinerIterator);    }    public void printMenu(Iterator iterator) {        while (iterator.hasNext()) {            MenuItem menuItem = (MenuItem) iterator.next();            System.out.println(menuItem.getName() + &quot;,&quot; + menuItem.getDescription() + &quot;,&quot; + menuItem.getPrice());        }    }    public static void main(String[] args) {        Menu pMenu = new PancakeHouseMenu();        Menu dMenu = new DinerMenu();        Waitress waitress = new Waitress(pMenu, dMenu);        waitress.printMenu();    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Head-First-设计模式》笔记11-模板方法模式</title>
      <link href="/2018/07/14/%E3%80%8AHead-First-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E7%AC%94%E8%AE%B011-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/07/14/%E3%80%8AHead-First-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E7%AC%94%E8%AE%B011-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>模板方法模式：在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。</p><a id="more"></a><h1 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h1><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20180714155252.png" alt=""></p><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>咖啡和茶的冲泡步骤都差不多，可以理解为两份冲泡法都采用了基本相同的算法：</p><ol><li>煮沸水。</li><li>用热水泡茶或咖啡。</li><li>把饮料倒进杯子。</li><li>加入适当调料（奶、糖或者柠檬片）。</li></ol><h2 id="创建咖啡因饮料抽象类"><a href="#创建咖啡因饮料抽象类" class="headerlink" title="创建咖啡因饮料抽象类"></a>创建咖啡因饮料抽象类</h2><pre><code class="java">public abstract class CaffeineBeverage {    final void prepareRecipe() { // 不希望子类覆盖这个方法        boilWater();        brew();        pourInCup();        addCondiments();    }    abstract void brew();    abstract void addCondiments();    void boilWater() {        System.out.println(&quot;Boiling water&quot;);    }    void pourInCup() {        System.out.println(&quot;Pouring into cup&quot;);    }}</code></pre><h2 id="创建具体饮料（子类）"><a href="#创建具体饮料（子类）" class="headerlink" title="创建具体饮料（子类）"></a>创建具体饮料（子类）</h2><pre><code class="java">public class Tea extends CaffeineBeverage {    @Override    void brew() {        System.out.println(&quot;tea&quot;);    }    @Override    void addCondiments() {        System.out.println(&quot;Adding lemon&quot;);    }}public class Coffee extends CaffeineBeverage {    @Override    void brew() {        System.out.println(&quot;coffee&quot;);    }    @Override    void addCondiments() {        System.out.println(&quot;Adding Sugar and Milk&quot;);    }}</code></pre><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><pre><code class="java">public class CaffeineTest {    public static void main(String[] args) {        Tea tea = new Tea();        tea.prepareRecipe();        Coffee coffee = new Coffee();        coffee.prepareRecipe();    }}</code></pre><h1 id="对模版方法进行挂钩"><a href="#对模版方法进行挂钩" class="headerlink" title="对模版方法进行挂钩"></a>对模版方法进行挂钩</h1><p>钩子是一种被声明在抽象类中的方法，但是只有空的或者默认的实现。</p><p>在 CaffeineBeverage 抽象类中加入 customerWantsCondiments() 方法，用来判断顾客是否想要加入调料，然后就可以在 prepareRecipe() 方法中进行判断。</p><pre><code class="java">final void prepareRecipe() {    boilWater();    brew();    pourInCup();    if (customerWantsCondiments()) {        addCondiments();    }}boolean customerWantsCondiments(){    return true;}</code></pre><p>然后在 Coffee 类中覆盖该方法。</p><pre><code class="java">@Overridepublic boolean customerWantsCondiments() { //调用钩子    String answer = getUserInput();    if (answer.toLowerCase().startsWith(&quot;y&quot;)) {        return true;    } else {        return false;    }}</code></pre><h1 id="Java-中数组排序"><a href="#Java-中数组排序" class="headerlink" title="Java 中数组排序"></a>Java 中数组排序</h1><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20180714165831.png" alt=""></p><p>由被排序的对象内的每个元素自行提供比较大小的算法部分，所以这虽然不是教科书上的模板方法，但它的实现仍然符合模板方法模式的精神。</p><h1 id="模板方法模式和工厂方法的对比"><a href="#模板方法模式和工厂方法的对比" class="headerlink" title="模板方法模式和工厂方法的对比"></a>模板方法模式和工厂方法的对比</h1><p>在看模板方法的时候，很容易想到工厂方法。因为他们都是让具体的实现放在子类中，但是工厂方法主要是生产出产品，然后去应用产品。模板方法是在于依赖子类中的步骤中的其中几个步骤，具体的步骤已经在基类中写好了。</p><p>工厂方法是模板方法的一种特殊版本。</p><h1 id="模板方法模式和策略模式的对比"><a href="#模板方法模式和策略模式的对比" class="headerlink" title="模板方法模式和策略模式的对比"></a>模板方法模式和策略模式的对比</h1><p>同样模板方法模式和策略模式都是封装算法。但是策略模式中的每个策略都是单独的一个类。可以随时去更改策略。模板方法模式虽然也是封装了算法，其实主要在于封装步骤，具体的实现是根据依靠各个子类。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Head-First-设计模式》笔记10-外观模式</title>
      <link href="/2018/07/13/%E3%80%8AHead-First-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E7%AC%94%E8%AE%B010-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/07/13/%E3%80%8AHead-First-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E7%AC%94%E8%AE%B010-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>外观模式（Facade Pattern）：外观模式提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。</p><a id="more"></a><h1 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h1><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20180713224746.png" alt="外观模式"></p><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>书中的例子：家庭影院系统，内含DVD播放器、投影仪、自动屏幕、环绕立体声等。那么当你想看一部DVD时，需要同时启动这些。</p><h2 id="构造家庭影院的外观"><a href="#构造家庭影院的外观" class="headerlink" title="构造家庭影院的外观"></a>构造家庭影院的外观</h2><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20180713225449.png" alt=""></p><h2 id="实现简化的接口"><a href="#实现简化的接口" class="headerlink" title="实现简化的接口"></a>实现简化的接口</h2><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20180713225604.png" alt=""></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20180713225728.png" alt=""></p><h1 id="外观模式和适配器模式"><a href="#外观模式和适配器模式" class="headerlink" title="外观模式和适配器模式"></a>外观模式和适配器模式</h1><p>外观模式和适配器模式的差异，在于它们的意图。</p><ul><li><strong>适配器模式</strong>的意图是，改变接口以符合客户的期望。</li><li>而<strong>外观模式</strong>的意图是，提供子系统的一个简化接口。</li></ul><h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><ul><li>对客户屏蔽子系统组件，减少了客户处理的对象数目并使得子系统使用起来更加容易。通过引入外观模式，客户代码将变得很简单，与之关联的对象也很少。</li><li>实现了子系统与客户之间的松耦合关系，这使得子系统的组件变化不会影响到调用它的客户类，只需要调整外观类即可。</li><li>降低了大型软件系统中的编译依赖性，并简化了系统在不同平台之间的移植过程，因为编译一个子系统一般不需要编译所有其他的子系统。一个子系统的修改对其他子系统没有任何影响，而且子系统内部变化也不会影响到外观对象。</li><li>只是提供了一个访问子系统的统一入口，并不影响用户直接使用子系统类。</li></ul><h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><ul><li>不能很好地限制客户使用子系统类，如果对客户访问子系统类做太多的限制则减少了可变性和灵活性。</li><li>在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。</li></ul><h1 id="值得注意的地方"><a href="#值得注意的地方" class="headerlink" title="值得注意的地方"></a>值得注意的地方</h1><ol><li>外观模式对接口进行了简化，但这并不意味着对子系统进行彻底封装。如果有必要，这些子系统的接口还可以继续暴露给客户，这就是所谓的高级功能（或称为自定义）。</li><li>外观模式不能新增功能，但他可以将某些功能按次序执行。例如先打开DVD，后播放DVD。</li><li>子系统与外观不是一对一关系，是多对多关系。一个子系统可以拥有多个外观，一个外观可以调用多个子系统。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Head-First-设计模式》笔记9-适配器模式</title>
      <link href="/2018/07/13/%E3%80%8AHead-First-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E7%AC%94%E8%AE%B09-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/07/13/%E3%80%8AHead-First-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E7%AC%94%E8%AE%B09-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p><strong>适配器模式(Adapter Pattern)</strong>：将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作。</p><p>适配器提供客户类需要的接口，适配器的实现就是把客户类的请求转化为对适配者的相应接口的调用。也就是说：当客户类调用适配器的方法时，在适配器类的内部将调用适配者类的方法，而这个过程对客户类是透明的，客户类并不直接访问适配者类（解耦）。因此，适配器可以使由于接口不兼容而不能交互的类可以一起工作。这就是适配器模式的模式动机。</p><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20180713220931.png" alt="适配器"></p><a id="more"></a><h1 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h1><ul><li>Target：目标抽象类</li><li>Adapter：适配器类</li><li>Adaptee：适配者类</li><li>Client：客户类</li></ul><h2 id="对象适配器"><a href="#对象适配器" class="headerlink" title="对象适配器"></a>对象适配器</h2><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20180713221251.png" alt="对象适配器"></p><p>这个适配器充满着良好的 OO 设计原则：使用对象组合，以修改的接口包装被适配者，被适配者的任何子类都可以搭配着适配器使用。</p><h2 id="类适配器"><a href="#类适配器" class="headerlink" title="类适配器"></a>类适配器</h2><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20180713221805.png" alt="类适配器"></p><p>使用了多重继承，所以在 Java 中无法使用。</p><p>和对象适配器唯一的差别就在于适配器继承了 Target 和 Adaptee。而对象适配器利用组合的方式将请求传送给被适配者。</p><h1 id="将枚举适配到迭代器"><a href="#将枚举适配到迭代器" class="headerlink" title="将枚举适配到迭代器"></a>将枚举适配到迭代器</h1><p>早期 Java 的集合都实现了一个 elements() 的方法，返回一个 Enumeration。</p><p>JDK 1.2 开始使用了 Iterator 接口。</p><p>我们经常面对遗留代码，这些代码暴露出枚举器接口，但我们又希望在新的代码中只使用迭代器。想解决这个问题，看来我们需要构造一个适配器。</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><pre><code class="java">public interface Iterator&lt;E&gt; {    boolean hasNext();    E next();    void remove();}public interface Enumeration&lt;E&gt; {    boolean hasMoreElements();    E nextElement();}</code></pre><h2 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h2><pre><code class="java">public class EnumerationIterator implements Iterator {    Enumeration enumeration;    public EnumerationIterator(Enumeration enumeration) {        this.enumeration = enumeration;    }    @Override    public boolean hasNext() {        return enumeration.hasMoreElements();    }    @Override    public Object next() {        return enumeration.nextElement();    }    @Override    public void remove() {        throw new UnsupportedOperationException();    }}</code></pre><h1 id="适配器模式与装饰者模式区别"><a href="#适配器模式与装饰者模式区别" class="headerlink" title="适配器模式与装饰者模式区别"></a>适配器模式与装饰者模式区别</h1><p><strong>适配器模式</strong>：将一个类的接口，转化成客户期望的另一个接口，适配器让原本接口不兼容的类可以合作无间。</p><p><strong>装饰者模式</strong>：装饰者模式用来添加一些新的功能，而维持<strong>接口不变</strong>。动态的将责任附加到对象上(因为利用组合而不是继承来实现，而组合是可以在运行时进行随机组合的)。若要扩展功能，装饰者提供了比继承更富有弹性的替代方案(同样地，通过组合可以很好的避免类暴涨，也规避了继承中的子类必须无条件继承父类所有属性的弊端)。</p><p><strong>总结</strong>：适配器模式主要是为了接口的转换，而装饰者模式关注的是通过组合来动态的为被装饰者注入新的功能或行为(即所谓的责任)。</p><p>适配器将一个对象包装起来以改变其接口；装饰者将一个对象包装起来以增强新的行为和责任；而外观将一群对象包装起来以简化其接口。</p><h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><ul><li>将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，而无须修改原有代码。</li><li>增加了类的透明性和复用性，将具体的实现封装在适配者类中，对于客户端类来说是透明的，而且提高了适配者的复用性。</li><li>灵活性和扩展性都非常好，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”。</li></ul><p><strong>类适配器模式还具有如下优点</strong>：由于适配器类是适配者类的子类，因此可以在适配器类中置换一些适配者的方法，使得适配器的灵活性更强。</p><p><strong>对象适配器模式还具有如下优点</strong>：一个对象适配器可以把多个不同的适配者适配到同一个目标，也就是说，同一个适配器可以把适配者类和它的子类都适配到目标接口。</p><h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><p><strong>类适配器模式的缺点如下</strong>：对于 Java、C# 等不支持多重继承的语言，一次最多只能适配一个适配者类，而且目标抽象类只能为抽象类，不能为具体类，其使用有一定的局限性，不能将一个适配者类和它的子类都适配到目标接口。</p><p><strong>对象适配器模式的缺点如下</strong>：与类适配器模式相比，要想置换适配者类的方法就不容易。如果一定要置换掉适配者类的一个或多个方法，就只好先做一个适配者类的子类，将适配者类的方法置换掉，然后再把适配者类的子类当做真正的适配者进行适配，实现过程较为复杂。</p><br>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Head-First-设计模式》笔记8-命令模式</title>
      <link href="/2018/07/11/%E3%80%8AHead-First-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E7%AC%94%E8%AE%B08-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/07/11/%E3%80%8AHead-First-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E7%AC%94%E8%AE%B08-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>命令模式将“请求”封装成对象，以便使用不同的请求，队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。</p><p>在软件设计中，我们经常需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是哪个，我们只需在程序运行时指定具体的请求接收者即可，此时，可以使用命令模式来进行设计，使得请求发送者与请求接收者消除彼此之间的耦合，让对象之间的调用关系更加灵活。</p><p>命令模式可以对发送者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求。这就是命令模式的模式动机。</p><a id="more"></a><h1 id="常见的情景"><a href="#常见的情景" class="headerlink" title="常见的情景"></a>常见的情景</h1><p>在餐厅点餐工作流程中，顾客将写好的订单看做一个命令，服务员接受了这个命令，然后他把订单（命令）交给厨师，厨师再根据订单（命令）去做菜。在这个情景中，顾客是动作请求者，厨师是动作执行者，二者并没有接触（解耦），但是通过命令的传递完成了整个点菜流程。</p><h1 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h1><p>命令模式包含如下角色：</p><ul><li>Command: 抽象命令类</li><li>ConcreteCommand: 具体命令类</li><li>Invoker: 调用者</li><li>Receiver: 接收者</li><li>Client:客户类</li></ul><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20180711212629.png" alt="命令模式类图"></p><h1 id="从餐厅到命令模式"><a href="#从餐厅到命令模式" class="headerlink" title="从餐厅到命令模式"></a>从餐厅到命令模式</h1><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20180711213135.png" alt=""></p><p>对应关系：</p><ul><li>女招待————Invoker</li><li>厨师————Receiver</li><li>顾客————Client</li><li>订单————Command</li><li>orderUp()————execute()</li><li>takeOrder()————setComand()</li></ul><h1 id="简单实例代码"><a href="#简单实例代码" class="headerlink" title="简单实例代码"></a>简单实例代码</h1><h2 id="命令接口"><a href="#命令接口" class="headerlink" title="命令接口"></a>命令接口</h2><pre><code class="java">public interface Command {    public void execute();}</code></pre><h2 id="电灯及打开电灯命令"><a href="#电灯及打开电灯命令" class="headerlink" title="电灯及打开电灯命令"></a>电灯及打开电灯命令</h2><pre><code class="java">// 电灯public class Light {    public void on() {        System.out.println(&quot;on&quot;);    }    public void off() {        System.out.println(&quot;off&quot;);    }}// 打开电灯命令public class LightOnCommand implements Command {    Light light;    public LightOnCommand(Light light) {        this.light = light;    }    @Override    public void execute() {        light.on();    }}</code></pre><h2 id="使用命令对象"><a href="#使用命令对象" class="headerlink" title="使用命令对象"></a>使用命令对象</h2><pre><code class="java">public class SimpleRemoteControl {    Command slot;    public void setCommand(Command command) {        slot = command;    }    public void buttonWasPressed() {        slot.execute();    }}</code></pre><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><pre><code class="java">public class RemoteControTest {    public static void main(String[] args) {        SimpleRemoteControl remote = new SimpleRemoteControl();        Light light = new Light();        LightOnCommand lightOn = new LightOnCommand(light);        remote.setCommand(lightOn);        remote.buttonWasPressed();    }} /*output:on*/</code></pre><h1 id="支持撤销，多个命令实例代码"><a href="#支持撤销，多个命令实例代码" class="headerlink" title="支持撤销，多个命令实例代码"></a>支持撤销，多个命令实例代码</h1><h2 id="命令接口-1"><a href="#命令接口-1" class="headerlink" title="命令接口"></a>命令接口</h2><pre><code class="java">public interface Command {    public void execute();    public void undo(); //增加撤回功能}</code></pre><h2 id="打开电灯命令"><a href="#打开电灯命令" class="headerlink" title="打开电灯命令"></a>打开电灯命令</h2><p>电灯类不变</p><pre><code class="java">public class LightOnCommand implements Command {    Light light;    public LightOnCommand(Light light) {        this.light = light;    }    @Override    public void execute() {        light.on();    }    @Override    public void undo() {        System.out.println(&quot;undo&quot;);        light.off();    }}</code></pre><h2 id="关灯命令"><a href="#关灯命令" class="headerlink" title="关灯命令"></a>关灯命令</h2><pre><code class="java">public class LightOffCommand implements Command {    Light light;    public LightOffCommand(Light light) {        this.light = light;    }    @Override    public void execute() {        light.off();    }    @Override    public void undo() {        System.out.println(&quot;undo&quot;);        light.on();    }}</code></pre><h2 id="NoCommand"><a href="#NoCommand" class="headerlink" title="NoCommand"></a>NoCommand</h2><p>NoCommand 对象是一个空对象(null object)的例子。当你不想返回一个有意义的对象时，空对象就很有用。客户也可以将处理 null 的责任转移给空对象。举例来说，遥控器不可能一出厂就设置了有意义的命令对象，所以提供了 Nocommand 对象作为代用品，当调用它的 execute() 方法时这种对象什么事情都不做。</p><p>在许多设计模式中，都会看到空对象的使用。甚至有些时候，空对象本身也被视为是一种设计模式。</p><pre><code class="java">public class NoCommand implements Command {    @Override    public void execute() { }    @Override    public void undo() { }}</code></pre><h2 id="使用命令对象（遥控器）"><a href="#使用命令对象（遥控器）" class="headerlink" title="使用命令对象（遥控器）"></a>使用命令对象（遥控器）</h2><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20180711222545.png" alt="遥控器"></p><pre><code class="java">public class RemoteControl {    Command[] onCommands; // 多个命令    Command[] offCommands;    Command undoCommand;    public RemoteControl() {        onCommands = new Command[7];        offCommands = new Command[7];        Command noCommand = new NoCommand();        for (int i = 0; i &lt; 7; i++) {            onCommands[i] = noCommand;            offCommands[i] = noCommand;        }        undoCommand = noCommand;    }    public void setCommand(int slot, Command onCommand, Command offCommand) {        onCommands[slot] = onCommand;        offCommands[slot] = offCommand;    }    public void onButtonWasPressed(int slot) {        onCommands[slot].execute();        undoCommand = onCommands[slot];    }    public void offButtonWasPressed(int slot) {        offCommands[slot].execute();        undoCommand = offCommands[slot];    }    public void undoButtonWasPressed() {        undoCommand.undo();    }}</code></pre><h2 id="风扇（多种状态）"><a href="#风扇（多种状态）" class="headerlink" title="风扇（多种状态）"></a>风扇（多种状态）</h2><p>风速不同，多种设置。</p><pre><code class="java">public class CeilingFan {    public static final int HIGH = 3;    public static final int MEDIUM = 2;    public static final int LOW = 1;    public static final int OFF = 0;    int speed;    public CeilingFan() { speed = OFF; }    public void high() { speed = HIGH; }    public void medium() { speed = MEDIUM; }    public void low() { speed = LOW; }    public void off() { speed = OFF; }    public int getSpeed() { return speed; }}</code></pre><h2 id="风扇高档命令"><a href="#风扇高档命令" class="headerlink" title="风扇高档命令"></a>风扇高档命令</h2><p>风扇其他命令省略。</p><pre><code class="java">public class CeilingFanHighCommand implements Command {    CeilingFan ceilingFan;    int prevSpeed;    public CeilingFanHighCommand(CeilingFan ceilingFan) {        this.ceilingFan = ceilingFan;    }    @Override    public void execute() {        prevSpeed = ceilingFan.getSpeed();    }    @Override    public void undo() {        if (prevSpeed == CeilingFan.HIGH) {            ceilingFan.high();        } else if (prevSpeed == CeilingFan.MEDIUM) {            ceilingFan.medium();        } else if (prevSpeed == CeilingFan.LOW) {            ceilingFan.low();        } else if (prevSpeed == CeilingFan.OFF) {            ceilingFan.off();        }    }}</code></pre><h2 id="多个命令"><a href="#多个命令" class="headerlink" title="多个命令"></a>多个命令</h2><p>测试时可以使用两个 Command[]，一个存放 on 命令，另一个存放 off 命令。可同时执行多个命令。</p><pre><code class="java">public class MacroCommand implements Command {    Command[] commands;    public MacroCommand(Command[] commands) {        this.commands = commands;    }    @Override    public void execute() {        for (int i = 0; i &lt; commands.length; i++) {            commands[i].execute();        }    }    @Override    public void undo() {        for (int i = 0; i &lt; commands.length; i++) {            commands[i].undo();        }    }}</code></pre><h2 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h2><pre><code class="java">public class RemoteControTest {    public static void main(String[] args) {        RemoteControl remote = new RemoteControl();        Light light = new Light();        LightOnCommand lightOn = new LightOnCommand(light);        LightOffCommand lightOff = new LightOffCommand(light);        remote.setCommand(0, lightOn, lightOff);        remote.onButtonWasPressed(0);        remote.offButtonWasPressed(0);        remote.undoButtonWasPressed();    }}/*output:onoffundoon*/</code></pre><h1 id="命令模式的其他用途"><a href="#命令模式的其他用途" class="headerlink" title="命令模式的其他用途"></a>命令模式的其他用途</h1><ul><li>队列请求：有一个工作队列：你在某端添加命令，然后另一端是线程。线程进行下面的动作：从队列中取出一个命令，调用它的 execute() 方法，等待这个调用完成，然后将此命令对象丢弃，再取出下一个命令；</li><li>日志请求： 某些应用需要我们将所有的动作都记录到 日志中， 并能在系统死机后，重新调用这些动作恢复到之前的状态。how to do that? 当我们执行命令的时候，将历史记录存储在磁盘中。一旦系统死机，我们就可以将命令对象重新加载，并成批次地调用这些对象的 execute 方法；</li></ul><h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><p>命令模式的优点</p><ul><li>降低系统的耦合度。</li><li>新的命令可以很容易地加入到系统中。</li><li>可以比较容易地设计一个命令队列和宏命令（组合命令）。</li><li>可以方便地实现对请求的 Undo 和 Redo。</li></ul><p>命令模式的缺点</p><ul><li>使用命令模式可能会导致某些系统有过多的具体命令类。因为针对每一个命令都需要设计一个具体命令类，因此某些系统可能需要大量具体命令类，这将影响命令模式的使用。</li></ul><br>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Head-First-设计模式》笔记7-单例模式</title>
      <link href="/2018/07/08/%E3%80%8AHead-First-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E7%AC%94%E8%AE%B07-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/07/08/%E3%80%8AHead-First-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E7%AC%94%E8%AE%B07-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>更多请查看：<a href="/2016/05/06/Effective-Java-读书笔记03-用私有构造器或者枚举类型强化Singleton属性/">Effective-Java-读书笔记03-用私有构造器或者枚举类型强化Singleton属性</a></p><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>单例模式(Singleton Pattern)：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。</p><a id="more"></a><h1 id="饿汉式方式"><a href="#饿汉式方式" class="headerlink" title="饿汉式方式"></a>饿汉式方式</h1><pre><code class="java">//饿汉式单例public class Singleton {    private static Singleton singleton = new Singleton();    private Singleton(){}    public static Singleton getInstance(){        return singleton;    }}</code></pre><p>饿汉式是线程安全的，因为虚拟机只会装载一次，在装载类的时候不会发生并发。</p><h1 id="懒汉式方式"><a href="#懒汉式方式" class="headerlink" title="懒汉式方式"></a>懒汉式方式</h1><pre><code class="java">/** * 利用双重加锁保证只在实例化变量的时候进行同步 */public class Singleton {    private static volatile Singleton instance; // 定义静态实例变量    private Singleton(){ }    /**     * 提供全局访问点     * @return 该类的实例     */    public static Singleton getInstance(){        if(instance == null) { // 两次判空，可以只在第一次生成对象时进入同步块，提高效率            synchronized(Singleton.class) { // 进入同步块                if(instance == null) // 再次判空                    instance = new Singleton();            }        }        return instance;    }}</code></pre><blockquote><p><a href="http://www.infoq.com/cn/articles/double-checked-locking-with-delay-initialization" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/double-checked-locking-with-delay-initialization</a></p></blockquote><p>在成员变量 instance 前面加了一个 <code>volatile</code> 关键字，这个特别重要。在 Java 内存模型(JMM)中，并不限制处理器的指令顺序，说白了就是在不影响结果的情况下，顺序可能会被打乱。</p><p>在执行 instance = new Singleton(); 这条命令语句时，JMM 并不是一下就执行完毕的，即不是原子性，实质上这句命令分为三大部分：</p><blockquote style="margin-top: 1em;margin-bottom: 1em;padding: 15px 15px 15px 1rem;color: rgb(129, 145, 152);border-left-width: 6px;border-left-color: rgb(220, 230, 240);background: rgb(242, 247, 251);font-family: -webkit-body;font-style: normal;"><ol style="margin-top: 0em;margin-bottom: 0em;"><li><span>为对象分配内存</span></li><li><span>执行构造方法语句，初始化实例对象</span></li><li><span>把sInstance的引用指向分配的内存空间</span></li></ol></blockquote><p>在 JMM 中这三个步骤中的 <strong>2 和 3 不一定是顺序执行的</strong>，如果线程 A 执行的顺序为 1、3、2，在第 2 步执行完毕的时候，恰好线程 B 执行第一次判空语句，则会直接返回 instance，那么此时获取到的 instance 仅仅只是不为 null，实质上没有初始化，这样的对象肯定是有问题的！</p><p>而 volatile 关键字的存在意义就是保证了执行命令不会被重排序，也就避免了这种异常情况的发生，所以这种获取单例的方法才是真正的安全可靠！</p><h1 id="使用静态的内部类作为单例"><a href="#使用静态的内部类作为单例" class="headerlink" title="使用静态的内部类作为单例"></a>使用静态的内部类作为单例</h1><pre><code class="java">public class Singleton {    //1 私有化构造函数，内部控制创建实例的个数    private Singleton(){}    //2 定义方法为客户端提供类实例    //3 需要定义成类方法，加static    public static Singleton getIntance(){        return SingletonInstace.instance;    }    //静态的内部类作为实例，一个类的静态属性只会在第一次加载类时初始化    private static class SingletonInstace{        static Singleton instance = new Singleton();    }}</code></pre><h1 id="多个-class-loader-环境下的单件模式"><a href="#多个-class-loader-环境下的单件模式" class="headerlink" title="多个 class loader 环境下的单件模式"></a>多个 class loader 环境下的单件模式</h1><p>如果存在多个类加载器，多个类加载器可能同时加载我们的单件类，从而产生多个实例。</p><p>对于这种情况，我们可以显式指定使用哪一个 class loader 来加载单件类，这样就有效避免了上述问题。</p><br>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Head-First-设计模式》笔记6-抽象工厂模式</title>
      <link href="/2018/07/08/%E3%80%8AHead-First-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E7%AC%94%E8%AE%B06-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/07/08/%E3%80%8AHead-First-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E7%AC%94%E8%AE%B06-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。</p><p>在工厂方法模式中具体工厂负责生产具体的产品，每一个具体工厂对应一种具体产品，工厂方法也具有唯一性，一般情况下，一个具体工厂中只有一个工厂方法或者一组重载的工厂方法。但是有时候我们<strong>需要一个工厂可以提供多个产品对象，而不是单一的产品对象</strong>。</p><a id="more"></a><h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><p>现在不同的比萨连锁店需要各自配备自己独特的一组原料。</p><p>现在要做的就是：</p><ol><li>为每个区域创建一个工厂，工厂可以生产一组该区域需要的原料。</li><li>实现一组原料类供工厂使用。</li><li>将新的工厂整合进原来的 PizzaStore 类。</li></ol><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="定义一个原料工厂接口"><a href="#定义一个原料工厂接口" class="headerlink" title="定义一个原料工厂接口"></a>定义一个原料工厂接口</h2><pre><code class="java">public interface PizzaIngredientFactory {    //在接口中，每个原料都有一个对应的方法创建该原料    public Dough createDough();    public Sauce createSauce();    public Cheese createCheese();}</code></pre><h2 id="创建原料工厂"><a href="#创建原料工厂" class="headerlink" title="创建原料工厂"></a>创建原料工厂</h2><pre><code class="java">public class NYPizzaIngredientFactory implements PizzaIngredientFactory{    @Override    public Dough createDough() {        return new ThinCrustDough();    }    @Override    public Sauce createSauce() {        return new MarinaraSauce();    }    @Override    public Cheese createCheese() {        return new ReggianoCheese();    }}</code></pre><h2 id="重做披萨"><a href="#重做披萨" class="headerlink" title="重做披萨"></a>重做披萨</h2><pre><code class="java">public abstract class Pizza {    /*每个披萨都持有一组在准备时会用到的原料 */    String name;    Dough dough;    Sauce sauce;    Cheese cheese;    /**     * prepare()方法声明为抽象方法。在这个方法中，我们需要收集披萨所需要的原料，而这些原料都是来自原料工厂     */    abstract void prepare();    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public void bake(){        System.out.println(&quot;Bake for 25 minutes at 350&quot;);    }    public void cut() {        System.out.println(&quot;Cutting the pizza into diagonal slices&quot;);    }    public void box() {        System.out.println(&quot;Place pizza in official PizzaStore box&quot;);    }    public String toString(){        return &quot;&quot;;    }}</code></pre><h2 id="披萨子类"><a href="#披萨子类" class="headerlink" title="披萨子类"></a>披萨子类</h2><pre><code class="java">public class CheesePizza extends Pizza {    PizzaIngredientFactory factory;    public CheesePizza(PizzaIngredientFactory factory) {        this.factory = factory;    }    @Override    void prepare() {        System.out.println(&quot;Preparing &quot; + name);        dough = factory.createDough();        sauce = factory.createSauce();        cheese = factory.createCheese();    }}</code></pre><h2 id="披萨店子类"><a href="#披萨店子类" class="headerlink" title="披萨店子类"></a>披萨店子类</h2><pre><code class="java">public class NYPizzaStore extends PizzaStore {    @Override    public Pizza createPizza(String type) {        Pizza pizza = null;        PizzaIngredientFactory factory = new NYPizzaIngredientFactory();        if (type.equals(&quot;cheese&quot;)) {            pizza = new CheesePizza(factory);            pizza.setName(&quot;NY Style Cheese Pizza&quot;);        }        return pizza;    }}</code></pre><h1 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h1><p>抽象工厂模式包含如下角色：</p><p>AbstractFactory：抽象工厂<br>ConcreteFactory：具体工厂<br>AbstractProduct：抽象产品<br>Product：具体产品</p><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/AbatractFactory.jpg" alt=""></p><h1 id="工厂方法和抽象工厂区别"><a href="#工厂方法和抽象工厂区别" class="headerlink" title="工厂方法和抽象工厂区别"></a>工厂方法和抽象工厂区别</h1><p>工厂方法的最大特点在于工厂接口只有一个工厂方法，具体产品的创建延迟到子类实现，客户端只需要知道获取了一个工厂对象，具体产品并不知道，实现客户端和具体产品的解耦。</p><p>而抽象工厂可以看做是工厂方法的升级版本，因为工厂方法可以看做生产一个产品等级的，抽象工厂则是生产不同产品等级的相关联的系列产品。但是正因为此，抽象工厂的缺点在于当向系列产品添加新的产品要修改抽象工厂的方法，这违背开放 -- 关闭原则的，而工厂方法若是添加新的产品只要扩展新的工厂类就可以了。</p><p>当抽象工厂模式中每一个具体工厂类只创建一个产品对象，也就是只存在一个产品等级结构时，抽象工厂模式<strong>退化</strong>成工厂方法模式；当工厂方法模式中抽象工厂与具体工厂合并，提供一个统一的工厂来创建产品对象，并将创建对象的工厂方法设计为静态方法时，工厂方法模式退化成简单工厂模式。</p><h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><p>优点</p><ul><li>抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易。所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。另外，应用抽象工厂模式可以实现高内聚低耦合的设计目的，因此抽象工厂模式得到了广泛的应用。</li><li>当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。这对一些需要根据当前环境来决定其行为的软件系统来说，是一种非常实用的设计模式。</li><li>增加新的具体工厂和产品族很方便，无须修改已有系统，符合“开闭原则”（结合缺点看）。</li></ul><p>缺点</p><ul><li>在添加新的产品对象时，难以扩展抽象工厂来生产新种类的产品，这是因为在抽象工厂角色中规定了所有可能被创建的产品集合，要支持新种类的产品就意味着要对该接口进行扩展，而这将涉及到对抽象工厂角色及其所有子类的修改，显然会带来较大的不便。</li><li>开闭原则的倾斜性（增加新的工厂和产品族容易，增加新的产品等级结构麻烦）。</li></ul><h2 id="“开闭原则”的倾斜性"><a href="#“开闭原则”的倾斜性" class="headerlink" title="“开闭原则”的倾斜性"></a>“开闭原则”的倾斜性</h2><p>“开闭原则”要求系统对扩展开放，对修改封闭，通过扩展达到增强其功能的目的。对于涉及到多个产品族与多个产品等级结构的系统，其功能增强包括两方面：</p><ul><li>增加产品族：对于增加新的产品族，工厂方法模式很好的支持了“开闭原则”，对于新增加的产品族，只需要对应增加一个新的具体工厂即可，对已有代码无须做任何修改。</li><li>增加新的产品等级结构：对于增加新的产品等级结构，需要修改所有的工厂角色，包括抽象工厂类，在所有的工厂类中都需要增加生产新产品的方法，不能很好地支持“开闭原则”。</li></ul><p>抽象工厂模式的这种性质称为“开闭原则”的倾斜性，抽象工厂模式以一种倾斜的方式支持增加新的产品，它为新产品族的增加提供方便，但不能为新的产品等级结构的增加提供这样的方便。</p><br>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Head-First-设计模式》笔记5-工厂方法模式</title>
      <link href="/2018/07/08/%E3%80%8AHead-First-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E7%AC%94%E8%AE%B05-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/07/08/%E3%80%8AHead-First-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E7%AC%94%E8%AE%B05-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>工厂方法模式定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。</p><p>现在对该系统进行修改，不再设计一个披萨工厂类来统一负责所有产品的创建，而是将具体披萨的创建过程交给专门的工厂子类（不同的加盟店）去完成，我们先定义一个抽象的披萨工厂类，再定义具体的工厂类来生成不同的披萨，它们实现在抽象披萨工厂类中定义的方法。这种抽象化的结果使这种结构可以在不修改具体工厂类的情况下引进新的产品，如果出现新的披萨类型，只需要为这种新类型的披萨创建一个具体的工厂类就可以获得该新披萨的实例，这一特点无疑使得工厂方法模式具有超越简单工厂模式的优越性，更加符合“开闭原则”。</p><a id="more"></a><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="改造后的-PizzaStore-的代码"><a href="#改造后的-PizzaStore-的代码" class="headerlink" title="改造后的 PizzaStore 的代码"></a>改造后的 PizzaStore 的代码</h2><pre><code class="java">public abstract class PizzaStore {    public Pizza orderPizza(String type) {        Pizza pizza = createPizza(type);        pizza.prepare();        pizza.bake();        pizza.cut();        pizza.box();        return pizza;    }    abstract Pizza createPizza(String type); // 允许子类做决定}</code></pre><h2 id="子类"><a href="#子类" class="headerlink" title="子类"></a>子类</h2><pre><code class="java">public class NYPizzaSrore extends PizzaStore {    @Override    Pizza createPizza(String type) {        if (type.equals(&quot;cheese&quot;)) {            return new CheesePizza();        } else if (type.equals(&quot;greek&quot;)) {            return new GreekPizza();        }        return null;    }}</code></pre><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><pre><code class="java">PizzaStore nyStore = new NYPizzaSrore();Pizza pizza = nyStore.orderPizza(&quot;cheese&quot;);</code></pre><h1 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h1><p>工厂方法模式包含如下角色：</p><ul><li>Product：抽象产品</li><li>ConcreteProduct：具体产品</li><li>Factory：抽象工厂</li><li>ConcreteFactory：具体工厂</li></ul><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/FactoryMethod.jpg" alt=""></p><h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><p>工厂方法模式的优点</p><ul><li>在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。</li><li>基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，是因为所有的具体工厂类都具有同一抽象父类。</li><li>使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了。这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。</li></ul><p>工厂方法模式的缺点</p><ul><li>在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。</li><li>由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。</li></ul><h1 id="工厂方法和简单工厂的区别"><a href="#工厂方法和简单工厂的区别" class="headerlink" title="工厂方法和简单工厂的区别"></a>工厂方法和简单工厂的区别</h1><ol><li>Factory Method 的核心是一个抽象工厂类，而 Simple Factory 把核心放在一个具体类上。</li><li>Factory Method 的具体工厂类都有共同的接口，或者有共同的抽象父类。</li><li>当系统扩展需要添加新的产品对象时，Factory Method仅仅需要添加一个具体对象以及一个具体工厂对象，原有工厂对象不需要进行任何修改，也不需要修改客户端，很好的符合了“开放－封闭”原则。而 Simple Factory 在添加新产品对象后不得不修改工厂方法，扩展性不好。</li></ol><h1 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h1><p>要依赖抽象，不要依赖具体类。</p><p>不要让“高层组件”依赖“低层组件”，而且，不管“高层组件”还是“低层组件”，两者都应该依赖于抽象。</p><p>上述例子中的披萨店是 高层组件，具体的披萨是底层组件，而比萨店是抽象的，北京加盟店是具体的；而比萨是抽象的，北京糖味披萨是具体的；</p><p>避免违反该原则的几个方针：</p><ol><li>变量不可以持有具体类的引用。<br>如果使用new，就会持有具体类的引用，可以使用工厂来避开这种引用。</li><li>不要让类派生自具体类。<br>如果派生自具体类，就会依赖具体类，可以派生自抽象或接口。</li><li>不要覆盖基类中已实现的方法。<br>如果覆盖基类中已实现的方法，那么基类就不是一个真正适合被继承的类。基类中已实现的方法应该被所有子类所共享。</li></ol><p>依赖倒置原则，究竟倒置在哪里？ 比较下面两幅图，你会注意到底层组件依赖现在依赖高层组件，而高层组件也依赖于相同的抽象 Pizza 类；</p><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20180708222954.png" alt=""></p><br>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Head-First-设计模式》笔记4-简单工厂模式</title>
      <link href="/2018/07/08/%E3%80%8AHead-First-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E7%AC%94%E8%AE%B04-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/07/08/%E3%80%8AHead-First-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E7%AC%94%E8%AE%B04-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式（使用静态方法，不能通过继承来改变创建方法的行为），它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。</p><p>简单工厂模式其实不是一个设计模式，反而比较像是一种编程习惯。但由于经常被使用，有些开发人员的确是把这个编程习惯误认为是 “工厂模式”。</p><a id="more"></a><h1 id="识别变化的方面"><a href="#识别变化的方面" class="headerlink" title="识别变化的方面"></a>识别变化的方面</h1><p>假如你有一个比萨店，你的比萨订购系统会这样写代码：</p><pre><code class="java">Pizza orderPizza(String type){    Pizza pizza = new Pizza();    pizza.prepare();    pizza.bake();    pizza.cut();    pizza.box();    return pizza;}</code></pre><h1 id="需要更多披萨类型"><a href="#需要更多披萨类型" class="headerlink" title="需要更多披萨类型"></a>需要更多披萨类型</h1><pre><code class="java">Pizza orderPizza(String type){    Pizza pizza = new Pizza();    if(type.equals(&quot;cheese&quot;)){        pizza = new CheesePizza();    }else if (type.equals(&quot;greek&quot;)){        pizza = new GreekPizza();    }    pizza.prepare();    pizza.bake();    pizza.cut();    pizza.box();    return pizza;}</code></pre><p>由于披萨的种类在变，根据第一条原则，可能变化的要封装起来，我们将变化的这段抽取出来：</p><pre><code class="java">if(type.equals(&quot;cheese&quot;)){    pizza = new CheesePizza();}else if (type.equals(&quot;greek&quot;)){    pizza = new GreekPizza();}</code></pre><h1 id="简单工厂模式实现"><a href="#简单工厂模式实现" class="headerlink" title="简单工厂模式实现"></a>简单工厂模式实现</h1><pre><code class="java">public class SimplePizzaFactory {    public Pizza createPizza(String type){        Pizza pizza = null;        if(type.equals(&quot;cheese&quot;)){            pizza = new CheesePizza();        }else if (type.equals(&quot;greek&quot;)){            pizza = new GreekPizza();        }        return pizza;    }}</code></pre><p>重做 PizzaStore 类</p><pre><code class="java">public class PizzaStore {    SimplePizzaFactory factory;    public PizzaStore (SimplePizzaFactory factory){        this.factory = factory;    }    public Pizza orderPizza(String type){        Pizza pizza = factory.createPizza(type);        pizza.prepare();        pizza.bake();        pizza.cut();        pizza.box();        return pizza;    }}</code></pre><h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><blockquote><p><a href="http://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/simple_factory.html#id9" target="_blank" rel="noopener">http://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/simple_factory.html#id9</a></p></blockquote><p>简单工厂模式的优点</p><ul><li>工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的责任，而仅仅“消费”产品；简单工厂模式通过这种做法实现了对责任的分割，它提供了专门的工厂类用于创建对象。</li><li>客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以减少使用者的记忆量。</li><li>通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。</li></ul><p>简单工厂模式的缺点</p><ul><li>由于工厂类集中了所有产品创建逻辑，一旦不能正常工作，整个系统都要受到影响。</li><li>使用简单工厂模式将会增加系统中类的个数，在一定程序上增加了系统的复杂度和理解难度。</li><li>系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。</li><li>简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。（可以不使用静态）。</li></ul><h1 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h1><ul><li>工厂类负责创建的对象比较少：由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。</li><li>客户端只知道传入工厂类的参数，对于如何创建对象不关心：客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数。</li></ul><br>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Head-First-设计模式》笔记3-装饰者模式</title>
      <link href="/2018/07/08/%E3%80%8AHead-First-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E7%AC%94%E8%AE%B03-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/07/08/%E3%80%8AHead-First-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E7%AC%94%E8%AE%B03-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>装饰者模式动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。</p><h1 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h1><p>下面我们以星巴兹（Starbuzz）的订单系统为例加以说明。</p><p>需求分析：</p><ol><li>星巴兹的饮料（Beverage）种类繁多，主要有 HouseBlend、DarkRoast、Decaf、Espresso。</li><li>星巴兹的调料很多，主要有 Steamed Milk、Soy、Mocha、Whip。</li><li>星巴兹的饮料价格是根据饮料的基础价和所加入的调料的价格相加得到。</li></ol><p>原先的设计：</p><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20180708133523.png" alt=""></p><a id="more"></a><h1 id="错误设计"><a href="#错误设计" class="headerlink" title="错误设计"></a>错误设计</h1><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20180708132911.png" alt="简直是“类爆炸”"></p><h1 id="另一种错误设计"><a href="#另一种错误设计" class="headerlink" title="另一种错误设计"></a>另一种错误设计</h1><p>新方案必须避免“类爆炸”。此时我们想到了实例变量和继承。</p><p>先从 Beverage 基类下手，加上实例变量代表是否加上调料（Steamed Milk、Soy、Mocha、Whip等），Beverage 基类的 cost() 计算调料的价钱，而各种具体的饮料（HouseBlend、DarkRoast、Decaf、Espresso等）的 cost() 将把基础饮料的价钱和调料的价钱相加得到饮料的价钱。由此可以设计出第二种类图。</p><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20180708133613.png" alt=""></p><p>对这个类图设计的评价：如果需求不再变化，那么这个类图设计没有错；但是需求发生了变化，这个设计就会难以招架。经过进一步的分析，我们发现部分需求被我们遗漏了。</p><p>新增加的需求：</p><ol><li>调料的价格可能发生变化。</li><li>调料的种类可能发生变化。</li><li>饮料的种类可能增加，不只 HouseBlend、DarkRoast、Decaf、Espresso 四种。</li><li>顾客可能在一种饮料里加双份的同种饮料。</li></ol><h1 id="开放-关闭原则"><a href="#开放-关闭原则" class="headerlink" title="开放-关闭原则"></a>开放-关闭原则</h1><p>类应该对扩展开放，对修改关闭。</p><p>每个地方都采用开放-关闭原则，是一种浪费，还会导致代码变得复杂且难以理解。</p><h1 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h1><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20180708134636.png" alt=""></p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol><li>装饰者和被装饰对象有相同的超类型。</li><li>你可以用一个或多个装饰者包装一个对象。</li><li>既然装饰者和被装饰对象有相同的超类型，所以在任何需要原始对象（被包装的）的场合，可以用装饰过的对象代替它。</li><li>装饰者可以在所委托被装饰者的行为之前与 / 或之后，加上自己的行为，以达到特定的目的。</li><li>对象可以在任何时候被装饰，所以可以在运行时动态地、不限量地用你喜欢的装饰者来装饰对象。</li></ol><h2 id="咖啡例子"><a href="#咖啡例子" class="headerlink" title="咖啡例子"></a>咖啡例子</h2><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20180708135204.png" alt=""></p><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20180708135354.png" alt=""></p><p>这里为什么没把 Beverage 类设计成一个接口，而是设计成了抽象类？</p><p>因为一开始 Beverage 就是一个抽象类，<strong>通常装饰者模式是采用抽象类，但是在 Java 中可以使用接口</strong>。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Beverage 类，不需要需改原始设计。</p><pre><code class="java">public abstract class Beverage {    String description = &quot;Unknown Beverage&quot;;    public String getDescription() {        return description;    }    public abstract double cost();}</code></pre><p>CondimentDecorator 装饰者类</p><pre><code class="java">public abstract class CondimentDecorator extends Beverage {    public abstract String getDescription(); // 必须重新实现该方法，可以打印出是被哪个装饰者装饰了。}</code></pre><p>饮料的代码</p><pre><code class="java">public class Espresso extends Beverage {    public Espresso(){        description = &quot;Espresso&quot;;    }    @Override    public double cost() {        return 1.99;    }}</code></pre><p>调料代码</p><pre><code class="java">public class Mocha extends CondimentDecorator {    Beverage beverage;    public Mocha(Beverage beverage){        this.beverage = beverage;    }    @Override    public String getDescription() {        return beverage.getDescription() + &quot;, Mocha&quot;;    }    @Override    public double cost() {        return .20 + beverage.cost();    }}</code></pre><p>测试代码，供应咖啡</p><pre><code class="java">public class StarBuzzCoffee {    public static void main(String[] args) {        Beverage beverage = new Espresso(); //普通咖啡        System.out.println(beverage.getDescription() + &quot; $&quot; + beverage.cost());        Beverage beverage2 = new Mocha(beverage); // 加了两份 Mocha 的咖啡        beverage2 = new Mocha(beverage2);        System.out.println(beverage2.getDescription() + &quot; $&quot; + beverage2.cost());    }}/* output:Espresso $1.99Espresso, Mocha, Mocha $2.39*/</code></pre><h2 id="需求扩展"><a href="#需求扩展" class="headerlink" title="需求扩展"></a>需求扩展</h2><p>那如果我们这时产生了新的需求，要求在菜单上加上咖啡的容量的大小，供顾客选择大杯，小杯，中杯，那该怎么办？要注意，大杯的饮料比较贵，同时它加的调料也要比较多，所以调料的价格也不一样。</p><p>这时我们应该在 Beverage 中定义 size 和g etSize() 的函数，并且在四种饮料中要根据 size 的大小，cost() 函数要返回不同的价格。</p><p>在调料中，我们也需要获取被装饰者的 size，然后 cost 函数加上对应调料的价格。</p><p>Beverage 类</p><pre><code class="java">public abstract class Beverage {    String description = &quot;Unknown Beverage&quot;;    public final static int TALL = 0; //小杯    public final static int GRANDE = 1; //中杯    public final static int VENTI = 2; //大杯    protected int size = TALL; //咖啡的大小（大/中/小杯）    public int getSize() {        return size;    }    public void setSize(int size){        this.size = size;    }    /**     * 返回咖啡的种类和杯子大小     */    public String getDescription() {        switch (size) {            case Beverage.VENTI:                return &quot;venti &quot; + description;            case Beverage.GRANDE:                return &quot;grande &quot; + description;            case Beverage.TALL:                return &quot;tall &quot; + description;            default:                return description;        }    }    public abstract double cost();}</code></pre><p>装饰类</p><pre><code class="java">public class Soy extends CondimentDecorator {    Beverage beverage;    public Soy(Beverage beverage) {        this.beverage = beverage;    }    @Override    public int getSize() {        return beverage.getSize();    }    @Override    public String getDescription() {        return beverage.getDescription() + &quot;, Soy&quot;;    }    @Override    public double cost() {        double cost = beverage.cost();        if (getSize() == Beverage.TALL) {            cost += .1;        } else if (getSize() == Beverage.GRANDE) {            cost += .15;        } else if (getSize() == Beverage.VENTI) {            cost += .2;        }        return cost;    }}</code></pre><h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><blockquote><p><a href="http://design-patterns.readthedocs.io/zh_CN/latest/structural_patterns/decorator.html#id10" target="_blank" rel="noopener">http://design-patterns.readthedocs.io/zh_CN/latest/structural_patterns/decorator.html#id10</a></p></blockquote><p>装饰模式的优点:</p><ul><li>装饰模式与继承关系的目的都是要扩展对象的功能，但是装饰模式可以提供比继承更多的灵活性。</li><li>可以通过一种动态的方式来扩展一个对象的功能，通过配置文件可以在运行时选择不同的装饰器，从而实现不同的行为。</li><li>通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合。可以使用多个具体装饰类来装饰同一对象，得到功能更为强大的对象。</li><li>具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，在使用时再对其进行组合，原有代码无须改变，符合“开闭原则”</li></ul><p>装饰模式的缺点:</p><ul><li>使用装饰模式进行系统设计时将产生很多小对象，这些对象的区别在于它们之间相互连接的方式有所不同，而不是它们的类或者属性值有所不同，同时还将产生很多具体装饰类。这些装饰类和小对象的产生将增加系统的复杂度，加大学习与理解的难度。</li><li>这种比继承更加灵活机动的特性，也同时意味着装饰模式比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐。</li></ul><br>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Head-First-设计模式》笔记2-观察者模式</title>
      <link href="/2018/07/07/%E3%80%8AHead-First-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E7%AC%94%E8%AE%B02-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/07/07/%E3%80%8AHead-First-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E7%AC%94%E8%AE%B02-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>先来看个报纸和杂志的订阅是怎么回事：</p><ol><li>报社的业务就是出版报纸</li><li>向某家报社订阅报纸，只有新报纸出版，报社才会送给你，只要你是用户，他就会一直向你发送。</li><li>当你不向看报纸了，取消订阅，他们就不会发送报纸。</li><li>只要报社还在运营，就会有人订阅报纸或取消报纸订阅</li></ol><p>其实这个过程就和我们的观察者模式的过程相似。所以我们可以简单的将观察者模式定义为：<code>出版社 + 订阅者 = 观察者模式</code></p><p>正式的定义：</p><blockquote><p>观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象改变时，它的所有依赖都会收到通知并自动更新。</p></blockquote><a id="more"></a><h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><p>一个天气信息类，当天气信息发生变化是，会自动运行 update() 函数，此时，需要及时更新当前信息版，和未来预测版。</p><h1 id="一个错误示范"><a href="#一个错误示范" class="headerlink" title="一个错误示范"></a>一个错误示范</h1><pre><code class="java">public class WrongWeatherData {    public void measurementsChanged() {        float temp = getTemperature();        float humidity = getHumidity();        float pressure = getPressure();        // 更新操作        currentConditionsDisplay.update(temp, humidity, pressure);    }}</code></pre><p>存在的问题：</p><ol><li>它针对实现编程，没有针对接口，这样导致每次增加布告板都要修改里面的代码。</li><li>可能改变的地方没有封装起来（三个更新方法直接在 measurementsChanged() 中）。</li><li>这样根本不可能在运行时动态添加删除一些布告板。</li></ol><h1 id="观察者模式：类图"><a href="#观察者模式：类图" class="headerlink" title="观察者模式：类图"></a>观察者模式：类图</h1><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20180707172020.png" alt="观察者模式：类图"></p><h1 id="松耦合"><a href="#松耦合" class="headerlink" title="松耦合"></a>松耦合</h1><p>当两个对象之间松耦合，它们依然可以交互，但是不太清楚彼此的细节。</p><p>观察者模式提供了一种对象设计，让主题和观察者之间松耦合。</p><p>任何时候我们都可以增加新的观察者。因为主题唯一依赖的东西是一个实现 Observer 接口的对象列表，所以我们可以随时增加观察者。事实上，在运行时我们可以用新的观察者取代现有的观察者，主题不会受到任何影响。同样的，也可以在任何时候删除某些观察者。</p><p>有新类型的观察者出现时，主题的代码不需要修改。假如我们有个新的具体类需要当观察者，我们不需要为了兼容新类型而修改主题的代码，所有要做的就是在新的类里实现此观察者接口，然后注册为观察者即可。主题不在乎别的，它只会发送通知给所有实现了观察者接口的对象。</p><blockquote><p>设计原则：为了交互对象之间的松耦合设计而努力。</p></blockquote><p>松耦合的设计之所以能让我们建立有弹性的 OO 系统，能够应对变化，是因为对象之间的互相依赖降到了最低。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="实现气象站，建立接口"><a href="#实现气象站，建立接口" class="headerlink" title="实现气象站，建立接口"></a>实现气象站，建立接口</h2><pre><code class="java">public interface Subject {    public void registerObserver(Observer o);    public void removeObserver(Observer o);    public void notifyObservers();}public interface Observer {    public void update(float temp, float humidity, float pressure);}/** * 布告栏公共接口 */public interface DisplayElement {    // 当布告栏需要显示时调用    public void display();}</code></pre><h2 id="在-WeatherData-中实现主题接口"><a href="#在-WeatherData-中实现主题接口" class="headerlink" title="在 WeatherData 中实现主题接口"></a>在 WeatherData 中实现主题接口</h2><pre><code class="java">public class WeatherData implements Subject {    private ArrayList observers; // 记录观察者    private float temperature;    private float humidity;    private float pressure;    public WeatherData() {        observers = new ArrayList&lt;Observer&gt;();    }    // 设置测量值，并通知观察者.    public void setMeasurements(float temp, float humidity, float pressure) {        this.temperature = temp;        this.humidity = humidity;        this.pressure = pressure;        measurementsChanged();    }    // 当从气象站得到更新观测值时，我们通知观察者.    public void measurementsChanged() {        notifyObservers();    }    @Override    public void notifyObservers() {        // 通知观察者        for (int i = 0; i &lt; observers.size(); i++) {            Observer observer = (Observer) observers.get(i);            observer.update(temperature, humidity, pressure);        }    }    @Override    public void registerObserver(Observer o) {        observers.add(o); // 注册观察者    }    @Override    public void removeObserver(Observer o) {        int i = observers.indexOf(o);        if (i &gt;= 0) {            observers.remove(i); // 取消注册        }    }}</code></pre><h2 id="建立布告板"><a href="#建立布告板" class="headerlink" title="建立布告板"></a>建立布告板</h2><pre><code class="java">public class CurrentDisplay implements Observer, DisplayElement {    private float temperature;    private float humidity;    private float pressure;    private Subject weatherData;    public CurrentDisplay(Subject weatherData) {        this.weatherData = weatherData;        weatherData.registerObserver(this);    }    // 当update() 被调用时，我们把温度和湿度保存起来，然后调用display。    @Override    public void update(float temp, float humidity, float pressure) {        this.temperature = temp;        this.humidity = humidity;        this.pressure = pressure;        display();    }    @Override    public void display() {        System.out.println(&quot;current contions: temperature is &quot; + temperature                + &quot;, humidity is &quot; + humidity + &quot;, pressure is &quot; + pressure);    }}</code></pre><h2 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h2><pre><code class="java">public class WeatherStation {    public static void main(String[] args) {        WeatherData data = new WeatherData();        CurrentDisplay display = new CurrentDisplay(data);        data.setMeasurements(1, 23, 30.4f);    }}/* output:current contions: temperature is 1.0, humidity is 23.0, pressure is 30.4*/</code></pre><h1 id="推（push），拉（pull）"><a href="#推（push），拉（pull）" class="headerlink" title="推（push），拉（pull）"></a>推（push），拉（pull）</h1><p>上述的观察者模式，由 subject 主动送出自己的状态通知给观察者，推（push）。</p><p>subject 提供一些公开的 getter 方法，观察者 “拉（pull）”走自己需要的状态。这样如果以后新增了更多的状态，就不用修改 subject 对 观察者的调用。</p><h1 id="Java-内置的的观察者模式"><a href="#Java-内置的的观察者模式" class="headerlink" title="Java 内置的的观察者模式"></a>Java 内置的的观察者模式</h1><p>java.util 包内包含最基本的 Observer 接口和 Observable 类，你甚至可以使用 推（push）或拉（pull）的方式传送数据。</p><h2 id="Java-内置观察者模式的类图结构"><a href="#Java-内置观察者模式的类图结构" class="headerlink" title="Java 内置观察者模式的类图结构"></a>Java 内置观察者模式的类图结构</h2><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20180707183622.png" alt="Java 内置观察者模式的类图结构"></p><h2 id="Observable-类"><a href="#Observable-类" class="headerlink" title="Observable 类"></a>Observable 类</h2><ul><li><code>void addObserver(Observer o)</code>：如果观察者与集合中已有的观察者不同，则向对象的观察者集中添加此观察者。</li><li><code>protected  void clearChanged()</code>：指示对象不再改变，或者它已对其所有的观察者通知了最近的改变，所以 hasChanged 方法将返回 false。</li><li><code>int countObservers()</code>：返回 Observable 对象的观察者数目。</li><li><code>void deleteObserver(Observer o)</code>：从对象的观察者集合中删除某个观察者。</li><li><code>void deleteObservers()</code>：清除观察者列表，使此对象不再有任何观察者。</li><li><code>boolean hasChanged()</code>：测试对象是否改变。</li><li><code>void notifyObservers()</code>：如果 hasChanged 方法指示对象已改变，则通知其所有观察者，并调用 clearChanged 方法来指示此对象不再改变。</li><li><code>void notifyObservers(Object arg)</code>：如果 hasChanged 方法指示对象已改变，则通知其所有观察者，并调用 clearChanged 方法来指示此对象不再改变。</li><li><code>protected  void setChanged()</code>：标记此 Observable 对象为已改变的对象；现在 hasChanged 方法将返回 true。</li></ul><h2 id="内置的代码实现"><a href="#内置的代码实现" class="headerlink" title="内置的代码实现"></a>内置的代码实现</h2><h3 id="WeatherData"><a href="#WeatherData" class="headerlink" title="WeatherData"></a>WeatherData</h3><pre><code class="java">public class WeatherData extends Observable {    private float temperature;    private float humidity;    private float pressure;    public WeatherData() {    }    public void measurementsChanged() {        setChanged(); // 标记此 Observable 对象为已改变的对象        notifyObservers();    }    public void setMeasurements(float temp, float humidity, float pressure) {        this.temperature = temp;        this.humidity = humidity;        this.pressure = pressure;        measurementsChanged();    }    public float getTemperature() {        return temperature;    }    public float getHumidity() {        return humidity;    }    public float getPressure() {        return pressure;    }}</code></pre><h3 id="重建布告栏"><a href="#重建布告栏" class="headerlink" title="重建布告栏"></a>重建布告栏</h3><pre><code class="java">public class CurrentDisplay implements Observer, DisplayElement {    private float temperature;    private float humidity;    Observable observable;    public CurrentDisplay(Observable observable) {        this.observable = observable;        observable.addObserver(this);    }    @Override    public void update(Observable obs, Object arg) {        if (obs instanceof WeatherData) {            WeatherData weatherData = (WeatherData) obs;            this.temperature = weatherData.getTemperature();            this.humidity = weatherData.getHumidity();            display();        }    }    @Override    public void display() {        System.out.println(&quot;current contions: temperature is &quot; + temperature + &quot;, humidity is &quot; + humidity);    }}</code></pre><h2 id="java-util-Observable-存在的问题"><a href="#java-util-Observable-存在的问题" class="headerlink" title="java.util.Observable 存在的问题"></a>java.util.Observable 存在的问题</h2><ol><li>Observable 是一个类</li><li>Observable 将关键的方法保护起来了，这样就只能继承 Observable，违反了第二个设计原则：“多用组合，少用继承”。</li><li>notifyObservers 方法中调用 update 时，查看源码得知：</li></ol><pre><code class="java">for (int i = arrLocal.length-1; i&gt;=0; i--)    ((Observer)arrLocal[i]).update(this, arg);</code></pre><p>在循环遍历观察者让观察者做出响应时，如果在这过程中有一个 update 方法抛出了异常，那么剩下还未通知的观察者就全都通知不到了。所以在 观察者中的 update 方法整个加上 try 块，或者确认不会发生运行时异常。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>观察者模式，可以从被观察者处推（push）或拉（pull）数据（推的方式被认为更“正确”）。</p><p>有多个观察者时，不可以依赖特定的通知次序。</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><blockquote><p><a href="http://design-patterns.readthedocs.io/zh_CN/latest/behavioral_patterns/observer.html#id10" target="_blank" rel="noopener">http://design-patterns.readthedocs.io/zh_CN/latest/behavioral_patterns/observer.html#id10</a></p></blockquote><p>优点</p><ul><li>观察者模式可以实现表示层和数据逻辑层的分离，并定义了稳定的消息更新传递机制，抽象了更新接口，使得可以有各种各样不同的表示层作为具体观察者角色。</li><li>观察者模式在观察目标和观察者之间建立一个抽象的耦合。</li><li>观察者模式支持广播通信。</li><li>观察者模式符合“开闭原则”的要求。</li></ul><p>缺点</p><ul><li>如果一个观察目标对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。</li><li>如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。</li><li>观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</li></ul><br>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Head First 设计模式》笔记1-策略模式</title>
      <link href="/2018/06/25/%E3%80%8AHead-First-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E7%AC%94%E8%AE%B01-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/06/25/%E3%80%8AHead-First-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E7%AC%94%E8%AE%B01-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>策略模式定义了算法族，分别封装起来，让它们之间可以互换替换，此模式让算法的变化独立使用算法的客户。</p><h1 id="书中鸭子的例子"><a href="#书中鸭子的例子" class="headerlink" title="书中鸭子的例子"></a>书中鸭子的例子</h1><h2 id="使用继承的方法"><a href="#使用继承的方法" class="headerlink" title="使用继承的方法"></a>使用继承的方法</h2><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20180625234745.png" alt="使用继承"></p><p>如果有新的需求，需要实现 fly() 方法，使用继承的方法会在 Duck 中加入 fly() 方法，不过并不是所有的鸭子都会飞，比如橡皮鸭子；这会导致下列缺点：</p><ol><li>代码在多个子类中重复；</li><li>运行时的行为不容易改变；</li><li>很难知道所有鸭子的全部行为；</li><li>改变会牵一发而动全身，造成其他鸭子不想要的改变；</li></ol><a id="more"></a><h2 id="利用接口实现"><a href="#利用接口实现" class="headerlink" title="利用接口实现"></a>利用接口实现</h2><p>这将导致一个问题，虽然 Flyable 和 Quackable 可以解决问题，但是代码不能复用；</p><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20180625235356.png" alt="利用接口实现"></p><h1 id="使用策略模式"><a href="#使用策略模式" class="headerlink" title="使用策略模式"></a>使用策略模式</h1><p>分类变化的部分：将 fly 和 quack 的动作从基类 Duck 中分离出来。</p><p>利用接口代替每个行为：定义 FlyBehavior 与 QuackBehavior 行为接口，鸭子类并不实现这些接口，是由我们创造一组其他类专门实现 FlyBehavior 与 QuackBehavior。</p><p>这样的设计，可以让各种 fly 和 quack 的动作被其他的对象复用，并且新增行为也不会影响到既有行为。</p><p><strong>QuackBehavior 接口</strong></p><pre><code class="java">interface QuackBehavior {    void quack();}</code></pre><p><strong>FlyBehavior接口</strong></p><pre><code class="java">interface FlyBehavior {    void fly();}</code></pre><p><strong>QuackBehavior 具体行为</strong></p><pre><code class="java">public class MuteQuack implements QuackBehavior {    public void quack() {        System.out.println(&quot;Silence&quot;);    }}public class Gua implements QuackBehavior {    public void quack() {        System.out.println(&quot;Gua Gua Gua~~&quot;);    }}</code></pre><p><strong>FlyBehavior 具体行为</strong></p><pre><code class="java">public class FlyWithWings implements FlyBehavior {    public void fly() {        System.out.println(&quot;fly fly fly~~~&quot;);    }}public class FlyNoWay implements FlyBehavior {    public void fly() {        // do nothing    }}</code></pre><p>现在鸭子会将飞行和呱呱叫的动作“委托”给 FlyBehavior 和 QuackBehavior 处理，我们在 Duck 中增加两个方法 <code>performFly()</code>，<code>performQuack()</code></p><pre><code class="java">public abstract class Duck {    Duck() {}    public FlyBehavior flyBehavior;    public QuackBehavior quackBehavior;    public abstract void display();    public void swim() {        System.out.println(&quot;all ducks can swim&quot;);    }    public void performFly() {        flyBehavior.fly();    }    public void performQuack() {        quackBehavior.quack();    }}</code></pre><p>在每种鸭子继承超类 Duck 的时候，只需要在构造函数中设置对应的 FlyBehavior 和 QuackBehavior 实例变量即可。如果需要动态的修改，只需要在 Duck 中 setter 方法即可。</p><pre><code class="java">public class RedHeadDuck extends Duck {    RedHeadDuck() {        quackBehavior = new Gua();        flyBehavior = new FlyWithWings();    }    @Override    public void display() {        System.out.println(&quot;This is RedHeadDuck&quot;);    }    public void performFly() {        flyBehavior.fly();    }    public void performQuack() {        quackBehavior.quack();    }}</code></pre><h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><p><a href="http://www.cnblogs.com/wolf-sun/p/3534573.html" target="_blank" rel="noopener">http://www.cnblogs.com/wolf-sun/p/3534573.html</a></p><p>优点：</p><ol><li>策略模式提供了管理相关的算法族的办法。策略类的等级结构定义了一个算法或行为族。恰当使用继承可以把公共的代码转移到父类里面，从而避免重复的代码。</li><li>策略模式提供了可以替换继承关系的办法。继承可以处理多种算法或行为。如果不是用策略模式，那么使用算法或行为的环境类就可能会有一些子类，每一个子类提供一个不同的算法或行为。但是，这样一来算法或行为的使用者就和算法或行为本身混在一起。决定使用哪一种算法或采取哪一种行为的逻辑就和算法或行为的逻辑混合在一起，从而不可能再独立演化。继承使得动态改变算法或行为变得不可能。</li><li>使用策略模式可以避免使用多重条件转移语句。多重转移语句不易维护，它把采取哪一种算法或采取哪一种行为的逻辑与算法或行为的逻辑混合在一起，统统列在一个多重转移语句里面，比使用继承的办法还要原始和落后。</li></ol><p>缺点：</p><ol><li>客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。换言之，策略模式只适用于客户端知道所有的算法或行为的情况。</li><li>策略模式造成很多的策略类，每个具体策略类都会产生一个新类。有时候可以通过把依赖于环境的状态保存到客户端里面，而将策略类设计成可共享的，这样策略类实例可以被不同客户端使用。换言之，可以使用享元模式来减少对象的数量。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Head First 设计模式》笔记0-引子</title>
      <link href="/2018/06/25/%E3%80%8AHead-First-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E7%AC%94%E8%AE%B00-%E5%BC%95%E5%AD%90/"/>
      <url>/2018/06/25/%E3%80%8AHead-First-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E7%AC%94%E8%AE%B00-%E5%BC%95%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<h1 id="可以用下面的方法让你的大脑就范"><a href="#可以用下面的方法让你的大脑就范" class="headerlink" title="可以用下面的方法让你的大脑就范"></a>可以用下面的方法让你的大脑就范</h1><ol><li>慢一点，你理解的越多，需要记的就越少。</li><li>勤做练习，自己记笔记。</li><li>上床睡觉之前不要再看别的书了，或者至少不再看其他有难度的东西。</li><li>要喝水，而且要多喝点水。</li><li>大声说出来。</li><li>听听你的大脑怎么说。</li><li>要有点感觉！</li><li>设计一点东西！</li></ol><a id="more"></a><h1 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h1><ol><li>知道 OO 基础，并不足以让你设计出良好的 OO 系统。</li><li>良好的 OO 设计必须具备可复用、可扩展、可维护三个特性。</li><li>模式可以让我们建造出具有良好的 OO 设计质量的系统。</li><li>模式被认为是历经验证的 OO 设计经验。</li><li>模式不是代码，而是针对设计问题的通用解决方案。你可把它们应用到特定的应用中。</li><li>模式不是被发明，而是被发现。</li><li>大多数的模式和原则，都是着眼于软件变化的主题。</li><li>大多数的模式都允许系统局部改变独立于其他部分。</li><li>我们常把系统中会变化的部分抽出来封装。</li><li>模式让开发人员之间有共享的语言，能够最大化沟通的价值。</li></ol><h1 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h1><ol><li><p>封装变化。找出应用中可能需要变化之处，把他们独立出来，不要和那些不需要变化的代码混在一起。P9。</p><p> 把会变化的部分取出并封装起来，以便以后可以轻易地改动或扩张此部分，而不影响不需要变化的其他部分。</p></li><li><p>针对接口编程，而不是针对实现编程。P11。</p><p> “针对实现编程”的做法：<code>Dog d = new Dog();d.bark();</code></p><p> “针对接口编程”的做法：<code>Animal animal = new Dog();animal.makeSound();</code> 或者：<code>Animal animal = getAnimal();animal.makeSound();</code></p></li><li><p>多用组合，少用继承。P23。</p></li><li><p>为了交互对象之间的松耦合设计而努力。P53。</p></li><li><p>类应该对扩展开放，对修改关闭（开闭原则）。P86。</p></li><li><p>要依赖抽象，不要依赖具体类（依赖倒置原则）。P139。</p><p> 不要让“高层组件”依赖“低层组件”，而且，不管“高层组件”还是“低层组件”，两者都应该依赖于抽象。<br> 避免违反该原则的几个方针：</p><ol><li>变量不可以持有具体类的引用。<br>如果使用new，就会持有具体类的引用，可以使用工厂来避开这种引用。</li><li>不要让类派生自具体类。<br>如果派生自具体类，就会依赖具体类，可以派生自抽象或接口。</li><li>不要覆盖基类中已实现的方法。<br>如果覆盖基类中已实现的方法，那么基类就不是一个真正适合被继承的类。基类中已实现的方法应该被所有子类所共享。</li></ol></li><li><p>最少知识原则：只和你的密友谈话。P265。</p><p> 解释：当你设计一个系统时，不管是任何对象，你都要注意与它交互的类有哪些，并注意它和这些类是如何交互的，尽量避免过多的类耦合在一起，带来维护成本的上升。这个原则推荐的一些方针：就任何对象而言，在该对象的方法内，我们只应该调用一下范围的方法：</p><ul><li><p>该对象本身</p></li><li><p>被当作方法的参数而传递进来的对象</p></li><li><p>此方法所创建或实例化的任何对象</p></li><li><p>对象的任何组件。</p><p>如果对象是调用其他的方法的返回结果，不要调用该对象方法。</p><pre><code class="java">public float  getTemp(){  //  没有采用该原则  Thermoment thermoment = station.getThermoment();  return thermoment.getTemperature();}public float getTemp(){  // 采用该原则  return station.getTemperature();}</code></pre></li></ul></li><li><p>别找我，我会找你。P296。</p><p> 高层组件对待底层组件的方式是“别调用我们，我们会调用你”。</p><p> 模板方法模式，工厂模式，观察者模式，都使用了该原则。</p><p> 好莱坞原则和依赖倒置原则：</p><ul><li>依赖倒置原则教我们尽量避免使用具体类，而多使用抽象。</li><li>而好莱坞原则是用在创建框架或组件上的一种技巧，好让低层组件能够被挂钩进计算中，而且又不会让高层组件依赖底层组件。</li><li>两者的目标都是在于解耦。</li></ul></li><li><p>单一责任：一个类应该只有一个引起变化的原因。P339。</p></li></ol><h1 id="书中类图示意"><a href="#书中类图示意" class="headerlink" title="书中类图示意"></a>书中类图示意</h1><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20180714161944.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Java编程思想》笔记目录</title>
      <link href="/2018/06/25/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B%E7%AC%94%E8%AE%B0%E7%9B%AE%E5%BD%95/"/>
      <url>/2018/06/25/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B%E7%AC%94%E8%AE%B0%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>笔记参考博客：<a href="http://www.ciaoshen.com/categories/thinking-in-java.html" target="_blank" rel="noopener">ciaoshen.com</a></p><p>练习题可参考：<a href="http://greggordon.org/java/tij4/solutions.htm" target="_blank" rel="noopener">http://greggordon.org/java/tij4/solutions.htm</a></p><p>并发章节暂时未看，图形化界面章节不打算看。</p><ol><li><a href="/2018/03/13/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B%E7%AC%94%E8%AE%B001-%E5%AF%B9%E8%B1%A1%E5%AF%BC%E8%AE%BA/">《Java编程思想》笔记01-对象导论</a></li><li><a href="/2018/03/15/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B%E7%AC%94%E8%AE%B002-%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1/">《Java编程思想》笔记02-一切都是对象</a></li><li><a href="/2018/03/19/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B%E7%AC%94%E8%AE%B003-%E6%93%8D%E4%BD%9C%E7%AC%A6/">《Java编程思想》笔记03-操作符</a></li><li><a href="/2018/03/19/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B%E7%AC%94%E8%AE%B004-%E6%8E%A7%E5%88%B6%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/">《Java编程思想》笔记04-控制执行流程</a></li><li><a href="/2018/03/19/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B%E7%AC%94%E8%AE%B005-%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86/">《Java编程思想》笔记05-初始化与清理</a></li><li><a href="/2018/03/19/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B%E7%AC%94%E8%AE%B006-%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/">《Java编程思想》笔记06-访问权限控制</a></li><li><a href="/2018/03/19/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B%E7%AC%94%E8%AE%B007-%E5%A4%8D%E7%94%A8%E7%B1%BB/">《Java编程思想》笔记07-复用类</a></li><li><a href="/2018/03/27/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B%E7%AC%94%E8%AE%B008-%E5%A4%9A%E6%80%81/">《Java编程思想》笔记08-多态</a></li><li><a href="/2018/03/27/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B%E7%AC%94%E8%AE%B009-%E6%8E%A5%E5%8F%A3/">《Java编程思想》笔记09-接口</a></li><li><a href="/2018/03/28/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B%E7%AC%94%E8%AE%B010-%E5%86%85%E9%83%A8%E7%B1%BB/">《Java编程思想》笔记10-内部类</a></li><li><a href="/2018/03/28/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B%E7%AC%94%E8%AE%B011-%E6%8C%81%E6%9C%89%E5%AF%B9%E8%B1%A1/">《Java编程思想》笔记11-持有对象</a></li><li><a href="/2018/03/28/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B%E7%AC%94%E8%AE%B012-%E9%80%9A%E8%BF%87%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E9%94%99%E8%AF%AF/">《Java编程思想》笔记12-通过异常处理错误</a></li><li><a href="/2018/05/01/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B%E7%AC%94%E8%AE%B013-%E5%AD%97%E7%AC%A6%E4%B8%B2/">《Java编程思想》笔记13-字符串</a></li><li><a href="/2018/05/08/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B%E7%AC%94%E8%AE%B014-%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF/">《Java编程思想》笔记14-类型信息</a></li><li><a href="/2018/05/25/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B%E7%AC%94%E8%AE%B015-%E6%B3%9B%E5%9E%8B/">《Java编程思想》笔记15-泛型</a></li><li><a href="/2018/05/29/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B%E7%AC%94%E8%AE%B016-%E6%95%B0%E7%BB%84/">《Java编程思想》笔记16-数组</a></li><li><a href="/2018/06/06/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B%E7%AC%94%E8%AE%B017-%E5%AE%B9%E5%99%A8%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6/">《Java编程思想》笔记17-容器深入研究</a></li><li><a href="/2018/06/16/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B%E7%AC%94%E8%AE%B018-Java-I-O%E7%B3%BB%E7%BB%9F/">《Java编程思想》笔记18-Java I/O系统</a></li><li><a href="/2018/06/23/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B%E7%AC%94%E8%AE%B019-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B/">《Java编程思想》笔记19-枚举类型</a></li><li><a href="/2018/06/24/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B%E7%AC%94%E8%AE%B020-%E6%B3%A8%E8%A7%A3/">《Java编程思想》笔记20-注解</a></li></ol><br>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java编程思想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Java编程思想》笔记20-注解</title>
      <link href="/2018/06/24/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B%E7%AC%94%E8%AE%B020-%E6%B3%A8%E8%A7%A3/"/>
      <url>/2018/06/24/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B%E7%AC%94%E8%AE%B020-%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>Java SE5 内置了三种，定义在 java.lang 中的注解：</p><ul><li><code>@Override</code>，表示当前的方法定义将覆盖超类中的方法。如果你不小心拼写错误，或者方法签名对不上被覆盖的方法，编译器就会发出错误提示。</li><li><code>@Deprecated</code>，如果程序员使用了注解为它的元素，那么编译器会发出警告信息（过时）</li><li><code>@SuppressWarnings</code>，关闭不当的编译器警告信息。在 Java SE5 之前的版本中，也可以使用该注解，不过会被忽略不起作用。</li></ul><p>每当你创建描述符性质的类或接口时，一旦其中包括了重复性的工作，那就可以考虑使用注解来简化与自动化该过程。</p><a id="more"></a><h1 id="定义注解"><a href="#定义注解" class="headerlink" title="定义注解"></a>定义注解</h1><p>注解的定义很像接口的定义，也会编译成 class 文件。注解<strong>不支持继承</strong>。</p><pre><code class="java">@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface UseCase {    public int id();    public String description() default &quot;no description&quot;; // 默认值}public class PasswordUtils {    @UseCase(id=47, description=&quot;description&quot;)    public boolean validatePassword(String password) {        return (password.matches(&quot;\\w*\\d\\w*&quot;));    }    @UseCase(id = 48)    public String encryptPassword(String password) {        return new StringBuilder(password).reverse().toString();    }}</code></pre><p>定义默认值时，不能以 null 作为其值。一般可以自己定义一些特殊的值，如空字符或负数，表示某个元素不存在。</p><h1 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h1><table><thead><tr><th align="center">注解</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">@Target</td><td align="left">定义注解应用的地方。ElementType 参数包括：<br/><code>CONSTRUCTOR</code>：构造器的声明；<br/><code>FIELD</code>：域声明（包括 enum 实例）；<br/><code>LOCAL_VARIABLE</code>：局部变量声明；<br/><code>METHOD</code>：方法声明；<br/><code>PACKAGE</code>：包声明；<br/><code>PARAMETER</code>：参数声明；<br/><code>TYPE</code>：类、接口或enum声明</td></tr><tr><td align="center">@Retention</td><td align="left">定义注解应用的级别。RetentionPolicy 参数包括：<br/><code>SOURCE</code>：注解将被编译器丢弃；<br/><code>CLASS</code>：注解在 class 文件中可用，但会被 VM 丢弃；<br/><code>RUNTIME</code>：VM 将在运行期也保留注解，因此可通过反射机制读取注解信息</td></tr><tr><td align="center">@Documented</td><td align="left">将此注解包含在 JavaDoc 中</td></tr><tr><td align="center">@Inherited</td><td align="left">允许子类继承父类中的注解</td></tr></tbody></table><p>ElementType 参数，可以只指定某一个值，也可以以<strong>逗号分隔</strong>的形式指定多个值，如果想将注解应用于<strong>所有</strong>的 ElementType，那么可以省去 <code>@Target</code> 元注解，不过不常用。</p><h1 id="注解元素"><a href="#注解元素" class="headerlink" title="注解元素"></a>注解元素</h1><p>注解元素可用的类型包括：</p><ul><li>所有基本类型</li><li>String</li><li>Class</li><li>enum</li><li>Annotation</li><li>所有前面这些类型的数组</li></ul><p>不允许使用任何包装类型（有自动装箱存在，所以算不上什么限制），注解可以嵌套。</p><p>如果元素值是一个数组，要将它的值用大括号括起来 <code>@Test(array={&quot;a&quot;,&quot;b&quot;})</code>，如果只有一个值，也可以省去括号。</p><p>注解中定义了名为 <code>value</code> 的元素，且在应用该注解时，若该元素是<strong>唯一需赋值元素</strong>，则无需使用名-值对语法，只需在括号内给出 value 值即可。</p><h1 id="编写注解处理器"><a href="#编写注解处理器" class="headerlink" title="编写注解处理器"></a>编写注解处理器</h1><pre><code class="java">public class UseCaseTracker {  public static void trackUseCases(List&lt;Integer&gt; useCases, Class&lt;?&gt; cl) {    for(Method m : cl.getDeclaredMethods()) {      UseCase uc = m.getAnnotation(UseCase.class);      if(uc != null) {        System.out.println(&quot;Found Use Case:&quot; + uc.id() + &quot; &quot; + uc.description());        useCases.remove(new Integer(uc.id()));      }    }    for(int i : useCases) {      System.out.println(&quot;Warning: Missing use case-&quot; + i);    }  }}</code></pre><p>反射方法 <code>getDeclaredMethods()</code> 与 <code>getAnnotation()</code> 均属于 AnnotationElement 接口，Class、Method、Field 均实现了该接口。</p><p><code>getAnnotation()</code> 方法返回指定类型的注解对象。如果没有则返回 null。使用反射获取到注解对象之后，类似使用调用方法的方式获取注解的值，如uc.id()等。</p><p><code>getDeclaredAnnotations()</code> 返回直接存在于此元素上的所有注释。也属于 AnnotationElement 接口。</p><h1 id="javac-处理注解"><a href="#javac-处理注解" class="headerlink" title="javac 处理注解"></a>javac 处理注解</h1><p>Java SE 6 引入了一个新的功能，叫做 可插入注解处理（Pluggable Annotation Processing） 框架，它提供了标准化的支持来编写自定义的注解处理器。之所以称为“可插入”，是因为注解处理器可以动态插入到 javac 中，并可以对出现在 Java 源文件中的一组注解进行操作。此框架具有两个部分：一个用于声明注解处理器并与其交互的 API 包 <code>javax.annotation.processing</code> 和一个用于对 Java 编程语言进行建模的 API 包 <code>javax.lang.model</code>。</p><blockquote><p><a href="http://howiefh.github.io/2014/11/06/thinking-in-java-note-7/#javac处理注解" target="_blank" rel="noopener">http://howiefh.github.io/2014/11/06/thinking-in-java-note-7/#javac处理注解</a></p></blockquote><br>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java编程思想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Java编程思想》笔记19-枚举类型</title>
      <link href="/2018/06/23/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B%E7%AC%94%E8%AE%B019-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2018/06/23/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B%E7%AC%94%E8%AE%B019-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="基本-enum-特性"><a href="#基本-enum-特性" class="headerlink" title="基本 enum 特性"></a>基本 enum 特性</h1><ul><li>枚举型的实质是“单例模式”的变种，枚举型中的每个枚举都是它的一个静态成员字段。而且无法改变（常量）。</li><li>Enum 类是枚举的一个封装类，是所有枚举类型的超类，它是一个没有抽象方法的抽象类。Enum 类实现了 Comparable 接口，所以它具有 compareTo() 方法。同时它还实现了 Serializable 接口。</li><li>ordinal()：获取枚举元素声明时的顺序，从 0 开始计算。</li><li>可以使用“==”来比较两个枚举实例相同与否，由于编译器自动实现了 equals() 和 hashCode() 两个方法。</li><li>调用 <code>getDeclaringClass()</code> 方法，我们就能知道其所属的 enum 类。</li><li>name()：返回 enum 实例声明时的名字，与使用 toString() 方法效果相同。</li><li>所有 enum 都继承了 Enum 类，所以 enum 不能再继承其他类，但是可以实现一个或多个接口。</li></ul><a id="more"></a><h1 id="向-enum-中添加新方法"><a href="#向-enum-中添加新方法" class="headerlink" title="向 enum 中添加新方法"></a>向 enum 中添加新方法</h1><p>除了不能继承自一个 enum 之外，可以将 enum 看作一个常规的类，也就是说可以向 enum 添加方法，甚至可以由 main 方法。</p><ul><li><p><strong>如果打算添加自己的方法，那么必须在 enum 实例的最后添加一个分号，而且必须先定义 enum 实例，实例之前不能有任何方法，否则报错。</strong></p></li><li><p><strong>只能在 enum 定义的内部使用其构造器创建 enum 实例</strong>，所以 enum 构造器声明为 private 并没有什么影响。</p></li></ul><h1 id="values-的神秘之处"><a href="#values-的神秘之处" class="headerlink" title="values() 的神秘之处"></a>values() 的神秘之处</h1><p>编译器自动合成了另外两个静态方法：values() 和 valueOf()。这两个是非常常用的用来获取枚举实例的手段：</p><ul><li>values(): 返回含有全部内部枚举实例的数组。</li><li>valueOf(String name): 通过某个枚举实例的String字面量来获取与之对应的枚举实例。</li></ul><p>如果将 enum 实例向上转型为 Enum，那么 values() 方法就不可访问了。不过，在 Class 中有一个 <code>getEnumConstants()</code> 方法，所以即便 Enum 接口中没有 values() 方法，我们仍然可以通过 Class 对象取得所有 enum 实例。</p><pre><code class="java">enum Search { HITHER, YON }public class UpcastEnum {    public static void main(String[] args) {        Search[] vals = Search.values();        Enum e = Search.HITHER; // Upcast        // e.values(); // No values() in Enum        for(Enum en : e.getClass().getEnumConstants())            System.out.println(en);    }} /* Output:HITHERYON*///:~</code></pre><h1 id="使用接口组织枚举"><a href="#使用接口组织枚举" class="headerlink" title="使用接口组织枚举"></a>使用接口组织枚举</h1><p>我们希望从 enum 继承子类，是由于有时我们希望扩展远 enum 中的元素，有时是因为我们希望使用子类将一个 enum 中的元素进行分组。</p><p>在一个接口的内部，创建实现该接口的枚举，以此将元素进行分组，可以达到将枚举元素分类组织的目的。</p><pre><code class="java">public interface Food {    enum Appetizer implements Food {        SALAD, SOUP, SPRING_ROLLS;    }    enum MainCourse implements Food {        LASAGNE, BURRITO, PAD_THAI,        LENTILS, HUMMOUS, VINDALOO;    }    enum Dessert implements Food {        TIRAMISU, GELATO, BLACK_FOREST_CAKE,        FRUIT, CREME_CARAMEL;    }    enum Coffee implements Food {        BLACK_COFFEE, DECAF_COFFEE, ESPRESSO,        LATTE, CAPPUCCINO, TEA, HERB_TEA;    }}</code></pre><p>如果想创建一个“枚举的枚举”，那么可以创建一个新的 enum，然后用其实例包装 Food 中的每一个 enum 类。</p><pre><code class="java">public enum Course {    APPETIZER(Food.Appetizer.class),    MAINCOURSE(Food.MainCourse.class),    DESSERT(Food.Dessert.class),    COFFEE(Food.Coffee.class);    private Food[] values;    private Course(Class&lt;? extends Food&gt; kind) {        values = kind.getEnumConstants();    }    public Food randomSelection() {        return Enums.random(values);    }}</code></pre><p>另一种管理枚举的方法</p><pre><code class="java">public enum Meal2 {    APPETIZER(Food.Appetizer.class),    MAINCOURSE(Food.MainCourse.class),    DESSERT(Food.Dessert.class),    COFFEE(Food.Coffee.class);    private Food[] values;    private Meal2(Class&amp;lt;? extends Food&gt; kind) {        values = kind.getEnumConstants();    }    public interface Food {        enum Appetizer implements Food {            SALAD, SOUP, SPRING_ROLLS;        }        enum MainCourse implements Food {            LASAGNE, BURRITO, PAD_THAI,            LENTILS, HUMMOUS, VINDALOO;        }        enum Dessert implements Food {            TIRAMISU, GELATO, BLACK_FOREST_CAKE,            FRUIT, CREME_CARAMEL;        }        enum Coffee implements Food {            BLACK_COFFEE, DECAF_COFFEE, ESPRESSO,            LATTE, CAPPUCCINO, TEA, HERB_TEA;        }    }    public Food randomSelection() {        return Enums.random(values);    }    public static void main(String[] args) {        for(int i = 0; i &amp;lt; 5; i++) {            for(Meal2 meal : Meal2.values()) {                Food food = meal.randomSelection();                System.out.println(food);            }            System.out.println(&quot;---&quot;);        }    }}</code></pre><h1 id="EnumSet"><a href="#EnumSet" class="headerlink" title="EnumSet"></a>EnumSet</h1><table><thead><tr><th align="center">函数名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">allOf(Class&lt;E&gt; elementType)</td><td align="center">创建一个包含指定元素类型的所有元素的枚举 set。</td></tr><tr><td align="center">complementOf(EnumSet&lt;E&gt; s)</td><td align="center">创建一个其元素类型与指定枚举 set 相同的枚举 set，最初包含指定 set 中所不 包含的此类型的所有元素。</td></tr><tr><td align="center">copyOf(Collection&lt;E&gt; c)</td><td align="center">创建一个从指定 collection 初始化的枚举 set。</td></tr><tr><td align="center">copyOf(EnumSet&lt;E&gt; s)</td><td align="center">创建一个其元素类型与指定枚举 set 相同的枚举 set，最初包含相同的元素（如果有的话）。</td></tr><tr><td align="center">noneOf(Class&lt;E&gt; elementType)</td><td align="center">创建一个具有指定元素类型的空枚举 set。</td></tr><tr><td align="center">of(E e)</td><td align="center">创建一个最初包含指定元素的枚举 set。重载函数可以接受多个元素</td></tr><tr><td align="center">range(E from, E to)</td><td align="center">创建一个最初包含由两个指定端点所定义范围内的所有元素的枚举 set。</td></tr></tbody></table><h1 id="EnumMap"><a href="#EnumMap" class="headerlink" title="EnumMap"></a>EnumMap</h1><p>所有键都必须来自单个 enum。</p><p><strong>“命令模式”</strong>，就是把“命令”当做 Key 值，然后相应的“行动”当做 Value 值，存储到 EnumMap 中。</p><pre><code class="java">enum AlarmPoint {    BATHROOM, UTILITY, KITCHEN}interface Command { void action(); }public class EnumMaps {    public static void main(String[] args) {        EnumMap&lt;AlarmPoint,Command&gt; em = new EnumMap&lt;AlarmPoint,Command&gt;(AlarmPoint.class);        em.put(AlarmPoint.KITCHEN, new Command() {            public void action() { print(&quot;Kitchen fire!&quot;); }        });        em.put(AlarmPoint.BATHROOM, new Command() {            public void action() { print(&quot;Bathroom alert!&quot;); }        });        for(Map.Entry&lt;AlarmPoint,Command&gt; e : em.entrySet()) {            printnb(e.getKey() + &quot;: &quot;);            e.getValue().action();        }    }} /* Output:BATHROOM: Bathroom alert!KITCHEN: Kitchen fire!*///:~</code></pre><p><strong>每个枚举实例有自己特有的行为方法</strong>，是实际开发中非常常见的一种抽象。这种场景下，用 EnumMap 能使代码很清晰，简洁。</p><h1 id="常量相关的方法"><a href="#常量相关的方法" class="headerlink" title="常量相关的方法"></a>常量相关的方法</h1><p>Java 允许 enum 实例编写方法，从而为每个 enum 实例赋予各自不同的行为。你需要为 enum 定义一个或多个 abstract 方法，然后为每个 enum 实例实现该抽象方法。</p><p>通过相应的 enum 实例，我们可以调用其上的方法。这通常也称为<em>表驱动的代码</em>，注意它与命令模式的区别。</p><pre><code class="java">enum LikeClasses {    WINKEN { void behavior() { print(&quot;Behavior1&quot;); } },    BLINKEN { void behavior() { print(&quot;Behavior2&quot;); } },    NOD { void behavior() { print(&quot;Behavior3&quot;); } };    abstract void behavior();}</code></pre><p><strong>职责链</strong>（Chain of Responsibility）是很常用的一种抽象。它的本质是把一系列的“操作”抽象成解决问题的一系列方法。在遇到问题之后，进行一一尝试，直到问题被解决为止，或者最终被标记为不可解决。</p><h1 id="多路分发"><a href="#多路分发" class="headerlink" title="多路分发"></a>多路分发</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>“<strong>多路分发</strong>（Multiple Dispatching）”模式源自于多对象交互的场景。比如下面这个算数的例子。</p><pre><code class="java">interface Number{    public Number plus(Number n);    public Number multiple(Number n);}class Integer extends Number{}class Real extends Number{}class Rational extends Number{}</code></pre><p>Number 接口面向其他 Number 定义了加法和乘法。而 Number 底下有自然数，实数，有理数这样的派生类。所以当我们用两个数做加法或乘法的时候会像下面这样：</p><pre><code class="java">Number a=new Integer();Number b=new Real();a.plus(b);</code></pre><p>但这里的问题是 Java 只支持单路分发，编译器只能对一个对象实施动态绑定。所以 <code>a.plus(b);</code> 是无法编译的。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>“石头剪刀布”游戏的例子</p><pre><code class="java">interface Item {    Outcome compete(Item it);    Outcome eval(Paper p);    Outcome eval(Scissors s);    Outcome eval(Rock r);}class Paper implements Item {    public Outcome compete(Item it) { return it.eval(this); }    public Outcome eval(Paper p) { return DRAW; }    public Outcome eval(Scissors s) { return WIN; }    public Outcome eval(Rock r) { return LOSE; }}class Scissors implements Item {    public Outcome compete(Item it) { return it.eval(this); }    public Outcome eval(Paper p) { return LOSE; }    public Outcome eval(Scissors s) { return DRAW; }    public Outcome eval(Rock r) { return WIN; }}class Rock implements Item {    public Outcome compete(Item it) { return it.eval(this); }    public Outcome eval(Paper p) { return WIN; }    public Outcome eval(Scissors s) { return LOSE; }    public Outcome eval(Rock r) { return DRAW; }}</code></pre><p>通过调用 Item.compete() 方法开始两路分发。当系统动态绑定 it 对象的运行时类型后，再通过 it 对象回调 this 对象。</p><h2 id="用枚举型多路分发"><a href="#用枚举型多路分发" class="headerlink" title="用枚举型多路分发"></a>用枚举型多路分发</h2><p>用枚举实现多路分发，完全是另外一个思路：“写死”。下面是书里给的例子：</p><pre><code class="java">public enum RoShamBo2 implements Competitor&lt;RoShamBo2&gt; {    PAPER(DRAW, LOSE, WIN),    SCISSORS(WIN, DRAW, LOSE),    ROCK(LOSE, WIN, DRAW);    private Outcome vPAPER, vSCISSORS, vROCK;    RoShamBo2(Outcome paper,Outcome scissors,Outcome rock) {        this.vPAPER = paper;        this.vSCISSORS = scissors;        this.vROCK = rock;    }    public Outcome compete(RoShamBo2 it) {        switch(it) {            default:            case PAPER: return vPAPER;            case SCISSORS: return vSCISSORS;            case ROCK: return vROCK;        }    }}</code></pre><p>“原理”也很简单，用枚举把石头，剪刀，布之间的胜负关系全部写死。实际玩游戏的时候，对参数进行 switch。</p><h2 id="使用常量相关的方法"><a href="#使用常量相关的方法" class="headerlink" title="使用常量相关的方法"></a>使用常量相关的方法</h2><pre><code class="java">public interface Competitor&lt;T extends Competitor&lt;T&gt;&gt; {    Outcome compete(T competitor);}public enum RoShamBo4 implements Competitor&lt;RoShamBo4&gt; {    ROCK {        public Outcome compete(RoShamBo4 opponent) {            return compete(SCISSORS, opponent);        }    },    SCISSORS {        public Outcome compete(RoShamBo4 opponent) {            return compete(PAPER, opponent);        }    },    PAPER {        public Outcome compete(RoShamBo4 opponent) {            return compete(ROCK, opponent);        }    };    Outcome compete(RoShamBo4 loser, RoShamBo4 opponent) {        return ((opponent == this) ? Outcome.DRAW                : ((opponent == loser) ? Outcome.WIN : Outcome.LOSE));    }}</code></pre><h2 id="使用-EnumMap-分发"><a href="#使用-EnumMap-分发" class="headerlink" title="使用 EnumMap 分发"></a>使用 EnumMap 分发</h2><pre><code class="java">enum RoShamBo5 implements Competitor&lt;RoShamBo5&gt; {    PAPER, SCISSORS, ROCK;    static EnumMap&lt;RoShamBo5, EnumMap&lt;RoShamBo5, Outcome&gt;&gt; table =                new EnumMap&lt;RoShamBo5, EnumMap&lt;RoShamBo5, Outcome&gt;&gt;(RoShamBo5.class);    static {        for (RoShamBo5 it : RoShamBo5.values()){            table.put(it, new EnumMap&lt;RoShamBo5, Outcome&gt;(RoShamBo5.class));        }        initRow(PAPER, DRAW, LOSE, WIN);        initRow(SCISSORS, WIN, DRAW, LOSE);        initRow(ROCK, LOSE, WIN, DRAW);    }    static void initRow(RoShamBo5 it, Outcome vPAPER, Outcome vSCISSORS,Outcome vROCK) {        EnumMap&lt;RoShamBo5, Outcome&gt; row = RoShamBo5.table.get(it);        row.put(RoShamBo5.PAPER, vPAPER);        row.put(RoShamBo5.SCISSORS, vSCISSORS);        row.put(RoShamBo5.ROCK, vROCK);    }    public Outcome compete(RoShamBo5 it) {        return table.get(this).get(it);    }}</code></pre><h2 id="使用二维数组"><a href="#使用二维数组" class="headerlink" title="使用二维数组"></a>使用二维数组</h2><p>最简洁，最直接的方案。</p><pre><code class="java">enum RoShamBo6 implements Competitor&lt;RoShamBo6&gt; {    PAPER, SCISSORS, ROCK;    private static Outcome[][] table = {        { DRAW, LOSE, WIN }, // PAPER        { WIN, DRAW, LOSE }, // SCISSORS        { LOSE, WIN, DRAW }, // ROCK    };    public Outcome compete(RoShamBo6 other) {        return table[this.ordinal()][other.ordinal()];    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java编程思想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Java编程思想》笔记18-Java I/O系统</title>
      <link href="/2018/06/16/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B%E7%AC%94%E8%AE%B018-Java-I-O%E7%B3%BB%E7%BB%9F/"/>
      <url>/2018/06/16/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B%E7%AC%94%E8%AE%B018-Java-I-O%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="File-类"><a href="#File-类" class="headerlink" title="File 类"></a>File 类</h1><p>File 类是文件和目录路径名的抽象表示形式。File 类的实例是不可变的；也就是说，一旦创建，File 对象表示的抽象路径名将永不改变。</p><h2 id="list"><a href="#list" class="headerlink" title="list()"></a>list()</h2><p><code>String[] list()</code> 返回一个字符串数组，这些字符串指定此抽象路径名表示的目录中的文件和目录。</p><p><code>String[] list(FilenameFilter filter)</code> 返回一个字符串数组，这些字符串指定此抽象路径名表示的目录中满足指定过滤器的文件和目录。</p><pre><code class="java">public interface FilenameFilter { // FilenameFilter 接口    boolean accept(File dir, String name);}public class DirList3 {    public static void main(final String[] args) {        File path = new File(&quot;.&quot;);        String[] list;        if (args.length == 0) {            list = path.list();        } else {            list = path.list(new FilenameFilter() { // 匿名内部类实现 FilenameFilter 接口                private Pattern pattern = Pattern.compile(args[0]);                public boolean accept(File dir, String name) {                    return pattern.matcher(name).matches();                }            });        }        Arrays.sort(list, String.CASE_INSENSITIVE_ORDER); // 字母顺序排序        for (String dirItem : list) {            System.out.println(dirItem);        }    }}</code></pre><a id="more"></a><h1 id="输出和输入"><a href="#输出和输入" class="headerlink" title="输出和输入"></a>输出和输入</h1><p>我们很少用单个类创建自己的系统对象。一般情况下，我们都是将多个对象重叠在一起，提供期望的功能（这是装饰器设计模式）。</p><h2 id="InputStream-类型"><a href="#InputStream-类型" class="headerlink" title="InputStream 类型"></a>InputStream 类型</h2><p>InputStream 的作用是标志那些从不同起源地产生输入的类。这些起源地包括（每个都有一个相关的InputStream 子类）：</p><ul><li>字节数组</li><li>String 对象</li><li>文件</li><li>“管道”，它的工作原理与现实生活中的管道类似：将一些东西置入一端，它们在另一端出来。</li><li>一系列其他流，以便我们将其统一收集到单独一个流内。</li><li>其他起源地，如 Internet 连接等</li></ul><style>.article-entry td , .article-entry th{    border: 1px solid #d6d6d6;    padding: 6px 13px;}</style><table><thead><tr><th align="center">类</th><th align="center">功能</th><th align="center">构建器参数／如何使用</th></tr></thead><tbody><tr><td align="center">ByteArrayInputStream</td><td align="center">允许内存中的一个缓冲区作为 InputStream 使用</td><td align="center">从中提取字节的缓冲区／作为一个数据源使用。通过将其同一个 FilterInputStream 对象连接，可提供一个有用的接口</td></tr><tr><td align="center">FileInputStream</td><td align="center">用于从文件读取信息</td><td align="center">代表文件名的一个 String，或者一个 File 或 FileDescriptor 对象 ／作为一个数据源使用。通过将其同一个 FilterInputStream 对象连接，可提供一个有用的接口</td></tr><tr><td align="center">PipedInputStream</td><td align="center">产生为相关的 PipedOutputStream 写的数据。实现了“管道化”的概念</td><td align="center">PipedOutputStream／作为一个数据源使用。通过将其同一个 FilterInputStream 对象连接，可提供一个有用的接口</td></tr><tr><td align="center">SequenceInputStream</td><td align="center">将两个或更多的 InputStream 对象转换成单个 InputStream 使用</td><td align="center">两个 InputStream 对象或者一个 Enumeration，用于 InputStream 对象的一个容器／作为一个数据源使用。通过将其同一个 FilterInputStream 对象连接，可提供一个有用的接口</td></tr><tr><td align="center">FilterInputStream</td><td align="center">抽象类，作为装饰器的接口，装饰器为其他 InputStream 类提供了有用的功能。</td><td align="center">&nbsp;</td></tr></tbody></table><h2 id="OutputStream-类型"><a href="#OutputStream-类型" class="headerlink" title="OutputStream 类型"></a>OutputStream 类型</h2><table><thead><tr><th align="center">类</th><th align="center">功能</th><th align="center">构建器参数／如何使用</th></tr></thead><tbody><tr><td align="center">ByteArrayOutputStream</td><td align="center">在内存中创建一个缓冲区。我们发送给流的所有数据都会置入这个缓冲区。</td><td align="center">可选缓冲区的初始大小／用于指出数据的目的地。若将其同 FilterOutputStream 对象连接到一起，可提供一个有用的接口</td></tr><tr><td align="center">FileOutputStream</td><td align="center">将信息发给一个文件</td><td align="center">用一个 String 代表文件名，或选用一个 File 或 FileDescriptor 对象／用于指出数据的目的地。若将其同 FilterOutputStream 对象连接到一起，可提供一个有用的接口</td></tr><tr><td align="center">PipedOutputStream</td><td align="center">我们写给它的任何信息都会自动成为相关的 PipedInputStream 的输出。</td><td align="center">实现了“管道化”的概念 PipedInputStream／为多线程处理指出自己数据的目的地／将其同 FilterOutputStream 对象连接到一起，便可提供一个有用的接口</td></tr><tr><td align="center">FilterOutputStream</td><td align="center">抽象类，作为装饰器的接口；装饰器为其他 OutputStream 类提供了有用的功能。</td><td align="center">&nbsp;</td></tr></tbody></table><h1 id="添加属性和有用的接口"><a href="#添加属性和有用的接口" class="headerlink" title="添加属性和有用的接口"></a>添加属性和有用的接口</h1><p>装饰器必须拥有与它装饰的那个对象相同的接口，但装饰器亦可对接口作出扩展，这种情况见诸于几个特殊的“过滤器”类中</p><p>装饰器为我们提供了大得多的灵活性（因为可以方便地混合与匹配属性），但它们也使自己的代码变得更加复杂。原因在于 Java IO 库操作不便，我们必须创建许多类——“核心”IO 类型加上所有装饰器——才能得到自己希望的单个 IO 对象。</p><h2 id="通过-FilterInputStream-从-InputStream-里读入数据"><a href="#通过-FilterInputStream-从-InputStream-里读入数据" class="headerlink" title="通过 FilterInputStream 从 InputStream 里读入数据"></a>通过 FilterInputStream 从 InputStream 里读入数据</h2><p>基本都是使用基本的 InputStream 类型作为构造器参数创建这些类对象。</p><table><thead><tr><th align="center">类</th><th align="center">功能</th><th align="center">构建器参数／如何使用</th></tr></thead><tbody><tr><td align="center">DataInputStream</td><td align="center">与 DataOutputStream 联合使用，使自己能以机动方式读取一个流中的基本数据类型（int，char ，long 等等）</td><td align="center">InputStream/ 包含了一个完整的接口，以便读取基本数据类型</td></tr><tr><td align="center">BufferedInputStream</td><td align="center">避免每次想要更多数据时都进行物理性的读取，告诉它“请先在缓冲区里找”</td><td align="center">InputStream，可以指定缓冲区大小／本质上不提供接口，只不过是向进程中添加缓冲区所必需的。与接口对象搭配</td></tr></tbody></table><h2 id="通过-FilterOutputStream-向-OutputStream-里写入数据"><a href="#通过-FilterOutputStream-向-OutputStream-里写入数据" class="headerlink" title="通过 FilterOutputStream 向 OutputStream 里写入数据"></a>通过 FilterOutputStream 向 OutputStream 里写入数据</h2><table><thead><tr><th align="center">类</th><th align="center">功能</th><th align="center">构建器参数／如何使用</th></tr></thead><tbody><tr><td align="center">DataOutputStream</td><td align="center">与 DataInputStream 配合使用，可以按照可移植的方式向流中写入基本数据类型</td><td align="center">包含用于写入基本类型数据的全部接口</td></tr><tr><td align="center">PrintStream</td><td align="center">用于产生格式化输出。DataOutputStream 处理是数据的存储，而 PrintStream 处理显示</td><td align="center">可以用 Boolean 值指示是否在每次换行时清空缓冲区（可选）应该是对 OutputStream 对象的 final 封装。</td></tr><tr><td align="center">BufferedOutputStream</td><td align="center">使用它以避免每次发出数据的时候都要进行实际的写入。可调用 flush()，对缓冲区进行刷新清空</td><td align="center">可选缓冲区大小，本身并不能提供一个接口，只不过是向进程中添加缓冲区所必需的。与接口对象搭配</td></tr></tbody></table><h1 id="Reader-和-Writer"><a href="#Reader-和-Writer" class="headerlink" title="Reader 和 Writer"></a>Reader 和 Writer</h1><p>InputStreamReader 将一个 InputStream 转换成 Reader，OutputStreamWriter 将一个 OutputStream 转换成 Writer。</p><h2 id="更改数据流的行为"><a href="#更改数据流的行为" class="headerlink" title="更改数据流的行为"></a>更改数据流的行为</h2><p>尽管 BufferedOutputStream 是 FilterOutputStream 的一个子类，但是 BufferedWriter 并不是 FilterWriter 的子类（尽管FilterWriter是一个抽象类，但没有任何子类，把它放在那里也只是把它作为一个占位符））。然而，两个类的接口是非常相似的</p><table><thead><tr><th align="center">过滤器：Java 1.0 类</th><th align="center">对应的 Java 1.1 类</th></tr></thead><tbody><tr><td align="center">FilterInputStream</td><td align="center">FilterReader</td></tr><tr><td align="center">FilterOutputStream</td><td align="center">FilterWriter （没有子类的抽象类）</td></tr><tr><td align="center">BufferedInputStream</td><td align="center">BufferedReader（也有 readLine()）</td></tr><tr><td align="center">BufferedOutputStream</td><td align="center">BufferedWriter</td></tr><tr><td align="center">DataInputStream</td><td align="center">使用 DataInputStream（除非要使用 readLine()，这时需要使用一个 BufferedReader）</td></tr><tr><td align="center">PrintStream</td><td align="center">PrintWriter</td></tr><tr><td align="center">LineNumberInputStream</td><td align="center">LineNumberReader</td></tr><tr><td align="center">StreamTokenizer</td><td align="center">StreamTokenizer （使用接收Reader的构造器）</td></tr><tr><td align="center">PushBackInputStream</td><td align="center">PushBackReader</td></tr></tbody></table><h1 id="RandomAccessFile"><a href="#RandomAccessFile" class="headerlink" title="RandomAccessFile"></a>RandomAccessFile</h1><p>RandomAccessFile 不在 io 继承体系内，直接继承的 Object。</p><p>RandomAccessFile 适用于由大小已知的记录组成的文件，所以我们能用 seek()从一条记录移至另一条，然后读取或修改那些记录。</p><p>RandomAccessFile 类似 DataInputStream 和 DataOutputStream 的联合使用。其中，getFilePointer()用于查找当前在文件的什么地方，seek()用于移至文件内的一个新地点，length() 用于判断文件的最大长度。此外，构建器要求使用另一个变量（与 C 的 fopen()完全一样），指出是读（”r”），还是读写（”rw” ）。</p><p>只有 RandomAccessFile 支持搜寻方法，并且只适用于文件。BufferedInputStream 可以允许我们标记一个位置（使用 mark()，它的值容纳于单个内部变量中），并用 reset()重设那个位置。</p><p>在 JDK1.4 中，RandomAccessFile 的大多数功能由 <strong>nio 存储映射文件</strong>所替代。</p><h1 id="I-O-流的经典适用方式"><a href="#I-O-流的经典适用方式" class="headerlink" title="I/O 流的经典适用方式"></a>I/O 流的经典适用方式</h1><h2 id="缓冲输入文件"><a href="#缓冲输入文件" class="headerlink" title="缓冲输入文件"></a>缓冲输入文件</h2><pre><code class="java">public static String read(String filename) throws IOException {    // Reading input by lines:    BufferedReader in = new BufferedReader(new FileReader(filename));    String s;    StringBuilder sb = new StringBuilder();    while ((s = in.readLine()) != null)        sb.append(s + &quot;\n&quot;);    in.close();    return sb.toString();}</code></pre><h2 id="从内存输入"><a href="#从内存输入" class="headerlink" title="从内存输入"></a>从内存输入</h2><pre><code class="java">StringReader in = new StringReader(BufferedInputFile.read(&quot;MemoryInput.java&quot;));int c;while ((c = in.read()) != -1) {    System.out.print((char) c); // read() 是以 int 形式返回下一字节}</code></pre><h2 id="格式化的内存输入"><a href="#格式化的内存输入" class="headerlink" title="格式化的内存输入"></a>格式化的内存输入</h2><pre><code class="java">DataInputStream in = new DataInputStream(new ByteArrayInputStream(        BufferedInputFile.read(&quot;FormattedMemoryInput.java&quot;).getBytes()));while (in.available() != 0) { // 查看还有多少可供存取的字符    System.out.print((char) in.readByte());}</code></pre><h2 id="基本的文件输出"><a href="#基本的文件输出" class="headerlink" title="基本的文件输出"></a>基本的文件输出</h2><pre><code class="java">BufferedReader in = new BufferedReader(new StringReader(        BufferedInputFile.read(&quot;BasicFileOutput.java&quot;)));PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(&quot;BasicFileOutput.out&quot;)));//PrintWriter out = new PrintWriter(&quot;file.out&quot;);  //Java SE5提供了更加快捷的构造器，仍然使用缓存，只是不用自己实现int lineCount = 1;String s;while ((s = in.readLine()) != null)    out.println(lineCount++ + &quot;: &quot; + s); // 自己记录行号out.close();in.close();BufferedReader in = new BufferedReader(new FileReader(&quot;BasicFileOutput.out&quot;));String s;StringBuilder sb = new StringBuilder();while ((s = in.readLine()) != null)    sb.append(s + &quot;\n&quot;);in.close();System.out.println(sb.toString());</code></pre><h2 id="存储和恢复数据"><a href="#存储和恢复数据" class="headerlink" title="存储和恢复数据"></a>存储和恢复数据</h2><p>为了输出可供另一个流恢复的数据，我们需要用 DataInputStream 写入数据，并用 DataInputStream 恢复数据。</p><pre><code class="java">DataOutputStream out = new DataOutputStream(new BufferedOutputStream(        new FileOutputStream(&quot;Data.txt&quot;)));out.writeDouble(3.14159);out.writeUTF(&quot;That was pi&quot;);out.writeDouble(1.41413);out.writeUTF(&quot;Square root of 2&quot;);out.close();DataInputStream in = new DataInputStream(new BufferedInputStream(        new FileInputStream(&quot;Data.txt&quot;)));System.out.println(in.readDouble()); // 需要按顺序调用，且不能多次调用System.out.println(in.readUTF());System.out.println(in.readDouble());System.out.println(in.readUTF());/* Output:3.14159That was pi1.41413Square root of 2*///:~</code></pre><h2 id="读写随机访问文件-RandomAccessFile"><a href="#读写随机访问文件-RandomAccessFile" class="headerlink" title="读写随机访问文件 RandomAccessFile"></a>读写随机访问文件 RandomAccessFile</h2><p>使用 RandomAccessFile，必须知道文件的排版，才能正确的操作它，类似于 DataInputStream 和 DataInputStream（实现了相同的接口：DataInput 和 DataOutput）。</p><pre><code class="java">public class UsingRandomAccessFile {    static String file = &quot;rtest.dat&quot;;    static void display() throws IOException {        RandomAccessFile rf = new RandomAccessFile(file, &quot;r&quot;);        for (int i = 0; i &lt; 3; i++)            System.out.println(&quot;Value &quot; + i + &quot;: &quot; + rf.readDouble());        System.out.println(rf.readUTF());        rf.close();    }    public static void main(String[] args) throws IOException {        RandomAccessFile rf = new RandomAccessFile(file, &quot;rw&quot;);        for (int i = 0; i &lt; 3; i++)            rf.writeDouble(i * 1.414);        rf.writeUTF(&quot;The end of the file&quot;);        rf.close();        display();        rf = new RandomAccessFile(file, &quot;rw&quot;);        rf.seek(2 * 8); // 因为 Double 是 8 字节长，查找第二个，可以使用 2*8 来产生查找位置        rf.writeDouble(47.0001);        rf.close();        display();    }} /* Output:Value 0: 0.0Value 1: 1.414Value 2: 2.828The end of the fileValue 0: 0.0Value 1: 1.414Value 2: 47.0001The end of the file*///:~</code></pre><h2 id="管道流"><a href="#管道流" class="headerlink" title="管道流"></a>管道流</h2><p>管道输入流应该连接到管道输出流；管道输入流提供要写入管道输出流的所有数据字节。通常，数据由某个线程从 PipedInputStream 对象读取，并由其他线程将其写入到相应的 PipedOutputStream。不建议对这两个对象尝试使用单个线程，因为这样可能死锁线程。<strong>结合多线程技术使用</strong>。还有 PipedReader 及 PipedWriter。</p><pre><code class="java">public class PipedStream {    public static void main(String[] args) throws IOException {        PipedInputStream input = new PipedInputStream();        PipedOutputStream output = new PipedOutputStream();        input.connect(output); // 管道输入输出流连接        new Thread(new Input(input)).start();        new Thread(new Output(output)).start();    }}class Input implements Runnable{    private PipedInputStream in;    Input(PipedInputStream in){        this.in = in;    }    public void run(){        try {            byte[] buf = new byte[1024];            int len = in.read(buf);            String s = new String(buf,0,len);            System.out.println(&quot;s=&quot;+s);            in.close();        } catch (Exception e) {        }    }}class Output implements Runnable{    private PipedOutputStream out;    Output(PipedOutputStream out){        this.out = out;    }    public void run(){        try {            Thread.sleep(5000);            out.write(&quot;hi，管道来了！&quot;.getBytes());        } catch (Exception e) {        }    }}</code></pre><h1 id="标准-I-O"><a href="#标准-I-O" class="headerlink" title="标准 I/O"></a>标准 I/O</h1><p>System.in，System.out 以及 System.err。System.out 已预封装成一个 PrintStream 对象。System.err 同样是一个 PrintStream，但 System.in 是一个原始的 InputStream。</p><h2 id="从标准输入中读取"><a href="#从标准输入中读取" class="headerlink" title="从标准输入中读取"></a>从标准输入中读取</h2><pre><code class="java">BufferedReader stdin = new BufferedReader(new InputStreamReader(System.in));String s;while ((s = stdin.readLine()) != null &amp;&amp; s.length() != 0) {    System.out.println(s);}Scanner scanner = new Scanner(System.in);while ((s = scanner.nextLine()) != null &amp;&amp; s.length() != 0) {    System.out.println(s);}</code></pre><h2 id="将-System-out-转换成-PrintWriter"><a href="#将-System-out-转换成-PrintWriter" class="headerlink" title="将 System.out 转换成 PrintWriter"></a>将 System.out 转换成 PrintWriter</h2><pre><code class="java">PrintWriter out = new PrintWriter(System.out, true);out.println(&quot;Hello, world&quot;);</code></pre><p>第二个参数设为 true，以便开启自动刷新缓存区的功能，否则，你可能看不到输出。</p><h2 id="标准-I-O-重定向"><a href="#标准-I-O-重定向" class="headerlink" title="标准 I/O 重定向"></a>标准 I/O 重定向</h2><p>System 类提供了 <strong>setIn(InputStream)，setOut(PrintStream)，setErr(PrintStream)</strong>三个静态方法重定向标准 I/O。</p><p>I/O 重定向操纵的是字节流，而不是字符流。</p><pre><code class="java">PrintStream console = System.out;BufferedInputStream in = new BufferedInputStream(new FileInputStream(&quot;Redirecting.java&quot;));PrintStream out = new PrintStream(new BufferedOutputStream(        new FileOutputStream(&quot;test.out&quot;)));System.setIn(in);System.setOut(out);System.setErr(out);BufferedReader br = new BufferedReader(new InputStreamReader(System.in));String s;while ((s = br.readLine()) != null) {    System.out.println(s); // 控制台不会打印，会写入 test.out 文件中}out.close();System.setOut(console); // 恢复标准输出流到控制台</code></pre><h1 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h1><p>运行外部程序，并将产生的输出发送到控制台。</p><pre><code class="java">String command = &quot;ls&quot;;Process process = new ProcessBuilder(command.split(&quot; &quot;)).start();BufferedReader results = new BufferedReader(new InputStreamReader(process.getInputStream()));String s;while((s = results.readLine())!= null)    System.out.println(s);BufferedReader errors = new BufferedReader(new InputStreamReader(process.getErrorStream()));while((s = errors.readLine())!= null) {    System.err.println(s);}</code></pre><h1 id="新-I-O"><a href="#新-I-O" class="headerlink" title="新 I/O"></a>新 I/O</h1><p>JDK 1.4 的 java.nio.* 包中引入了新的 Java I/O 类库，其目的在于提高速度。实际上，旧的 I/O 包已经使用 nio 重新实现过，以便充分利用这种速度提高。</p><p>速度的提高来自于所使用的结构更接近于操作系统执行 I/O 的方式：<strong>通道和缓冲器</strong>。就像是 “煤矿隧道” 和 “拉煤车” 的关系。我们没有直接和通道交互，只是和缓冲器交互，并把缓冲器派送到通道。通道要么从缓冲器获得数据，要么向缓冲器发送数据。</p><p>唯一直接与通道交互的缓冲器是 <code>ByteBuffer</code>，可以存储未加工字节的缓冲器。通过告知分配多少存储空间来创建一个 ByteBuffer 对象，并且还有一个方法选择集，用于以原始的字节形式或基本数据类型输出和读取数据。但是，没办法输出或读取对象，即使是字符串对象也不行。这是大多数操作系统中更有效的映射方式。</p><p>旧 I/O 类库中有三个类（FileInputStream、FileOutputStream、RandomAccessFile）被修改了，用以产生 FileChannel。注意这些都是字节操纵流，与底层的 nio 性质一致。Reader 和 Writer 这种字符模式类不能用于产生通道；但是 java.nio.channels.Channels 类提供了实用方法，用以在通道中产生 Reader 和 Writer。</p><pre><code class="java">public class GetChannel {    private static final int BSIZE = 1024;    @SuppressWarnings(&quot;resource&quot;)    public static void main(String[] args) throws Exception {        // Write a file:        FileChannel fc = new FileOutputStream(&quot;data.txt&quot;).getChannel();        fc.write(ByteBuffer.wrap(&quot;Some text &quot;.getBytes())); // 将已存在的字节数组“包装”到 ByteBuffer        fc.close();        // 添加到文件的末尾        fc = new RandomAccessFile(&quot;data.txt&quot;, &quot;rw&quot;).getChannel();        fc.position(fc.size()); // 移动到最后        // position() 返回此缓冲区的位置。        fc.write(ByteBuffer.wrap(&quot;Some more&quot;.getBytes()));        fc.close();        // Read the file:        fc = new FileInputStream(&quot;data.txt&quot;).getChannel();        ByteBuffer buff = ByteBuffer.allocate(BSIZE);        fc.read(buff);        buff.flip();        while (buff.hasRemaining()) // 告知在当前位置和限制之间是否有元素。            System.out.print((char) buff.get());    }} /* Output:Some text Some more */// :~</code></pre><p>getChannel() 将会产生一个 <code>FileChannel</code>。通道是一种相当基础的东西：可以向它传送用于读写的 ByteBuffer，并且可以锁定文件的某些区域用于<strong>独占式访问</strong>。</p><p>将字节存放在 ByteBuffer 的方法之一是：使用一种 “put” 方法直接对它们进行填充，填入一个或多个字节，或基本数据类型的值。也可以使用 <code>wrap()</code> 方法将已存在的字节数组“包装”到 ByteBuffer 中。一旦如此，就不再复制底层的数组，而是把它作为所产生的 ByteBuffer 的存储器，称之为数组支持的 ByteBuffer。</p><p>对于只读操作，必须显式的使用静态的 <code>allocate()</code> 方法来分配 ByteBuffer，分配的大小单位是字节。nio 的目标就是快速移动大量数据，因此 ByteBuffer 的大小就显得尤为重要————实际上，这里使用的 1K 可能比通常使用的小一点（必须通过实际运行应用程序来找到最佳尺寸）。</p><p>甚至达到<strong>更高的速度</strong>也有可能，方法就是使用 <code>allocateDirect()</code> 而不是allocate()，以产生一个与操作系统有更高耦合性的“直接”缓冲器。但是，这种分配的<strong>开支会更大</strong>，并且具体实现也随操作系统的不同而不同，因此必须再次实际运行应用程序来查看直接缓冲是否可以使程序获得速度上的优势。</p><p>一旦调用 <code>read()</code> 来告知 FileChannel 向 ByteBuffer 存储字节，就必须调用缓冲器上的 <code>flip()</code>,让它做好让别人读取字节的准备。（适用于获取最大速度）如果打算使用缓冲器执行进一步的 read() 操作，也必须得调用 <code>clear()</code> 来为每个 read() 做好准备。</p><pre><code class="java">// 文件复制程序public class ChannelCopy {    private static final int BSIZE = 1024;    @SuppressWarnings(&quot;resource&quot;)    public static void main(String[] args) throws Exception {        if (args.length != 2) {            System.out.println(&quot;arguments: sourcefile destfile&quot;);            System.exit(1);        }        FileChannel in = new FileInputStream(args[0]).getChannel(),                out = new FileOutputStream(args[1]).getChannel();        ByteBuffer buffer = ByteBuffer.allocate(BSIZE);        while (in.read(buffer) != -1) {            buffer.flip(); // Prepare for writing            out.write(buffer);            buffer.clear(); // Prepare for reading        }    }}</code></pre><p>当 FileChannel.read() 返回 -1 时（一个分界符，源于Unix和C），表示已经到达了输入的末尾。每次 read() 操作之后，就会将数据输入到缓冲器中，<strong><code>flip()</code> 则是准备缓冲器以便它的信息可以由 write() 提取。write() 操作之后，信息仍在缓冲器中，接着 <code>clear()</code> 操作则对所有的内部指针重新安排，以便缓冲器在另一个 read() 操作期间能够做好接收数据的准备</strong>。</p><p>特殊方法 <code>transferTo()</code> 和 <code>transferFrom()</code> 允许将一个通道和另一个通道直接相连。</p><pre><code class="java">FileChannel in = new FileInputStream(args[0]).getChannel(),        out = new FileOutputStream(args[1]).getChannel();in.transferTo(0, in.size(), out);//Or://out.transferFrom(in, 0, in.size());</code></pre><h2 id="转换数据"><a href="#转换数据" class="headerlink" title="转换数据"></a>转换数据</h2><p>java.nio.CharBuffer 的 toString() 方法返回一个包含缓冲器中所有字符的字符串。Bytebuffer 可以看做是具有 <strong><code>asCharBuffer()</code> 方法的 <code>CharBuffer</code></strong>。</p><pre><code class="java">public class BufferToText {    private static final int BSIZE = 1024;    @SuppressWarnings(&quot;resource&quot;)    public static void main(String[] args) throws Exception {        FileChannel fc = new FileOutputStream(&quot;data2.txt&quot;).getChannel();        fc.write(ByteBuffer.wrap(&quot;Some text&quot;.getBytes()));        fc.close();        fc = new FileInputStream(&quot;data2.txt&quot;).getChannel();        ByteBuffer buff = ByteBuffer.allocate(BSIZE);        fc.read(buff);        buff.flip();        System.out.println(buff.asCharBuffer()); // 乱码        // 使用默认字符集解码:        buff.rewind(); // 返回到数据开始部分        String encoding = System.getProperty(&quot;file.encoding&quot;); // 获得默认字符        System.out.println(&quot;Decoded using &quot; + encoding + &quot;: &quot;                + Charset.forName(encoding).decode(buff));        // 或者,我们可以用东西将打印编码:        fc = new FileOutputStream(&quot;data2.txt&quot;).getChannel();        fc.write(ByteBuffer.wrap(&quot;Some text&quot;.getBytes(&quot;UTF-8&quot;)));        fc.close();        // 现在再次尝试 读:        fc = new FileInputStream(&quot;data2.txt&quot;).getChannel();        buff.clear();        fc.read(buff);        buff.flip();        System.out.println(buff.asCharBuffer());        // 使用 CharBuffer 写:        fc = new FileOutputStream(&quot;data2.txt&quot;).getChannel();        buff = ByteBuffer.allocate(24); // 比需要的更多，可以在控制台中看到有空白符存在，但是复制不出来        buff.asCharBuffer().put(&quot;Some text&quot;);        fc.write(buff);        fc.close();        // Read and display:        fc = new FileInputStream(&quot;data2.txt&quot;).getChannel();        buff.clear();        fc.read(buff);        buff.flip();        System.out.println(buff.asCharBuffer());    }} /* Output:????Decoded using UTF-8: Some textSome textSome text*///:~</code></pre><p>buff.rewind() 返回到数据开始部分，如果数据超出缓冲区大小，可以调用该方法或 clear()。</p><p>ByteBuffer.allocate(1024)，limit() 可以查看缓冲区大小，缓冲器（ByteBuffer）会自动把自己的内容置为零。</p><p>缓冲器容纳的是普通的字节，为了把它们转换成字符，要么在输入它们的时候对其进行<strong>编码</strong>（这样，它们输出时才具有意义，否则会有乱码），要么在将其从缓冲器输出时对它们进行<strong>解码</strong>。<code>java.nio.charset.Charset</code> 类提供了把数据编码成多种不同类型的字符集的工具。</p><h2 id="获取基本类型"><a href="#获取基本类型" class="headerlink" title="获取基本类型"></a>获取基本类型</h2><pre><code class="java">ByteBuffer bb = ByteBuffer.allocate(1024);bb.asCharBuffer().put(&quot;Howdy!&quot;);char c;while ((c = bb.getChar()) != 0)    printnb(c + &quot; &quot;);print();bb.asShortBuffer().put((short) 471142); // 需要类型转换print(bb.getShort());bb.asIntBuffer().put(99471142);print(bb.getInt());bb.asLongBuffer().put(99471142);print(bb.getLong());bb.asFloatBuffer().put(99471142);print(bb.getFloat());bb.asDoubleBuffer().put(99471142);print(bb.getDouble());/* Output:H o w d y !1239099471142994711429.9471144E79.9471142E7*///:~</code></pre><h2 id="视图缓冲器"><a href="#视图缓冲器" class="headerlink" title="视图缓冲器"></a>视图缓冲器</h2><p>视图缓冲器（view buffer）可以让我们通过某个特定的基本数据类型的视窗查看其底层的 ByteBuffer。<strong>ByteBuffer 依然是实际存储数据的地方</strong>，“支持”着前面的视图，因此，对视图的任何修改都会映射成为对 ByteBuffer 中数据的修改。视图还允许从 ByteBuffer 一次一个地（与 ByteBuffer 所支持的方式相同）或者成批地（放入数组中）读取基本类型值。</p><pre><code class="java">ByteBuffer bb = ByteBuffer.allocate(BSIZE);IntBuffer ib = bb.asIntBuffer();ib.put(new int[] { 11, 42, 47, 99, 143, 811, 1016 });System.out.println(ib.get(3));ib.put(3, 1811);ib.flip();while (ib.hasRemaining()) {    int i = ib.get();    System.out.print(i + &quot; &quot;);}/* Output:9911 42 47 1811 143 811 1016 */// :~</code></pre><h2 id="字节存放次序"><a href="#字节存放次序" class="headerlink" title="字节存放次序"></a>字节存放次序</h2><p>不同的机器可能会使用不同的字节排序方法来存储数据。“big endian”（高位字节优先）将高位字节存放在地址最低的存储器单元。“litter endian”（低位字节优先）则是将高位字节放在地址最高的存储器单元。当存储量大于一个字节时，像 int、float等，就要考虑字节的顺序问题了。ByteBuffer 是以高字节优先的形式存储数据的，并且数据在网上传送时也常常使用高位优先的形式。可以使用带有参数的 <code>ByteOrder.BIG_ENDIAN</code> 或 <code>ByteOrder.LITTLE_ENDIAN</code> 的 <code>order()</code> 方法改变 ByteBuffer 的字节排序方式。</p><p>如果以 short(ByteBuffer.asShortBuffer) 形式读取数据，得到的数字是 97（二进制的形式为 00000000 01100001）；但是如果将 ByteBuffer 更改成低位优先形式，得到的数字却是 24832（01100001 00000000）</p><pre><code class="java">public class Endians {    public static void main(String[] args) {        ByteBuffer bb = ByteBuffer.wrap(new byte[12]);        bb.asCharBuffer().put(&quot;abcdef&quot;);        print(Arrays.toString(bb.array()));        bb.rewind();        bb.order(ByteOrder.BIG_ENDIAN);        bb.asCharBuffer().put(&quot;abcdef&quot;);        print(Arrays.toString(bb.array()));        bb.rewind();        bb.order(ByteOrder.LITTLE_ENDIAN);        bb.asCharBuffer().put(&quot;abcdef&quot;);        print(Arrays.toString(bb.array()));    }} /* Output:[0, 97, 0, 98, 0, 99, 0, 100, 0, 101, 0, 102][0, 97, 0, 98, 0, 99, 0, 100, 0, 101, 0, 102][97, 0, 98, 0, 99, 0, 100, 0, 101, 0, 102, 0]*///:~</code></pre><p>ByteBuffer 有足够的空间，以存储作为外部缓冲器的 charArray 中的所有字节，因此可以调用 <code>array()</code> 方法显示视图底层的字节。array() 方法是“可选的”，并且只能对由数组支持的缓冲器调用此方法；否则，将会抛出 UnsupportedOperationException。</p><h2 id="用缓冲器操纵数据"><a href="#用缓冲器操纵数据" class="headerlink" title="用缓冲器操纵数据"></a>用缓冲器操纵数据</h2><p>如果想把一个字节数组写到文件中去，那么就应该使用 ByteBuffer.wrap() 方法把字节数组包装起来，然后用 getChannel() 方法在 FileOutputstream 上打开一个通道，接着讲来自于 ByteBuffer 的数据写到 FileChannel中。</p><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20180609161341.png" alt="nio 类之间关系"></p><p>注意，ByteBuffer 是将数据移进移出通道的唯一方式，并且<strong>只能创建一个独立的基本类型缓冲器</strong>，或者使用 “as” 方法从 ByteBuffer 中获得。也就是说，<strong>不能把基本类型的缓冲器转换成 ByteBuffer</strong>。然而，由于可以经由视图缓冲器将基本类型数据移进移出 ByteBuffer，所以这也不是什么真正的限制了。</p><h2 id="缓冲器的细节"><a href="#缓冲器的细节" class="headerlink" title="缓冲器的细节"></a>缓冲器的细节</h2><p>Buffer 由数据和可以高效地访问及操纵这些数据的四个索引（mark（标记）、position（位置）、limit（界限）、capacity（容量））组成。</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>capacity()</td><td>返回缓冲区容量</td></tr><tr><td>clear()</td><td>清空缓冲区，将 position 设置为 0，limit 设置为容量。我们可以调用此方法覆写缓冲区。</td></tr><tr><td>flip()</td><td>将 position 和 limit 设置为 0，此方法用于准备从缓冲区读取已经写入的数据。</td></tr><tr><td>limit()</td><td>返回 limit 值</td></tr><tr><td>limit(int lim)</td><td>设置 limit 值</td></tr><tr><td>mark()</td><td>将 mark 设置为 position</td></tr><tr><td>reset()</td><td>将 position 设置为 mark</td></tr><tr><td>rewind()</td><td>将 position 设置为 0，mark 设置为 -1</td></tr><tr><td>position()</td><td>返回 position 值</td></tr><tr><td>position(int pos)</td><td>设置 position 值</td></tr><tr><td>remaining()</td><td>返回 (limit - position)</td></tr><tr><td>hasRemaining()</td><td>若有介于 position 和 limit 之间的元素，则返回 true</td></tr></tbody></table><h2 id="内存映射文件"><a href="#内存映射文件" class="headerlink" title="内存映射文件"></a>内存映射文件</h2><p>内存映射文件允许我们创建和修改那些因为太大而不能放入内存的文件。有了内存映射文件，我们就可以假定整个文件都放在内存中，而且可以完全把它当作非常大的数组来访问。这种方法极大地简化了用于修改文件的代码。</p><pre><code class="java">public class LargeMappedFiles {    static int length = 0x8FFFFFF; // 128 MB，实际文件查看 143MB    public static void main(String[] args) throws Exception {        MappedByteBuffer out = new RandomAccessFile(&quot;test.dat&quot;, &quot;rw&quot;)                .getChannel().map(FileChannel.MapMode.READ_WRITE, 0, length);        for (int i = 0; i &lt; length; i++) {            out.put((byte) &#39;x&#39;);        }        print(&quot;Finished writing&quot;);        for (int i = length / 2; i &lt; length / 2 + 6; i++) {            System.out.print((char) out.get(i));        }    }}// Finished writing// xxxxxx</code></pre><p>为了既能写又能读，先由 RandomAccessFile 开始，获得该文件上的通道，然后调用 <code>map()</code> 产生 <code>MappedByteBuffer</code>，这是一种<strong>特殊类型的直接缓冲器</strong>。注意<strong>必须指定映射文件的初始位置和映射区域的长度</strong>，这意味着可以映射某个大文件的较小的部分。</p><p>MappedByteBuffer 由 ByteBuffer 继承而来，因此它具有 ByteBuffer 的所有方法。</p><p>只有一部份文件放入了内存，文件的其他部分被交换了出去，用这种方式，很大的文件（可达 2GB）也可以很容易地修改。注意底层操作系统的文件映射工具是用来最大化地提高性能。</p><h2 id="文件加锁"><a href="#文件加锁" class="headerlink" title="文件加锁"></a>文件加锁</h2><p>文件加锁机制，它允许我们同步访问某个作为共享资源的文件。文件锁对其他的操作系统进程是可见的，因为 Java 的文件锁直接映射到了本地操作系统的加锁工具。</p><pre><code class="java">public class FileLocking {    public static void main(String[] args) throws Exception {        FileOutputStream fos = new FileOutputStream(&quot;file.txt&quot;);        FileLock fl = fos.getChannel().tryLock();        if (fl != null) {            System.out.println(&quot;Locked File&quot;);            TimeUnit.MILLISECONDS.sleep(100);            fl.release();            System.out.println(&quot;Released Lock&quot;);        }        fos.close();    }} /* Output:Locked FileReleased Lock*///:~</code></pre><p>通过对 FileChannel 调用 <code>tryLock()</code> 或 <code>lock()</code>，就可以获得整个文件的 <code>FileLock</code>。（SocketChannel、DatagramChannel 和 ServerSocketChannel 不需要加锁，因为它们是从单进程实体继承而来，我们通常不再两个进程之间共享网络 socket）。</p><p>tryLock() 是非阻塞式的，它设法获得锁，但是如果不能获得（当其他一些进程已经持有相同的锁，并且不共享时），它将直接从方法调用返回。</p><p>lock() 则是阻塞式的，它要阻塞进程直至锁可以获得，或调用 lock() 的线程中断，或调用 lock() 的通道关闭。使用 <code>FileLock.release()</code> 可以释放锁。</p><p>也可以对文件的一部分上锁：</p><pre><code class="java">tryLock(long position, long size, boolean shared)lock(long position, long size, boolean shared)</code></pre><p>加锁的区域由 size-position 决定。第三个参数指定<strong>是否是共享锁</strong>。</p><p>如果操作系统不支持共享锁并为每一个请求都创建一个锁，那么它就会使用<strong>独占锁</strong>。锁的类型可以通过 <code>FileLock.isShared()</code> 进行查询。</p><h2 id="对映射文件的部分加锁"><a href="#对映射文件的部分加锁" class="headerlink" title="对映射文件的部分加锁"></a>对映射文件的部分加锁</h2><p>文件映射通常用于极大的文件。我们需要对这种巨大的文件进行部分加锁，以便其他进程可以修改文件中未被加锁的部分。</p><p>下面例子中有两个线程，分别加锁文件的不同部分。</p><pre><code class="java">public class LockingMappedFiles {    static final int LENGTH = 0x8FFFFFF; // 128 MB    static FileChannel fc;    public static void main(String[] args) throws Exception {        fc = new RandomAccessFile(&quot;test.dat&quot;, &quot;rw&quot;).getChannel();        MappedByteBuffer out = fc.map(FileChannel.MapMode.READ_WRITE, 0, LENGTH);        for (int i = 0; i &lt; LENGTH; i++) {            out.put((byte) &#39;x&#39;);        }        new LockAndModify(out, 0, 0 + LENGTH / 3);        new LockAndModify(out, LENGTH / 2, LENGTH / 2 + LENGTH / 4);    }    private static class LockAndModify extends Thread {        private ByteBuffer buff;        private int start, end;        LockAndModify(ByteBuffer mbb, int start, int end) {            this.start = start;            this.end = end;            mbb.limit(end);            mbb.position(start);            buff = mbb.slice(); // 创建新的字节缓冲区，其内容是此缓冲区内容的共享子序列。            start();        }        public void run() {            try {                // Exclusive lock with no overlap:                FileLock fl = fc.lock(start, end, false);                System.out.println(&quot;Locked: &quot; + start + &quot; to &quot; + end);                // Perform modification:                while (buff.position() &lt; buff.limit() - 1) {                    buff.put((byte) (buff.get() + 1));                }                fl.release(); // Java 虚拟机会自动释放锁                System.out.println(&quot;Released: &quot; + start + &quot; to &quot; + end);            } catch (IOException e) {                throw new RuntimeException(e);            }        }    }} /*Locked: 0 to 50331647Locked: 75497471 to 113246206Released: 75497471 to 113246206Released: 0 to 50331647/:~</code></pre><h1 id="Java-档案文件"><a href="#Java-档案文件" class="headerlink" title="Java 档案文件"></a>Java 档案文件</h1><p>“选项”用一系列字母表示（不必输入 &quot;-&quot; 或其他任何指示符）和 tar 命令类似。如下所示：</p><ul><li>c，创建新的或空的压缩档</li><li>t，列出目录表</li><li>x，解压所有文件</li><li>x，file 解压指定文件</li><li>f，指出“我准备向你提供文件名”。若省略此参数，jar 会假定它的输入来自标准输入；或者在它创建文件时，输出会进入标准输出内</li><li>m，指出第一个参数将是用户自建的详情表文件的名字</li><li>v，产生详细输出，对 jar 做的工作进行巨细无遗的描述</li><li>O，只保存文件；不压缩文件（用于创建一个 JAR 文件，以便我们将其置入自己的类路径中）</li><li>M，不自动生成详情表文件</li></ul><h1 id="对象序列化"><a href="#对象序列化" class="headerlink" title="对象序列化"></a>对象序列化</h1><p>对象实现了 Serializable 接口，序列化对象就会很简单。首先要创建某些 OutputStream 对象，然后将其封装到 ObjectOutputStream 对象内。此时，只需调用 writeObject() 即可完成对象的序列化，并将其发送给 OutputStream。相反的过程是将一个InputStream 封装到 ObjectInputStream 内，然后调用 readObject()。和往常一样，我们最后获得的是指向一个上溯造型 Object 的句柄，所以必须下溯造型，以便能够直接设置。</p><p>每个类都持有一个特定的 serialVersionUID，如果待序列化的对象和目标对象的 serialVersionUID 不同，那么在反序列化时就会抛出 InvalidClassException 异常。</p><p>序列化有个“缺陷”，就是<strong>不能序列化静态字段</strong>。需要自己添加额外方法来实现追加序列化静态字段。</p><h2 id="序列化的控制-Externalizable-接口"><a href="#序列化的控制-Externalizable-接口" class="headerlink" title="序列化的控制 Externalizable 接口"></a>序列化的控制 <code>Externalizable</code> 接口</h2><p>通过实现 <code>Externalizable</code> 接口，用它代替 Serializable 接口，便可控制序列化的具体过程。这个 Externalizable 接口扩展了 Serializable，并增添了两个方法：<code>writeExternal()</code> 和 <code>readExternal()</code>。在序列化和重新装配的过程中，会自动调用这两个方法，以便我们执行一些特殊操作。</p><p>与恢复一个 Serializable（可序列化）对象不同。在后者的情况下，对象完全以它保存下来的二进制位为基础恢复，不存在构建器调用。而对一个 Externalizable 对象，<strong>所有默认构造器都会被调用</strong>（包括在字段定义时的初始化），而且会调用 readExternal()。必须注意这一事实————特别注意所有默认构造器都会被调用，才能使 Externalizable 对象中产生正确的行为。<strong>所以默认构造器得是public的，否则会抛出异常</strong>。</p><pre><code class="java">public class Blip3 implements Externalizable {    private int i;    private String s; // No initialization    public Blip3() {        print(&quot;Blip3 Constructor&quot;);        // s, i not initialized    }    public Blip3(String x, int a) {        print(&quot;Blip3(String x, int a)&quot;);        s = x;        i = a;        // s &amp; i initialized only in non-default constructor.    }    public String toString() {        return s + i;    }    public void writeExternal(ObjectOutput out) throws IOException {        print(&quot;Blip3.writeExternal&quot;);        // You must do this:        out.writeObject(s);        out.writeInt(i);    }    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {        print(&quot;Blip3.readExternal&quot;);        // You must do this:        s = (String) in.readObject();        i = in.readInt();    }    public static void main(String[] args) throws IOException, ClassNotFoundException {        print(&quot;Constructing objects:&quot;);        Blip3 b3 = new Blip3(&quot;A String &quot;, 47);        print(b3);        ObjectOutputStream o = new ObjectOutputStream(new FileOutputStream(&quot;Blip3.out&quot;));        print(&quot;Saving object:&quot;);        o.writeObject(b3);        o.close();        // Now get it back:        ObjectInputStream in = new ObjectInputStream(new FileInputStream(&quot;Blip3.out&quot;));        print(&quot;Recovering b3:&quot;);        b3 = (Blip3) in.readObject();        print(b3);    }} /* Output:Constructing objects:Blip3(String x, int a)A String 47Saving object:Blip3.writeExternalRecovering b3:Blip3 ConstructorBlip3.readExternalA String 47*///:~</code></pre><p>为了让一切正常运作起来，不仅需在 writeExternal() 方法（没有默认的行为可用来为一个 Externalizable 对象写入所有成员对象）中将重要信息写入，还必须在 readExternal() 方法中也恢复那些数据。</p><h2 id="transient（瞬时）关键字"><a href="#transient（瞬时）关键字" class="headerlink" title="transient（瞬时）关键字"></a>transient（瞬时）关键字</h2><p>在对象中具有 “private” 属性，但一旦经序列化处理，人们就可以通过读取一个文件，或者拦截网络传输得到它。为解决这个问题，可以用 transient（临时）逐个字段地关闭序列化。</p><p>由于 Externalizable 对象在默认情况下不保存它们的任何字段，所以 transient 只能和 Serializable 对象一起使用</p><h2 id="Externalizable-的替代方法"><a href="#Externalizable-的替代方法" class="headerlink" title="Externalizable 的替代方法"></a>Externalizable 的替代方法</h2><p>我们可以实现 Serializable 接口，并添加（注意是“添加”，而非“覆盖”或者“实现”）名为 writeObject() 和 readObject()的方法。一旦对象被序列化或者被反序列化还原，就会分别调用那两个方法。也就是说，只要提供了这两个方法，就会优先使用它们，而不考虑默认的序列化机制。</p><p>这些方法必须含有下列准确的签名：</p><pre><code class="java">private void writeObject(ObjectOutputStream stream) throws IOException;private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException</code></pre><p>被定义成 “private”，这意味着它们只能由这个类的其他成员调用。然而，我们实际并不从这个类的其他成员中调用它们，而是由 ObjectOutputStream 和 ObjectInputStream 的 writeObject() 及 readObject() 方法来调用我们对象的 writeObject() 和 readObject() 方法。</p><p>在我们的 writeObject() 内部，可以调用 <code>defaultWriteObject()</code>，从而决定执行默认的 writeObject()。调用 <code>defaultReadObject()</code>，令其作为 readObject() 的第一个操作。</p><h2 id="使用持久性"><a href="#使用持久性" class="headerlink" title="使用持久性"></a>使用持久性</h2><p>通过一个字节数组应用对象的序列化，从而实现对任何 Serializable（可序列化）对象的一个“深度复制”（深度复制意味着复制的是整个对象网，而不仅是基本对象及其引用，且需要都实现 Serializable）。</p><p>只要将所有东西都序列化到单独一个数据流里，就能恢复获得与以前写入时完全一样的对象网，不会不慎造成对象的重复（实际两个引用都是指向同一个对象，但是如果分开写入不同的流，恢复时，会重复恢复出不同的对象）。</p><p>如果想保存系统状态，最安全的做法是当作一种“原子”操作序列化。应将构成系统状态的所有对象都置入单个容器内，并在一次操作里完成那个容器的写入。这样一来，同样只需一次方法调用，即可成功恢复之。</p><h1 id="Preferences"><a href="#Preferences" class="headerlink" title="Preferences"></a>Preferences</h1><p>只能存储基本类型和字符串（小于 8K）。</p><pre><code class="java">Preferences prefs = Preferences.userNodeForPackage(PreferencesDemo.class);prefs.clear(); // 清空prefs.put(&quot;Location&quot;, &quot;Oz&quot;);prefs.putInt(&quot;Companions&quot;, 4);prefs.putBoolean(&quot;Are there witches?&quot;, true);int usageCount = prefs.getInt(&quot;UsageCount&quot;, 0); // 必需提供默认值usageCount++;prefs.putInt(&quot;UsageCount&quot;, usageCount); // 每次运行 +1，存储在了系统资源中for (String key : prefs.keys()){    System.out.println(key + &quot;: &quot; + prefs.get(key, null));}System.out.println(prefs.getInt(&quot;Companions&quot;, 0));/* Output: (Sample)Location: OzCompanions: 4Are there witches?: trueUsageCount: 53How many companions does Dorothy have? 4*///:~</code></pre><p><code>userNodeForPackage()</code> 用于个别用户偏好，<code>systemNodeForPackage()</code> 用于通用的安装配置。在非静态方法内部，通常用 getClass() 标识节点，静态方法中可以用 .class。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java编程思想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis foreach 中使用 Map</title>
      <link href="/2018/06/16/Mybatis%20foreach%20%E4%B8%AD%E4%BD%BF%E7%94%A8%20Map/"/>
      <url>/2018/06/16/Mybatis%20foreach%20%E4%B8%AD%E4%BD%BF%E7%94%A8%20Map/</url>
      
        <content type="html"><![CDATA[<h2 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h2><p><a href="http://www.mybatis.org/mybatis-3/zh/dynamic-sql.html#foreach" target="_blank" rel="noopener">动态 SQL</a> 的另外一个常用的操作需求是对一个集合进行遍历，通常是在构建 IN 条件语句的时候。比如：</p><pre><code class="xml">&lt;select id=&quot;selectPostIn&quot; resultType=&quot;domain.blog.Post&quot;&gt;  SELECT *  FROM POST P  WHERE ID in  &lt;foreach item=&quot;item&quot; index=&quot;index&quot; collection=&quot;list&quot;      open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt;        #{item}  &lt;/foreach&gt;&lt;/select&gt;</code></pre><p>foreach 元素的功能非常强大，它允许你指定一个集合，声明可以在元素体内使用的集合项（item）和索引（index）变量。它也允许你指定开头与结尾的字符串以及在迭代结果之间放置分隔符。这个元素是很智能的，因此它不会偶然地附加多余的分隔符。</p><p><strong>注意</strong> 你可以将任何可迭代对象（如 List、Set 等）、Map 对象或者数组对象传递给 foreach 作为集合参数。当使用可迭代对象或者数组时，index 是当前迭代的次数，item 的值是本次迭代获取的元素。当使用 Map 对象（或者 Map.Entry 对象的集合）时，index 是键，item 是值。</p><a id="more"></a><h2 id="使用-Map"><a href="#使用-Map" class="headerlink" title="使用 Map"></a>使用 Map</h2><blockquote><p>当使用 Map 对象（或者 Map.Entry 对象的集合）时，index 是键，item 是值。</p></blockquote><p>Mybatis 版本3.1.1，这句话存在问题，应该是迭代对象 <code>Map.entrySet()</code>，<code>item.key</code> 是键，<code>item.value</code> 是值。</p><pre><code class="xml">&lt;if test=&quot;tablenameTaskidMap != null and tablenameTaskidMap.entrySet() != null&quot;&gt;    &lt;foreach collection=&quot;tablenameTaskidMap.entrySet()&quot; item=&quot;mapitem&quot; index=&quot;mapindex&quot; open=&quot;&quot; separator=&quot;&quot; close=&quot;&quot;&gt;        union        select result,count(*) as handle from ${mapitem.key}        &lt;where&gt;            &lt;if test=&quot;taskids != null and taskids !=&#39;&#39;&quot;&gt;                and taskid in                &lt;foreach collection=&quot;mapitem.value&quot; item=&quot;item&quot; index=&quot;index&quot;                    open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt;                     #{item}                &lt;/foreach&gt;            &lt;/if&gt;        &lt;/where&gt;        group by result    &lt;/foreach&gt;&lt;/if&gt;</code></pre><p>参考链接：<a href="https://stackoverflow.com/questions/18610955/mybatis-iterate-hashmap-with-foreach/46088731#46088731" target="_blank" rel="noopener">https://stackoverflow.com/questions/18610955/mybatis-iterate-hashmap-with-foreach/46088731#46088731</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Java编程思想》笔记17-容器深入研究</title>
      <link href="/2018/06/06/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B%E7%AC%94%E8%AE%B017-%E5%AE%B9%E5%99%A8%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6/"/>
      <url>/2018/06/06/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B%E7%AC%94%E8%AE%B017-%E5%AE%B9%E5%99%A8%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6/</url>
      
        <content type="html"><![CDATA[<p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/full_container_taxonomy.png" alt="完整的容器分类法"></p><p>虚线框表示 abstract 类，Abstract 开头的类是部分实现了特定接口的工具。</p><a id="more"></a><h2 id="可选操作"><a href="#可选操作" class="headerlink" title="可选操作"></a>可选操作</h2><p>在 Collection 接口中，以下几个方法，</p><ul><li>retainAll()</li><li>removeAll()</li><li>clear()</li><li>add()</li><li>addAll()</li><li>remove()</li></ul><p>它们是可选方法。但仅仅是在官方文档的方法解释后面加了两个字“(optional operation)”而已。</p><p>它的实现方式非常隐蔽，当我们用“Arrays.asList()”方法把一个数组转换成一个 List 的时候，看起来返回的数据类型是 ArrayList，但注意这不是 java.util.ArrayList，而是 Arrays 内部一个同名的套嵌类 java.util.Arrays.ArrayList。在这个“山寨” ArrayList 里以上列出来的方法只是假装实现了一下，抛出一个 UnsupportedOperationException 而已。</p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>希望放入 Set 中的元素类型必须先实现一些特定方法：</p><ol><li>所有实现Set接口的类，都要求内部元素实现 equals() 方法。为了保证唯一性。对于良好的编程风格而言，你应该在覆盖 eqauls() 方法时，总是同时覆盖 hashCode() 方法。</li><li>HashSet 要实现 hashCode() 方法。</li><li>以 TreeSet 为代表的 SortedSet 系需要内部元素实现 Comparable 接口。也就是实现 compareTo() 方法。</li></ol><p>没有实现特定方法，存到 Set 里就会乱套。但编译器不会报错。因为默认的 equals() 和 hashCode() 虽然是错的，但是能运行的。</p><p>在 compareTo() 中，我没有使用“简洁明了”的形式 <code>return i – i2</code>，因为这是一个常见的编程错误，它只有在 i 和 i2 都是无符号的 int 时才能正确工作。对于 Jav a的有符号 int，它就会出错，因为 int 不够大，不足以表现两个有符号的 int 的差。例如 i 是很大的正整数，而 j 是很大的负整数， i-j 就会溢出并且返回负值，这就不正确了。<code>return (arg.i &lt; i ? -1 : (arg.i == i ? 0 : 1))</code></p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><ul><li><code>HashMap(默认选择，速度最快)</code>：Map基于散列表的实现（它取代了 Hashtable）。插入和查询“键值对”的开销是固定的。可以通过构造器设置容量和负载因子，以调整容器的性能。</li><li><code>LinkedHashMap</code>：类似于 HashMap，但是迭代遍历它时，取得“键值对”的顺序是其插入次序，或者是最近最少使用（LRU）的次序。只比 HashMap 慢一点；而在迭代访问时反而更快，因为它使用链表维护内部次序。</li><li><code>TreeMap</code>：基于红黑树的实现。查看“键”或“键值对”时，它们会被排序（次序由 Comparable 或 Comparator 决定，必须实现 Comparable）。TreeMap 的特点在于，所得到的结果是经过排序的。TreeMap 是唯一的带有 subMap() 方法的 Map，它可以访问一个子树。</li><li><code>WeakHashMap</code>：弱键（weak key）映射，允许释放映射所指向的对象；这是为解决某类特殊问题而设计的。如果映射之外没有引用指向某个“键”，则此“键”可以被垃圾回收器回收</li><li><code>ConcurrentHashMap</code>：一种线程安全的 Map，它不涉及同步加锁。</li><li><code>IdentityHashMap</code>：使用 == 代替 equals() 对“键”进行比较的散列映射。专为解决特殊问题而设计的。</li></ul><h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>为了提高速度，LinkedHashSet 散列化所有的元素，但是在遍历键值对时，却又以元素的插入顺序返回键值对。此外，可以在构造器中设定 LinkedHashSet，使之采用基于访问的最少使用<strong>（LRU）算法</strong>，于是<strong>没有被访问过的（可被看作需要删除的）元素就会出现在队列的前面</strong>。对于需要定期清理元素以节省空间的程序来说，此功能使得程序很容易得以实现。</p><pre><code class="java">public class LinkedHashMapDemo {  public static void main(String[] args) {    LinkedHashMap&lt;Integer,String&gt; linkedMap = new LinkedHashMap&lt;Integer,String&gt;(new CountingMapData(9));    print(linkedMap);    linkedMap = new LinkedHashMap&lt;Integer,String&gt;(16, 0.75f, true);    linkedMap.putAll(new CountingMapData(9));    print(linkedMap);    for(int i = 0; i &lt; 6; i++)      linkedMap.get(i);    print(linkedMap);    linkedMap.get(0);    print(linkedMap);  }} /* Output:{0=A0, 1=B0, 2=C0, 3=D0, 4=E0, 5=F0, 6=G0, 7=H0, 8=I0}{0=A0, 1=B0, 2=C0, 3=D0, 4=E0, 5=F0, 6=G0, 7=H0, 8=I0}{6=G0, 7=H0, 8=I0, 0=A0, 1=B0, 2=C0, 3=D0, 4=E0, 5=F0}{6=G0, 7=H0, 8=I0, 1=B0, 2=C0, 3=D0, 4=E0, 5=F0, 0=A0}*///:~</code></pre><h2 id="散列与散列码"><a href="#散列与散列码" class="headerlink" title="散列与散列码"></a>散列与散列码</h2><p>数组并不保存键本身。而是通过键对象生成一个数字，将其作为数组的下标。这个数字就是散列码，由定义在 Object 中的、且可能由你的类覆盖的 hashCode() 方法。</p><p>数组容量是固定的，所以散列码可能会有冲突，如果没有冲突就是一个完美的散列函数（EnumMap 和 EnumSet）。通常，冲突由外部链接处理：数组不保存值，而是保存值的 list。</p><h2 id="HashMap-的性能因子"><a href="#HashMap-的性能因子" class="headerlink" title="HashMap 的性能因子"></a>HashMap 的性能因子</h2><p>可以通过手工调整 HashMap 来提高其性能，从而满足我们特定应用的需求。</p><ul><li>容量：表中的桶位数</li><li>初始容量：表在创建时所拥有的桶位数。HashMap 和 HashSet 都具有允许你指定初始容量的构造器。</li><li>尺寸：表中当前存储的项数。</li><li>负载因子：尺寸/容量。空表的负载因子是 0，而半满表的负载因子是 0.5，依次类推。负载轻的表产生冲突的可能性小，因此对于插入和查找都是最理想的（但是会减慢使用迭代器进行遍历的过程）。HashMap 和 HashSet 都具有允许你指定负载因子的构造器，表示当负载情况达到该负载因子的水平时，容器将自动增加其容量（桶位数），实现方式是使容量大致加倍，并重新将现有对象分布到新的桶位集中（则被称为再散列）</li></ul><p>HashMap 使用的默认负载因子是 0.75（只有当表达到四分之三满时，才进行再散列），这个因子在时间和空间代价之间达到了平衡。更高的负载因子可以减低表所需的空间，但是会增加查找代价，这很重要，因为查找是我们在大多数时间里所做的操作（包括 get() 和 put()）。</p><p>如果你知道将在 HashMap 中存储多少项，那么创建一个具有恰当大小的初始容量将可以避免自动再散列的开销。</p><h2 id="设定-Collection-或-Map-为不可修改"><a href="#设定-Collection-或-Map-为不可修改" class="headerlink" title="设定 Collection 或 Map 为不可修改"></a>设定 Collection 或 Map 为不可修改</h2><p>unmodifiableSet() 方法</p><p>此方法允许你保留一份可修改的容器，作为类的 private 成员，然后通过某个方法调用返回该容器的“只读”的引用。这样一来，就只有你可以修改容器的内容，而别人只能读取。</p><pre><code class="java">HashSet&lt;String&gt; original = new HashSet&lt;String&gt;(data);Set&lt;String&gt; unmodifiable = Collections.unmodifiableSet(original);print(unmodifiable); // [BENIN, BURUNDI]print(original); // [BENIN, BURUNDI]original.add(&quot;one&quot;); //print(unmodifiable); // [BENIN, one, BURUNDI]print(original); // [BENIN, one, BURUNDI]unmodifiable.add(&quot;one&quot;); // 报错</code></pre><h2 id="Collection-或-Map-的同步控制"><a href="#Collection-或-Map-的同步控制" class="headerlink" title="Collection 或 Map 的同步控制"></a>Collection 或 Map 的同步控制</h2><p>synchronizedSet() 方法</p><h2 id="持有引用"><a href="#持有引用" class="headerlink" title="持有引用"></a>持有引用</h2><p><a href="http://www.ciaoshen.com/java/thinking%20in%20java/data%20structure/2016/09/09/tij4-17.html" target="_blank" rel="noopener">http://www.ciaoshen.com/java/thinking%20in%20java/data%20structure/2016/09/09/tij4-17.html</a></p><p>关于弱引用方面不错的一篇文章： <a href="http://www.ibm.com/developerworks/cn/java/j-lo-langref/" target="_blank" rel="noopener">《深入探讨 java.lang.ref 包》</a></p><p>四种不同强度 reference 的定义： 1.普通引用：没什么好说的。 2.软引用（SoftReference）：系统资源紧张的时候，系统会删除软引用。优先删除长久没用的引用。 3.弱引用（WeakReference）：GC的时候删除清理弱引用。 4.虚引用（PhantomReference）：通过虚引用无法获得对象。</p><h3 id="ReferenceQueue"><a href="#ReferenceQueue" class="headerlink" title="ReferenceQueue"></a>ReferenceQueue</h3><p>当软引用，弱引用，虚引用被系统清除以后，如果绑定了 ReferenceQueue，这些引用会被加入 ReferenceQueue。</p><p>虚引用（PhantomReference）构造函数必须传入一个 ReferenceQueue 作为参数。</p><pre><code class="java">public PhantomReference(T referent, ReferenceQueue&lt;? super T&gt; q) {    super(referent, q);}</code></pre><p>软引用和弱引用可以选择在构造函数传入 ReferenceQueue 或者不传入。</p><p>不同强度引用被加入 ReferenceQueue 的时机不同：</p><ul><li>当一个对象只维持着 WeakReference，直接被加入 ReferenceQueue。然后等待被GC销毁。</li><li>当一个对象只维持着 PhantomReference，GC 先销毁对象，然后把这个虚引用加入 ReferenceQueue。</li></ul><h2 id="BitSet"><a href="#BitSet" class="headerlink" title="BitSet"></a>BitSet</h2><p>如果想要高效率地存储大量“开/关”信息，BitSet 是很好的选择。不过它的效率仅是对空间而言；如果需要高效的访问时间，BitSet 比本地数组稍慢一点。</p><p>BitSet 的最小容量是 long:64 位。如果存储的内容比较小，例如 8 位，那么 BitSet 就浪费了一些空间。</p><p>如果拥有一个可以命名的固定的标志集合，那么 <code>EnumSet</code> 和 BitSet 相比，通常是一种更好的选择，因为 EnumSet 允许你按照名字而不是数字位的位置进行操作，因此可以减少错误。EnumSet 还可以防止你因不注意而添加新的标志位置，这种行为能够引发严重的、难以发现的缺陷。你应该使用 BitSet 而不是 EnumSet 的理由只包括：<strong>只有在运行时才知道需要多少个标志；对标志命名不合理；需要 BitSet 中的某些特殊操作</strong>。</p><br>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java编程思想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Java编程思想》笔记16-数组</title>
      <link href="/2018/05/29/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B%E7%AC%94%E8%AE%B016-%E6%95%B0%E7%BB%84/"/>
      <url>/2018/05/29/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B%E7%AC%94%E8%AE%B016-%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p>数组的优点，不能和现在的泛型容器比。要和它同时期的无泛型的原生容器比。站在Java1.0的时间基准上看，数组至少有三大优势：</p><ul><li>高效（下标随机访问O(1)）</li><li>持有特定类型（无泛型容器只能持有Object）</li><li>能持有基本型</li></ul><p>但现在有泛型容器，也已经编译器类型检查。而且直接有“自动包装机制”，容器持有基本型不成问题。数组只剩下高效一个优点了。但因为数组有长度限制，而且容器功能更多。所以现在普遍都用容器。</p><a id="more"></a><h1 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h1><p>使用 <code>Arrays.deepToString()</code> 将多维数组转换为多个 String。</p><h1 id="数组与泛型"><a href="#数组与泛型" class="headerlink" title="数组与泛型"></a>数组与泛型</h1><p>通常，数组与泛型不能很好结合，你不能实例化具有参数化类型的数组。</p><pre><code class="java">Peel&lt;Banana&gt;[] peels = new Peel&lt;&gt;[10]; //不合法</code></pre><p>擦除会移除参数类型信息，而数组必须知道它们所持有的确切类型，以强制保证类型安全。</p><p>但是它允许你创建对这种数组的引用。你可以创建非泛型的数组，然后将其转型。</p><pre><code class="java">public class ArrayOfGenerics {  public static void main(String[] args) {    List&lt;String&gt;[] ls;    List[] la = new List[10];    ls = (List&lt;String&gt;[])la; // &quot;Unchecked&quot; warning    ls[0] = new ArrayList&lt;String&gt;();    //! ls[1] = new ArrayList&lt;Integer&gt;();    // 数组是协变类型的，因此 List&lt;String&gt;[] 也是一个 Object[]，    // 并且利用这点可以把 ArrayList&lt;Integer&gt;赋值到数组中，不会有任何编译期或运行时错误。    // 如果知道将来不会向上转型，并且需求也相对比较简单，那么你仍旧可以创建泛型数组。    Object[] objects = ls; // OK    objects[1] = new ArrayList&lt;Integer&gt;();  }}</code></pre><h1 id="填充数组"><a href="#填充数组" class="headerlink" title="填充数组"></a>填充数组</h1><p><code>Arrays.fill()</code> 标准类库的 fill() 只能用同一个值填充各个位置。</p><pre><code class="java">int[] i=new int[10];Arrays.fill(i,9); // [9,9,9,9,9,9,9,9,9,9]</code></pre><h1 id="Arrays-实用功能"><a href="#Arrays-实用功能" class="headerlink" title="Arrays 实用功能"></a>Arrays 实用功能</h1><h2 id="复制数组"><a href="#复制数组" class="headerlink" title="复制数组"></a>复制数组</h2><h3 id="System-arraycopy"><a href="#System-arraycopy" class="headerlink" title="System.arraycopy()"></a>System.arraycopy()</h3><p>复制数组，比用 for 循环复制要快很多，该方法对所有类型做了重载。</p><p>注意复制对象数组的时候，只是<strong>浅复制</strong>。另外，<code>System.arraycopy()</code> <strong>不会执行自动包装和自动拆包</strong>，两个数组必须具有相同的类型。</p><h3 id="Arrays-copyOf"><a href="#Arrays-copyOf" class="headerlink" title="Arrays.copyOf()"></a>Arrays.copyOf()</h3><p>Arrays.copyOf() 接受两个参数，第一个是源数组，第二个拷贝以后数组的长度。可以用来扩展数组。用起来比 System.arraycopy() 简便，内部调用 System.arraycopy()</p><h3 id="Object-clone"><a href="#Object-clone" class="headerlink" title="Object.clone()"></a>Object.clone()</h3><p>最后一个 Object.clone() 只是<strong>浅复制</strong>，被复制的类需要实现 Clonenable 接口（不实现的话在调用 clone 方法会抛出 CloneNotSupportedException 异常) 该接口为标记接口（不含任何方法）</p><blockquote><p>由于 Clonable 接口有这么多问题，很多专家级程序员干脆从来不去覆盖 clone 方法。————《Effective Java》P52</p></blockquote><h2 id="数组的比较"><a href="#数组的比较" class="headerlink" title="数组的比较"></a>数组的比较</h2><p><code>Arrays.equals()</code>: 相等的条件：元素个数相等，对应位置的元素也相等。</p><h2 id="在已排序的数组中查找"><a href="#在已排序的数组中查找" class="headerlink" title="在已排序的数组中查找"></a>在已排序的数组中查找</h2><p>排序，比较，对象实现了 Comparable 接口，或具有相关联的 Comparator。</p><p>如果使用 Comparator 排序对象数组（基本类型数组无法使用 Comparator 进行排序）了，<strong>使用 binarySearch 对对象数组进行排序的时候必须提供同样的 Comparator</strong>。</p><pre><code class="java">int index = Arrays.binarySearch(sa, sa[10], String.CASE_INSENSITIVE_ORDER);</code></pre><br>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java编程思想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 识别验证码‎</title>
      <link href="/2018/05/28/Python%20%E8%AF%86%E5%88%AB%E9%AA%8C%E8%AF%81%E7%A0%81/"/>
      <url>/2018/05/28/Python%20%E8%AF%86%E5%88%AB%E9%AA%8C%E8%AF%81%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol><li><p><code>Tesseract-OCR</code><br> 链接：<a href="https://www.jianshu.com/p/9e97c9b7dab6" target="_blank" rel="noopener">https://www.jianshu.com/p/9e97c9b7dab6</a><br> 源码编译：可参照官方 <a href="https://github.com/tesseract-ocr/tesseract/wiki/Compiling" target="_blank" rel="noopener">Wiki</a><br> windows：安装包可以在 <a href="https://sourceforge.net/projects/tesseract-ocr-alt/files/" target="_blank" rel="noopener">Sourceforge</a> 上下载，不过只有 3.02 版本的安装包<br> Linux：以 Ubuntu 为例，在终端输入 <code>sudo apt-get tesseract-ocr</code> 即可进行安装</p></li><li><p><code>pytesseract</code>，<code>Pillow</code>，pip 安装即可 <code>pip install pytesseract</code> <code>pip install Pillow</code></p></li></ol><p>识别率较低。</p><a id="more"></a><h2 id="图片处理"><a href="#图片处理" class="headerlink" title="图片处理"></a>图片处理</h2><pre><code class="py"># 降噪，图片二值化，为了消除背景对文字的影响，可以通过设置一个阈值来将文字与背景分隔开来。# 这里将阈值设置为 140，然后将大于阈值的像素置 1，小于阈值的置 0。def initTable(threshold=140):    table = []    for i in range(256):        if i &lt; threshold:            table.append(0)        else:            table.append(1)    return tablei = Image.open(BytesIO(r.content))i = i.convert(&#39;L&#39;) # 将彩色图像转化为灰度图binaryImage = i.point(initTable(), &#39;1&#39;) # im.point() 可以将灰度图二值化# binaryImage.show() # 打开图片</code></pre><h2 id="识别文本"><a href="#识别文本" class="headerlink" title="识别文本"></a>识别文本</h2><p>可以通过 <code>pytesseract</code> 的 <code>image_to_string()</code> 函数将图片转化为文本，该函数还可以接受参数 config，config 设置的是 Tesseract-OCR 引擎的参数，可自行查阅引擎的帮助文本。不过我们只需要用到 psm 参数，具体的 psm 参数值如下：</p><pre><code class="shell">-psm N    Set Tesseract to only run a subset of layout analysis and assume a certain form of image. The options for N are:    0 = Orientation and script detection (OSD) only.    1 = Automatic page segmentation with OSD.    2 = Automatic page segmentation, but no OSD, or OCR.    3 = Fully automatic page segmentation, but no OSD. (Default)    4 = Assume a single column of text of variable sizes.    5 = Assume a single uniform block of vertically aligned text.    6 = Assume a single uniform block of text.    7 = Treat the image as a single text line.    8 = Treat the image as a single word.    9 = Treat the image as a single word in a circle.    10 = Treat the image as a single character.</code></pre><p>识别图片的代码：</p><pre><code class="py">print(pytesseract.image_to_string(binaryImage, config=&#39;-psm 7&#39;))</code></pre><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><pre><code class="py"># 降噪，图片二值化，为了消除背景对文字的影响，可以通过设置一个阈值来将文字与背景分隔开来。# 这里将阈值设置为 140，然后将大于阈值的像素置 1，小于阈值的置 0。def initTable(threshold=140):    table = []    for i in range(256):        if i &lt; threshold:            table.append(0)        else:            table.append(1)    return table# 验证码处理，去掉识别出来的空格特殊字符等，仅保留字母和数字codePattern = re.compile(r&#39;[^a-zA-Z0-9]&#39;)def replaceCode(code):    return codePattern.sub(&#39;&#39;, code)# 获得验证码def vcode(req):    posturl = baseURL + &quot;varpic.do&quot;    r = req.get(posturl, headers=headers) # 获得验证码图片    i = Image.open(BytesIO(r.content))    i = i.convert(&#39;L&#39;) # 将彩色图像转化为灰度图    binaryImage = i.point(initTable(), &#39;1&#39;) # im.point() 可以将灰度图二值化    # binaryImage.show() # 打开图片    code = pytesseract.image_to_string(binaryImage, config=&#39;-psm 7&#39;)    code = replaceCode(code)    return code</code></pre><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.jianshu.com/p/9e97c9b7dab6" target="_blank" rel="noopener">Python 识别验证码</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Selenium 简介‎</title>
      <link href="/2018/05/28/Selenium%E7%AE%80%E4%BB%8B/"/>
      <url>/2018/05/28/Selenium%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<p>Selenium 是什么？一句话，自动化测试工具。它支持各种浏览器，包括 Chrome，Safari，Firefox 等主流界面式浏览器，如果你在这些浏览器里面安装一个 Selenium 的插件，那么便可以方便地实现 Web 界面的测试。</p><p><a href="http://selenium-python.readthedocs.io/index.html" target="_blank" rel="noopener">Selenium Python 文档</a>，<a href="https://selenium-python-zh.readthedocs.io/en/latest/" target="_blank" rel="noopener">中文版</a></p><p><a href="https://www.seleniumhq.org/docs/index.jsp" target="_blank" rel="noopener">Selenium 官网</a></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p><code>pip install selenium</code></p><p><a href="https://sites.google.com/a/chromium.org/chromedriver/downloads" target="_blank" rel="noopener">Chrome 浏览器驱动</a><br><a href="https://github.com/mozilla/geckodriver/releases" target="_blank" rel="noopener">Firefox 浏览器驱动</a><br><a href="http://selenium-release.storage.googleapis.com/index.html" target="_blank" rel="noopener">IE 浏览器驱动</a>，IE 其他相关配置参考：<a href="https://www.jianshu.com/p/169e05c8dad6" target="_blank" rel="noopener">Selenium 3.0 WebDriver IEDriverServer配置</a><br><a href="https://developer.microsoft.com/en-us/microsoft-edge/tools/webdriver/" target="_blank" rel="noopener">Edge 浏览器驱动</a>，根据自己电脑的操作系统版本来决定下载哪个版本的 webdriver</p><p>然后将驱动文件路径配置在环境变量下，或者当前目录下。</p><a id="more"></a><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><pre><code class="py">import requestsfrom selenium import webdriverfrom selenium.webdriver.support import expected_conditionsfrom selenium.webdriver.common.alert import Alertwd = webdriver.Chrome()# wd=webdriver.Firefox() # 使用火狐浏览器# wd = webdriver.Ie() # 使用 IE 浏览器# wd = webdriver.Edge() # 使用 Edge 浏览器wd.get(baseURL + &#39;logon.do&#39;) # 会自动打开浏览器，然后访问</code></pre><h2 id="页面元素"><a href="#页面元素" class="headerlink" title="页面元素"></a>页面元素</h2><pre><code class="py">wd.find_element_by_name(&#39;userName&#39;).send_keys(username) # 获得页面元素并赋值# element = driver.find_elements_by_tag_name(&quot;input&quot;)# element.clear() # 清除输入的文本wd.find_element_by_id(&#39;passWord&#39;).send_keys(password)# wd.find_element_by_name(&#39;validateCode&#39;).send_keys(input(&quot;输入验证码： &quot;))wd.find_element_by_name(&#39;validateCode&#39;).send_keys(vcode(req)) # 验证码自动识别，如无法自动识别使用上面的手动输入wd.find_element_by_xpath(&quot;//*[@id=&#39;loginform&#39;]/form/div[5]/div/input&quot;).click()  # 按钮点击</code></pre><h2 id="Cookies"><a href="#Cookies" class="headerlink" title="Cookies"></a>Cookies</h2><pre><code class="py">req = requests.Session()cookies = wd.get_cookies()for cookie in cookies: # 将 selenium 的 cookie 赋给 requests    req.cookies.set(cookie[&#39;name&#39;], cookie[&#39;value&#39;])cookie = {&#39;name&#39; : &#39;foo&#39;, &#39;value&#39; : &#39;bar&#39;}wd.add_cookie(cookie) # 添加 Cookies</code></pre><h2 id="alert"><a href="#alert" class="headerlink" title="alert"></a>alert</h2><pre><code class="py">if expected_conditions.alert_is_present()(wd): # 判断是否有alert    alert = Alert(wd)  # 获取弹出窗口    text1 = alert.text  # 获取窗口文本信息    print(text1)    alert.accept()  # 确认    # alert.dismiss()  # Confirm 取消    # alert.send_keys(keysToSend)  # Prompt 输入信息    # alert.authenticate(username, password)  # 用户认证信息登录，已有确认操作</code></pre><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p><a href="https://cuiqingcai.com/2599.html" target="_blank" rel="noopener">Python 爬虫利器五之 Selenium 的用法</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Java编程思想》笔记15-泛型</title>
      <link href="/2018/05/25/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B%E7%AC%94%E8%AE%B015-%E6%B3%9B%E5%9E%8B/"/>
      <url>/2018/05/25/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B%E7%AC%94%E8%AE%B015-%E6%B3%9B%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h1><p>如果使用泛型方法可以取代将整个类泛型化，那么就应该只使用泛型方法，因为它可以使事情更清楚明白。</p><p>对于一个 static 方法，无法访问泛型类的类型参数。</p><pre><code class="java">public &lt;T&gt; void function(T i){}  //将泛型参数列表置于返回类型之前</code></pre><a id="more"></a><h2 id="类型参数推断"><a href="#类型参数推断" class="headerlink" title="类型参数推断"></a>类型参数推断</h2><pre><code class="java">public class New {  public static &lt;K,V&gt; Map&lt;K,V&gt; map() {    return new HashMap&lt;K,V&gt;();  }  public static void f(Map&lt;Person, List&lt;? extends Pet&gt;&gt; petPeople) {}  public static void main(String[] args) {    Map&lt;String, List&lt;String&gt;&gt; sls = New.map();    Map&lt;Person, List&lt;? extends Pet&gt;&gt; petPeople = New.map();    f(petPeople);    //f(New.map()); // 无法编译    f(New.&lt;Person, List&lt;? extends Pet&gt;&gt;map()); // 显示指明类型  }}</code></pre><p>类型推断只对赋值操作有效，其他时候不一定有作用，将 New.map() 作为参数传递给另一个方法，并不会执行类型推断。</p><h2 id="Java7-的泛型类型推断改进"><a href="#Java7-的泛型类型推断改进" class="headerlink" title="Java7 的泛型类型推断改进"></a>Java7 的泛型类型推断改进</h2><p><a href="https://my.oschina.net/benhaile/blog/184390" target="_blank" rel="noopener">Java 8新特性探究（六）泛型的目标类型推断</a></p><p>在以前的版本中使用泛型类型，需要在声明并赋值的时候，两侧都加上泛型类型。例如：</p><pre><code class="java">Map&lt;String, String&gt; myMap = new HashMap&lt;String, String&gt;();</code></pre><p>在Java SE 7中，这种方式得以改进，现在你可以使用如下语句进行声明并赋值：</p><pre><code class="java">Map&lt;String, String&gt; myMap = new HashMap&lt;&gt;(); //注意后面的 &quot;&lt;&gt;&quot;，加上这个 &quot;&lt;&gt;&quot; 才表示是自动类型推断</code></pre><p>但是：Java7 在创建泛型实例时的类型推断是有限制的：只有构造器的参数化类型在上下文中被显著的声明了，才可以使用类型推断，否则不行。例如：下面的例子在 Java7 无法正确编译（但现在在 Java8 里面可以编译，因为根据方法参数来自动推断泛型的类型）：</p><pre><code class="java">List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;A&quot;);// 由于addAll期望获得Collection&lt;? extends String&gt;类型的参数，因此下面的语句无法通过list.addAll(new ArrayList&lt;&gt;());</code></pre><h2 id="Java8-的泛型类型推断改进"><a href="#Java8-的泛型类型推断改进" class="headerlink" title="Java8 的泛型类型推断改进"></a>Java8 的泛型类型推断改进</h2><p>上文中 <code>f(New.map());</code> 可以编译通过。</p><pre><code class="java">static void processStringList(List&lt;String&gt; stringList) {    // process stringList}processStringList(Collections.emptyList());processStringList(Collections.&lt;String&gt; emptyList()); //低版本</code></pre><h1 id="擦除"><a href="#擦除" class="headerlink" title="擦除"></a>擦除</h1><pre><code class="java">public class HasF {  public void f() { System.out.println(&quot;HasF.f()&quot;); }}</code></pre><pre><code class="java">class Manipulator&lt;T&gt; {  private T obj;  public Manipulator(T x) { obj = x; }  // Error: cannot find symbol: method f():  public void manipulate() { obj.f(); } // 编译不通过}public class Manipulation {  public static void main(String[] args) {    HasF hf = new HasF();    Manipulator&lt;HasF&gt; manipulator = new Manipulator&lt;HasF&gt;(hf);    manipulator.manipulate();  }}</code></pre><p>上面的代码没有通过编译，就是由于擦除，会将 T 替换为 Object，这样就没法调用 f() 方法了。可以使用边界来解决这个问题。</p><pre><code class="java">class Manipulator&lt;T extends HasF&gt; {  private T obj;  public Manipulator(T x) { obj = x; }  public void manipulate() { obj.f(); }}</code></pre><h2 id="擦除的问题"><a href="#擦除的问题" class="headerlink" title="擦除的问题"></a>擦除的问题</h2><p>泛型不能用于显式地引用运行时类型的操作之中，例如转型、instanceof 操作和 new 表达式（不能 new T()）。因为类型信息会丢失，必须时刻提醒自己，只是看起来像拥有有关参数的类型信息而已。</p><p>在整个类的各个地方，类型 T 都在被替换，无论何时，必须时刻提醒自己“<strong>它只是个 Object</strong>”。</p><p>泛型中的所有动作都发生在边界处————对传递进来的值进行额外的编译期检查，并插入对传递出去的值的转型。这有助于澄清对擦除的混淆，记住，“<strong>边界就是发生动作的地方</strong>”。</p><h1 id="擦除的补偿"><a href="#擦除的补偿" class="headerlink" title="擦除的补偿"></a>擦除的补偿</h1><p>Java 泛型在 instanceof、创建类型实例，创建数组、转型时都会有问题。</p><pre><code class="java">public class Erased&lt;T&gt; {  public void f(Object arg) { // 书中    if(arg instanceof T) {}          // Error    T var = new T();                 // Error    T[] array = new T[10];         // Error    T[] array = (T)new Object[10]; // Unchecked warning  }}</code></pre><p>有时必须通过引入类型标签（即你的类型的 Class 对象）进行补偿。使用动态的 isInstance() 方法，而不是 instanceof。</p><pre><code class="java">class Building {}class House extends Building {}public class ClassTypeCapture&lt;T&gt; {  Class&lt;T&gt; kind;  public ClassTypeCapture(Class&lt;T&gt; kind) {    this.kind = kind;  }  public boolean f(Object arg) {    return kind.isInstance(arg);  }  public static void main(String[] args) {    ClassTypeCapture&lt;Building&gt; ctt1 = new ClassTypeCapture&lt;Building&gt;(Building.class);    System.out.println(ctt1.f(new Building()));    System.out.println(ctt1.f(new House()));    ClassTypeCapture&lt;House&gt; ctt2 = new ClassTypeCapture&lt;House&gt;(House.class);    System.out.println(ctt2.f(new Building()));    System.out.println(ctt2.f(new House()));  }} /* Output:truetruefalsetrue*///:~</code></pre><h2 id="创建类型实例"><a href="#创建类型实例" class="headerlink" title="创建类型实例"></a>创建类型实例</h2><p>解决方案是传递一个工厂对象，并使用它来创建新的实例。最便利的工厂对象就是 Class 对象。</p><pre><code class="java">class ClassAsFactory&lt;T&gt; {  T x;  public ClassAsFactory(Class&lt;T&gt; kind) {    try {      x = kind.newInstance();    } catch (Exception e) {      throw new RuntimeException(e);    }  }}class Employee { }public class InstantiateGenericType {  public static void main(String[] args) {    ClassAsFactory&lt;Employee&gt; fe = new ClassAsFactory&lt;Employee&gt;(Employee.class);    print(&quot;ClassAsFactory&lt;Employee&gt; succeeded&quot;);    try {      ClassAsFactory&lt;Integer&gt; fi = new ClassAsFactory&lt;Integer&gt;(Integer.class);    } catch (Exception e) {      print(&quot;ClassAsFactory&lt;Integer&gt; failed&quot;);    }  }}</code></pre><p>但是对于没有默认构造器的类，上述方法不能奏效了。可以使用显示的工厂。</p><pre><code class="java">interface FactoryI&lt;T&gt; {  T create();}public class Foo2&lt;T&gt; {  private T x;  public &lt;F extends FactoryI&lt;T&gt;&gt; Foo2(F factory) {    x = factory.create();  }  public static void main(String[] args) {    new Foo2&lt;Integer&gt;(new IntegerFactory());    new Foo2&lt;Widget&gt;(new Widget.Factory());  }}class IntegerFactory implements FactoryI&lt;Integer&gt; {  public Integer create() {    return new Integer(0);  }}class Widget {  public static class Factory implements FactoryI&lt;Widget&gt; {    public Widget create() {      return new Widget();    }  }}</code></pre><p>另一种方式是模板方法设计模式。</p><pre><code class="java">abstract class GenericWithCreate&lt;T&gt; {  final T element;  GenericWithCreate() { element = create(); }  abstract T create();}class X {}class Creator extends GenericWithCreate&lt;X&gt; {  X create() { return new X(); }  void f() {    System.out.println(element.getClass().getSimpleName());  }}public class CreatorGeneric {  public static void main(String[] args) {    Creator c = new Creator();    c.f();  }} /* Output:X*///:~</code></pre><h2 id="泛型数组"><a href="#泛型数组" class="headerlink" title="泛型数组"></a>泛型数组</h2><p>解决方案是在任何想要创建泛型数组的地方都<strong>使用 ArrayList</strong>。</p><p>如果非要用泛型数组，可以创建Object数组，然后转型。但是如果返回该泛型数组还是需要再进行一次转型。</p><pre><code class="java">T[] array;public Constructor(int sz){  array = (T[]) new Object[sz];}</code></pre><p>使用类型标记</p><pre><code class="java">T[] array;public Constructor(Class&lt;T&gt; type, int sz){    array = (T[]) Array.newInstance(type, sz);}</code></pre><h1 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h1><pre><code class="java">interface HasColor { }class Colored&lt;T extends HasColor&gt; { }class Dimension { }// 编译不通过，class 必须在前// class ColoredDimension&lt;T extends HasColor &amp; Dimension&gt; {// Multiple bounds:class ColoredDimension&lt;T extends Dimension &amp; HasColor&gt; { }interface Weight { }// 只能有一个类，可以有多个接口class Solid&lt;T extends Dimension &amp; HasColor &amp; Weight&gt; { }</code></pre><h1 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h1><pre><code class="java">class Fruit {}class Apple extends Fruit {}class Jonathan extends Apple {}class Orange extends Fruit {}public class CovariantArrays {  public static void main(String[] args) {    Fruit[] fruit = new Apple[10]; // 向上转型不合适这里    fruit[0] = new Apple(); // OK    fruit[1] = new Jonathan(); // OK    fruit[0] = new Fruit(); // ArrayStoreException    fruit[0] = new Orange(); // ArrayStoreException    List&lt;Fruit&gt; flist = new ArrayList&lt;Apple&gt;(); // 编译错误    List&lt;? extends Fruit&gt; flist = new ArrayList&lt;Apple&gt;();    // 添加任何类型，都是编译失败    // flist.add(new Apple());    // flist.add(new Fruit());    // flist.add(new Object());    flist.add(null); // 合法    Fruit f = flist.get(0);    List&lt;? extends Fruit&gt; flist2 = Arrays.asList(new Apple());    Apple a = (Apple) flist2.get(0);    flist2.contains(new Apple()); // contains() 和 indexOf() 方法接受 Object 类型的参数    flist2.indexOf(new Apple());  }}</code></pre><h2 id="逆变"><a href="#逆变" class="headerlink" title="逆变"></a>逆变</h2><p>超类型通配符。可以声明通配符是由某个特定类的任何基类来界定的，方法是指定 <code>&lt;? super MyClass&gt;</code>，可以使用类型参数：<code>&lt;? super T&gt;</code> (<strong>不能声明类型参数为<code>&lt;T super MyClass&gt;</code></strong>)</p><pre><code class="java">List&lt;? super Apple&gt; flist = new ArrayList&lt;&gt;();flist.add(new Apple());flist.add(new Jonathan());//flist.add(new Fruit()); //Compile Error</code></pre><p>Apple 是下界，这样你就知道向其中添加 Apple 或 Apple 的子类型是安全的，而添加 Fruit 是不安全的了。</p><h2 id="无界通配符"><a href="#无界通配符" class="headerlink" title="无界通配符"></a>无界通配符</h2><p>无界通配符 <code>&lt;?&gt;</code> 看起来意味着“任何事物”，因此使用无界通配符好像等价于使用原生类型。</p><p>List 实际上表示“持有任何 Object 类型的原生 List”，而 List&lt;?&gt; 表示“具有某种特定类型的非原生 List，只是我们不知道那种类型是什么。”</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="任何基本类型都不能作为类型参数"><a href="#任何基本类型都不能作为类型参数" class="headerlink" title="任何基本类型都不能作为类型参数"></a>任何基本类型都不能作为类型参数</h2><p>解决之道是自动包装机制。但是自动包装机制不能作用于数组。</p><p>类泛型无法在静态方法中工作。</p><pre><code class="java">public class ByteSet {  Byte[] possibles = { 1,2,3,4,5,6,7,8,9 };  Set&lt;Byte&gt; mySet = new HashSet&lt;Byte&gt;(Arrays.asList(possibles));  // 不能这样  // Set&lt;Byte&gt; mySet2 = new HashSet&lt;Byte&gt;(Arrays.&lt;Byte&gt;asList(1,2,3,4,5,6,7,8,9));} ///:~</code></pre><p>专门适配基本类型的容器版本，org.apache.commons.collections.primitives</p><h2 id="实现参数化接口"><a href="#实现参数化接口" class="headerlink" title="实现参数化接口"></a>实现参数化接口</h2><p>一个类不能同时实现同一个泛型接口的两种变体，由于擦除的原因，这两个变体会变成相同的接口。</p><pre><code class="java">interface Payable&lt;T&gt;{}class Employee implements Payable&lt;Employee&gt; {}class Hourly extends Employee implements Payable&lt;Hourly&gt; {} // 编译失败，如果把泛型都去掉，就可以了</code></pre><h2 id="转型和警告"><a href="#转型和警告" class="headerlink" title="转型和警告"></a>转型和警告</h2><p>泛型没有消除对转型的需要。</p><pre><code class="java">ObjectInputStream in = new ObjectInputStream(new FileInputStream(args[0]));List&lt;Widget&gt; shapes = (List&lt;Widget&gt;)in.readObject(); // 警告List&lt;Widget&gt; lw = List&lt;Widget&gt;.class.cast(in.readObject()); // 编译失败List&lt;Widget&gt; lw = (List&lt;Widget&gt;)List.class.cast(in.readObject()); // 警告List&lt;Widget&gt; lw = List.class.cast(in.readObject()); // 通过泛型类来转型</code></pre><h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><p>由于擦除的原因，重载方法将产生相同的类型签名。</p><pre><code class="java">void f(List&lt;T&gt; v);void f(List&lt;W&gt; v); // 编译失败</code></pre><h2 id="基类劫持了接口"><a href="#基类劫持了接口" class="headerlink" title="基类劫持了接口"></a>基类劫持了接口</h2><pre><code class="java">public class ComparablePet implements Comparable&lt;ComparablePet&gt; {  public int compareTo(ComparablePet arg) { return 0; }} ///:~class Cat extends ComparablePet implements Comparable&lt;Cat&gt;{  // 编译失败  public int compareTo(Cat arg) { return 0; }} ///:~</code></pre><h1 id="自限定的类型"><a href="#自限定的类型" class="headerlink" title="自限定的类型"></a>自限定的类型</h1><pre><code class="java">class SelfBounded&lt;T extends Selfbounded&lt;T&gt;&gt;{}</code></pre><p>古怪的循环泛型（CRG）：基类用导出类替代其参数。这意味着泛型基类变成了一种其所有导出类的公共功能的模板，但是这些功能对于其所有参数和返回值，将使用导出类型。</p><pre><code class="java">public class BasicHolder&lt;T&gt; {  T element;  void set(T arg) { element = arg; }  T get() { return element; }  void f() {    System.out.println(element.getClass().getSimpleName());  }} ///:~class Subtype extends BasicHolder&lt;Subtype&gt; {}public class CRGWithBasicHolder {  public static void main(String[] args) {    Subtype st1 = new Subtype(), st2 = new Subtype();    st1.set(st2);    Subtype st3 = st1.get();    st1.f();  }} /* Output:Subtype*///:~</code></pre><h2 id="自限定"><a href="#自限定" class="headerlink" title="自限定"></a>自限定</h2><p>可以保证类型参数必须与正在被定义的类相同。</p><pre><code class="java">class SelfBounded&lt;T extends SelfBounded&lt;T&gt;&gt; {  T element;  SelfBounded&lt;T&gt; set(T arg) {    element = arg;    return this;  }  T get() { return element; }}class A extends SelfBounded&lt;A&gt; {}class B extends SelfBounded&lt;A&gt; {} // Also OKclass C extends SelfBounded&lt;C&gt; {  C setAndGet(C arg) { set(arg); return get(); }}class D {}// Can&#39;t do this:// class E extends SelfBounded&lt;D&gt; {}// Compile error: Type parameter D is not within its bound// Alas, you can do this, so you can&#39;t force the idiom:class F extends SelfBounded {}</code></pre><p>自限定限制只能作用于继承关系。</p><h1 id="动态类型安全"><a href="#动态类型安全" class="headerlink" title="动态类型安全"></a>动态类型安全</h1><p>java.util.Collections 中提供来一组便利工具，可以解决类型检查的问题。它们是：静态方法 checkedCollection()、checkedList()、checkedMap()、checkedSet()、checkedSortedMap() 和 checkedSortedSet()。这些方法每一个都会将你希望动态检查的容器当做第一个参数接受，并将你希望强制要求的类型作为第二个参数接受。如果向Java SE5 之前的代码传递泛型容器，可能会导致类似“将猫插入狗队列”的问题，使用这些方法可以确保不出现这种问题。</p><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p>由于擦除的原因，将泛型应用于异常是非常受限的。catch 语句不能捕获泛型类型的异常，泛型类也不能直接或间接继承自 Throwable。但是，类型参数可能会在一个方法的 throws 子句中用到。</p><pre><code class="java">interface Processor&lt;T,E extends Exception&gt;{    void process(List&lt;T&gt; resultCollector) throws E;}</code></pre><p>剩余部分看着有点懵...</p><br>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java编程思想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python AES 加密 pycrypto‎</title>
      <link href="/2018/05/18/Python%20AES%20%E5%8A%A0%E5%AF%86%20pycrypto%E2%80%8E/"/>
      <url>/2018/05/18/Python%20AES%20%E5%8A%A0%E5%AF%86%20pycrypto%E2%80%8E/</url>
      
        <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>有多种方式：</p><ol><li>Windows 下 exe 文件，<a href="http://www.voidspace.org.uk/python/modules.shtml#pycrypto" target="_blank" rel="noopener">下载地址</a>，如果有报错，可以下载 <a href="https://www.microsoft.com/en-us/download/details.aspx?id=44266" target="_blank" rel="noopener">VCForPython27</a></li><li><code>pip install pycrypto</code>，可能会报错 microsoft visual c++ 14.0 is required，查看 <a href="https://wiki.python.org/moin/WindowsCompilers" target="_blank" rel="noopener">https://wiki.python.org/moin/WindowsCompilers</a> ，需要下载 Visual Studio，最后采用了第三种方法。</li><li><code>pip install pycrypto‎dome</code>，GitHub ：<a href="https://github.com/Legrandin/pycryptodome" target="_blank" rel="noopener">https://github.com/Legrandin/pycryptodome</a></li></ol><a id="more"></a><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="python-2-7"><a href="#python-2-7" class="headerlink" title="python 2.7"></a>python 2.7</h3><p>参考 <a href="https://stackoverflow.com/questions/12524994/encrypt-decrypt-using-pycrypto-aes-256/12525165#12525165" target="_blank" rel="noopener">https://stackoverflow.com/questions/12524994/encrypt-decrypt-using-pycrypto-aes-256/12525165#12525165</a></p><pre><code class="py"># -*- coding: utf-8 -*import timefrom binascii import b2a_hex, a2b_hexfrom Crypto.Cipher import AESBS = AES.block_size# 加密算法pad = lambda s: s + (BS - len(s) % BS) * chr(BS - len(s) % BS)# 解密算法unpad = lambda s: s[:-ord(s[len(s) - 1:])]class AESCipher:    def __init__(self, key):        self.key = key        self.iv = b&#39;0102030405060708&#39;    # 加密    def encrypt(self, raw):        raw = pad(raw)        cipher = AES.new(self.key, AES.MODE_CBC, self.iv)        return b2a_hex(cipher.encrypt(raw))    # 解密    def decrypt(self, enc):        cipher = AES.new(self.key, AES.MODE_CBC, self.iv)        return unpad(cipher.decrypt(a2b_hex(enc)))timeStamp = str(int(time.time()))key = b&#39;AD0001&#39; + timeStampaa = AESCipher(key)s = aa.encrypt(&#39;123456&#39;)print(&quot;加密：&quot; + s)ss = aa.decrypt(s)print(&quot;解密：&quot; + ss)</code></pre><h3 id="python-3-6"><a href="#python-3-6" class="headerlink" title="python 3.6"></a>python 3.6</h3><pre><code class="py"># -*- coding: utf-8 -*import timefrom binascii import b2a_hex, a2b_hexfrom Crypto.Cipher import AESBS = AES.block_size# 加密算法pad = lambda s: s + (BS - len(s) % BS) * chr(BS - len(s) % BS)# 解密算法unpad = lambda s: s[:-ord(s[len(s) - 1:])]class AESCipher:    def __init__(self, key):        self.key = key        self.iv = b&#39;0102030405060708&#39;    # 加密    def encrypt(self, raw):        raw = pad(raw).encode(&quot;utf-8&quot;) # 1        cipher = AES.new(self.key, AES.MODE_CBC, self.iv)        return b2a_hex(cipher.encrypt(raw))    # 解密    def decrypt(self, enc):        cipher = AES.new(self.key, AES.MODE_CBC, self.iv)        return unpad(cipher.decrypt(a2b_hex(enc)))timeStamp = str(int(time.time()))key = bytes(&quot;AD0001&quot;+timeStamp,&#39;utf-8&#39;) # 2aa = AESCipher(key)s = aa.encrypt(&#39;123456&#39;)print(&quot;加密：&quot; + str(s, encoding=&quot;utf-8&quot;)) # 3ss = aa.decrypt(s)print(&quot;解密：&quot; + str(ss, encoding=&quot;utf-8&quot;)) # 4</code></pre><p>由 python 2.7 版本修改至 python 3.6 版本。</p><ul><li>注释 1，如果不修改会报错 <code>TypeError: Object type &lt;class &#39;str&#39;&gt; cannot be passed to C code</code>，感谢 <a href="https://stackoverflow.com/questions/46052752/using-aes-encrypt-get-raise-typeerroronly-byte-strings-can-be-passed-to-c-code" target="_blank" rel="noopener">https://stackoverflow.com/questions/46052752/using-aes-encrypt-get-raise-typeerroronly-byte-strings-can-be-passed-to-c-code</a></li><li>注释 2，报错同注释 1，key 的类型需要是 bytes。</li><li>注释 3，4，如果不修改会报错 <code>TypeError: must be str, not bytes</code>，类型转换下即可。</li></ul><br>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Java编程思想》笔记14-类型信息</title>
      <link href="/2018/05/08/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B%E7%AC%94%E8%AE%B014-%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF/"/>
      <url>/2018/05/08/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B%E7%AC%94%E8%AE%B014-%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF/</url>
      
        <content type="html"><![CDATA[<p><strong>运行时类型信息</strong>使得你可以在程序运行时发现和使用类型信息。</p><p>Java 是如何让我们在运行时识别对象和类的信息的。主要是两种方式：</p><ol><li>“传统的”RTTI，它假定我们在编译时就已经知道了所有的类型。</li><li>“反射”机制，运行我们在运行时发现和使用类的信息。</li></ol><a id="more"></a><h1 id="RTTI"><a href="#RTTI" class="headerlink" title="RTTI"></a>RTTI</h1><p>为什么要使用 RTTI：如果想知道某个泛化引用的确切类型，如 list 中存放着多种 Shape ，想将其中的三角形变种颜色。多态无法解决这种问题，使用 RTTI，可以查询某个 Shape 引用所指向的对象的确切类型，然后进行操作。</p><h1 id="Class-对象"><a href="#Class-对象" class="headerlink" title="Class 对象"></a>Class 对象</h1><p>每个类都用一个 Class 对象。为了生成这个类的对象，运行这个程序的 Java 虚拟机（JVM）将使用被称为“类加载器”的子系统。</p><p>当程序创建第一个对类的静态成员的引用时，就会加载这个类（new 也一样，可以理解为构造器也是静态的）初始化。</p><p>如果类中有一个 static final 值是编译期常量，<strong>则不会引发对该类进行初始化就能读取</strong>。</p><h2 id="获取-Class-对象"><a href="#获取-Class-对象" class="headerlink" title="获取 Class 对象"></a>获取 Class 对象</h2><ol><li>Class 类中存在静态方法 <strong>static Class&lt;?&gt; forName(String className)</strong>：返回与带有给定字符串名的类或接口相关联的 Class 对象。<strong>会立即进行初始化</strong>。</li><li><strong>类名.class</strong>：获得 Class 对象引用。<strong>不会引发初始化</strong>。</li><li>如果已经有了该类的对象，调用 getClass() 方法来获得 Class 引用。</li></ol><h2 id="Class-类的常用方法"><a href="#Class-类的常用方法" class="headerlink" title="Class 类的常用方法"></a>Class 类的常用方法</h2><ul><li><strong>String getName()</strong>：返回此类的全限定名（包名+类名）</li><li><strong>String getSimpleName()</strong>：返回此类的类名</li><li><strong>boolean isInterface()</strong>：判定此类是不是接口</li><li><strong>Class&lt;?&gt;[] getInterfaces()</strong>：返回此类实现的接口的 Class 类对象</li><li><strong>Class&lt;? super T&gt; getSuperClass()</strong>：返回表示此 Class 所表示的实体（类、接口、基本类型或 void）的超类的 Class。如果此 Class 表示 Object 类、一个接口、一个基本类型或 void，则返回 null。</li><li><strong>T newInstance()</strong>：返回此类的一个对象。<strong>此类必须有默认构造器</strong>。</li></ul><h2 id="泛化-Class-对象"><a href="#泛化-Class-对象" class="headerlink" title="泛化 Class 对象"></a>泛化 Class 对象</h2><pre><code class="java">Class intClass = int.class;Class&lt;Integer&gt; genericIntClass = int.class;// Class&lt;Number&gt; genericNumberClass = int.class; //编译不通过，因为 Integer.class 不是 Number.class 的子类// 可以用“通配符”来代替。代表随便什么类型的 Class 类对象。Class&lt;?&gt; c = int.class;// Class&lt;?&gt; 等同与平凡的 Class，因为使用 Class&lt;?&gt; 代表了你就是选择了非具体类型的版本，而不是因为疏忽。Class&lt;? extends Number&gt; bounded = int.class; // 该类型或其子类bounded = double.class;bounded = Number.class;</code></pre><pre><code class="java">Class&lt;FancyToy&gt; ftClass = FancyToy.class;FancyToy fancyToy = ftClass.newInstance(); // 可以指定具体类型Class&lt;? super FancyToy&gt; up = ftClass.getSuperclass();// Class&lt;Toy&gt; up2 = ftClass.getSuperclass(); // 无法编译Object obj = up.newInstance(); // 无法指定具体类型</code></pre><h1 id="类型检查"><a href="#类型检查" class="headerlink" title="类型检查"></a>类型检查</h1><h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><p>instanceof 关键字可以判断对象是不是某个类型的实例。</p><pre><code class="java">if (x instanceof Dog) {    ((Dog)x).bark();}</code></pre><h2 id="isInstance"><a href="#isInstance" class="headerlink" title="isInstance()"></a>isInstance()</h2><p>另一种类型检查方式： Class 对象的 isInstance() 方法：检查是否是某个类的实例。</p><pre><code class="java">Triangle t = new Triangle();Class c = Circle.class;c.isInstance(t);</code></pre><h2 id="isAssignableFrom"><a href="#isAssignableFrom" class="headerlink" title="isAssignableFrom"></a>isAssignableFrom</h2><p><strong>boolean isAssignableFrom(Class&lt;?&gt; cls)</strong>：判定此 Class 对象所表示的类或接口与指定的 Class 参数所表示的类或接口是否相同，或是否是其超类或超接口。</p><pre><code class="java">Class s = Pet.class;Class c = Dog.class;c.isAssignableFrom(s); // falses.isAssignableFrom(c); // true</code></pre><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>如果不知道某个对象的具体类型，RTTI 可以告诉你。但是这个类型必须在编译时已知，这样 RTTI 才能识别它。</p><p>有时根本无法获知这个对象的所属类。</p><p>Claas 类与 java.lang.reflect 类库一起对反射提供了支持，该类库包含了：</p><ul><li>Field：用 get() 和 set() 方法读取和修改与 Field 对象关联的字段。</li><li>Method：用 invoke() 方法调用与 Method 相关的方法</li><li>Constructor：可以创建新的对象</li></ul><p>每个类都实现了 Member 接口。</p><p>在 Method 对象上调用 setAccessible(true)，就可以调用所有的方法，包含 private 方法。</p><h2 id="类方法提取器"><a href="#类方法提取器" class="headerlink" title="类方法提取器"></a>类方法提取器</h2><pre><code class="java">public class ShowMethods {  private static Pattern p = Pattern.compile(&quot;\\w+\\.&quot;);  public static void main(String[] args) {    String classname = &quot;ShowMethods&quot;;    try {      Class&lt;?&gt; c = Class.forName(classname);      Method[] methods = c.getMethods();      Constructor[] ctors = c.getConstructors();      for(Method method : methods)        print(p.matcher(method.toString()).replaceAll(&quot;&quot;));      print();      for(Constructor ctor : ctors)        print(p.matcher(ctor.toString()).replaceAll(&quot;&quot;));    } catch(ClassNotFoundException e) {      print(&quot;No such class: &quot; + e);    }  }} /* Output:public static void main(String[])public final void wait() throws InterruptedExceptionpublic final void wait(long,int) throws InterruptedExceptionpublic final native void wait(long) throws InterruptedExceptionpublic boolean equals(Object)public String toString()public native int hashCode()public final native Class getClass()public final native void notify()public final native void notifyAll()public ShowMethods()*///:~</code></pre><h1 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h1><h2 id="代理设计模式"><a href="#代理设计模式" class="headerlink" title="代理设计模式"></a>代理设计模式</h2><pre><code class="java">interface Interface {  void doSomething();  void somethingElse(String arg);}class RealObject implements Interface {  public void doSomething() { print(&quot;doSomething&quot;); }  public void somethingElse(String arg) {    print(&quot;somethingElse &quot; + arg);  }}</code></pre><pre><code class="java">class SimpleProxy implements Interface {  private Interface proxied;  public SimpleProxy(Interface proxied) {    this.proxied = proxied;  }  public void doSomething() {    print(&quot;SimpleProxy doSomething&quot;);    proxied.doSomething();  }  public void somethingElse(String arg) {    print(&quot;SimpleProxy somethingElse &quot; + arg);    proxied.somethingElse(arg);  }}</code></pre><pre><code class="java">public class SimpleProxyDemo {  public static void consumer(Interface iface) {    iface.doSomething();    iface.somethingElse(&quot;bonobo&quot;);  }  public static void main(String[] args) {    consumer(new RealObject());    consumer(new SimpleProxy(new RealObject()));  }} /* Output:doSomethingsomethingElse bonoboSimpleProxy doSomethingdoSomethingSimpleProxy somethingElse bonobosomethingElse bonobo*///:~</code></pre><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>Java 的动态代理比代理的思想更近了一步，因为它可以动态地创建代理并动态地处理对所代理方法的调用。在动态代理上所做的所有调用都会被重定向到单一的调用处理器上，它的工作是揭示调用的类型并确定相应的政策。</p><pre><code class="java">class DynamicProxyHandler implements InvocationHandler {  private Object proxied;  public DynamicProxyHandler(Object proxied) {    this.proxied = proxied;  }  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {    System.out.println(&quot;proxy: &quot; + proxy.getClass() + &quot;, method: &quot; + method + &quot;, args: &quot; + args);    if(args != null)      for(Object arg : args)        System.out.println(&quot;参数值：&quot; + arg);    return method.invoke(proxied, args);  }}public class SimpleDynamicProxy {  public static void consumer(Interface iface) {    iface.doSomething();    iface.somethingElse(&quot;bonobo&quot;);  }  public static void main(String[] args) {    RealObject real = new RealObject();    consumer(real);    Interface proxy = (Interface)Proxy.newProxyInstance(      Interface.class.getClassLoader(),      new Class[]{ Interface.class },      new DynamicProxyHandler(real)); // 创建动态代理    consumer(proxy);  }} /* Output: (95% match)doSomethingsomethingElse bonobo**** proxy: class $Proxy0, method: public abstract void Interface.doSomething(), args: nulldoSomething**** proxy: class $Proxy0, method: public abstract void Interface.somethingElse(java.lang.String), args: [Ljava.lang.Object;@42e816参数值：bonobosomethingElse bonobo*///:~</code></pre><br>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java编程思想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Java编程思想》笔记13-字符串</title>
      <link href="/2018/05/01/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B%E7%AC%94%E8%AE%B013-%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2018/05/01/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B%E7%AC%94%E8%AE%B013-%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="重载-quot-quot-与-StringBuilder"><a href="#重载-quot-quot-与-StringBuilder" class="headerlink" title="重载 &quot;+&quot; 与 StringBuilder"></a>重载 &quot;+&quot; 与 StringBuilder</h1><p>使用 JDK自带的工具 javap 来反编译。<code>javap -c 文件名</code>，这里的 -c 表示将生成 JVM 字节码。</p><p>使用重载 &quot;+&quot;，发现编译器会创建一个 StringBuilder 对象，每次 &quot;+&quot; 会调用一次 StringBuilder 的 append() 方法，最后调用 toString() 方法生成结果。但如果在循环中，每次循环将会生成新的 StringBuilder 对象。</p><pre><code class="java">String s = &quot;&quot;;for (int i=0; i&lt;10; i++&gt;) {  s+=i; // 相当于 StringBuilder sb=new StringBuilder(); sb.append(i);}</code></pre><p>直接使用 StringBuilder，只会生成一个对象，还可以预先指定大小，避免多次重新分配缓冲。</p><a id="more"></a><h1 id="无意识的递归"><a href="#无意识的递归" class="headerlink" title="无意识的递归"></a>无意识的递归</h1><p>如果想要在 toString() 方法中打印出对象的地址，可能会使用 this 关键字，会造成递归。所以应该调用 super.toString() 方法。</p><h1 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h1><h2 id="printf"><a href="#printf" class="headerlink" title="printf()"></a>printf()</h2><p><code>System.out.format()</code> 和 <code>System.out.printf()</code>。这两个是等价的。类似于 C语言的 printf()。</p><pre><code class="java">System.out.println(&quot;Row 1: [&quot;+x+&quot; &quot;+y+&quot; &quot;+z+&quot;]\n&quot;);System.out.printf(&quot;Row 1: [%d %f %s]\n&quot;, x, y, z);System.out.format(&quot;Row 1: [%d %f %s]\n&quot;, x, y, z);</code></pre><h2 id="Formatter"><a href="#Formatter" class="headerlink" title="Formatter"></a>Formatter</h2><p>java.util.Formatter，可以看做是一个翻译器，它将你的格式化字符串于数据翻译成需要的结果。</p><p>Formatter 的构造器通过重载可以接受多种输出目的地，最常用的还是 PrintStream()，OutputStream 和 File。</p><h2 id="格式化说明符"><a href="#格式化说明符" class="headerlink" title="格式化说明符"></a>格式化说明符</h2><p>可以控制空格与对齐。</p><blockquote><p>%[argument_index$][flags][width][.precision][conversion]</p></blockquote><ul><li>argument_index: 一个正整数。标明是第几个参数。&quot;1$&quot; 表示第一个参数 arg1, &quot;2$&quot; 表示第二个参数 arg2，以此类推。</li><li>flags: 格式符。比较常用的几个是：&quot;-&quot; 表示左对齐。&quot; &quot; 空格表示右对齐，前面用空格填满。&quot;0&quot; 右对齐，前面用0填满。</li><li>width: 一个正整数。表示这个域的最小尺寸。不足用空格来补。</li><li>precision: 精度。对不同数据类型的意义不同。对 String 表示字符串的最大长度 <code>%.10s</code>。对 float 和 double 则表示小数部分有几位。不能应用于整数。</li><li>conversion: 转换成什么数据类型来输出。之前的 %d 这样的占位符，其实就是中间其他参数省略的结果，最后的 conversion 直接跟在 % 后面。</li></ul><pre><code class="java">public class Receipt {  private double total = 0;  private Formatter f = new Formatter(System.out);  public void printTitle() {    f.format(&quot;%-15s %5s %10s\n&quot;, &quot;Item&quot;, &quot;Qty&quot;, &quot;Price&quot;);    f.format(&quot;%-15s %5s %10s\n&quot;, &quot;----&quot;, &quot;---&quot;, &quot;-----&quot;);  }  public void print(String name, int qty, double price) {    f.format(&quot;%-15.15s %5d %10.2f\n&quot;, name, qty, price);    total += price;  }  public void printTotal() {    f.format(&quot;%-15s %5s %10.2f\n&quot;, &quot;Tax&quot;, &quot;&quot;, total*0.06);    f.format(&quot;%-15s %5s %10s\n&quot;, &quot;&quot;, &quot;&quot;, &quot;-----&quot;);    f.format(&quot;%-15s %5s %10.2f\n&quot;, &quot;Total&quot;, &quot;&quot;,      total * 1.06);  }  public static void main(String[] args) {    Receipt receipt = new Receipt();    receipt.printTitle();    receipt.print(&quot;Jack&#39;s Magic Beans&quot;, 4, 4.25);    receipt.print(&quot;Princess Peas&quot;, 3, 5.1);    receipt.print(&quot;Three Bears Porridge&quot;, 1, 14.29);    receipt.printTotal();  }} /* Output:Item              Qty      Price----              ---      -----Jack&#39;s Magic Be     4       4.25Princess Peas       3       5.10Three Bears Por     1      14.29Tax                         1.42                           -----Total                      25.06*///:~</code></pre><h2 id="conversion"><a href="#conversion" class="headerlink" title="conversion"></a>conversion</h2><table><thead><tr><th align="center">转换</th><th align="center">参数类别</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">b, B</td><td align="center">常规</td><td align="center">如果参数为 null，则结果为 &quot;false&quot;，否则结果为 &quot;true&quot;。</td></tr><tr><td align="center">h, H</td><td align="center">常规</td><td align="center">结果为调用 Integer.toHexString(arg.hashCode()) 得到的结果。</td></tr><tr><td align="center">s, S</td><td align="center">常规</td><td align="center">String</td></tr><tr><td align="center">c, C</td><td align="center">字符</td><td align="center">结果是一个 Unicode 字符</td></tr><tr><td align="center">d</td><td align="center">整数</td><td align="center">十进制整数</td></tr><tr><td align="center">o</td><td align="center">整数</td><td align="center">八进制整数</td></tr><tr><td align="center">x, X</td><td align="center">整数</td><td align="center">十六进制整数</td></tr><tr><td align="center">e, E</td><td align="center">浮点</td><td align="center">用计算机科学记数法表示的十进制数</td></tr><tr><td align="center">f</td><td align="center">浮点</td><td align="center">十进制数</td></tr><tr><td align="center">t, &#39;T&#39;</td><td align="center">日期/时间</td><td align="center">日期和时间转换字符的前缀。</td></tr><tr><td align="center">%</td><td align="center">百分比</td><td align="center">结果为字面值 &#39;%&#39; (&#39;\u0025&#39;)</td></tr><tr><td align="center">n</td><td align="center">行分隔符</td><td align="center">结果为特定于平台的行分隔符</td></tr></tbody></table><h2 id="String-format"><a href="#String-format" class="headerlink" title="String.format()"></a>String.format()</h2><p>接受与 Formatter.format() 方法一样的参数。</p><pre><code class="java">String.format(&quot;(t%d, q%d) %s&quot;, 3, 7, &quot;Write failed&quot;);// new Formatter().format(format, args).toString() // 内部如此实现// (t3, q7) Write failed</code></pre><h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>完整的语法定义参见 <a href="https://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html" target="_blank" rel="noopener"><code>java.util.regex.Pattern</code></a> 类的官方文档。</p><p>正则表达式最常用到的符号就是三个表示数量的符号了：</p><ul><li><strong>?</strong>：出现零次或一次。</li><li><strong>*</strong>：出现零次或一次或多次。就是不管出现不出现，也不管出现多少次。</li><li><strong>+</strong>：至少出现一次或多次。就是出现至少一次。</li><li><strong>{n}</strong>：准确地出现n次。</li><li><strong>{n,}</strong>：至少出现n次。</li><li><strong>{n,m}</strong>：至少出现n次，但至最多出现m次。</li></ul><p>这些表示数量的符号要结合表示“字符”的符号一起使用。正则表达式语法里定义了很多，举几个最常用的例子：</p><ul><li><strong>1</strong>：正常阿拉伯数字，就表示它本身。</li><li><strong>x</strong>：正常英语字母，就表示他们本身。</li><li><strong>[abc]</strong>：a、b 或 c（简单类）</li><li><strong>[^abc]</strong>：任何字符，除了 a、b 或 c（否定）</li><li><strong>[a-zA-Z]</strong>：a 到 z 或 A 到 Z，两头的字母包括在内（范围）</li><li><strong>[a-d[m-p]]</strong>：a 到 d 或 m 到 p：[a-dm-p]（并集）</li><li><strong>[a-z&amp;&amp;[def]]</strong>：d、e 或 f（交集）</li><li><strong>[a-z&amp;&amp;[^bc]]</strong>：a 到 z，除了 b 和 c：[ad-z]（减去）</li><li><strong>[a-z&amp;&amp;[^m-p]]</strong>：a 到 z，而非 m 到 p：[a-lq-z]（减去）</li></ul><p>预定义字符类</p><ul><li><strong>.</strong>：任何字符</li><li><strong>\d</strong>：任意一个[0-9]的阿拉伯数字。</li><li><strong>\D</strong>：除了[0-9]数字之外的其他所有字符。</li><li><strong>\s</strong>：一个空白符。包括[ \t\n\x0B\f\r]这些。这个真的很好用。</li><li><strong>\S</strong>：相反的除了空白符之外的所有字符。</li><li><strong>\w</strong>：一个单词字符。就是英语大小写字母加阿拉伯数字零到九，注意还有一个下划线_也算在里面。[a-zA-Z_0-9]</li><li><strong>\W</strong>：除了单词字符以外的全部其他字符。</li><li><strong>\b</strong>：单词边界符。这比较神奇。只匹配一个单词的边界，不匹配任何字符。占零个长度。这里的单词，就是前面\w单词符的内容。</li><li><strong>\B</strong>：判断不是单词边界。</li><li><strong>\G</strong>：前一个匹配的结束。</li></ul><p>还有其他的一些格式符：</p><ul><li><strong>\t</strong>：一个tab符。对应的ASKII码是：(&#39;\u0009&#39;)</li><li><strong>\n</strong>：一个换行符。对应的ASKII码是：(&#39;\u000A&#39;)</li><li><strong>\r</strong>：一个回车符。对应的ASKII码是：(&#39;\u000D&#39;)</li><li><strong>\e</strong>：一个空格符。对应的ASKII码是：(&#39;\u001B&#39;)</li><li><strong>\xhh</strong>：带有十六进制值 0x 的字符 hh</li><li><strong>\uhhhh</strong>：带有十六进制值 0x 的 Unicode 字符 hhhh</li><li><strong>^</strong>：行首符。必须在正则表达式的起始位置。</li><li><strong>$</strong>：行尾符。也可以是文末符，表示一段文本的末尾。</li></ul><h2 id="组"><a href="#组" class="headerlink" title="组"></a>组</h2><p>正则表达式用括号括起来的部分都是一个组。每个组在正则表达式里，都有自己的序号。序号是这样定义的： 假设有 <code>A(B(C))D</code> 这个正则表达式，一共有三个组：</p><ol><li>Group 0：就是全体 ABCD</li><li>Group 1：就是左起第一个括号里的内容 BC</li><li>Group 2：是左起第二个括号里的 C</li></ol><h2 id="Pattern"><a href="#Pattern" class="headerlink" title="Pattern"></a>Pattern</h2><p>在 java.util.regex 包里的 Pattern 类和 Matcher 类才是专门为正则表达式而生的类。</p><ol><li><strong>static Pattern compile(String regex)</strong> 可以把 String 形式的正则表达式编译成一个 Pattern 对象。</li><li><strong>public static Pattern compile(String regex, int flags)</strong> 将给定的正则表达式编译到具有<a href="#Pattern标记">给定标志</a>的模式中。</li><li><strong>Matcher matcher(CharSequence input)</strong> 传递一个需要匹配的字符串，返回一个 Matcher 对象。</li><li><strong>static boolean matches(String regex, CharSequence input)</strong> 用以检查 regex 是否匹配整个 CharSequence 类型的 input 参数。</li><li><strong>public String[] split(CharSequence input)</strong> 围绕此模式的匹配拆分给定输入序列。</li><li><strong>public String[] split(CharSequence input, int limit)</strong>（limit 参数控制应用模式的次数，从而影响结果数组的长度。<strong>如果 n 大于零</strong>，数组的长度不大于 n，并且数组的最后条目将包含除最后的匹配定界符之外的所有输入。<strong>如果 n 非正</strong>，那么将应用模式的次数不受限制，并且数组可以为任意长度。<strong>如果 n 为零</strong>，非正基础上，并且将丢弃尾部空字符串。）</li></ol><h2 id="Matcher"><a href="#Matcher" class="headerlink" title="Matcher"></a>Matcher</h2><ol><li><p><strong>boolean matches()</strong> 判断整个输入字符串是否匹配正则表达式模式（完全匹配）。</p></li><li><p><strong>boolean lookingAt()</strong> 判断字符串的起始部分是否能够匹配模式（与 matches() 方法类似，只是不需要完全匹配，只需开头部分匹配）。</p></li><li><p><strong>boolean find()</strong> 尝试查找与该模式匹配的输入序列的下一个子序列。此方法从匹配器区域的开头开始，如果该方法的前一次调用成功了并且从那时开始匹配器没有被重置，则从以前匹配操作没有匹配的第一个字符开始。如果匹配成功，则可以通过 start、end 和 group 方法获取更多信息。</p></li><li><p><strong>boolean find(int start)</strong> 重置此匹配器（<strong>每次调用都会重置</strong>），然后尝试查找匹配该模式，从指定索引开始的输入序列的下一个子序列。</p></li></ol><pre><code class="java">public class Finding {  public static void main(String[] args) {    Matcher m = Pattern.compile(&quot;\\w+&quot;)      .matcher(&quot;Evening is full&quot;);    while(m.find())      printnb(m.group() + &quot; &quot;);    print();    int i = 0;    while(m.find(i)) {      printnb(m.group() + &quot; &quot;);      i++;    }  }} /* Output:Evening is fullEvening vening ening ning ing ng g is is s full full ull ll l*///:~</code></pre><ol start="5"><li><strong>int groupCount()</strong> 返回此匹配器模式中的捕获组数。第0组不包括在内。</li><li><strong>String group(int group)</strong> 返回在以前匹配操作期间由给定组捕获的输入子序列。对于匹配器 m、输入序列 s 和组索引 g，表达式 m.group(g) 和 s.substring(m.start(g), m.end(g)) 是等效的。</li><li><strong>String group()</strong> 表达式 m.group(0) 等效于 m.group()。</li><li><strong>int start(int group)</strong> 返回匹配到的子字符串在字符串中的索引位置。</li><li><strong>int start()</strong> 表达式 m.start(0) 等效于 m.start()。</li><li><strong>int end(int group)</strong> 返回匹配到的子字符串的最后一个字符在字符串中的索引位置。</li><li><strong>int end()</strong> 表达式 m.end(0) 等效于 m.end()。</li></ol><pre><code class="java">public class Groups {  static public final String POEM =    &quot;Twas brillig, and the slithy toves\n&quot; +    &quot;Did gyre and gimble in the wabe.\n&quot; +    &quot;The frumious Bandersnatch.&quot;;  public static void main(String[] args) {    // 练习12：匹配小写 \\b[^A-Z\\s][a-z]+    Matcher m = Pattern.compile(&quot;(?m)(\\S+)\\s+((\\S+)\\s+(\\S+))$&quot;).matcher(POEM);    while(m.find()) {      for(int j = 0; j &lt;= m.groupCount(); j++)        printnb(&quot;[&quot; + m.start(j) + &quot; - &quot; + m.group(j) + &quot; - &quot; + m.end(j) + &quot;]&quot;);      print();    }  }} /* Output:[18 - the slithy toves - 34][18 - the - 21][22 - slithy toves - 34][22 - slithy - 28][29 - toves - 34][55 - in the wabe. - 67][55 - in - 57][58 - the wabe. - 67][58 - the - 61][62 - wabe. - 67][68 - The frumious Bandersnatch. - 94][68 - The - 71][72 - frumious Bandersnatch. - 94][72 - frumious - 80][81 - Bandersnatch. - 94]*///:~</code></pre><h2 id="Pattern标记"><a href="#Pattern标记" class="headerlink" title="Pattern标记"></a>Pattern标记</h2><ol><li><strong>Pattern.CANON_EQ</strong> 启用规范等价。当且仅当完全规范分解相匹配时，就认为它们是匹配的，指定此标记a\u030A就会匹配?</li><li><strong>Pattern.CASE_INSENSITIVE(?i)</strong> 启用不区分大小写的匹配。</li><li><strong>Pattern.COMMENTS(?x)</strong> 模式中允许空白和注释。空白和以#开始的注释都会被忽略</li><li><strong>Pattern.DOTALL(?s)</strong> 启用 dotall 模式。.可以匹配任何字符，包括行结束符。默认情况下，此表达式不匹配行结束符。</li><li><strong>Pattern.LITERAL</strong> 启用模式的字面值解析。指定此标志后，输入序列中的元字符或转义序列不具有任何特殊意义。</li><li><strong>Pattern.MULTILINE(?m)</strong> 启用多行模式。仅分别在行结束符前后匹配，或者在输入序列的结尾处匹配。默认情况下，这些表达式仅在整个输入序列的开头和结尾处匹配。</li><li><strong>Pattern.UNICODE_CASE(?u)</strong> 启用 Unicode 感知的大小写折叠。</li><li><strong>Pattern.UNIX_LINES(?d)</strong> 启用 Unix 行模式。在此模式中，.、^ 和 $ 的行为中仅识别 ‘\n’ 行结束符。</li></ol><p><strong>Pattern.CASE_INSENSITIVE</strong>、<strong>Pattern.MULTILINE</strong>、<strong>Pattern.COMMENTS</strong>这三个标记特别有用。<code>compile(String regex, int flags)</code> 中的标记 flags 还<strong>可以用或(|)来组合多个标记的功能</strong>。</p><h2 id="替换操作"><a href="#替换操作" class="headerlink" title="替换操作"></a>替换操作</h2><ol><li><p><strong>String replaceFirst(String replacement)</strong> 首先重置匹配器，以参数字符串 replacement 替换掉第一个匹配成功的部分。</p></li><li><p><strong>String replaceAll(String replacement)</strong> 首先重置匹配器，以参数字符串 replacement 替换掉所有匹配成功的部分。</p></li><li><p><strong>Matcher appendReplacement(StringBuffer sb, String replacement)</strong> 执行渐进式的替换。</p></li></ol><pre><code class="java">Pattern p = Pattern.compile(&quot;cat&quot;);Matcher m = p.matcher(&quot;one cat two cats in the yard&quot;);StringBuffer sb = new StringBuffer();while (m.find()) {    m.appendReplacement(sb, m.group().toUpperCase());}m.appendTail(sb);System.out.println(sb.toString()); // one CAT two CATs in the yard</code></pre><ol start="4"><li><p><strong>StringBuffer appendTail(StringBuffer sb)</strong> 此方法从添加位置开始从输入序列读取字符，并将其添加到给定字符串缓冲区。可以在一次或<strong>多次</strong>调用 appendReplacement 方法后调用它来<strong>复制剩余的输入序列</strong>。</p></li><li><p><strong>Matcher reset()</strong> 重置匹配器。</p></li><li><p><strong>Matcher reset(CharSequence input)</strong> 重置匹配器，并应用于新的字符串序列。</p></li></ol><h1 id="Scanner-类"><a href="#Scanner-类" class="headerlink" title="Scanner 类"></a>Scanner 类</h1><p>一个可以使用正则表达式来解析基本类型和字符串的简单文本扫描器。</p><p>Scanner 的构造器可以接受任何类型的输入对象，如 File 对象，InputStream，String 对象。</p><pre><code class="java">public class BetterRead {  public static BufferedReader input = new BufferedReader(new StringReader(&quot;zz\n22 1.61803&quot;));  public static void main(String[] args) {    Scanner stdin = new Scanner(SimpleRead.input);    System.out.println(&quot;What is your name?&quot;);    String name = stdin.nextLine();    System.out.println(name);    System.out.println(&quot;How old are you? What is your favorite double?&quot;);    System.out.println(&quot;(input: &lt;age&gt; &lt;double&gt;)&quot;);    int age = stdin.nextInt();    double favorite = stdin.nextDouble();    System.out.println(age);    System.out.println(favorite);    System.out.format(&quot;Hi %s.\n&quot;, name);    System.out.format(&quot;In 5 years you will be %d.\n&quot;, age + 5);    System.out.format(&quot;My favorite double is %f.&quot;, favorite / 2);  }} /* Output:What is your name?zzHow old are you? What is your favorite double?(input: &lt;age&gt; &lt;double&gt;)221.61803Hi zz.In 5 years you will be 27.My favorite double is 0.809015.*///:~</code></pre><p><strong>IOException ioException()</strong> 返回此 Scanner 的底层 Readable 最后抛出的 IOException。如果不存在这样的异常，则此方法返回 null。</p><h2 id="Scanner-定界符"><a href="#Scanner-定界符" class="headerlink" title="Scanner 定界符"></a>Scanner 定界符</h2><pre><code class="java">public class ScannerDelimiter {  public static void main(String[] args) {    Scanner scanner = new Scanner(&quot;12, 42, 78, 99, 42&quot;);    scanner.useDelimiter(&quot;\\s*,\\s*&quot;);    while(scanner.hasNextInt())      System.out.println(scanner.nextInt());  }} /* Output:1242789942*///:~</code></pre><p><strong>Scanner useDelimiter(String pattern)</strong> 将此扫描器的分隔模式设置为从指定 String 构造的模式。<br>此方法调用 <strong><code>useDelimiter(pattern)</code></strong> 的行为与调用 <strong><code>useDelimiter(Pattern.compile(pattern))</code></strong> 完全相同。</p><p><strong>Pattern delimiter()</strong> 返回此 Scanner 当前正在用于匹配分隔符的 Pattern。</p><h2 id="用正则表达式扫描"><a href="#用正则表达式扫描" class="headerlink" title="用正则表达式扫描"></a>用正则表达式扫描</h2><p>除了能够扫描基本类型之外，你还可以使用自定义的正则表达式进行扫描，这在扫描复杂数据是非常有用。</p><pre><code class="java">public class ThreatAnalyzer {  static String threatData =    &quot;58.27.82.161@02/10/2005\n&quot; +    &quot;204.45.234.40@02/11/2005\n&quot; +    &quot;58.27.82.161@02/11/2005\n&quot; +    &quot;58.27.82.161@02/12/2005\n&quot; +    &quot;58.27.82.161@02/12/2005\n&quot; +    &quot;[Next log section with different data format]&quot;;  public static void main(String[] args) {    Scanner scanner = new Scanner(threatData);    String pattern = &quot;(\\d+[.]\\d+[.]\\d+[.]\\d+)@(\\d{2}/\\d{2}/\\d{4})&quot;;    while(scanner.hasNext(pattern)) {      scanner.next(pattern); // 如果下一个标记与指定模式匹配，则返回下一个标记。      MatchResult match = scanner.match(); // 返回此扫描器所执行的最后扫描操作的匹配结果。      String ip = match.group(1);      String date = match.group(2);      System.out.format(&quot;Threat on %s from %s\n&quot;, date,ip);    }  }} /* Output:Threat on 02/10/2005 from 58.27.82.161Threat on 02/11/2005 from 204.45.234.40Threat on 02/11/2005 from 58.27.82.161Threat on 02/12/2005 from 58.27.82.161Threat on 02/12/2005 from 58.27.82.161*///:~</code></pre><br>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java编程思想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《跟我学Shiro》笔记24-在线会话管理</title>
      <link href="/2018/04/28/%E3%80%8A%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%E3%80%8B%E7%AC%94%E8%AE%B024-%E5%9C%A8%E7%BA%BF%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86/"/>
      <url>/2018/04/28/%E3%80%8A%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%E3%80%8B%E7%AC%94%E8%AE%B024-%E5%9C%A8%E7%BA%BF%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>原文地址：<a href="http://jinnianshilongnian.iteye.com/blog/2047643" target="_blank" rel="noopener">第二十四章 在线会话管理——《跟我学Shiro》</a><br>目录贴： <a href="http://jinnianshilongnian.iteye.com/blog/2018398" target="_blank" rel="noopener">跟我学Shiro目录贴</a></p><p>有时候需要显示当前在线人数、当前在线用户，有时候可能需要强制某个用户下线等；此时就需要获取相应的在线用户并进行一些操作。</p><a id="more"></a><h1 id="会话控制器"><a href="#会话控制器" class="headerlink" title="会话控制器"></a>会话控制器</h1><pre><code class="java">@RequiresPermissions(&quot;session:*&quot;)@Controller@RequestMapping(&quot;/sessions&quot;)public class SessionController {    @Autowired    private SessionDAO sessionDAO;    // 提供了展示所有在线会话列表，通过sessionDAO.getActiveSessions()获取所有在线的会话。    @RequestMapping()    public String list(Model model) {        Collection&lt;Session&gt; sessions =  sessionDAO.getActiveSessions();        model.addAttribute(&quot;sessions&quot;, sessions);        model.addAttribute(&quot;sessionCount&quot;, sessions.size());        return &quot;sessions/list&quot;;    }    // 强制退出某一个会话，此处只在指定会话中设置    @RequestMapping(&quot;/{sessionId}/forceLogout&quot;)    public String forceLogout(            @PathVariable(&quot;sessionId&quot;) String sessionId, RedirectAttributes redirectAttributes) {        try {            Session session = sessionDAO.readSession(sessionId);            if(session != null) {                session.setAttribute(Constants.SESSION_FORCE_LOGOUT_KEY, Boolean.TRUE);            }        } catch (Exception e) {/*ignore*/}        redirectAttributes.addFlashAttribute(&quot;msg&quot;, &quot;强制退出成功！&quot;);        return &quot;redirect:/sessions&quot;;    }}</code></pre><p><code>Constants.SESSION_FORCE_LOGOUT_KEY</code> 属性，之后通过 <code>ForceLogoutFilter</code> 判断并进行强制退出。</p><h1 id="ForceLogoutFilter"><a href="#ForceLogoutFilter" class="headerlink" title="ForceLogoutFilter"></a>ForceLogoutFilter</h1><pre><code class="java">public class ForceLogoutFilter extends AccessControlFilter {    @Override    protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception {        Session session = getSubject(request, response).getSession(false);        if(session == null) {            return true;        }        return session.getAttribute(Constants.SESSION_FORCE_LOGOUT_KEY) == null;    }    @Override    protected boolean onAccessDenied(ServletRequest request, ServletResponse response) throws Exception {        try {            getSubject(request, response).logout();//强制退出        } catch (Exception e) {/*ignore exception*/}        String loginUrl = getLoginUrl() + (getLoginUrl().contains(&quot;?&quot;) ? &quot;&amp;&quot; : &quot;?&quot;) + &quot;forceLogout=1&quot;;        WebUtils.issueRedirect(request, response, loginUrl);        return false;    }}</code></pre><p>强制退出拦截器，如果用户会话中存在 Constants.SESSION_FORCE_LOGOUT_KEY 属性，表示被管理员强制退出了；然后调用 Subject.logout() 退出，且重定向到登录页面（自动拼上 fourceLogout 请求参数）。</p><h1 id="登录控制器"><a href="#登录控制器" class="headerlink" title="登录控制器"></a>登录控制器</h1><pre><code class="java">@Controllerpublic class LoginController {    @RequestMapping(value = &quot;/login&quot;)    public String showLoginForm(HttpServletRequest req, Model model) {        String exceptionClassName = (String)req.getAttribute(&quot;shiroLoginFailure&quot;);        String error = null;        if(UnknownAccountException.class.getName().equals(exceptionClassName)) {            error = &quot;用户名/密码错误&quot;;        } else if(IncorrectCredentialsException.class.getName().equals(exceptionClassName)) {            error = &quot;用户名/密码错误&quot;;        } else if(exceptionClassName != null) {            error = &quot;其他错误：&quot; + exceptionClassName;        }        model.addAttribute(&quot;error&quot;, error);        if(req.getParameter(&quot;forceLogout&quot;) != null) {            model.addAttribute(&quot;error&quot;, &quot;您已经被管理员强制退出，请重新登录&quot;);        }        return &quot;login&quot;;    }}</code></pre><h1 id="spring-config-shiro-xml"><a href="#spring-config-shiro-xml" class="headerlink" title="spring-config-shiro.xml"></a>spring-config-shiro.xml</h1><p>和之前的唯一区别是在 shiroFilter 中的 filterChainDefinitions 拦截器链定义中添加了 forceLogout 拦截器：</p><pre><code class="xml">&lt;bean id=&quot;sysUserFilter&quot; class=&quot;com.github.zhangkaitao.shiro.chapter24.web.shiro.filter.SysUserFilter&quot;/&gt;&lt;bean id=&quot;forceLogoutFilter&quot; class=&quot;com.github.zhangkaitao.shiro.chapter24.web.shiro.filter.ForceLogoutFilter&quot;/&gt;&lt;!-- Shiro的Web过滤器 --&gt;&lt;bean id=&quot;shiroFilter&quot; class=&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;&gt;    &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot;/&gt;    &lt;property name=&quot;loginUrl&quot; value=&quot;/login&quot;/&gt;    &lt;property name=&quot;filters&quot;&gt;        &lt;util:map&gt;            &lt;entry key=&quot;authc&quot; value-ref=&quot;formAuthenticationFilter&quot;/&gt;            &lt;entry key=&quot;sysUser&quot; value-ref=&quot;sysUserFilter&quot;/&gt;            &lt;entry key=&quot;forceLogout&quot; value-ref=&quot;forceLogoutFilter&quot;/&gt;        &lt;/util:map&gt;    &lt;/property&gt;    &lt;property name=&quot;filterChainDefinitions&quot;&gt;        &lt;value&gt;            /login = authc            /logout = logout            /authenticated = authc            /** = forceLogout,user,sysUser        &lt;/value&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Shiro </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《跟我学Shiro》笔记22-集成验证码</title>
      <link href="/2018/04/25/%E3%80%8A%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%E3%80%8B%E7%AC%94%E8%AE%B022-%E9%9B%86%E6%88%90%E9%AA%8C%E8%AF%81%E7%A0%81/"/>
      <url>/2018/04/25/%E3%80%8A%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%E3%80%8B%E7%AC%94%E8%AE%B022-%E9%9B%86%E6%88%90%E9%AA%8C%E8%AF%81%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>原文地址：<a href="http://jinnianshilongnian.iteye.com/blog/2046041" target="_blank" rel="noopener">第二十二章 集成验证码——《跟我学Shiro》</a><br>目录贴： <a href="http://jinnianshilongnian.iteye.com/blog/2018398" target="_blank" rel="noopener">跟我学Shiro目录贴</a></p><h1 id="添加JCaptcha依赖"><a href="#添加JCaptcha依赖" class="headerlink" title="添加JCaptcha依赖"></a>添加JCaptcha依赖</h1><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;com.octo.captcha&lt;/groupId&gt;    &lt;artifactId&gt;jcaptcha-api&lt;/artifactId&gt;    &lt;version&gt;1.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.octo.captcha&lt;/groupId&gt;    &lt;artifactId&gt;jcaptcha&lt;/artifactId&gt;    &lt;version&gt;2.0-alpha-1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.octo.captcha&lt;/groupId&gt;    &lt;artifactId&gt;jcaptcha-integration-simple-servlet&lt;/artifactId&gt;    &lt;version&gt;2.0-alpha-1&lt;/version&gt;    &lt;exclusions&gt;        &lt;exclusion&gt;            &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;        &lt;/exclusion&gt;    &lt;/exclusions&gt;&lt;/dependency&gt;</code></pre><a id="more"></a><h1 id="GMailEngine"><a href="#GMailEngine" class="headerlink" title="GMailEngine"></a>GMailEngine</h1><pre><code class="java">/** * JCaptcha验证码图片生成引擎, 仿照JCaptcha2.0编写类似GMail验证码的样式. */public class GMailEngine extends ListImageCaptchaEngine {    @Override    protected void buildInitialFactories() {        // 图片和字体大小设置        int minWordLength = 6;        int maxWordLength = 6;        int fontSize = 20;        int imageWidth = 100;        int imageHeight = 36;        WordGenerator dictionnaryWords = new ComposeDictionaryWordGenerator(                new FileDictionary(&quot;toddlist&quot;));        // word2image components        TextPaster randomPaster = new DecoratedRandomTextPaster(minWordLength,                maxWordLength, new RandomListColorGenerator(new Color[]{                new Color(23, 170, 27), new Color(220, 34, 11),                new Color(23, 67, 172)}), new TextDecorator[]{});        BackgroundGenerator background = new UniColorBackgroundGenerator(                imageWidth, imageHeight, Color.white);        FontGenerator font = new RandomFontGenerator(fontSize, fontSize,                new Font[]{new Font(&quot;nyala&quot;, Font.BOLD, fontSize),                        new Font(&quot;Bell MT&quot;, Font.PLAIN, fontSize),                        new Font(&quot;Credit valley&quot;, Font.BOLD, fontSize)});        ImageDeformation postDef = new ImageDeformationByFilters(                new ImageFilter[]{});        ImageDeformation backDef = new ImageDeformationByFilters(                new ImageFilter[]{});        ImageDeformation textDef = new ImageDeformationByFilters(                new ImageFilter[]{});        WordToImage word2image = new DeformedComposedWordToImage(font,                background, randomPaster, backDef, textDef, postDef);        addFactory(new GimpyFactory(dictionnaryWords, word2image));    }}</code></pre><h1 id="MyManageableImageCaptchaService-判断仓库中是否有相应的验证码存在"><a href="#MyManageableImageCaptchaService-判断仓库中是否有相应的验证码存在" class="headerlink" title="MyManageableImageCaptchaService 判断仓库中是否有相应的验证码存在"></a>MyManageableImageCaptchaService 判断仓库中是否有相应的验证码存在</h1><pre><code class="java">public class MyManageableImageCaptchaService extends DefaultManageableImageCaptchaService {    public MyManageableImageCaptchaService(CaptchaStore captchaStore, CaptchaEngine captchaEngine, int minGuarantedStorageDelayInSeconds,             int maxCaptchaStoreSize, int captchaStoreLoadBeforeGarbageCollection) {        super(captchaStore, captchaEngine, minGuarantedStorageDelayInSeconds, maxCaptchaStoreSize, captchaStoreLoadBeforeGarbageCollection);    }    public boolean hasCapcha(String id, String userCaptchaResponse) {        return store.getCaptcha(id).validateResponse(userCaptchaResponse);    }}</code></pre><h1 id="JCaptcha-工具类，提供相应的API来验证当前请求输入的验证码是否正确"><a href="#JCaptcha-工具类，提供相应的API来验证当前请求输入的验证码是否正确" class="headerlink" title="JCaptcha 工具类，提供相应的API来验证当前请求输入的验证码是否正确"></a>JCaptcha 工具类，提供相应的API来验证当前请求输入的验证码是否正确</h1><pre><code class="java">public class JCaptcha {    public static final MyManageableImageCaptchaService captchaService            = new MyManageableImageCaptchaService(new FastHashMapCaptchaStore(), new GMailEngine(), 180, 100000, 75000);    // 验证当前请求输入的验证码否正确；并从 CaptchaService 中删除已经生成的验证码；    public static boolean validateResponse(HttpServletRequest request, String userCaptchaResponse) {        if (request.getSession(false) == null) return false;        boolean validated = false;        try {            String id = request.getSession().getId();            validated = captchaService.validateResponseForID(id, userCaptchaResponse).booleanValue();        } catch (CaptchaServiceException e) {            e.printStackTrace();        }        return validated;    }    // 验证当前请求输入的验证码是否正确；但不从 CaptchaService 中删除已经生成的验证码    // 比如 Ajax 验证时可以使用，防止多次生成验证码    public static boolean hasCaptcha(HttpServletRequest request, String userCaptchaResponse) {        if (request.getSession(false) == null) return false;        boolean validated = false;        try {            String id = request.getSession().getId();            validated = captchaService.hasCapcha(id, userCaptchaResponse);        } catch (CaptchaServiceException e) {            e.printStackTrace();        }        return validated;    }}</code></pre><h1 id="JCaptchaFilter-用于生成验证码图片的过滤器"><a href="#JCaptchaFilter-用于生成验证码图片的过滤器" class="headerlink" title="JCaptchaFilter 用于生成验证码图片的过滤器"></a>JCaptchaFilter 用于生成验证码图片的过滤器</h1><p>CaptchaService 使用当前会话 ID 当作 key 获取相应的验证码图片；另外需要设置响应内容不进行浏览器端缓存。</p><pre><code class="java">public class JCaptchaFilter extends OncePerRequestFilter {    @Override    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {        response.setDateHeader(&quot;Expires&quot;, 0L);        response.setHeader(&quot;Cache-Control&quot;, &quot;no-store, no-cache, must-revalidate&quot;);        response.addHeader(&quot;Cache-Control&quot;, &quot;post-check=0, pre-check=0&quot;);        response.setHeader(&quot;Pragma&quot;, &quot;no-cache&quot;);        response.setContentType(&quot;image/jpeg&quot;);        String id = request.getRequestedSessionId();        BufferedImage bi = JCaptcha.captchaService.getImageChallengeForID(id);        ServletOutputStream out = response.getOutputStream();        ImageIO.write(bi, &quot;jpg&quot;, out);        try {            out.flush();        } finally {            out.close();        }    }}</code></pre><h1 id="web-xml"><a href="#web-xml" class="headerlink" title="web.xml"></a>web.xml</h1><pre><code class="xml">&lt;!-- 验证码过滤器需要放到Shiro之后 因为Shiro将包装HttpSession 如果不 可能造成两次的sesison id 不一样 --&gt;&lt;filter&gt;    &lt;filter-name&gt;JCaptchaFilter&lt;/filter-name&gt;    &lt;filter-class&gt;com.github.zhangkaitao.shiro.chapter22.jcaptcha.JCaptchaFilter&lt;/filter-class&gt;    &lt;async-supported&gt;true&lt;/async-supported&gt;&lt;/filter&gt;&lt;filter-mapping&gt;    &lt;filter-name&gt;JCaptchaFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/jcaptcha.jpg&lt;/url-pattern&gt;&lt;/filter-mapping&gt;</code></pre><h1 id="JCaptchaValidateFilter-验证码验证"><a href="#JCaptchaValidateFilter-验证码验证" class="headerlink" title="JCaptchaValidateFilter 验证码验证"></a>JCaptchaValidateFilter 验证码验证</h1><pre><code class="java">public class JCaptchaValidateFilter extends AccessControlFilter {    private boolean jcaptchaEbabled = true;//是否开启验证码支持    private String jcaptchaParam = &quot;jcaptchaCode&quot;;//前台提交的验证码参数名    private String failureKeyAttribute = &quot;shiroLoginFailure&quot;; //验证码验证失败后存储到的属性名    public void setJcaptchaEbabled(boolean jcaptchaEbabled) {        this.jcaptchaEbabled = jcaptchaEbabled;    }    public void setJcaptchaParam(String jcaptchaParam) {        this.jcaptchaParam = jcaptchaParam;    }    public void setFailureKeyAttribute(String failureKeyAttribute) {        this.failureKeyAttribute = failureKeyAttribute;    }    @Override    protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception {        //1、设置验证码是否开启属性，页面可以根据该属性来决定是否显示验证码        request.setAttribute(&quot;jcaptchaEbabled&quot;, jcaptchaEbabled);        HttpServletRequest httpServletRequest = WebUtils.toHttp(request);        //2、判断验证码是否禁用 或不是表单提交（允许访问）        if (jcaptchaEbabled == false || !&quot;post&quot;.equalsIgnoreCase(httpServletRequest.getMethod())) {            return true;        }        //3、此时是表单提交，验证验证码是否正确        return JCaptcha.validateResponse(httpServletRequest, httpServletRequest.getParameter(jcaptchaParam));    }    @Override    protected boolean onAccessDenied(ServletRequest request, ServletResponse response) throws Exception {        //如果验证码失败了，存储失败key属性        request.setAttribute(failureKeyAttribute, &quot;jCaptcha.error&quot;);        return true;    }}</code></pre><h1 id="MyFormAuthenticationFilter"><a href="#MyFormAuthenticationFilter" class="headerlink" title="MyFormAuthenticationFilter"></a>MyFormAuthenticationFilter</h1><p>用于验证码验证的 Shiro 拦截器在用于身份认证的拦截器之前运行；但是如果验证码验证拦截器失败了，就不需要进行身份认证拦截器流程了；所以需要修改下如 FormAuthenticationFilter 身份认证拦截器，当验证码验证失败时不再走身份认证拦截器。即如果之前已经错了，那直接跳过即可。</p><pre><code class="java">public class MyFormAuthenticationFilter extends FormAuthenticationFilter {    @Override    protected boolean onAccessDenied(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception {        if(request.getAttribute(getFailureKeyAttribute()) != null) {            return true;        }        return super.onAccessDenied(request, response, mappedValue);    }}</code></pre><h1 id="spring-config-shiro-xml"><a href="#spring-config-shiro-xml" class="headerlink" title="spring-config-shiro.xml"></a>spring-config-shiro.xml</h1><pre><code class="xml">&lt;!-- 基于Form表单的身份验证过滤器 --&gt;&lt;bean id=&quot;authcFilter&quot; class=&quot;com.github.zhangkaitao.shiro.chapter22.jcaptcha.MyFormAuthenticationFilter&quot;&gt;    &lt;property name=&quot;usernameParam&quot; value=&quot;username&quot;/&gt;    &lt;property name=&quot;passwordParam&quot; value=&quot;password&quot;/&gt;    &lt;property name=&quot;rememberMeParam&quot; value=&quot;rememberMe&quot;/&gt;    &lt;property name=&quot;failureKeyAttribute&quot; value=&quot;shiroLoginFailure&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;jCaptchaValidateFilter&quot; class=&quot;com.github.zhangkaitao.shiro.chapter22.jcaptcha.JCaptchaValidateFilter&quot;&gt;    &lt;property name=&quot;jcaptchaEbabled&quot; value=&quot;true&quot;/&gt;    &lt;property name=&quot;jcaptchaParam&quot; value=&quot;jcaptchaCode&quot;/&gt;    &lt;property name=&quot;failureKeyAttribute&quot; value=&quot;shiroLoginFailure&quot;/&gt;&lt;/bean&gt;&lt;!-- Shiro的Web过滤器 --&gt;&lt;bean id=&quot;shiroFilter&quot; class=&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;&gt;    &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot;/&gt;    &lt;property name=&quot;loginUrl&quot; value=&quot;/login&quot;/&gt;    &lt;property name=&quot;filters&quot;&gt;        &lt;util:map&gt;            &lt;entry key=&quot;authc&quot; value-ref=&quot;authcFilter&quot;/&gt;            &lt;entry key=&quot;sysUser&quot; value-ref=&quot;sysUserFilter&quot;/&gt;            &lt;entry key=&quot;jCaptchaValidate&quot; value-ref=&quot;jCaptchaValidateFilter&quot;/&gt;        &lt;/util:map&gt;    &lt;/property&gt;    &lt;property name=&quot;filterChainDefinitions&quot;&gt;        &lt;value&gt;            /static/** = anon            /jcaptcha* = anon            /login = jCaptchaValidate,authc            /logout = logout            /authenticated = authc            /** = user,sysUser        &lt;/value&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre><h1 id="login-jsp-登录页面"><a href="#login-jsp-登录页面" class="headerlink" title="login.jsp 登录页面"></a>login.jsp 登录页面</h1><pre><code class="jsp">&lt;c:if test=&quot;${jcaptchaEbabled}&quot;&gt;    验证码：    &lt;input type=&quot;text&quot; name=&quot;jcaptchaCode&quot;&gt;    &lt;img class=&quot;jcaptcha-btn jcaptcha-img&quot; src=&quot;${pageContext.request.contextPath}/jcaptcha.jpg&quot; title=&quot;点击更换验证码&quot;&gt;    &lt;a class=&quot;jcaptcha-btn&quot; href=&quot;javascript:;&quot;&gt;换一张&lt;/a&gt;&lt;/c:if&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Shiro </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《跟我学Shiro》笔记18-并发登录人数控制</title>
      <link href="/2018/04/21/%E3%80%8A%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%E3%80%8B%E7%AC%94%E8%AE%B018-%E5%B9%B6%E5%8F%91%E7%99%BB%E5%BD%95%E4%BA%BA%E6%95%B0%E6%8E%A7%E5%88%B6/"/>
      <url>/2018/04/21/%E3%80%8A%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%E3%80%8B%E7%AC%94%E8%AE%B018-%E5%B9%B6%E5%8F%91%E7%99%BB%E5%BD%95%E4%BA%BA%E6%95%B0%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文地址：<a href="http://jinnianshilongnian.iteye.com/blog/2039760" target="_blank" rel="noopener">第十八章 并发登录人数控制——《跟我学Shiro》</a><br>目录贴： <a href="http://jinnianshilongnian.iteye.com/blog/2018398" target="_blank" rel="noopener">跟我学Shiro目录贴</a><br>源码：<a href="https://github.com/zhangkaitao/shiro-example" target="_blank" rel="noopener">https://github.com/zhangkaitao/shiro-example</a></p></blockquote><p>在某些项目中可能会遇到如每个账户同时只能有一个人登录或几个人同时登录，如果同时有多人登录：要么不让后者登录；要么踢出前者登录（强制退出）。比如 <code>spring security</code> 就直接提供了相应的功能；Shiro 的话没有提供默认实现，不过可以很容易的在 Shiro 中加入这个功能。</p><a id="more"></a><h1 id="配置使用（spring-config-shiro-xml）"><a href="#配置使用（spring-config-shiro-xml）" class="headerlink" title="配置使用（spring-config-shiro.xml）"></a>配置使用（spring-config-shiro.xml）</h1><pre><code class="xml">&lt;bean id=&quot;kickoutSessionControlFilter&quot;class=&quot;com.github.zhangkaitao.shiro.chapter18.web.shiro.filter.KickoutSessionControlFilter&quot;&gt;    &lt;property name=&quot;cacheManager&quot; ref=&quot;cacheManager&quot;/&gt;    &lt;property name=&quot;sessionManager&quot; ref=&quot;sessionManager&quot;/&gt;    &lt;property name=&quot;kickoutAfter&quot; value=&quot;false&quot;/&gt;    &lt;property name=&quot;maxSession&quot; value=&quot;2&quot;/&gt;    &lt;property name=&quot;kickoutUrl&quot; value=&quot;/login?kickout=1&quot;/&gt;&lt;/bean&gt;</code></pre><ol><li><code>cacheManager</code>：使用 <code>cacheManager</code> 获取相应的 <code>cache</code> 来缓存用户登录的会话；用于保存用户—会话之间的关系的；</li><li><code>sessionManager</code>：用于根据会话 <code>ID</code>，获取会话进行踢出操作的；</li><li><code>kickoutAfter</code>：是否踢出后来登录的，默认是 <code>false</code>；即后者登录的用户踢出前者登录的用户；</li><li><code>maxSession</code>：同一个用户最大的会话数，默认 <code>1</code>；比如 <code>2</code> 的意思是同一个用户允许最多同时两个人登录；</li><li><code>kickoutUrl</code>：被踢出后重定向到的地址。</li></ol><h1 id="shiroFilter-配置"><a href="#shiroFilter-配置" class="headerlink" title="shiroFilter 配置"></a>shiroFilter 配置</h1><pre><code class="xml">&lt;bean id=&quot;shiroFilter&quot; class=&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;&gt;     &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot;/&gt;     &lt;property name=&quot;loginUrl&quot; value=&quot;/login&quot;/&gt;     &lt;property name=&quot;filters&quot;&gt;         &lt;util:map&gt;             &lt;entry key=&quot;authc&quot; value-ref=&quot;formAuthenticationFilter&quot;/&gt;             &lt;entry key=&quot;sysUser&quot; value-ref=&quot;sysUserFilter&quot;/&gt;             &lt;entry key=&quot;kickout&quot; value-ref=&quot;kickoutSessionControlFilter&quot;/&gt;         &lt;/util:map&gt;     &lt;/property&gt;     &lt;property name=&quot;filterChainDefinitions&quot;&gt;         &lt;value&gt;             /login = authc             /logout = logout             /authenticated = authc             /** = kickout,user,sysUser         &lt;/value&gt;     &lt;/property&gt; &lt;/bean&gt;</code></pre><p>除了登录等之外的地址都走 <code>kickout</code> 拦截器进行并发登录控制</p><h1 id="KickoutSessionControlFilter"><a href="#KickoutSessionControlFilter" class="headerlink" title="KickoutSessionControlFilter"></a>KickoutSessionControlFilter</h1><pre><code class="java">public class KickoutSessionControlFilter extends AccessControlFilter {    private String kickoutUrl; // 踢出后到的地址    private boolean kickoutAfter = false; // 踢出之前登录的/之后登录的用户 默认踢出之前登录的用户    private int maxSession = 1; // 同一个帐号最大会话数 默认 1    private SessionManager sessionManager;    private Cache&lt;String, Deque&lt;Serializable&gt;&gt; cache;    public void setKickoutUrl(String kickoutUrl) {        this.kickoutUrl = kickoutUrl;    }    public void setKickoutAfter(boolean kickoutAfter) {        this.kickoutAfter = kickoutAfter;    }    public void setMaxSession(int maxSession) {        this.maxSession = maxSession;    }    public void setSessionManager(SessionManager sessionManager) {        this.sessionManager = sessionManager;    }    public void setCacheManager(CacheManager cacheManager) {        this.cache = cacheManager.getCache(&quot;shiro-kickout-session&quot;);    }    @Override    protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception {        return false;    }    @Override    protected boolean onAccessDenied(ServletRequest request, ServletResponse response) throws Exception {        Subject subject = getSubject(request, response);        if(!subject.isAuthenticated() &amp;&amp; !subject.isRemembered()) {            // 如果没有登录，直接进行之后的流程            return true;        }        Session session = subject.getSession();        String username = (String) subject.getPrincipal();        Serializable sessionId = session.getId();        // 同步控制        Deque&lt;Serializable&gt; deque = cache.get(username);        if(deque == null) {            deque = new LinkedList&lt;Serializable&gt;();            cache.put(username, deque);        }        // 如果队列里没有此 sessionId，且用户没有被踢出；放入队列        if(!deque.contains(sessionId) &amp;&amp; session.getAttribute(&quot;kickout&quot;) == null) {            deque.push(sessionId);        }        // 如果队列里的 sessionId 数超出最大会话数，开始踢人        while(deque.size() &gt; maxSession) {            Serializable kickoutSessionId = null;            if(kickoutAfter) { // 如果踢出后者                kickoutSessionId = deque.removeFirst();            } else { // 否则踢出前者                kickoutSessionId = deque.removeLast();            }            try {                Session kickoutSession = sessionManager.getSession(new DefaultSessionKey(kickoutSessionId));                if(kickoutSession != null) {                    // 设置会话的 kickout 属性表示踢出了                    kickoutSession.setAttribute(&quot;kickout&quot;, true);                }            } catch (Exception e) { // ignore exception            }        }        // 如果被踢出了，直接退出，重定向到踢出后的地址        if (session.getAttribute(&quot;kickout&quot;) != null) {            // 会话被踢出了            try {                subject.logout();            } catch (Exception e) { // ignore            }            saveRequest(request);            WebUtils.issueRedirect(request, response, kickoutUrl);            return false;        }        return true;    }}</code></pre><p>此处使用了 <strong><code>Cache</code> 缓存用户名—会话 id</strong> 之间的关系；如果量比较大可以考虑如持久化到数据库/其他带持久化的 <code>Cache</code> 中；另外此处没有并发控制的同步实现，可以考虑根据用户名获取锁来控制，减少锁的粒度。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Shiro </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《跟我学Shiro》笔记15-单点登录</title>
      <link href="/2018/04/20/%E3%80%8A%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%E3%80%8B%E7%AC%94%E8%AE%B015-%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"/>
      <url>/2018/04/20/%E3%80%8A%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%E3%80%8B%E7%AC%94%E8%AE%B015-%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文地址：<a href="http://jinnianshilongnian.iteye.com/blog/2036730" target="_blank" rel="noopener">第十五章 单点登录——《跟我学Shiro》</a><br>目录贴： <a href="http://jinnianshilongnian.iteye.com/blog/2018398" target="_blank" rel="noopener">跟我学Shiro目录贴</a><br>源码：<a href="https://github.com/zhangkaitao/shiro-example" target="_blank" rel="noopener">https://github.com/zhangkaitao/shiro-example</a></p></blockquote><p>Shiro 1.2 开始提供了 <code>Jasig CAS</code> 单点登录的支持，单点登录主要用于多系统集成，即在多个系统中，用户只需要到一个中央服务器登录一次即可访问这些系统中的任何一个，无须多次登录。此处我们使用 <a href="https://github.com/Jasig/cas/tree/v4.0.0-RC3" target="_blank" rel="noopener">Jasig CAS v4.0.0-RC3 版本</a>：</p><p><code>Jasig CAS</code> 单点登录系统分为服务器端和客户端，服务器端提供单点登录，多个客户端（子系统）将跳转到该服务器进行登录验证，大体流程如下：</p><ol><li>访问客户端需要登录的页面 <a href="http://localhost:9080/client/，此时会跳到单点登录服务器" target="_blank" rel="noopener">http://localhost:9080/client/，此时会跳到单点登录服务器</a> <a href="https://localhost:8443/server/login?service=https://localhost:9443/client/cas；" target="_blank" rel="noopener">https://localhost:8443/server/login?service=https://localhost:9443/client/cas；</a></li><li>如果此时单点登录服务器也没有登录的话，会显示登录表单页面，输入用户名/密码进行登录；</li><li>登录成功后服务器端会回调客户端传入的地址：<a href="https://localhost:9443/client/cas?ticket=ST-1-eh2cIo92F9syvoMs5DOg-cas01.example.org，且带着一个" target="_blank" rel="noopener">https://localhost:9443/client/cas?ticket=ST-1-eh2cIo92F9syvoMs5DOg-cas01.example.org，且带着一个</a> <code>ticket</code>；</li><li>客户端会把 <code>ticket</code> 提交给服务器来验证 <code>ticket</code> 是否有效；如果有效服务器端将返回用户身份；</li><li>客户端可以再根据这个用户身份获取如当前系统用户/角色/权限信息。</li></ol><a id="more"></a><h1 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h1><p>我们使用了 <code>Jasig CAS</code> 服务器 <code>v4.0.0-RC3</code> 版本，可以到其官方的 <code>github</code> 下载：<a href="https://github.com/Jasig/cas/tree/v4.0.0-RC3" target="_blank" rel="noopener">https://github.com/Jasig/cas/tree/v4.0.0-RC3</a> 下载，然后将其 <code>cas-server-webapp</code> 模块封装到 <code>shiro-example-chapter15-server</code> 模块中，具体请参考源码。</p><p>修改 <code>src/main/webapp/WEB-INF/deployerConfigContext.xml</code>，找到 <code>primaryAuthenticationHandler</code>，然后添加一个账户： <code>&lt;entry key=&quot;zhang&quot; value=&quot;123&quot;/&gt;</code>，其也支持如 <code>JDBC</code> 查询，可以自己定制；具体请参考文档。</p><h1 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h1><p>首先使用 <code>localhost.keystore</code> 导出数字证书（公钥）到 <code>D:\localhost.cer</code></p><pre><code class="cmd">keytool -export -alias localhost -file D:\localhost.cer -keystore D:\localhost.keystore</code></pre><p>因为 <code>CAS client</code> 需要使用该证书进行验证，需要将证书导入到 <code>JDK</code> 中：</p><pre><code class="cmd">cd D:\jdk1.7.0_21\jre\lib\securitykeytool -import -alias localhost -file D:\localhost.cer -noprompt -trustcacerts -storetype jks -keystore cacerts -storepass 123456</code></pre><p>导入 <code>shiro-cas</code> 依赖：</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;    &lt;artifactId&gt;shiro-cas&lt;/artifactId&gt;    &lt;version&gt;1.2.2&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>自定义 <code>CasRealm</code>：</p><pre><code class="java">// CasRealm 根据 CAS 服务器端返回的用户身份获取相应的角色/权限信息。public class MyCasRealm extends CasRealm {    private UserService userService;    public void setUserService(UserService userService) {        this.userService = userService;    }    @Override    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {        String username = (String)principals.getPrimaryPrincipal();        SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo();        authorizationInfo.setRoles(userService.findRoles(username));        authorizationInfo.setStringPermissions(userService.findPermissions(username));        return authorizationInfo;    }}</code></pre><p><code>spring-shiro-web.xml</code> 配置：</p><pre><code class="xml">&lt;bean id=&quot;casRealm&quot; class=&quot;com.github.zhangkaitao.shiro.chapter13.realm.MyCasRealm&quot;&gt;    &lt;property name=&quot;userService&quot; ref=&quot;userService&quot;/&gt;    &lt;!-- …… --&gt;    &lt;property name=&quot;casServerUrlPrefix&quot; value=&quot;https://localhost:8443/chapter15-server&quot;/&gt;    &lt;property name=&quot;casService&quot; value=&quot;https://localhost:9443/chapter15-client/cas&quot;/&gt;&lt;/bean&gt;</code></pre><ul><li><code>casServerUrlPrefix</code>：是 <code>CAS Server</code> 服务器端地址；</li><li><code>casService</code>：是当前应用 <code>CAS</code> 服务 <code>URL</code>，即用于接收并处理登录成功后的 <code>Ticket</code> 的；</li></ul><p>如果角色/权限信息是由服务器端提供的话，我们可以直接使用 <code>CasRealm</code>：</p><pre><code class="xml">&lt;bean id=&quot;casRealm&quot; class=&quot;org.apache.shiro.cas.CasRealm&quot;&gt;    &lt;!-- …… --&gt;    &lt;property name=&quot;defaultRoles&quot; value=&quot;admin,user&quot;/&gt;    &lt;property name=&quot;defaultPermissions&quot; value=&quot;user:create,user:update&quot;/&gt;    &lt;property name=&quot;roleAttributeNames&quot; value=&quot;roles&quot;/&gt;    &lt;property name=&quot;permissionAttributeNames&quot; value=&quot;permissions&quot;/&gt;    &lt;property name=&quot;casServerUrlPrefix&quot; value=&quot;https://localhost:8443/chapter15-server&quot;/&gt;    &lt;property name=&quot;casService&quot; value=&quot;https://localhost:9443/chapter15-client/cas&quot;/&gt;&lt;/bean&gt;</code></pre><ul><li><code>defaultRoles/defaultPermissions</code>：默认添加给所有 <code>CAS</code> 登录成功用户的角色和权限信息；</li><li><code>roleAttributeNames/permissionAttributeNames</code>：角色属性/权限属性名称，如果用户的角色/权限信息是从服务器端返回的（即返回的 <code>CAS Principal</code> 中除了 <code>Principal</code> 之外还有如一些 <code>Attributes</code>），此时可以使用 <code>roleAttributeNames/permissionAttributeNames</code> 得到 <code>Attributes</code> 中的角色/权限数据；请自行查询 <code>CAS</code> 获取用户更多信息。</li></ul><pre><code class="java">&lt;bean id=&quot;casFilter&quot; class=&quot;org.apache.shiro.cas.CasFilter&quot;&gt;    &lt;property name=&quot;failureUrl&quot; value=&quot;/casFailure.jsp&quot;/&gt;&lt;/bean&gt;</code></pre><p><code>CasFilter</code> 类似于 <code>FormAuthenticationFilter</code>，只不过其验证服务器端返回的 <code>CAS Service Ticket</code>。</p><pre><code class="xml">&lt;bean id=&quot;shiroFilter&quot; class=&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;&gt;    &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot;/&gt;    &lt;property name=&quot;loginUrl&quot; value=&quot;https://localhost:8443/chapter15-server/login?service=https://localhost:9443/chapter15-client/cas&quot;/&gt;    &lt;property name=&quot;successUrl&quot; value=&quot;/&quot;/&gt;    &lt;property name=&quot;filters&quot;&gt;        &lt;util:map&gt;            &lt;entry key=&quot;cas&quot; value-ref=&quot;casFilter&quot;/&gt;        &lt;/util:map&gt;    &lt;/property&gt;    &lt;property name=&quot;filterChainDefinitions&quot;&gt;        &lt;value&gt;            /casFailure.jsp = anon            /cas = cas            /logout = logout            /** = user        &lt;/value&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre><ul><li><code>loginUrl</code>：<a href="https://localhost:8443/chapter15-server/login" target="_blank" rel="noopener">https://localhost:8443/chapter15-server/login</a> 表示服务端端登录地址，登录成功后跳转到 <code>?service</code> 参数对于的地址进行客户端验证及登录；</li><li><code>/cas=cas</code>：即 <code>/cas</code> 地址是服务器端回调地址，使用 <code>CasFilter</code> 获取 <code>Ticket</code> 进行登录。</li></ul><blockquote><p><a href="https://www.iteye.com/blog/jinnianshilongnian-2037222" target="_blank" rel="noopener">第十六章  综合实例</a><br><a href="https://www.iteye.com/blog/jinnianshilongnian-2038646" target="_blank" rel="noopener">第十七章  OAuth2集成</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Shiro </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《跟我学Shiro》笔记14-SSL</title>
      <link href="/2018/04/19/%E3%80%8A%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%E3%80%8B%E7%AC%94%E8%AE%B014-SSL/"/>
      <url>/2018/04/19/%E3%80%8A%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%E3%80%8B%E7%AC%94%E8%AE%B014-SSL/</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文地址：<a href="http://jinnianshilongnian.iteye.com/blog/2036420" target="_blank" rel="noopener">第十四章 SSL——《跟我学Shiro》</a><br>目录贴： <a href="http://jinnianshilongnian.iteye.com/blog/2018398" target="_blank" rel="noopener">跟我学Shiro目录贴</a><br>源码：<a href="https://github.com/zhangkaitao/shiro-example" target="_blank" rel="noopener">https://github.com/zhangkaitao/shiro-example</a></p></blockquote><p>对于 <code>SSL</code> 的支持，Shiro 只是判断当前 <code>url</code> 是否需要 <code>SSL</code> 登录，如果需要自动重定向到 <code>https</code> 进行访问。</p><h1 id="生成数字证书"><a href="#生成数字证书" class="headerlink" title="生成数字证书"></a>生成数字证书</h1><p>使用 <code>JDK</code> 的 <code>keytool</code> 命令，生成证书（包含证书/公钥/私钥）到 <code>D:\localhost.keystore</code>：</p><p><code>keytool -genkey -keystore &quot;D:\localhost.keystore&quot; -alias localhost -keyalg RSA</code></p><a id="more"></a><h1 id="设置-tomcat"><a href="#设置-tomcat" class="headerlink" title="设置 tomcat"></a>设置 tomcat</h1><p>此处使用了 <code>apache-tomcat-7.0.40</code> 版本，打开 <code>conf/server.xml</code>，加上：</p><pre><code class="xml">&lt;Connector port=&quot;8443&quot; protocol=&quot;HTTP/1.1&quot; SSLEnabled=&quot;true&quot;       maxThreads=&quot;150&quot; scheme=&quot;https&quot; secure=&quot;true&quot;       clientAuth=&quot;false&quot; sslProtocol=&quot;TLS&quot;       keystoreFile=&quot;D:\localhost.keystore&quot; keystorePass=&quot;123456&quot;/&gt; &lt;!-- 生成 keystore 时设置的密码 --&gt;</code></pre><h1 id="添加-SSL-到配置文件"><a href="#添加-SSL-到配置文件" class="headerlink" title="添加 SSL 到配置文件"></a>添加 SSL 到配置文件</h1><pre><code class="xml">&lt;bean id=&quot;sslFilter&quot; class=&quot;org.apache.shiro.web.filter.authz.SslFilter&quot;&gt;    &lt;property name=&quot;port&quot; value=&quot;8443&quot;/&gt; &lt;!-- 默认端口是 443，此处使用了 8443 --&gt;&lt;/bean&gt;&lt;bean id=&quot;shiroFilter&quot; class=&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;&gt;    &lt;!-- …… --&gt;    &lt;property name=&quot;filters&quot;&gt;        &lt;util:map&gt;            &lt;entry key=&quot;authc&quot; value-ref=&quot;formAuthenticationFilter&quot;/&gt;            &lt;entry key=&quot;ssl&quot; value-ref=&quot;sslFilter&quot;/&gt;        &lt;/util:map&gt;    &lt;/property&gt;    &lt;property name=&quot;filterChainDefinitions&quot;&gt;        &lt;value&gt;            /login.jsp = ssl,authc &lt;!-- 表示访问登录页面时需要走 SSL --&gt;            /logout = logout            /authenticated.jsp = authc            /** = user        &lt;/value&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre><h1 id="使用-Maven-Jetty-插件"><a href="#使用-Maven-Jetty-插件" class="headerlink" title="使用 Maven Jetty 插件"></a>使用 Maven Jetty 插件</h1><p>如果使用 Maven Jetty 插件，可以直接如下插件配置：</p><pre><code class="xml">&lt;plugin&gt;   &lt;groupId&gt;org.mortbay.jetty&lt;/groupId&gt;   &lt;artifactId&gt;jetty-maven-plugin&lt;/artifactId&gt;   &lt;version&gt;8.1.8.v20121106&lt;/version&gt;   &lt;configuration&gt;     &lt;webAppConfig&gt;       &lt;contextPath&gt;/${project.build.finalName}&lt;/contextPath&gt;     &lt;/webAppConfig&gt;     &lt;connectors&gt;     &lt;connector implementation=&quot;org.eclipse.jetty.server.nio.SelectChannelConnector&quot;&gt;       &lt;port&gt;8080&lt;/port&gt;     &lt;/connector&gt;     &lt;connector implementation=&quot;org.eclipse.jetty.server.ssl.SslSocketConnector&quot;&gt;       &lt;port&gt;8443&lt;/port&gt;       &lt;keystore&gt;${project.basedir}/localhost.keystore&lt;/keystore&gt;       &lt;password&gt;123456&lt;/password&gt;       &lt;keyPassword&gt;123456&lt;/keyPassword&gt;     &lt;/connector&gt;     &lt;/connectors&gt;   &lt;/configuration&gt;&lt;/plugin&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Shiro </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《跟我学Shiro》笔记13-RememberMe</title>
      <link href="/2018/04/19/%E3%80%8A%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%E3%80%8B%E7%AC%94%E8%AE%B013-RememberMe/"/>
      <url>/2018/04/19/%E3%80%8A%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%E3%80%8B%E7%AC%94%E8%AE%B013-RememberMe/</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文地址：<a href="http://jinnianshilongnian.iteye.com/blog/2031823" target="_blank" rel="noopener">第十三章 RememberMe——《跟我学Shiro》</a><br>目录贴： <a href="http://jinnianshilongnian.iteye.com/blog/2018398" target="_blank" rel="noopener">跟我学Shiro目录贴</a><br>源码：<a href="https://github.com/zhangkaitao/shiro-example" target="_blank" rel="noopener">https://github.com/zhangkaitao/shiro-example</a></p></blockquote><p>Shiro 提供了记住我（<code>RememberMe</code>）的功能，比如访问如淘宝等一些网站时，关闭了浏览器下次再打开时还是能记住你是谁，下次访问时无需再登录即可访问，基本流程如下：</p><ol><li>首先在登录页面选中 <code>RememberMe</code> 然后登录成功；如果是浏览器登录，一般会把 <code>RememberMe</code> 的 <code>Cookie</code> 写到客户端并保存下来；</li><li>关闭浏览器再重新打开；会发现浏览器还是记住你的；</li><li>访问一般的网页服务器端还是知道你是谁，且能正常访问；</li><li>但是比如我们访问淘宝时，如果要查看我的订单或进行支付时，此时还是需要再进行身份认证的，以确保当前用户还是你。</li></ol><a id="more"></a><h1 id="RememberMe-配置"><a href="#RememberMe-配置" class="headerlink" title="RememberMe 配置"></a>RememberMe 配置</h1><p><code>spring-shiro-web.xml</code> 配置：</p><pre><code class="xml">&lt;!-- 会话 Cookie 模板 --&gt;&lt;bean id=&quot;sessionIdCookie&quot; class=&quot;org.apache.shiro.web.servlet.SimpleCookie&quot;&gt;    &lt;constructor-arg value=&quot;sid&quot;/&gt;    &lt;property name=&quot;httpOnly&quot; value=&quot;true&quot;/&gt;    &lt;property name=&quot;maxAge&quot; value=&quot;-1&quot;/&gt; &lt;!-- 表示浏览器关闭时失效此 Cookie --&gt;&lt;/bean&gt;&lt;bean id=&quot;rememberMeCookie&quot; class=&quot;org.apache.shiro.web.servlet.SimpleCookie&quot;&gt;    &lt;constructor-arg value=&quot;rememberMe&quot;/&gt;    &lt;property name=&quot;httpOnly&quot; value=&quot;true&quot;/&gt;    &lt;property name=&quot;maxAge&quot; value=&quot;2592000&quot;/&gt; &lt;!-- 30 天 --&gt;&lt;/bean&gt;&lt;!-- rememberMe 管理器 --&gt;&lt;bean id=&quot;rememberMeManager&quot; class=&quot;org.apache.shiro.web.mgt.CookieRememberMeManager&quot;&gt;    &lt;!-- rememberMe cookie 加密的密钥 建议每个项目都不一样 默认 AES 算法 密钥长度（128 256 512 位）--&gt;    &lt;property name=&quot;cipherKey&quot;                value=&quot;#{T(org.apache.shiro.codec.Base64).decode(&#39;4AvVhmFLUs0KTA3Kprsdag==&#39;)}&quot;/&gt;    &lt;property name=&quot;cookie&quot; ref=&quot;rememberMeCookie&quot;/&gt;&lt;/bean&gt;&lt;/bean&gt;&lt;!-- 安全管理器 --&gt;&lt;bean id=&quot;securityManager&quot; class=&quot;org.apache.shiro.web.mgt.DefaultWebSecurityManager&quot;&gt;    &lt;property name=&quot;realm&quot; ref=&quot;userRealm&quot;/&gt;    &lt;property name=&quot;sessionManager&quot; ref=&quot;sessionManager&quot;/&gt;    &lt;property name=&quot;cacheManager&quot; ref=&quot;cacheManager&quot;/&gt;    &lt;!-- 设置 securityManager 安全管理器的 rememberMeManager --&gt;    &lt;property name=&quot;rememberMeManager&quot; ref=&quot;rememberMeManager&quot;/&gt;&lt;/bean&gt;&lt;!-- 基于 Form 表单的身份验证过滤器 --&gt;&lt;bean id=&quot;formAuthenticationFilter&quot; class=&quot;org.apache.shiro.web.filter.authc.FormAuthenticationFilter&quot;&gt;    &lt;property name=&quot;usernameParam&quot; value=&quot;username&quot;/&gt;    &lt;property name=&quot;passwordParam&quot; value=&quot;password&quot;/&gt;    &lt;!-- rememberMeParam，即 rememberMe 请求参数名，请求参数是 boolean 类型，true 表示 rememberMe。         页面上可以 &lt;input type=&quot;checkbox&quot; name=&quot;rememberMe&quot; value=&quot;true&quot;&gt; --&gt;    &lt;property name=&quot;rememberMeParam&quot; value=&quot;rememberMe&quot;/&gt;    &lt;property name=&quot;loginUrl&quot; value=&quot;/login.jsp&quot;/&gt;&lt;/bean&gt;&lt;!-- Shiro 的 Web 过滤器 --&gt;&lt;bean id=&quot;shiroFilter&quot; class=&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;&gt;    &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot;/&gt;    &lt;property name=&quot;loginUrl&quot; value=&quot;/login.jsp&quot;/&gt;    &lt;property name=&quot;unauthorizedUrl&quot; value=&quot;/unauthorized.jsp&quot;/&gt;    &lt;property name=&quot;filters&quot;&gt;        &lt;util:map&gt;            &lt;entry key=&quot;authc&quot; value-ref=&quot;formAuthenticationFilter&quot;/&gt;        &lt;/util:map&gt;    &lt;/property&gt;    &lt;!-- &quot;/authenticated.jsp = authc&quot; 表示访问该地址用户必须身份验证通过（Subject. isAuthenticated()==true）；    而 &quot;/** = user&quot; 表示访问该地址的用户是身份验证通过或 RememberMe 登录的都可以。 --&gt;    &lt;property name=&quot;filterChainDefinitions&quot;&gt;        &lt;value&gt;            /login.jsp = authc            /logout = logout            /authenticated.jsp = authc            /** = user        &lt;/value&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre><p>自己做 <code>RememeberMe</code>，需要在登录之前这样创建 <code>Token</code>：<code>UsernamePasswordToken</code>（用户名，密码，是否记住我），如：</p><pre><code class="java">Subject subject = SecurityUtils.getSubject();UsernamePasswordToken token = new UsernamePasswordToken(username, password);token.setRememberMe(true);subject.login(token);</code></pre><ul><li><code>subject.isAuthenticated()</code> 表示用户进行了身份验证登录的，即使有 <code>Subject.login</code> 进行了登录；</li><li><code>subject.isRemembered()</code>：表示用户是通过记住我登录的，此时可能并不是真正的你（如你的朋友使用你的电脑，或者你的 <code>cookie</code> 被窃取）在访问的；</li><li>且两者二选一，即 <code>subject.isAuthenticated()==true</code>，则 <code>subject.isRemembered()==false</code>；反之一样。</li></ul><p>另外对于过滤器，一般这样使用：</p><p><strong>访问一般网页</strong>，如个人在主页之类的，我们使用 <code>user</code> 拦截器即可，<code>user</code> 拦截器只要用户登录 <code>(isRemembered()==true or isAuthenticated()==true)</code> 过即可访问成功；</p><p><strong>访问特殊网页</strong>，如我的订单，提交订单页面，我们使用 <code>authc</code> 拦截器即可，<code>authc</code> 拦截器会判断用户是否是通过 <code>Subject.login(isAuthenticated()==true)</code> 登录的，如果是才放行，否则会跳转到登录页面叫你重新登录。</p><p>因此 <code>RememberMe</code> 使用过程中，需要配合相应的拦截器来实现相应的功能，用错了拦截器可能就不能满足你的需求了。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Shiro </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《跟我学Shiro》笔记12-与Spring集成</title>
      <link href="/2018/04/18/%E3%80%8A%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%E3%80%8B%E7%AC%94%E8%AE%B012-%E4%B8%8ESpring%E9%9B%86%E6%88%90/"/>
      <url>/2018/04/18/%E3%80%8A%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%E3%80%8B%E7%AC%94%E8%AE%B012-%E4%B8%8ESpring%E9%9B%86%E6%88%90/</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文地址：<a href="http://jinnianshilongnian.iteye.com/blog/2029717" target="_blank" rel="noopener">第十二章 与Spring集成——《跟我学Shiro》</a><br>目录贴： <a href="http://jinnianshilongnian.iteye.com/blog/2018398" target="_blank" rel="noopener">跟我学Shiro目录贴</a><br>源码：<a href="https://github.com/zhangkaitao/shiro-example" target="_blank" rel="noopener">https://github.com/zhangkaitao/shiro-example</a></p></blockquote><p>Shiro 的组件都是 JavaBean/POJO 式的组件，所以非常容易使用 <code>Spring</code> 进行组件管理，可以非常方便的从 <code>ini</code> 配置迁移到 <code>Spring</code> 进行管理，且支持 <code>JavaSE</code> 应用及 <code>Web</code> 应用的集成。</p><a id="more"></a><h1 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h1><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;    &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt;    &lt;version&gt;1.2.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 省略 spring 等其他 jar 包 --&gt;</code></pre><h1 id="JavaSE-应用"><a href="#JavaSE-应用" class="headerlink" title="JavaSE 应用"></a>JavaSE 应用</h1><pre><code class="xml">&lt;!-- 缓存管理器 使用 Ehcache 实现 --&gt;&lt;!-- cacheManager=org.apache.shiro.cache.ehcache.EhCacheManager     cacheManager.cacheManagerConfigFile=classpath:shiro-ehcache.xml --&gt;&lt;bean id=&quot;cacheManager&quot; class=&quot;org.apache.shiro.cache.ehcache.EhCacheManager&quot;&gt;    &lt;property name=&quot;cacheManagerConfigFile&quot; value=&quot;classpath:ehcache.xml&quot;/&gt;&lt;/bean&gt;&lt;!-- 凭证匹配器 --&gt;&lt;!-- credentialsMatcher=com.github.zhangkaitao.shiro.chapter12.credentials.RetryLimitHashedCredentialsMatcher     credentialsMatcher.hashAlgorithmName=md5     credentialsMatcher.hashIterations=2     credentialsMatcher.storedCredentialsHexEncoded=true --&gt;&lt;bean id=&quot;credentialsMatcher&quot; class=&quot;com.github.zhangkaitao.shiro.chapter12.credentials.RetryLimitHashedCredentialsMatcher&quot;&gt;    &lt;constructor-arg ref=&quot;cacheManager&quot;/&gt;    &lt;property name=&quot;hashAlgorithmName&quot; value=&quot;md5&quot;/&gt;    &lt;property name=&quot;hashIterations&quot; value=&quot;2&quot;/&gt;    &lt;property name=&quot;storedCredentialsHexEncoded&quot; value=&quot;true&quot;/&gt;&lt;/bean&gt;&lt;!-- Realm 实现 --&gt;&lt;!-- userRealm=com.github.zhangkaitao.shiro.chapter11.realm.UserRealm     userRealm.credentialsMatcher=$credentialsMatcher     userRealm.cachingEnabled=true     userRealm.authenticationCachingEnabled=true     userRealm.authenticationCacheName=authenticationCache     userRealm.authorizationCachingEnabled=true     userRealm.authorizationCacheName=authorizationCache --&gt;&lt;bean id=&quot;userRealm&quot; class=&quot;com.github.zhangkaitao.shiro.chapter12.realm.UserRealm&quot;&gt;    &lt;property name=&quot;userService&quot; ref=&quot;userService&quot;/&gt;    &lt;property name=&quot;credentialsMatcher&quot; ref=&quot;credentialsMatcher&quot;/&gt;    &lt;property name=&quot;cachingEnabled&quot; value=&quot;true&quot;/&gt;    &lt;property name=&quot;authenticationCachingEnabled&quot; value=&quot;true&quot;/&gt;    &lt;property name=&quot;authenticationCacheName&quot; value=&quot;authenticationCache&quot;/&gt;    &lt;property name=&quot;authorizationCachingEnabled&quot; value=&quot;true&quot;/&gt;    &lt;property name=&quot;authorizationCacheName&quot; value=&quot;authorizationCache&quot;/&gt;&lt;/bean&gt;&lt;!-- 会话 ID 生成器 --&gt;&lt;!-- sessionIdGenerator=org.apache.shiro.session.mgt.eis.JavaUuidSessionIdGenerator --&gt;&lt;bean id=&quot;sessionIdGenerator&quot; class=&quot;org.apache.shiro.session.mgt.eis.JavaUuidSessionIdGenerator&quot;/&gt;&lt;!-- 会话 DAO --&gt;&lt;!-- sessionDAO.sessionIdGenerator=$sessionIdGenerator     sessionDAO.activeSessionsCacheName=shiro-activeSessionCache --&gt;&lt;bean id=&quot;sessionDAO&quot; class=&quot;org.apache.shiro.session.mgt.eis.EnterpriseCacheSessionDAO&quot;&gt;    &lt;property name=&quot;activeSessionsCacheName&quot; value=&quot;shiro-activeSessionCache&quot;/&gt;    &lt;property name=&quot;sessionIdGenerator&quot; ref=&quot;sessionIdGenerator&quot;/&gt;&lt;/bean&gt;&lt;!-- 会话验证调度器 --&gt;&lt;!-- sessionValidationScheduler=org.apache.shiro.session.mgt.quartz.QuartzSessionValidationSchedulersessionValidationScheduler.sessionValidationInterval = 1800000sessionValidationScheduler.sessionManager=$sessionManager --&gt;&lt;bean id=&quot;sessionValidationScheduler&quot; class=&quot;org.apache.shiro.session.mgt.quartz.QuartzSessionValidationScheduler&quot;&gt;    &lt;property name=&quot;sessionValidationInterval&quot; value=&quot;1800000&quot;/&gt;    &lt;property name=&quot;sessionManager&quot; ref=&quot;sessionManager&quot;/&gt;&lt;/bean&gt;&lt;!-- 会话管理器 --&gt;&lt;!-- sessionManager=org.apache.shiro.session.mgt.DefaultSessionManager     sessionManager.globalSessionTimeout=1800000     sessionManager.deleteInvalidSessions=true     sessionManager.sessionValidationSchedulerEnabled=true     sessionManager.sessionValidationScheduler=$sessionValidationScheduler     sessionManager.sessionDAO=$sessionDAO --&gt;&lt;bean id=&quot;sessionManager&quot; class=&quot;org.apache.shiro.session.mgt.DefaultSessionManager&quot;&gt;    &lt;property name=&quot;globalSessionTimeout&quot; value=&quot;1800000&quot;/&gt;    &lt;property name=&quot;deleteInvalidSessions&quot; value=&quot;true&quot;/&gt;    &lt;property name=&quot;sessionValidationSchedulerEnabled&quot; value=&quot;true&quot;/&gt;    &lt;property name=&quot;sessionValidationScheduler&quot; ref=&quot;sessionValidationScheduler&quot;/&gt;    &lt;property name=&quot;sessionDAO&quot; ref=&quot;sessionDAO&quot;/&gt;&lt;/bean&gt;&lt;!-- 安全管理器 --&gt;&lt;!-- securityManager.realms=$userRealm     securityManager.sessionManager=$sessionManager     securityManager.cacheManager=$cacheManager --&gt;&lt;bean id=&quot;securityManager&quot; class=&quot;org.apache.shiro.mgt.DefaultSecurityManager&quot;&gt;    &lt;property name=&quot;realms&quot;&gt;        &lt;list&gt;            &lt;ref bean=&quot;userRealm&quot;/&gt;        &lt;/list&gt;    &lt;/property&gt;    &lt;property name=&quot;sessionManager&quot; ref=&quot;sessionManager&quot;/&gt;    &lt;property name=&quot;cacheManager&quot; ref=&quot;cacheManager&quot;/&gt;&lt;/bean&gt;&lt;!-- 相当于调用 SecurityUtils.setSecurityManager(securityManager) --&gt;&lt;bean class=&quot;org.springframework.beans.factory.config.MethodInvokingFactoryBean&quot;&gt;    &lt;property name=&quot;staticMethod&quot; value=&quot;org.apache.shiro.SecurityUtils.setSecurityManager&quot;/&gt;    &lt;property name=&quot;arguments&quot; ref=&quot;securityManager&quot;/&gt;&lt;/bean&gt;&lt;!-- Shiro 生命周期处理器--&gt;&lt;bean id=&quot;lifecycleBeanPostProcessor&quot; class=&quot;org.apache.shiro.spring.LifecycleBeanPostProcessor&quot;/&gt;</code></pre><p><code>LifecycleBeanPostProcessor</code> 用于在实现了 <code>Initializable</code> 接口的 Shiro bean 初始化时调用 <code>Initializable</code> 接口回调，在实现了 <code>Destroyable</code> 接口的 Shiro bean 销毁时调用 <code>Destroyable</code> 接口回调。如 <code>UserRealm</code> 就实现了 <code>Initializable</code>，而 <code>DefaultSecurityManager</code> 实现了 <code>Destroyable</code>。具体可以查看它们的继承关系。</p><h1 id="Web-应用"><a href="#Web-应用" class="headerlink" title="Web 应用"></a>Web 应用</h1><p><code>Web</code> 应用和普通 <code>JavaSE</code> 应用的某些配置是类似的。</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:util=&quot;http://www.springframework.org/schema/util&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd&quot;&gt;    &lt;!-- 缓存管理器 使用 Ehcache 实现 --&gt;    &lt;bean id=&quot;cacheManager&quot; class=&quot;org.apache.shiro.cache.ehcache.EhCacheManager&quot;&gt;        &lt;property name=&quot;cacheManagerConfigFile&quot; value=&quot;classpath:ehcache.xml&quot;/&gt;    &lt;/bean&gt;    &lt;!-- 凭证匹配器 --&gt;    &lt;bean id=&quot;credentialsMatcher&quot; class=&quot;com.github.zhangkaitao.shiro.chapter12.credentials.RetryLimitHashedCredentialsMatcher&quot;&gt;        &lt;constructor-arg ref=&quot;cacheManager&quot;/&gt;        &lt;property name=&quot;hashAlgorithmName&quot; value=&quot;md5&quot;/&gt;        &lt;property name=&quot;hashIterations&quot; value=&quot;2&quot;/&gt;        &lt;property name=&quot;storedCredentialsHexEncoded&quot; value=&quot;true&quot;/&gt;    &lt;/bean&gt;    &lt;!-- Realm 实现 --&gt;    &lt;bean id=&quot;userRealm&quot; class=&quot;com.github.zhangkaitao.shiro.chapter12.realm.UserRealm&quot;&gt;        &lt;property name=&quot;userService&quot; ref=&quot;userService&quot;/&gt;        &lt;property name=&quot;credentialsMatcher&quot; ref=&quot;credentialsMatcher&quot;/&gt;        &lt;property name=&quot;cachingEnabled&quot; value=&quot;true&quot;/&gt;        &lt;property name=&quot;authenticationCachingEnabled&quot; value=&quot;true&quot;/&gt;        &lt;property name=&quot;authenticationCacheName&quot; value=&quot;authenticationCache&quot;/&gt;        &lt;property name=&quot;authorizationCachingEnabled&quot; value=&quot;true&quot;/&gt;        &lt;property name=&quot;authorizationCacheName&quot; value=&quot;authorizationCache&quot;/&gt;    &lt;/bean&gt;    &lt;!-- 会话 ID 生成器 --&gt;    &lt;bean id=&quot;sessionIdGenerator&quot; class=&quot;org.apache.shiro.session.mgt.eis.JavaUuidSessionIdGenerator&quot;/&gt;    &lt;!-- 会话 Cookie 模板，是用于生产 Session ID Cookie 的模板 --&gt;    &lt;bean id=&quot;sessionIdCookie&quot; class=&quot;org.apache.shiro.web.servlet.SimpleCookie&quot;&gt;        &lt;constructor-arg value=&quot;sid&quot;/&gt;        &lt;property name=&quot;httpOnly&quot; value=&quot;true&quot;/&gt;        &lt;property name=&quot;maxAge&quot; value=&quot;180000&quot;/&gt;    &lt;/bean&gt;    &lt;!-- 会话 DAO --&gt;    &lt;bean id=&quot;sessionDAO&quot; class=&quot;org.apache.shiro.session.mgt.eis.EnterpriseCacheSessionDAO&quot;&gt;        &lt;property name=&quot;activeSessionsCacheName&quot; value=&quot;shiro-activeSessionCache&quot;/&gt;        &lt;property name=&quot;sessionIdGenerator&quot; ref=&quot;sessionIdGenerator&quot;/&gt;    &lt;/bean&gt;    &lt;!-- 会话验证调度器 --&gt;    &lt;bean id=&quot;sessionValidationScheduler&quot; class=&quot;org.apache.shiro.session.mgt.quartz.QuartzSessionValidationScheduler&quot;&gt;        &lt;property name=&quot;sessionValidationInterval&quot; value=&quot;1800000&quot;/&gt;        &lt;property name=&quot;sessionManager&quot; ref=&quot;sessionManager&quot;/&gt;    &lt;/bean&gt;    &lt;!-- 会话管理器，用于 web 环境的 DefaultWebSessionManager --&gt;    &lt;bean id=&quot;sessionManager&quot; class=&quot;org.apache.shiro.web.session.mgt.DefaultWebSessionManager&quot;&gt;        &lt;property name=&quot;globalSessionTimeout&quot; value=&quot;1800000&quot;/&gt;        &lt;property name=&quot;deleteInvalidSessions&quot; value=&quot;true&quot;/&gt;        &lt;property name=&quot;sessionValidationSchedulerEnabled&quot; value=&quot;true&quot;/&gt;        &lt;property name=&quot;sessionValidationScheduler&quot; ref=&quot;sessionValidationScheduler&quot;/&gt;        &lt;property name=&quot;sessionDAO&quot; ref=&quot;sessionDAO&quot;/&gt;        &lt;property name=&quot;sessionIdCookieEnabled&quot; value=&quot;true&quot;/&gt;        &lt;property name=&quot;sessionIdCookie&quot; ref=&quot;sessionIdCookie&quot;/&gt;    &lt;/bean&gt;    &lt;!-- 安全管理器，用于 web 环境的 DefaultWebSecurityManager --&gt;    &lt;bean id=&quot;securityManager&quot; class=&quot;org.apache.shiro.web.mgt.DefaultWebSecurityManager&quot;&gt;        &lt;property name=&quot;realm&quot; ref=&quot;userRealm&quot;/&gt;        &lt;property name=&quot;sessionManager&quot; ref=&quot;sessionManager&quot;/&gt;        &lt;property name=&quot;cacheManager&quot; ref=&quot;cacheManager&quot;/&gt;    &lt;/bean&gt;    &lt;!-- 相当于调用 SecurityUtils.setSecurityManager(securityManager) --&gt;    &lt;bean class=&quot;org.springframework.beans.factory.config.MethodInvokingFactoryBean&quot;&gt;        &lt;property name=&quot;staticMethod&quot; value=&quot;org.apache.shiro.SecurityUtils.setSecurityManager&quot;/&gt;        &lt;property name=&quot;arguments&quot; ref=&quot;securityManager&quot;/&gt;    &lt;/bean&gt;    &lt;!-- 基于 Form 表单的身份验证过滤器 --&gt;    &lt;bean id=&quot;formAuthenticationFilter&quot; class=&quot;org.apache.shiro.web.filter.authc.FormAuthenticationFilter&quot;&gt;        &lt;property name=&quot;usernameParam&quot; value=&quot;username&quot;/&gt;        &lt;property name=&quot;passwordParam&quot; value=&quot;password&quot;/&gt;        &lt;property name=&quot;loginUrl&quot; value=&quot;/login.jsp&quot;/&gt;    &lt;/bean&gt;    &lt;!-- Shiro 的 Web 过滤器 --&gt;    &lt;bean id=&quot;shiroFilter&quot; class=&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;&gt;        &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot;/&gt;        &lt;property name=&quot;loginUrl&quot; value=&quot;/login.jsp&quot;/&gt;        &lt;property name=&quot;unauthorizedUrl&quot; value=&quot;/unauthorized.jsp&quot;/&gt;        &lt;property name=&quot;filters&quot;&gt;            &lt;util:map&gt;                &lt;entry key=&quot;authc&quot; value-ref=&quot;formAuthenticationFilter&quot;/&gt;            &lt;/util:map&gt;        &lt;/property&gt;        &lt;property name=&quot;filterChainDefinitions&quot;&gt;            &lt;value&gt;                /index.jsp = anon                /unauthorized.jsp = anon                /login.jsp = authc                /logout = logout                /** = user            &lt;/value&gt;        &lt;/property&gt;    &lt;/bean&gt;    &lt;!-- Shiro 生命周期处理器--&gt;    &lt;bean id=&quot;lifecycleBeanPostProcessor&quot; class=&quot;org.apache.shiro.spring.LifecycleBeanPostProcessor&quot;/&gt;</code></pre><ol><li><code>formAuthenticationFilter</code> 为基于 <code>Form</code> 表单的身份验证过滤器；此处可以再添加自己的 <code>Filter bean</code> 定义；</li><li><code>shiroFilter</code>：此处使用 <code>ShiroFilterFactoryBean</code> 来创建 <code>ShiroFilter</code> 过滤器；<code>filters</code> 属性用于定义自己的过滤器，即 <code>ini</code> 配置中的 <code>[filters]</code> 部分；<code>filterChainDefinitions</code> 用于声明 <code>url</code> 和 <code>filter</code> 的关系，即 <code>ini</code> 配置中的 <code>[urls]</code> 部分。</li></ol><p>在 <code>web.xml</code> 中进行如下配置：</p><pre><code class="xml">&lt;!-- 通过 ContextLoaderListener 加载 contextConfigLocation 指定的 Spring 配置文件。 --&gt;&lt;context-param&gt;    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;    &lt;param-value&gt;        classpath:spring-beans.xml,        classpath:spring-shiro-web.xml    &lt;/param-value&gt;&lt;/context-param&gt;&lt;listener&gt;    &lt;listener-class&gt;        org.springframework.web.context.ContextLoaderListener    &lt;/listener-class&gt;&lt;/listener&gt;&lt;!-- DelegatingFilterProxy 会自动到 Spring 容器中查找名字为 shiroFilter 的 bean 并把 filter 请求交给它处理。 --&gt;&lt;filter&gt;    &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;    &lt;async-supported&gt;true&lt;/async-supported&gt;    &lt;init-param&gt;        &lt;param-name&gt;targetFilterLifecycle&lt;/param-name&gt;        &lt;param-value&gt;true&lt;/param-value&gt;    &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt;    &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;</code></pre><h1 id="Shiro-权限注解"><a href="#Shiro-权限注解" class="headerlink" title="Shiro 权限注解"></a>Shiro 权限注解</h1><p>Shiro 提供了相应的注解用于权限控制，如果使用这些注解就需要使用 <code>AOP</code> 的功能来进行判断，如 <code>Spring AOP</code>；Shiro 提供了 <code>Spring AOP</code> 集成用于权限注解的解析和验证。</p><p>为了测试，此处使用了 <code>Spring MVC</code> 来测试 Shiro 注解，当然 Shiro 注解不仅仅可以在 <code>web</code> 环境使用，在独立的 <code>JavaSE</code> 中也是可以用的，此处只是以 <code>web</code> 为例了。</p><p>在 <code>spring-mvc.xml</code> 配置文件<strong>添加 Shiro Spring AOP 权限注解的支持</strong>：</p><pre><code class="xml">&lt;!-- 表示代理类 --&gt;&lt;aop:config proxy-target-class=&quot;true&quot;&gt;&lt;/aop:config&gt;&lt;bean class=&quot;org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor&quot;&gt;    &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot;/&gt;&lt;/bean&gt;&lt;!-- 控制器异常处理 --&gt;&lt;bean id=&quot;exceptionHandlerExceptionResolver&quot; class=&quot;org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver&quot;&gt;&lt;/bean&gt;&lt;bean class=&quot;com.github.zhangkaitao.shiro.chapter12.web.exception.DefaultExceptionHandler&quot;/&gt;</code></pre><p>在相应的控制器（<code>AnnotationController</code>）中使用如下方式进行注解：</p><pre><code class="java">// 访问 hello2 方法的前提是当前用户有 admin 角色@RequiresRoles(&quot;admin&quot;)@RequestMapping(&quot;/hello2&quot;)public String hello2() {    return &quot;success&quot;;}</code></pre><p>当验证失败，其会抛出 <code>UnauthorizedException</code> 异常，此时可以使用 <code>Spring</code> 的 <code>ExceptionHandler</code>（<code>DefaultExceptionHandler</code>）来进行拦截处理：</p><pre><code class="java">@ExceptionHandler({UnauthorizedException.class})@ResponseStatus(HttpStatus.UNAUTHORIZED)public ModelAndView processUnauthenticatedException(NativeWebRequest request, UnauthorizedException e) {    ModelAndView mv = new ModelAndView();    mv.addObject(&quot;exception&quot;, e);    mv.setViewName(&quot;unauthorized&quot;);    return mv;}</code></pre><p>如果集成 Struts2，需要注意<a href="http://jinnianshilongnian.iteye.com/blog/1850425" target="_blank" rel="noopener">《Shiro+Struts2+Spring3 加上@RequiresPermissions 后@Autowired失效》</a>问题。</p><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><pre><code class="java">@RequiresAuthentication // 表示当前 Subject 已经通过 login 进行了身份验证；即 Subject.isAuthenticated() 返回 true。@RequiresUser // 表示当前 Subject 已经身份验证或者通过记住我登录的@RequiresGuest // 表示当前 Subject 没有身份验证或通过记住我登录过，即是游客身份。@RequiresRoles(value={&quot;admin&quot;, &quot;user&quot;}, logical=Logical.AND) // 表示当前 Subject 需要角色 admin 和 user。@RequiresPermissions (value={&quot;user:a&quot;, &quot;user:b&quot;}, logical=Logical.OR) // 表示当前 Subject 需要权限 user:a 或 user:b。</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Shiro </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《跟我学Shiro》笔记11-缓存机制</title>
      <link href="/2018/04/17/%E3%80%8A%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%E3%80%8B%E7%AC%94%E8%AE%B011-%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
      <url>/2018/04/17/%E3%80%8A%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%E3%80%8B%E7%AC%94%E8%AE%B011-%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文地址：<a href="http://jinnianshilongnian.iteye.com/blog/2029217" target="_blank" rel="noopener">第十一章 缓存机制——《跟我学Shiro》</a><br>目录贴： <a href="http://jinnianshilongnian.iteye.com/blog/2018398" target="_blank" rel="noopener">跟我学Shiro目录贴</a><br>源码：<a href="https://github.com/zhangkaitao/shiro-example" target="_blank" rel="noopener">https://github.com/zhangkaitao/shiro-example</a></p></blockquote><h1 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h1><p>Shiro 提供了类似于 <code>Spring</code> 的 <code>Cache</code> 抽象，即 Shiro 本身不实现 <code>Cache</code>，但是对 <code>Cache</code> 进行了又抽象，方便更换不同的底层 <code>Cache</code> 实现。对于 <code>Cache</code> 的一些概念可以参考<a href="http://jinnianshilongnian.iteye.com/blog/2001040" target="_blank" rel="noopener">《Spring Cache抽象详解》</a>。</p><h2 id="Shiro-提供的-Cache-接口"><a href="#Shiro-提供的-Cache-接口" class="headerlink" title="Shiro 提供的 Cache 接口"></a>Shiro 提供的 Cache 接口</h2><pre><code class="java">public interface Cache&lt;K, V&gt; {    // 根据 Key 获取缓存中的值    public V get(K key) throws CacheException;    // 往缓存中放入 key-value，返回缓存中之前的值    public V put(K key, V value) throws CacheException;    // 移除缓存中 key 对应的值，返回该值    public V remove(K key) throws CacheException;    // 清空整个缓存    public void clear() throws CacheException;    // 返回缓存大小    public int size();    // 获取缓存中所有的 key    public Set&lt;K&gt; keys();    // 获取缓存中所有的 value    public Collection&lt;V&gt; values();}</code></pre><a id="more"></a><h2 id="Shiro-提供的-CacheManager-接口"><a href="#Shiro-提供的-CacheManager-接口" class="headerlink" title="Shiro 提供的 CacheManager 接口"></a>Shiro 提供的 CacheManager 接口</h2><pre><code class="java">public interface CacheManager {    // 根据缓存名字获取一个 Cache    public &lt;K, V&gt; Cache&lt;K, V&gt; getCache(String name) throws CacheException;}</code></pre><p>Shiro 还提供了 <code>CacheManagerAware</code> 用于注入 <code>CacheManager</code>：</p><pre><code class="java">public interface CacheManagerAware {    // 注入 CacheManager    void setCacheManager(CacheManager cacheManager);}</code></pre><p>Shiro 内部相应的组件（<code>DefaultSecurityManager</code>）会自动检测相应的对象（如 <code>Realm</code>）是否实现了 <code>CacheManagerAware</code> 并自动注入相应的 <code>CacheManager</code>。</p><h1 id="Realm-缓存"><a href="#Realm-缓存" class="headerlink" title="Realm 缓存"></a>Realm 缓存</h1><p>Shiro 提供了 <code>CachingRealm</code>，其实现了 <code>CacheManagerAware</code> 接口，提供了缓存的一些基础实现；另外 <code>AuthenticatingRealm</code> 及 <code>AuthorizingRealm</code> 分别提供了对 <code>AuthenticationInfo</code> 和 <code>AuthorizationInfo</code> 信息的缓存。</p><h2 id="ini配置"><a href="#ini配置" class="headerlink" title="ini配置"></a>ini配置</h2><pre><code class="ini">[main]credentialsMatcher=com.github.zhangkaitao.shiro.chapter11.credentials.RetryLimitHashedCredentialsMatchercredentialsMatcher.hashAlgorithmName=md5credentialsMatcher.hashIterations=2credentialsMatcher.storedCredentialsHexEncoded=trueuserRealm=com.github.zhangkaitao.shiro.chapter11.realm.UserRealmuserRealm.credentialsMatcher=$credentialsMatcher;启用缓存，默认 falseuserRealm.cachingEnabled=true;启用身份验证缓存，即缓存 AuthenticationInfo 信息，默认 falseuserRealm.authenticationCachingEnabled=true;缓存 AuthenticationInfo 信息的缓存名称（在 shiro-ehcache.xml 中配置相同名字的缓存）userRealm.authenticationCacheName=authenticationCache;启用授权缓存，即缓存 AuthorizationInfo 信息，默认 falseuserRealm.authorizationCachingEnabled=true;缓存 AuthorizationInfo 信息的缓存名称（在 shiro-ehcache.xml 中配置相同名字的缓存）userRealm.authorizationCacheName=authorizationCachesecurityManager.realms=$userRealm;缓存管理器，此处使用 EhCacheManager，即 Ehcache实现cacheManager=org.apache.shiro.cache.ehcache.EhCacheManagercacheManager.cacheManagerConfigFile=classpath:shiro-ehcache.xmlsecurityManager.cacheManager=$cacheManager</code></pre><h2 id="UserRealm"><a href="#UserRealm" class="headerlink" title="UserRealm"></a>UserRealm</h2><pre><code class="java">public class UserRealm extends AuthorizingRealm {    private UserService userService = new UserServiceImpl();    @Override    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {        String username = (String)principals.getPrimaryPrincipal();        SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo();        authorizationInfo.setRoles(userService.findRoles(username));        authorizationInfo.setStringPermissions(userService.findPermissions(username));        return authorizationInfo;    }    @Override    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {        String username = (String)token.getPrincipal();        User user = userService.findByUsername(username);        if(user == null) {            throw new UnknownAccountException(); // 没找到帐号        }        if(Boolean.TRUE.equals(user.getLocked())) {            throw new LockedAccountException(); // 帐号锁定        }        // 交给 AuthenticatingRealm 使用 CredentialsMatcher 进行密码匹配，如果觉得人家的不好可以自定义实现        SimpleAuthenticationInfo authenticationInfo = new SimpleAuthenticationInfo(                user.getUsername(), // 用户名                user.getPassword(), // 密码                ByteSource.Util.bytes(user.getCredentialsSalt()), //s alt=username+salt                getName()  // realm name        );        return authenticationInfo;    }    @Override    public void clearCachedAuthorizationInfo(PrincipalCollection principals) {        super.clearCachedAuthorizationInfo(principals);    }    @Override    public void clearCachedAuthenticationInfo(PrincipalCollection principals) {        super.clearCachedAuthenticationInfo(principals);    }    @Override    public void clearCache(PrincipalCollection principals) {        super.clearCache(principals);    }    public void clearAllCachedAuthorizationInfo() {        getAuthorizationCache().clear();    }    public void clearAllCachedAuthenticationInfo() {        getAuthenticationCache().clear();    }    // 清空整个缓存    public void clearAllCache() {        clearAllCachedAuthenticationInfo();        clearAllCachedAuthorizationInfo();    }}</code></pre><h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><pre><code class="java">@Testpublic void testClearCachedAuthenticationInfo() {    login(u1.getUsername(), password);    userService.changePassword(u1.getId(), password + &quot;1&quot;);    RealmSecurityManager securityManager = (RealmSecurityManager) SecurityUtils.getSecurityManager();    UserRealm userRealm = (UserRealm) securityManager.getRealms().iterator().next();    userRealm.clearCachedAuthenticationInfo(subject().getPrincipals());    login(u1.getUsername(), password + &quot;1&quot;);}</code></pre><p>首先登录成功（此时会缓存相应的 <code>AuthenticationInfo</code>），然后修改密码；此时密码就变了；接着需要调用 <code>Realm</code> 的 <code>clearCachedAuthenticationInfo</code> 方法清空之前缓存的 <code>AuthenticationInfo</code>；否则下次登录时还会获取到修改密码之前的那个 <code>AuthenticationInfo</code>；</p><pre><code class="java">// 此处调用 Realm 的 clearCachedAuthorizationInfo 清空之前缓存的 AuthorizationInfo@Testpublic void testClearCachedAuthorizationInfo() {    login(u1.getUsername(), password);    subject().checkRole(r1.getRole());    userService.correlationRoles(u1.getId(), r2.getId());    RealmSecurityManager securityManager = (RealmSecurityManager) SecurityUtils.getSecurityManager();    UserRealm userRealm = (UserRealm) securityManager.getRealms().iterator().next();    userRealm.clearCachedAuthorizationInfo(subject().getPrincipals());    subject().checkRole(r2.getRole());}</code></pre><pre><code class="java">// 同时调用 clearCachedAuthenticationInfo 和 clearCachedAuthorizationInfo，清空 AuthenticationInfo 和 AuthorizationInfo@Testpublic void testClearCache() {    login(u1.getUsername(), password);    subject().checkRole(r1.getRole());    userService.changePassword(u1.getId(), password + &quot;1&quot;);    userService.correlationRoles(u1.getId(), r2.getId());    RealmSecurityManager securityManager = (RealmSecurityManager) SecurityUtils.getSecurityManager();    UserRealm userRealm = (UserRealm) securityManager.getRealms().iterator().next();    userRealm.clearCache(subject().getPrincipals());    login(u1.getUsername(), password + &quot;1&quot;);    subject().checkRole(r2.getRole());}</code></pre><p>在某些清空下这种方式可能不是最好的选择，可以考虑直接废弃 Shiro 的缓存，然后自己通过如 <code>AOP</code> 机制实现自己的缓存；可以参考：<br><a href="https://github.com/zhangkaitao/es/tree/master/web/src/main/java/com/sishuok/es/extra/aop" target="_blank" rel="noopener">https://github.com/zhangkaitao/es/tree/master/web/src/main/java/com/sishuok/es/extra/aop</a></p><p>另外如果和 <code>Spring</code> 集成时可以考虑直接使用 <code>Spring</code> 的 <code>Cache</code> 抽象，可以考虑使用 <code>SpringCacheManagerWrapper</code>，其对 <code>Spring Cache</code> 进行了包装，转换为 Shiro 的 <code>CacheManager</code> 实现：<br><a href="https://github.com/zhangkaitao/es/blob/master/web/src/main/java/org/apache/shiro/cache/spring/SpringCacheManagerWrapper.java" target="_blank" rel="noopener">https://github.com/zhangkaitao/es/blob/master/web/src/main/java/org/apache/shiro/cache/spring/SpringCacheManagerWrapper.java</a></p><h1 id="Session-缓存"><a href="#Session-缓存" class="headerlink" title="Session 缓存"></a>Session 缓存</h1><pre><code class="ini">securityManager.cacheManager=$cacheManagersessionManager=org.apache.shiro.session.mgt.DefaultSessionManagersessionDAO=com.github.zhangkaitao.shiro.chapter11.session.dao.MySessionDAOsessionDAO.activeSessionsCacheName=shiro-activeSessionCachesecurityManager.sessionManager=$sessionManager</code></pre><p>如 <code>securityManager</code> 实现了 <code>SessionsSecurityManager</code>，其会自动判断 <code>SessionManager</code> 是否实现了 <code>CacheManagerAware</code> 接口，如果实现了会把 <code>CacheManager</code> 设置给它。然后 <code>sessionManager</code> 会判断相应的 <code>sessionDAO</code>（如继承自 <code>CachingSessionDAO</code>）是否实现了 <code>CacheManagerAware</code>，如果实现了会把 <code>CacheManager</code> 设置给它；如第九章的 <code>MySessionDAO</code> 就是带缓存的 <code>SessionDAO</code>；其会先查缓存，如果找不到才查数据库。</p><h1 id="shiro-ehcache-xml"><a href="#shiro-ehcache-xml" class="headerlink" title="shiro-ehcache.xml"></a>shiro-ehcache.xml</h1><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;ehcache name=&quot;shirocache&quot;&gt;    &lt;diskStore path=&quot;java.io.tmpdir&quot;/&gt;    &lt;cache name=&quot;authorizationCache&quot;           maxEntriesLocalHeap=&quot;2000&quot;           eternal=&quot;false&quot;           timeToIdleSeconds=&quot;3600&quot;           timeToLiveSeconds=&quot;0&quot;           overflowToDisk=&quot;false&quot;           statistics=&quot;true&quot;&gt;    &lt;/cache&gt;    &lt;cache name=&quot;authenticationCache&quot;           maxEntriesLocalHeap=&quot;2000&quot;           eternal=&quot;false&quot;           timeToIdleSeconds=&quot;3600&quot;           timeToLiveSeconds=&quot;0&quot;           overflowToDisk=&quot;false&quot;           statistics=&quot;true&quot;&gt;    &lt;/cache&gt;    &lt;cache name=&quot;shiro-activeSessionCache&quot;           maxEntriesLocalHeap=&quot;2000&quot;           eternal=&quot;false&quot;           timeToIdleSeconds=&quot;3600&quot;           timeToLiveSeconds=&quot;0&quot;           overflowToDisk=&quot;false&quot;           statistics=&quot;true&quot;&gt;    &lt;/cache&gt;&lt;/ehcache&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Shiro </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《跟我学Shiro》笔记10-会话管理</title>
      <link href="/2018/04/17/%E3%80%8A%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%E3%80%8B%E7%AC%94%E8%AE%B010-%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86/"/>
      <url>/2018/04/17/%E3%80%8A%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%E3%80%8B%E7%AC%94%E8%AE%B010-%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文地址：<a href="https://www.iteye.com/blog/jinnianshilongnian-2028675" target="_blank" rel="noopener">第十章 会话管理——《跟我学Shiro》</a><br>目录贴： <a href="http://jinnianshilongnian.iteye.com/blog/2018398" target="_blank" rel="noopener">跟我学Shiro目录贴</a><br>源码：<a href="https://github.com/zhangkaitao/shiro-example" target="_blank" rel="noopener">https://github.com/zhangkaitao/shiro-example</a></p></blockquote><h1 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h1><p>Shiro 提供了完整的企业级会话管理功能，不依赖于底层容器（如 <code>web</code> 容器 <code>tomcat</code>），不管 <code>JavaSE</code> 还是 <code>JavaEE</code> 环境都可以使用，提供了会话管理、会话事件监听、会话存储/持久化、容器无关的集群、失效/过期支持、对 <code>Web</code> 的透明支持、<code>SSO</code> 单点登录的支持等特性。即直接使用 Shiro 的会话管理可以直接替换如 <code>Web</code> 容器的会话管理。</p><p>所谓会话，即用户访问应用时保持的连接关系，在多次交互中应用能够识别出当前访问的用户是谁，且可以在多次交互中保存一些数据。如访问一些网站时登录成功后，网站可以记住用户，且在退出之前都可以识别当前用户是谁。</p><p>Shiro 的会话支持不仅可以在普通的 <code>JavaSE</code> 应用中使用，也可以在 <code>JavaEE</code> 应用中使用，如 <code>web</code> 应用。且使用方式是一致的。</p><pre><code class="java">login(&quot;classpath:shiro.ini&quot;, &quot;zhang&quot;, &quot;123&quot;);Subject subject = SecurityUtils.getSubject();Session session = subject.getSession();</code></pre><a id="more"></a><p>登录成功后使用 <code>Subject.getSession()</code> 即可获取会话；其等价于 <code>Subject.getSession(true)</code>，即如果当前没有创建 <code>Session</code> 对象会创建一个；另外 <code>Subject.getSession(false)</code>，如果当前没有创建 <code>Session</code> 则返回 <code>null</code>（不过默认情况下如果启用会话存储功能的话在创建 <code>Subject</code> 时会主动创建一个 <code>Session</code>）。</p><pre><code class="java">// 获取当前会话的唯一标识。session.getId();// 获取当前 Subject 的主机地址，该地址是通过 HostAuthenticationToken.getHost() 提供的。session.getHost();// 获取/设置当前 Session 的过期时间；如果不设置默认是会话管理器的全局过期时间session.getTimeout();session.setTimeout(long timeout); // 毫秒// 获取会话的启动时间及最后访问时间；// 如果是 JavaSE 应用需要自己定期调用 session.touch() 去更新最后访问时间；// 如果是 Web 应用，每次进入 ShiroFilter 都会自动调用 session.touch() 来更新最后访问时间。session.getStartTimestamp(); // 会话的启动时间session.getLastAccessTime(); // 最后访问时间// 更新会话最后访问时间及销毁会话；// 当 Subject.logout() 时会自动调用 stop 方法来销毁会话。// 如果在 web 中，调用 javax.servlet.http.HttpSession.invalidate() 也会自动调用 Shiro Session.stop 方法进行销毁 Shiro 的会话。session.touch(); // 更新会话最后访问时间session.stop(); // 销毁会话// 设置/获取/删除会话属性；在整个会话范围内都可以对这些属性进行操作。session.setAttribute(&quot;key&quot;, &quot;123&quot;);Assert.assertEquals(&quot;123&quot;, session.getAttribute(&quot;key&quot;));session.removeAttribute(&quot;key&quot;);</code></pre><h1 id="会话管理器"><a href="#会话管理器" class="headerlink" title="会话管理器"></a>会话管理器</h1><p>会话管理器管理着应用中所有 <code>Subject</code> 的会话的创建、维护、删除、失效、验证等工作。是 Shiro 的核心组件，顶层组件 <code>SecurityManager</code> 直接继承了 <code>SessionManager</code>，且提供了 <code>SessionsSecurityManager</code> 实现直接把会话管理委托给相应的 <code>SessionManager</code>，<code>DefaultSecurityManager</code> 及 <code>DefaultWebSecurityManager</code> 默认 <code>SecurityManager</code> 都继承了 <code>SessionsSecurityManager</code>。</p><p><code>SecurityManager</code> 提供了如下接口：</p><pre><code class="java">Session start(SessionContext context); // 启动会话Session getSession(SessionKey key) throws SessionException; // 根据会话 Key 获取会话</code></pre><p>另外用于 <code>Web</code> 环境的 <code>WebSessionManager</code> 又提供了如下接口：</p><pre><code class="java">boolean isServletContainerSessions(); // 是否使用 Servlet 容器的会话</code></pre><p>Shiro 还提供了 <code>ValidatingSessionManager</code> 用于验资并过期会话：</p><pre><code class="java">void validateSessions(); // 验证所有会话是否过期</code></pre><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20180416191613.png" alt="会话管理器"></p><p>Shiro 提供了三个默认实现：</p><ol><li><code>DefaultSessionManager</code>：<code>DefaultSecurityManager</code> 使用的默认实现，用于 <code>JavaSE</code> 环境；</li><li><code>ServletContainerSessionManager</code>：<code>DefaultWebSecurityManager</code> 使用的默认实现，用于 <code>Web</code> 环境，其直接使用 <code>Servlet</code> 容器的会话；</li><li><code>DefaultWebSessionManager</code>：用于 <code>Web</code> 环境的实现，可以替代 <code>ServletContainerSessionManager</code>，自己维护着会话，直接废弃了 <code>Servlet</code> 容器的会话管理。</li></ol><p>替换 <code>SecurityManager</code> 默认的 <code>SessionManager</code> 可以在 <code>ini</code> 中配置（<code>shiro.ini</code>）：</p><pre><code class="ini">[main]sessionManager=org.apache.shiro.session.mgt.DefaultSessionManager;Web 环境下;sessionManager=org.apache.shiro.web.session.mgt.ServletContainerSessionManagersecurityManager.sessionManager=$sessionManager;设置会话的全局过期时间（毫秒为单位），默认 30 分钟sessionManager.globalSessionTimeout=1800000</code></pre><p>默认情况下 <code>globalSessionTimeout</code> 将应用给所有 <code>Session</code>。可以单独设置每个 <code>Session</code> 的 <code>timeout</code> 属性来为每个 <code>Session</code> 设置其超时时间。</p><p>另外如果使用 <code>ServletContainerSessionManager</code> 进行会话管理，<code>Session</code> 的超时依赖于底层 <code>Servlet</code> 容器的超时时间，可以在 <code>web.xml</code> 中配置其会话的超时时间（分钟为单位）：</p><pre><code class="xml">&lt;session-config&gt;    &lt;session-timeout&gt;30&lt;/session-timeout&gt;&lt;/session-config&gt;</code></pre><p>在 <code>Servlet</code> 容器中，默认使用 <code>JSESSIONID Cookie</code> 维护会话，且会话默认是跟容器绑定的；在某些情况下可能需要使用自己的会话机制，此时我们可以使用 <code>DefaultWebSessionManager</code> 来维护会话：</p><pre><code class="ini">;sessionManager 创建会话 Cookie 的模板sessionIdCookie=org.apache.shiro.web.servlet.SimpleCookiesessionManager=org.apache.shiro.web.session.mgt.DefaultWebSessionManager;设置 Cookie 名字，默认为 JSESSIONIDsessionIdCookie.name=sid;设置 Cookie 的域名，默认空，即当前访问的域名;sessionIdCookie.domain=sishuok.com;设置 Cookie 的路径，默认空，即存储在域名根下;sessionIdCookie.path=;设置 Cookie 的过期时间，秒为单位，默认 -1 表示关闭浏览器时过期 CookiesessionIdCookie.maxAge=1800;如果设置为 true，则客户端不会暴露给客户端脚本代码，使用 HttpOnly cookie 有助于减少某些类型的跨站点脚本攻击；;此特性需要实现了 Servlet 2.5 MR6 及以上版本的规范的 Servlet 容器支持；sessionIdCookie.httpOnly=truesessionManager.sessionIdCookie=$sessionIdCookie;是否启用/禁用 Session Id Cookie，默认是启用的；;如果禁用后将不会设置 Session Id Cookie，即默认使用了 Servlet 容器的 JSESSIONID，且通过 URL 重写（URL中的 &quot;;JSESSIONID=id&quot; 部分）保存 Session Id。sessionManager.sessionIdCookieEnabled=truesecurityManager.sessionManager=$sessionManager</code></pre><h1 id="会话监听器"><a href="#会话监听器" class="headerlink" title="会话监听器"></a>会话监听器</h1><p>会话监听器用于监听会话创建、过期及停止事件：</p><pre><code class="java">public class MySessionListener1 implements SessionListener {    @Override    public void onStart(Session session) {//会话创建时触发        System.out.println(&quot;会话创建：&quot; + session.getId());    }    @Override    public void onExpiration(Session session) {//会话过期时触发        System.out.println(&quot;会话过期：&quot; + session.getId());    }    @Override    public void onStop(Session session) {//退出/会话过期时触发        System.out.println(&quot;会话停止：&quot; + session.getId());    }}</code></pre><p>如果<strong>只想监听某一个事件</strong>，可以继承 <code>SessionListenerAdapter</code> 实现：</p><pre><code class="java">public class MySessionListener2 extends SessionListenerAdapter {    @Override    public void onStart(Session session) {        System.out.println(&quot;会话创建：&quot; + session.getId());    }}</code></pre><p>在 <code>shiro-web.ini</code> 配置文件中可以进行如下配置<strong>设置会话监听器</strong>：</p><pre><code class="ini">sessionListener1=com.github.zhangkaitao.shiro.chapter10.web.listener.MySessionListener1sessionListener2=com.github.zhangkaitao.shiro.chapter10.web.listener.MySessionListener2sessionManager.sessionListeners=$sessionListener1,$sessionListener2</code></pre><h1 id="会话存储-持久化"><a href="#会话存储-持久化" class="headerlink" title="会话存储/持久化"></a>会话存储/持久化</h1><p>Shiro 提供 <code>SessionDAO</code> 用于会话的 <code>CRUD</code>，即 <code>DAO（Data Access Object）</code>模式实现：</p><pre><code class="java">// 如 DefaultSessionManager 在创建完 session 后会调用该方法；如保存到关系数据库/文件系统/NoSQL 数据库；// 即可以实现会话的持久化；返回会话 ID；主要此处返回的 ID.equals(session.getId())；Serializable create(Session session);// 根据会话 ID 获取会话Session readSession(Serializable sessionId) throws UnknownSessionException;// 更新会话；如更新会话最后访问时间/停止会话/设置超时时间/设置移除属性等会调用void update(Session session) throws UnknownSessionException;// 删除会话；当会话过期/会话停止（如用户退出时）会调用void delete(Session session);// 获取当前所有活跃用户，如果用户量多此方法影响性能Collection&lt;Session&gt; getActiveSessions();</code></pre><p>Shiro 内嵌了如下 <code>SessionDAO</code> 实现：</p><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20180416193225.png" alt="Shiro 拦截器"></p><ul><li><code>AbstractSessionDAO</code> 提供了 <code>SessionDAO</code> 的基础实现，如生成会话 ID 等；</li><li><code>CachingSessionDAO</code> 提供了对开发者透明的会话缓存的功能，只需要设置相应的 <code>CacheManager</code> 即可；</li><li><code>MemorySessionDAO</code> 直接在内存中进行会话维护；</li><li><code>EnterpriseCacheSessionDAO</code> 提供了缓存功能的会话维护，默认情况下使用 <code>MapCache</code> 实现，内部使用 <code>ConcurrentHashMap</code> 保存缓存的会话。</li></ul><p>可以通过如下配置设置 <code>SessionDAO</code>：</p><pre><code class="ini">sessionDAO=org.apache.shiro.session.mgt.eis.EnterpriseCacheSessionDAOsessionManager.sessionDAO=$sessionDAO</code></pre><h2 id="使用-Ehcache-进行会话存储"><a href="#使用-Ehcache-进行会话存储" class="headerlink" title="使用 Ehcache 进行会话存储"></a>使用 Ehcache 进行会话存储</h2><p>Shiro 提供了使用 <code>Ehcache</code> 进行会话存储，<code>Ehcache</code> 可以配合 <code>TerraCotta</code> 实现容器无关的分布式集群。</p><p>首先在 <code>pom.xml</code> 里添加如下依赖：</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;    &lt;artifactId&gt;shiro-ehcache&lt;/artifactId&gt;    &lt;version&gt;1.2.2&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>接着配置 <code>shiro-web.ini</code> 文件：</p><pre><code class="ini">sessionDAO=org.apache.shiro.session.mgt.eis.EnterpriseCacheSessionDAO;设置 Session 缓存名字，默认就是 shiro-activeSessionCachesessionDAO.activeSessionsCacheName=shiro-activeSessionCachesessionManager.sessionDAO=$sessionDAO;缓存管理器，用于管理缓存的，此处使用 Ehcache 实现cacheManager = org.apache.shiro.cache.ehcache.EhCacheManager;设置 ehcache 缓存的配置文件cacheManager.cacheManagerConfigFile=classpath:ehcache.xml;设置 SecurityManager 的 cacheManager，会自动设置实现了 CacheManagerAware 接口的相应对象，如 SessionDAO 的 cacheManagersecurityManager.cacheManager = $cacheManager</code></pre><p>然后配置 <code>ehcache.xml</code>：</p><pre><code class="xml">&lt;ehcache name=&quot;es&quot;&gt;    &lt;diskStore path=&quot;java.io.tmpdir&quot;/&gt;    &lt;!-- Cache 的名字为 shiro-activeSessionCache，即设置的 sessionDAO 的 activeSessionsCacheName 属性值。 --&gt;    &lt;cache name=&quot;shiro-activeSessionCache&quot;           maxEntriesLocalHeap=&quot;10000&quot;           overflowToDisk=&quot;false&quot;           eternal=&quot;false&quot;           diskPersistent=&quot;false&quot;           timeToLiveSeconds=&quot;0&quot;           timeToIdleSeconds=&quot;0&quot;           statistics=&quot;true&quot;/&gt;&lt;/ehcache&gt;</code></pre><p>另外可以通过如下 <code>ini</code> 配置<strong>设置会话 ID 生成器</strong>：</p><pre><code class="ini">sessionIdGenerator=org.apache.shiro.session.mgt.eis.JavaUuidSessionIdGeneratorsessionDAO.sessionIdGenerator=$sessionIdGenerator</code></pre><p>用于生成会话 ID，默认就是 <code>JavaUuidSessionIdGenerator</code>，使用 <code>java.util.UUID</code> 生成。</p><h2 id="自定义实现-SessionDAO"><a href="#自定义实现-SessionDAO" class="headerlink" title="自定义实现 SessionDAO"></a>自定义实现 SessionDAO</h2><p>如果自定义实现 <code>SessionDAO</code>，继承 <code>CachingSessionDAO</code> 即可：</p><pre><code class="java">// 把会话序列化后存储到数据库public class MySessionDAO extends CachingSessionDAO {    private JdbcTemplate jdbcTemplate = JdbcTemplateUtils.jdbcTemplate();    // 创建会话    @Override    protected Serializable doCreate(Session session) {        Serializable sessionId = generateSessionId(session);        assignSessionId(session, sessionId);        String sql = &quot;insert into sessions(id, session) values(?,?)&quot;;        jdbcTemplate.update(sql, sessionId, SerializableUtils.serialize(session));        return session.getId();    }    // 修改会话    @Override    protected void doUpdate(Session session) {        if(session instanceof ValidatingSession &amp;&amp; !((ValidatingSession)session).isValid()) {            return; // 如果会话过期/停止 没必要再更新了        }        String sql = &quot;update sessions set session=? where id=?&quot;;        jdbcTemplate.update(sql, SerializableUtils.serialize(session), session.getId());    }    // 删除会话    @Override    protected void doDelete(Session session) {        String sql = &quot;delete from sessions where id=?&quot;;        jdbcTemplate.update(sql, session.getId());    }    // 读取会话    @Override    protected Session doReadSession(Serializable sessionId) {        String sql = &quot;select session from sessions where id=?&quot;;        List&lt;String&gt; sessionStrList = jdbcTemplate.queryForList(sql, String.class, sessionId);        if(sessionStrList.size() == 0) return null;        return SerializableUtils.deserialize(sessionStrList.get(0));    }}</code></pre><pre><code class="java">public class SerializableUtils {    public static String serialize(Session session) {        try {            ByteArrayOutputStream bos = new ByteArrayOutputStream();            ObjectOutputStream oos = new ObjectOutputStream(bos);            oos.writeObject(session);            return Base64.encodeToString(bos.toByteArray());        } catch (Exception e) {            throw new RuntimeException(&quot;serialize session error&quot;, e);        }    }    public static Session deserialize(String sessionStr) {        try {            ByteArrayInputStream bis = new ByteArrayInputStream(Base64.decode(sessionStr));            ObjectInputStream ois = new ObjectInputStream(bis);            return (Session)ois.readObject();        } catch (Exception e) {            throw new RuntimeException(&quot;deserialize session error&quot;, e);        }    }}</code></pre><p>接着在 <code>shiro-web.ini</code> 中配置</p><pre><code class="ini">sessionDAO=com.github.zhangkaitao.shiro.chapter10.session.dao.MySessionDAO</code></pre><p>其他设置和之前一样，因为继承了 <code>CachingSessionDAO</code>；所有在读取时会先查缓存中是否存在，如果找不到才到数据库中查找。</p><h1 id="会话验证"><a href="#会话验证" class="headerlink" title="会话验证"></a>会话验证</h1><p>Shiro 提供了会话验证调度器，<strong>用于定期的验证会话是否已过期</strong>，如果过期将停止会话；出于性能考虑，一般情况下都是获取会话时来验证会话是否过期并停止会话的；但是如在 <code>web</code> 环境中，如果用户不主动退出是不知道会话是否过期的，因此需要定期的检测会话是否过期，Shiro 提供了会话验证调度器 <code>SessionValidationScheduler</code> 来做这件事情。</p><p>可以通过如下 <code>ini</code> 配置开启会话验证：</p><pre><code class="ini">;会话验证调度器，sessionManager 默认就是使用 ExecutorServiceSessionValidationScheduler;其使用 JDK 的 ScheduledExecutorService 进行定期调度并验证会话是否过期sessionValidationScheduler=org.apache.shiro.session.mgt.ExecutorServiceSessionValidationScheduler;设置调度时间间隔，单位毫秒，默认就是 1小时sessionValidationScheduler.interval = 3600000;设置会话验证调度器进行会话验证时的会话管理器sessionValidationScheduler.sessionManager=$sessionManager;设置全局会话超时时间，默认 30 分钟，即如果 30 分钟内没有访问会话将过期sessionManager.globalSessionTimeout=1800000;是否开启会话验证器，默认是开启的sessionManager.sessionValidationSchedulerEnabled=true;设置会话验证调度器，默认就是使用 ExecutorServiceSessionValidationSchedulersessionManager.sessionValidationScheduler=$sessionValidationScheduler</code></pre><h2 id="使用-Quartz-会话验证调度器"><a href="#使用-Quartz-会话验证调度器" class="headerlink" title="使用 Quartz 会话验证调度器"></a>使用 Quartz 会话验证调度器</h2><pre><code class="ini">sessionValidationScheduler=org.apache.shiro.session.mgt.quartz.QuartzSessionValidationSchedulersessionValidationScheduler.sessionValidationInterval = 3600000sessionValidationScheduler.sessionManager=$sessionManager</code></pre><p>使用时需要导入 <code>shiro-quartz</code> 依赖：</p><pre><code class="xml">&lt;dependency&gt;     &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;     &lt;artifactId&gt;shiro-quartz&lt;/artifactId&gt;     &lt;version&gt;1.2.2&lt;/version&gt;&lt;/dependency&gt;</code></pre><h2 id="自定义会话验证调度器"><a href="#自定义会话验证调度器" class="headerlink" title="自定义会话验证调度器"></a>自定义会话验证调度器</h2><p>如上会话验证调度器实现都是直接调用 <code>AbstractValidatingSessionManager</code> 的 <code>validateSessions</code> 方法进行验证，其直接调用 <code>SessionDAO</code> 的 <code>getActiveSessions</code> 方法获取所有会话进行验证，如果会话比较多，会影响性能；可以考虑如分页获取会话并进行验证，如：</p><pre><code class="java">public class MySessionValidationScheduler implements SessionValidationScheduler, Runnable {    private JdbcTemplate jdbcTemplate = JdbcTemplateUtils.jdbcTemplate();    /*     * 省略其他代码 可以在 org.apache.shiro.session.mgt.ExecutorServiceSessionValidationScheduler 查看     */    @Override    public void run() {        if (log.isDebugEnabled()) {            log.debug(&quot;Executing session validation...&quot;);        }        long startTime = System.currentTimeMillis();        // 分页获取会话并验证        String sql = &quot;select session from sessions limit ?,?&quot;;        int start = 0; // 起始记录        int size = 20; // 每页大小        List&lt;String&gt; sessionList = jdbcTemplate.queryForList(sql, String.class, start, size);        while(sessionList.size() &gt; 0) {            for(String sessionStr : sessionList) {                try {                    Session session = SerializableUtils.deserialize(sessionStr);                    Method validateMethod = ReflectionUtils.findMethod(AbstractValidatingSessionManager.class, &quot;validate&quot;, Session.class, SessionKey.class);                    validateMethod.setAccessible(true);                    ReflectionUtils.invokeMethod(validateMethod, sessionManager, session, new DefaultSessionKey(session.getId()));                } catch (Exception e) {                    // ignore                }            }            start = start + size;            sessionList = jdbcTemplate.queryForList(sql, String.class, start, size);        }        long stopTime = System.currentTimeMillis();        if (log.isDebugEnabled()) {            log.debug(&quot;Session validation completed successfully in &quot; + (stopTime - startTime) + &quot; milliseconds.&quot;);        }    }}</code></pre><p>其直接改造自 <code>ExecutorServiceSessionValidationScheduler</code>，如上代码是验证的核心代码，可以根据自己的需求改造此验证调度器器；<code>ini</code> 的配置和之前的类似。</p><p>如果在会话过期时不想删除过期的会话，可以通过如下 <code>ini</code> 配置进行设置：</p><pre><code class="ini">sessionManager.deleteInvalidSessions=false</code></pre><p>默认是开启的，在会话过期后会调用 <code>SessionDAO</code> 的 <code>delete</code> 方法删除会话。如会话时持久化存储的，可以调用此方法进行删除。</p><p>如果是在获取会话时验证了会话已过期，将抛出 <code>InvalidSessionException</code>；因此需要捕获这个异常并跳转到相应的页面告诉用户会话已过期，让其重新登录，如可以在 <code>web.xml</code> 配置相应的错误页面：</p><pre><code class="xml">&lt;error-page&gt;    &lt;exception-type&gt;org.apache.shiro.session.InvalidSessionException&lt;/exception-type&gt;    &lt;location&gt;/invalidSession.jsp&lt;/location&gt;&lt;/error-page&gt;</code></pre><h1 id="sessionFactory"><a href="#sessionFactory" class="headerlink" title="sessionFactory"></a>sessionFactory</h1><p><code>sessionFactory</code> 是创建会话的工厂，根据相应的 <code>Subject</code> 上下文信息来创建会话；默认提供了 <code>SimpleSessionFactory</code> 用来创建 <code>SimpleSession</code> 会话。</p><h2 id="自定义-Session"><a href="#自定义-Session" class="headerlink" title="自定义 Session"></a>自定义 Session</h2><p><code>OnlineSession</code> 用于保存当前登录用户的在线状态，支持如离线等状态的控制。</p><pre><code class="java">public class OnlineSession extends SimpleSession {    private static final long serialVersionUID = -7125642695178165650L;    public static enum OnlineStatus {        on_line(&quot;在线&quot;), hidden(&quot;隐身&quot;), force_logout(&quot;强制退出&quot;);        private final String info;        private OnlineStatus(String info) {            this.info = info;        }        public String getInfo() {            return info;        }    }    private static final int USER_AGENT_BIT_MASK = 1 &lt;&lt; bitIndexCounter++;    private static final int STATUS_BIT_MASK = 1 &lt;&lt; bitIndexCounter++;    private String userAgent; // 用户浏览器类型    private OnlineStatus status = OnlineStatus.on_line; // 在线状态    private String systemHost; // 用户登录时系统 IP    // 省略上面三个 set，get 方法    public OnlineSession() {        super();    }    public OnlineSession(String host) {        super(host);    }    /**     * 属性是否改变 优化 session 数据同步     */    private transient boolean attributeChanged = false;    public void markAttributeChanged() {        this.attributeChanged = true;    }    public void resetAttributeChanged() {        this.attributeChanged = false;    }    public boolean isAttributeChanged() {        return attributeChanged;    }    /**     * Serializes this object to the specified output stream for JDK Serialization.     *     * @param out output stream used for Object serialization.     * @throws java.io.IOException if any of this object&#39;s fields cannot be written to the stream.     * @since 1.0     */    private void writeObject(ObjectOutputStream out) throws IOException {        out.defaultWriteObject();        short alteredFieldsBitMask = getAlteredFieldsBitMask();        out.writeShort(alteredFieldsBitMask);        if (userAgent != null) {            out.writeObject(userAgent);        }        if (status != null) {            out.writeObject(status);        }    }    /**     * Reconstitutes this object based on the specified InputStream for JDK Serialization.     *     * @param in the input stream to use for reading data to populate this object.     * @throws java.io.IOException            if the input stream cannot be used.     * @throws ClassNotFoundException if a required class needed for instantiation is not available in the present JVM     * @since 1.0     */    @SuppressWarnings({&quot;unchecked&quot;})    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {        in.defaultReadObject();        short bitMask = in.readShort();        if (isFieldPresent(bitMask, USER_AGENT_BIT_MASK)) {            this.userAgent = (String) in.readObject();        }        if (isFieldPresent(bitMask, STATUS_BIT_MASK)) {            this.status = (OnlineStatus) in.readObject();        }    }    /**     * Returns a bit mask used during serialization indicating which fields have been serialized. Fields that have been     * altered (not null and/or not retaining the class defaults) will be serialized and have 1 in their respective     * index, fields that are null and/or retain class default values have 0.     *     * @return a bit mask used during serialization indicating which fields have been serialized.     * @since 1.0     */    private short getAlteredFieldsBitMask() {        int bitMask = 0;        bitMask = userAgent != null ? bitMask | USER_AGENT_BIT_MASK : bitMask;        bitMask = status != null ? bitMask | STATUS_BIT_MASK : bitMask;        return (short) bitMask;    }}</code></pre><h2 id="自定义-SessionFactory"><a href="#自定义-SessionFactory" class="headerlink" title="自定义 SessionFactory"></a>自定义 SessionFactory</h2><pre><code class="java">// 创建自定义的 session，添加一些自定义的数据，如 用户登录到的系统 ip，用户状态（在线 隐身 强制退出）等public class OnlineSessionFactory implements SessionFactory {    @Override    public Session createSession(SessionContext initData) {        OnlineSession session = new OnlineSession();        if (initData != null &amp;&amp; initData instanceof WebSessionContext) {            WebSessionContext sessionContext = (WebSessionContext) initData;            HttpServletRequest request = (HttpServletRequest) sessionContext.getServletRequest();            if (request != null) {                session.setHost(IpUtils.getIpAddr(request));                session.setUserAgent(request.getHeader(&quot;User-Agent&quot;));                session.setSystemHost(request.getLocalAddr() + &quot;:&quot; + request.getLocalPort());            }        }        return session;    }}</code></pre><p>最后在 <code>shiro-web.ini</code> 配置文件中配置：</p><pre><code class="ini">sessionFactory=org.apache.shiro.session.mgt.OnlineSessionFactorysessionManager.sessionFactory=$sessionFactory</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Shiro </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《跟我学Shiro》笔记09-JSP标签</title>
      <link href="/2018/04/16/%E3%80%8A%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%E3%80%8B%E7%AC%94%E8%AE%B009-JSP%E6%A0%87%E7%AD%BE/"/>
      <url>/2018/04/16/%E3%80%8A%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%E3%80%8B%E7%AC%94%E8%AE%B009-JSP%E6%A0%87%E7%AD%BE/</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文地址：<a href="http://jinnianshilongnian.iteye.com/blog/2026398" target="_blank" rel="noopener">第九章 JSP标签——《跟我学Shiro》</a><br>目录贴： <a href="http://jinnianshilongnian.iteye.com/blog/2018398" target="_blank" rel="noopener">跟我学Shiro目录贴</a><br>源码：<a href="https://github.com/zhangkaitao/shiro-example" target="_blank" rel="noopener">https://github.com/zhangkaitao/shiro-example</a></p></blockquote><p>Shiro 提供了 <code>JSTL</code> 标签用于在 <code>JSP/GSP</code> 页面进行权限控制，如根据登录用户显示相应的页面按钮。</p><h1 id="导入标签库"><a href="#导入标签库" class="headerlink" title="导入标签库"></a>导入标签库</h1><pre><code class="jsp">&lt;%@taglib prefix=&quot;shiro&quot; uri=&quot;http://shiro.apache.org/tags&quot; %&gt;</code></pre><p>标签库定义在 <code>shiro-web.jar</code> 包下的 <code>META-INF/shiro.tld</code> 中定义。</p><a id="more"></a><h1 id="guest-标签"><a href="#guest-标签" class="headerlink" title="guest 标签"></a>guest 标签</h1><pre><code class="jsp">&lt;shiro:guest&gt;欢迎游客访问，&lt;a href=&quot;${pageContext.request.contextPath}/login.jsp&quot;&gt;登录&lt;/a&gt;&lt;/shiro:guest&gt;</code></pre><p>用户没有身份验证时显示相应信息，即游客访问信息。</p><h1 id="user-标签"><a href="#user-标签" class="headerlink" title="user 标签"></a>user 标签</h1><pre><code class="jsp">&lt;shiro:user&gt;欢迎[&lt;shiro:principal/&gt;]登录，&lt;a href=&quot;${pageContext.request.contextPath}/logout&quot;&gt;退出&lt;/a&gt;&lt;/shiro:user&gt;</code></pre><p>用户已经身份验证/记住我登录后显示相应的信息。</p><h1 id="authenticated-标签"><a href="#authenticated-标签" class="headerlink" title="authenticated 标签"></a>authenticated 标签</h1><pre><code class="jsp">&lt;shiro:authenticated&gt;    用户[&lt;shiro:principal/&gt;]已身份验证通过&lt;/shiro:authenticated&gt;</code></pre><p>用户已经身份验证通过，即 <code>Subject.login</code> 登录成功，不是记住我登录的。</p><h1 id="notAuthenticated-标签"><a href="#notAuthenticated-标签" class="headerlink" title="notAuthenticated 标签"></a>notAuthenticated 标签</h1><pre><code class="jsp">&lt;shiro:notAuthenticated&gt;    未身份验证（包括记住我）&lt;/shiro:notAuthenticated&gt;</code></pre><p>用户没有身份验证通过，即没有调用 <code>Subject.login</code> 进行登录，包括记住我自动登录的也属于未进行身份验证。</p><h1 id="principal-标签"><a href="#principal-标签" class="headerlink" title="principal 标签"></a>principal 标签</h1><pre><code class="jsp">&lt;shiro: principal/&gt;</code></pre><p>显示用户身份信息，默认调用 <code>Subject.getPrincipal()</code> 获取，即 <code>Primary Principal</code>。</p><pre><code class="jsp">&lt;shiro:principal type=&quot;java.lang.String&quot;/&gt;</code></pre><p>相当于 <code>Subject.getPrincipals().oneByType(String.class)</code>。</p><pre><code class="jsp">&lt;shiro:principal property=&quot;username&quot;/&gt;</code></pre><p>相当于 <code>((User)Subject.getPrincipals()).getUsername()</code>。</p><h1 id="hasRole-标签"><a href="#hasRole-标签" class="headerlink" title="hasRole 标签"></a>hasRole 标签</h1><pre><code class="jsp">&lt;shiro:hasRole name=&quot;admin&quot;&gt;    用户[&lt;shiro:principal/&gt;]拥有角色 admin&lt;br/&gt;&lt;/shiro:hasRole&gt;</code></pre><p>如果当前 <code>Subject</code> 有角色将显示 body 体内容。</p><h1 id="hasAnyRoles标签"><a href="#hasAnyRoles标签" class="headerlink" title="hasAnyRoles标签"></a>hasAnyRoles标签</h1><pre><code class="jsp">&lt;shiro:hasAnyRoles name=&quot;admin,user&quot;&gt;    用户[&lt;shiro:principal/&gt;]拥有角色 admin 或 user&lt;br/&gt;&lt;/shiro:hasAnyRoles&gt;</code></pre><p>如果当前 <code>Subject</code> 有任意一个角色（或的关系）将显示 body 体内容。</p><h1 id="lacksRole-标签"><a href="#lacksRole-标签" class="headerlink" title="lacksRole 标签"></a>lacksRole 标签</h1><pre><code class="jsp">&lt;shiro:lacksRole name=&quot;abc&quot;&gt;    用户[&lt;shiro:principal/&gt;]没有角色 abc&lt;br/&gt;&lt;/shiro:lacksRole&gt;</code></pre><p>如果当前 <code>Subject</code> 没有角色将显示 body 体内容。</p><h1 id="hasPermission-标签"><a href="#hasPermission-标签" class="headerlink" title="hasPermission 标签"></a>hasPermission 标签</h1><pre><code class="jsp">&lt;shiro:hasPermission name=&quot;user:create&quot;&gt;    用户[&lt;shiro:principal/&gt;]拥有权限 user:create&lt;br/&gt;&lt;/shiro:hasPermission&gt;</code></pre><p>如果当前 <code>Subject</code> 有权限将显示 body 体内容。</p><h1 id="lacksPermission-标签"><a href="#lacksPermission-标签" class="headerlink" title="lacksPermission 标签"></a>lacksPermission 标签</h1><pre><code class="jsp">&lt;shiro:lacksPermission name=&quot;org:create&quot;&gt;    用户[&lt;shiro:principal/&gt;]没有权限 org:create&lt;br/&gt;&lt;/shiro:lacksPermission&gt;</code></pre><p>如果当前 <code>Subject</code> 没有权限将显示 body 体内容。</p><h1 id="导入自定义标签库"><a href="#导入自定义标签库" class="headerlink" title="导入自定义标签库"></a>导入自定义标签库</h1><pre><code class="jsp">&lt;%@taglib prefix=&quot;zhang&quot; tagdir=&quot;/WEB-INF/tags&quot; %&gt;</code></pre><pre><code class="jsp">&lt;zhang:hasAllRoles name=&quot;admin,user&quot;&gt;    用户[&lt;shiro:principal/&gt;]拥有角色 admin 和 user&lt;br/&gt;&lt;/zhang:hasAllRoles&gt;&lt;zhang:hasAllPermissions name=&quot;user:create,user:update&quot;&gt;    用户[&lt;shiro:principal/&gt;]拥有权限 user:create 和 user:update&lt;br/&gt;&lt;/zhang:hasAllPermissions&gt;&lt;zhang:hasAnyPermissions name=&quot;user:create,abc:update&quot;&gt;    用户[&lt;shiro:principal/&gt;]拥有权限 user:create 或 abc:update&lt;br/&gt;&lt;/zhang:hasAnyPermissions&gt;</code></pre><p><code>hasAllRoles</code> 表示拥有所有相关的角色；<code>hasAllPermissions</code> 表示拥有所有相关的权限；<code>hasAnyPermissions</code> 表示拥有任意一个相关的权限。</p><h2 id="hasAllRoles-tag"><a href="#hasAllRoles-tag" class="headerlink" title="hasAllRoles.tag"></a>hasAllRoles.tag</h2><pre><code class="java">&lt;%@ tag import=&quot;org.apache.shiro.util.StringUtils&quot; %&gt;&lt;%@ tag import=&quot;org.apache.shiro.SecurityUtils&quot; %&gt;&lt;%@ tag import=&quot;java.util.Arrays&quot; %&gt;&lt;%@ tag pageEncoding=&quot;UTF-8&quot; trimDirectiveWhitespaces=&quot;true&quot; %&gt;&lt;%@ attribute name=&quot;name&quot; type=&quot;java.lang.String&quot; required=&quot;true&quot; description=&quot;角色列表&quot; %&gt;&lt;%@ attribute name=&quot;delimiter&quot; type=&quot;java.lang.String&quot; required=&quot;false&quot; description=&quot;角色列表分隔符&quot; %&gt;&lt;%    if (!StringUtils.hasText(delimiter)) {        delimiter = &quot;,&quot;; // 默认逗号分隔    }    if (!StringUtils.hasText(name)) {%&gt;&lt;jsp:doBody/&gt;&lt;%        return;    }    String[] roles = name.split(delimiter);    if (!SecurityUtils.getSubject().hasAllRoles(Arrays.asList(roles))) {        return;    } else {%&gt;&lt;jsp:doBody/&gt;&lt;%    }%&gt;</code></pre><h2 id="hasAllPermissions-tag"><a href="#hasAllPermissions-tag" class="headerlink" title="hasAllPermissions.tag"></a>hasAllPermissions.tag</h2><pre><code class="java">&lt;%@ tag import=&quot;org.apache.shiro.util.StringUtils&quot; %&gt;&lt;%@ tag import=&quot;org.apache.shiro.SecurityUtils&quot; %&gt;&lt;%@ tag pageEncoding=&quot;UTF-8&quot; trimDirectiveWhitespaces=&quot;true&quot;%&gt;&lt;%@ attribute name=&quot;name&quot; type=&quot;java.lang.String&quot; required=&quot;true&quot; description=&quot;权限字符串列表&quot; %&gt;&lt;%@ attribute name=&quot;delimiter&quot; type=&quot;java.lang.String&quot; required=&quot;false&quot; description=&quot;权限字符串列表分隔符&quot; %&gt;&lt;%    if (!StringUtils.hasText(delimiter)) {        delimiter = &quot;,&quot;; // 默认逗号分隔    }    if (!StringUtils.hasText(name)) {%&gt;        &lt;jsp:doBody/&gt;&lt;%        return;    }    String[] roles = name.split(delimiter);    if (!SecurityUtils.getSubject().isPermittedAll(roles)) {        return;    } else {%&gt;        &lt;jsp:doBody/&gt;&lt;%    }%&gt;</code></pre><h2 id="hasAnyPermissions-tag"><a href="#hasAnyPermissions-tag" class="headerlink" title="hasAnyPermissions.tag"></a>hasAnyPermissions.tag</h2><pre><code class="java">&lt;%@ tag import=&quot;org.apache.shiro.util.StringUtils&quot; %&gt;&lt;%@ tag import=&quot;org.apache.shiro.SecurityUtils&quot; %&gt;&lt;%@ tag import=&quot;java.util.Arrays&quot; %&gt;&lt;%@ tag import=&quot;org.apache.shiro.subject.Subject&quot; %&gt;&lt;%@ tag pageEncoding=&quot;UTF-8&quot; trimDirectiveWhitespaces=&quot;true&quot;%&gt;&lt;%@ attribute name=&quot;name&quot; type=&quot;java.lang.String&quot; required=&quot;true&quot; description=&quot;权限字符串列表&quot; %&gt;&lt;%@ attribute name=&quot;delimiter&quot; type=&quot;java.lang.String&quot; required=&quot;false&quot; description=&quot;权限字符串列表分隔符&quot; %&gt;&lt;%    if (!StringUtils.hasText(delimiter)) {        delimiter = &quot;,&quot;; // 默认逗号分隔    }    if (!StringUtils.hasText(name)) {%&gt;        &lt;jsp:doBody/&gt;&lt;%        return;    }    String[] permissions = name.split(delimiter);    Subject subject = SecurityUtils.getSubject();    for (String permission : permissions) {        if (subject.isPermitted(permission)) {%&gt;            &lt;jsp:doBody/&gt;&lt;%        }    }%&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Shiro </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《跟我学Shiro》笔记08-拦截器机制</title>
      <link href="/2018/04/15/%E3%80%8A%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%E3%80%8B%E7%AC%94%E8%AE%B008-%E6%8B%A6%E6%88%AA%E5%99%A8%E6%9C%BA%E5%88%B6/"/>
      <url>/2018/04/15/%E3%80%8A%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%E3%80%8B%E7%AC%94%E8%AE%B008-%E6%8B%A6%E6%88%AA%E5%99%A8%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文地址：<a href="http://jinnianshilongnian.iteye.com/blog/2025656" target="_blank" rel="noopener">第八章 拦截器机制——《跟我学Shiro》</a><br>目录贴： <a href="http://jinnianshilongnian.iteye.com/blog/2018398" target="_blank" rel="noopener">跟我学Shiro目录贴</a><br>源码：<a href="https://github.com/zhangkaitao/shiro-example" target="_blank" rel="noopener">https://github.com/zhangkaitao/shiro-example</a></p></blockquote><h1 id="拦截器介绍"><a href="#拦截器介绍" class="headerlink" title="拦截器介绍"></a>拦截器介绍</h1><p>Shiro 使用了与 <code>Servlet</code> 一样的 <code>Filter</code> 接口进行扩展；所以如果对 <code>Filter</code> 不熟悉可以参考《Servlet3.1规范》<a href="http://www.iteye.com/blogs/subjects/Servlet-3-1" target="_blank" rel="noopener">http://www.iteye.com/blogs/subjects/Servlet-3-1</a> 了解 <code>Filter</code> 的工作原理。首先下图是 Shiro 拦截器的基础类图：</p><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20180414190113.png" alt="Shiro 拦截器"></p><a id="more"></a><h2 id="NameableFilter"><a href="#NameableFilter" class="headerlink" title="NameableFilter"></a>NameableFilter</h2><p><code>NameableFilter</code> <strong>给 <code>Filter</code> 起个名字</strong>，如果没有设置默认就是 <code>FilterName</code>；还记得之前的如 <code>authc</code> 吗？当我们组装拦截器链时<strong>会根据这个名字找到相应的拦截器实例</strong>；</p><h2 id="OncePerRequestFilter"><a href="#OncePerRequestFilter" class="headerlink" title="OncePerRequestFilter"></a>OncePerRequestFilter</h2><p><code>OncePerRequestFilter</code> <strong>用于防止多次执行 <code>Filter</code> 的</strong>；也就是说一次请求只会走一次拦截器链；另外提供 <code>enabled</code> 属性，表示是否开启该拦截器实例，默认 <code>enabled=true</code> 表示开启，如果不想让某个拦截器工作，可以设置为 false 即可。</p><h2 id="ShiroFilter"><a href="#ShiroFilter" class="headerlink" title="ShiroFilter"></a>ShiroFilter</h2><p><code>ShiroFilter</code> <strong>是整个 Shiro 的入口点</strong>，用于拦截需要安全控制的请求进行处理，这个之前已经用过了。</p><h2 id="AdviceFilter"><a href="#AdviceFilter" class="headerlink" title="AdviceFilter"></a>AdviceFilter</h2><p><code>AdviceFilter</code> <strong>提供了 AOP 风格的支持</strong>，类似于 <code>SpringMVC</code> 中的 <code>Interceptor</code>：</p><pre><code class="java">boolean preHandle(ServletRequest request, ServletResponse response) throws Exceptionvoid postHandle(ServletRequest request, ServletResponse response) throws Exceptionvoid afterCompletion(ServletRequest request, ServletResponse response, Exception exception) throws Exception;</code></pre><ul><li><code>preHandler</code>：类似于 AOP 中的<strong>前置增强</strong>；在拦截器链执行之前执行；如果返回 true 则继续拦截器链；否则中断后续的拦截器链的执行直接返回；进行预处理（如基于表单的身份验证、授权）</li><li><code>postHandle</code>：类似于 AOP 中的<strong>后置返回增强</strong>；在拦截器链执行完成后执行；进行后处理（如记录执行时间之类的）；</li><li><code>afterCompletion</code>：类似于 AOP 中的<strong>后置最终增强</strong>；即不管有没有异常都会执行；可以进行清理资源（如接触 <code>Subject</code> 与线程的绑定之类的）；</li></ul><h2 id="PathMatchingFilter"><a href="#PathMatchingFilter" class="headerlink" title="PathMatchingFilter"></a>PathMatchingFilter</h2><p><code>PathMatchingFilter</code> 提供了基于 <code>Ant</code> 风格的请求路径匹配功能及拦截器参数解析的功能，如 <code>roles[admin,user]</code> 自动根据 <code>,</code> 分割解析到一个路径参数配置并绑定到相应的路径：</p><pre><code class="java">boolean pathsMatch(String path, ServletRequest request)boolean onPreHandle(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception</code></pre><ul><li><code>pathsMatch</code>：该方法用于 <code>path</code> 与请求路径进行匹配的方法；如果匹配返回 true；</li><li><code>onPreHandle</code>：在 <code>preHandle</code> 中，当 <code>pathsMatch</code> 匹配一个路径后，会调用 <code>opPreHandler</code> 方法并将路径绑定参数配置传给 <code>mappedValue</code>；然后可以在这个方法中进行一些验证（如角色授权），如果验证失败可以返回 false 中断流程；默认返回 true；也就是说子类可以只实现 <code>onPreHandle</code> 即可，无须实现 <code>preHandle</code>。如果没有 <code>path</code> 与请求路径匹配，默认是通过的（即 <code>preHandle</code> 返回 true）。</li></ul><h2 id="AccessControlFilter"><a href="#AccessControlFilter" class="headerlink" title="AccessControlFilter"></a>AccessControlFilter</h2><p><code>AccessControlFilter</code> 提供了访问控制的基础功能；比如是否允许访问/当访问拒绝时如何处理等：</p><pre><code class="java">abstract boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception;boolean onAccessDenied(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception;abstract boolean onAccessDenied(ServletRequest request, ServletResponse response) throws Exception;</code></pre><ul><li><code>isAccessAllowed</code>：表示是否允许访问；<code>mappedValue</code> 就是 <code>[urls]</code> 配置中拦截器参数部分，如果允许访问返回 true，否则 false；</li><li><code>onAccessDenied</code>：表示当访问拒绝时是否已经处理了；如果返回 true 表示需要继续处理；如果返回 false 表示该拦截器实例已经处理了，将直接返回即可。</li></ul><p><code>onPreHandle</code> 会自动调用这两个方法决定是否继续处理：</p><pre><code class="java">boolean onPreHandle(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception {    return isAccessAllowed(request, response, mappedValue) || onAccessDenied(request, response, mappedValue);}</code></pre><p>另外 <code>AccessControlFilter</code> 还提供了如下方法用于处理如登录成功后/重定向到上一个请求：</p><pre><code class="java">void setLoginUrl(String loginUrl) // 身份验证时使用，默认 /login.jspString getLoginUrl()Subject getSubject(ServletRequest request, ServletResponse response) // 获取 Subject 实例boolean isLoginRequest(ServletRequest request, ServletResponse response) // 当前请求是否是登录请求// 将当前请求保存起来并重定向到登录页面void saveRequestAndRedirectToLogin(ServletRequest request, ServletResponse response) throws IOExceptionvoid saveRequest(ServletRequest request) // 将请求保存起来，如登录成功后再重定向回该请求void redirectToLogin(ServletRequest request, ServletResponse response) // 重定向到登录页面</code></pre><p>比如基于表单的身份验证就需要使用这些功能。</p><p>到此基本的拦截器就完事了，如果我们<strong>想进行访问的控制</strong>就可以继承 <code>AccessControlFilter</code>；如果我们要<strong>添加一些通用数据</strong>我们可以直接继承 <code>PathMatchingFilter</code>。</p><h1 id="拦截器链"><a href="#拦截器链" class="headerlink" title="拦截器链"></a>拦截器链</h1><p>Shiro 对 <code>Servlet</code> 容器的 <code>FilterChain</code> 进行了代理，即 <code>ShiroFilter</code> 在继续 <code>Servlet</code> 容器的 <code>Filter</code> 链的执行之前，通过 <code>ProxiedFilterChain</code> 对 <code>Servlet</code> 容器的 <code>FilterChain</code> 进行了代理；即先走 Shiro 自己的 <code>Filter</code> 体系，然后才会委托给 <code>Servlet</code> 容器的 <code>FilterChain</code> 进行 <code>Servlet</code> 容器级别的 <code>Filter</code> 链执行；Shiro 的 <code>ProxiedFilterChain</code> 执行流程：</p><ol><li>先执行 Shiro 自己的 <code>Filter</code> 链；</li><li>再执行 <code>Servlet</code> 容器的 <code>Filter</code> 链（即原始的 <code>Filter</code>）。</li></ol><p>而 <code>ProxiedFilterChain</code> 是通过 <code>FilterChainResolver</code> 根据配置文件中 <code>[urls]</code> 部分是否与请求的 <code>URL</code> 是否匹配解析得到的。</p><pre><code class="java">FilterChain getChain(ServletRequest request, ServletResponse response, FilterChain originalChain);</code></pre><p>即传入原始的 <code>chain</code> 得到一个代理的 <code>chain</code>。</p><p>Shiro 内部提供了一个路径匹配的 <code>FilterChainResolver</code> 实现：<code>PathMatchingFilterChainResolver</code>，其根据 <code>[urls]</code> 中配置的 <code>url</code> 模式（默认 <code>Ant</code> 风格）= 拦截器链和请求的 <code>url</code> 是否匹配来解析得到配置的拦截器链的；而 <code>PathMatchingFilterChainResolver</code> 内部通过 <code>FilterChainManager</code> 维护着拦截器链，比如 <code>DefaultFilterChainManager</code> 实现维护着 <code>url</code> 模式与拦截器链的关系。因此我们可以通过 <code>FilterChainManager</code> 进行动态动态增加 <code>url</code> 模式与拦截器链的关系。</p><p><code>DefaultFilterChainManager</code> 会默认添加 <code>org.apache.shiro.web.filter.mgt.DefaultFilter</code>中声明的拦截器：</p><pre><code class="java">public enum DefaultFilter {    anon(AnonymousFilter.class),    authc(FormAuthenticationFilter.class),    authcBasic(BasicHttpAuthenticationFilter.class),    logout(LogoutFilter.class),    noSessionCreation(NoSessionCreationFilter.class),    perms(PermissionsAuthorizationFilter.class),    port(PortFilter.class),    rest(HttpMethodPermissionFilter.class),    roles(RolesAuthorizationFilter.class),    ssl(SslFilter.class),    user(UserFilter.class);}</code></pre><p>如果要<strong>注册自定义拦截器</strong>，<code>IniSecurityManagerFactory</code>/<code>WebIniSecurityManagerFactory</code> 在启动时会自动扫描 <code>ini</code> 配置文件中的 <code>[filters]/[main]</code> 部分并注册这些拦截器到 <code>DefaultFilterChainManager</code>；且创建相应的 <code>url</code> 模式与其拦截器关系链。如果使用 <code>Spring</code> 后续章节会介绍如果注册自定义拦截器。</p><p>如果想自定义 <code>FilterChainResolver</code>，可以通过实现 <code>WebEnvironment</code> 接口完成：</p><pre><code class="java">public class MyIniWebEnvironment extends IniWebEnvironment {    @Override    protected FilterChainResolver createFilterChainResolver() {        // 在此处扩展自己的 FilterChainResolver        return super.createFilterChainResolver();    }}</code></pre><p><code>FilterChain</code> 之间的关系。如果想动态实现 url-拦截器的注册，就可以通过实现此处的 <code>FilterChainResolver</code> 来完成，比如：</p><pre><code class="java">public class MyIniWebEnvironment extends IniWebEnvironment {    @Override    protected FilterChainResolver createFilterChainResolver() {        // 在此处扩展自己的 FilterChainResolver        // 1、创建 FilterChainResolver        PathMatchingFilterChainResolver filterChainResolver = new PathMatchingFilterChainResolver();        // 2、创建 FilterChainManager        DefaultFilterChainManager filterChainManager = new DefaultFilterChainManager();        // 3、注册 Filter        for(DefaultFilter filter : DefaultFilter.values()) {            filterChainManager.addFilter(filter.name(), (Filter) ClassUtils.newInstance(filter.getFilterClass()));        }        // 4、注册 URL-Filter 的映射关系        filterChainManager.addToChain(&quot;/login.jsp&quot;, &quot;authc&quot;);        filterChainManager.addToChain(&quot;/unauthorized.jsp&quot;, &quot;anon&quot;);        filterChainManager.addToChain(&quot;/**&quot;, &quot;authc&quot;);        filterChainManager.addToChain(&quot;/**&quot;, &quot;roles&quot;, &quot;admin&quot;);        // 5、设置 Filter 的属性        FormAuthenticationFilter authcFilter = (FormAuthenticationFilter)filterChainManager.getFilter(&quot;authc&quot;);        authcFilter.setLoginUrl(&quot;/login.jsp&quot;);        RolesAuthorizationFilter rolesFilter = (RolesAuthorizationFilter)filterChainManager.getFilter(&quot;roles&quot;);        rolesFilter.setUnauthorizedUrl(&quot;/unauthorized.jsp&quot;);        filterChainResolver.setFilterChainManager(filterChainManager);        return filterChainResolver;//        return super.createFilterChainResolver();    }}</code></pre><p>此处自己去实现注册 <code>filter</code>，及 <code>url</code> 模式与 <code>filter</code> 之间的映射关系。可以通过定制 <code>FilterChainResolver</code> 或 <code>FilterChainManager</code> 来完成诸如动态 <code>URL</code> 匹配的实现。</p><p>然后再 <code>web.xml</code> 中进行如下配置 <code>Environment</code>：</p><pre><code class="xml">&lt;context-param&gt;    &lt;param-name&gt;shiroEnvironmentClass&lt;/param-name&gt;    &lt;param-value&gt;com.github.zhangkaitao.shiro.chapter8.web.env.MyIniWebEnvironment&lt;/param-value&gt;&lt;/context-param&gt;</code></pre><h1 id="自定义拦截器"><a href="#自定义拦截器" class="headerlink" title="自定义拦截器"></a>自定义拦截器</h1><p>通过自定义自己的拦截器可以扩展一些功能，诸如动态 url-角色/权限访问控制的实现、根据 <code>Subject</code> 身份信息获取用户信息绑定到 <code>Request</code>（即设置通用数据）、验证码验证、在线用户信息的保存等等，因为其本质就是一个 <code>Filter</code>；所以 <code>Filter</code> 能做的它就能做。</p><h2 id="扩展-OncePerRequestFilter"><a href="#扩展-OncePerRequestFilter" class="headerlink" title="扩展 OncePerRequestFilter"></a>扩展 OncePerRequestFilter</h2><p><code>OncePerRequestFilter</code> 保证一次请求只调用一次 <code>doFilterInternal</code>，即如内部的 <code>forward</code> 不会再多执行一次 <code>doFilterInternal</code>：</p><pre><code class="java">public class MyOncePerRequestFilter extends OncePerRequestFilter {    @Override    protected void doFilterInternal(ServletRequest request, ServletResponse response, FilterChain chain) throws ServletException, IOException {        System.out.println(&quot;=========once per request filter&quot;);        chain.doFilter(request, response);    }}</code></pre><p>然后再 <code>shiro.ini</code> 配置文件中：</p><pre><code class="ini">[main]myFilter1=com.github.zhangkaitao.shiro.chapter8.web.filter.MyOncePerRequestFilter;[filters];myFilter1=com.github.zhangkaitao.shiro.chapter8.web.filter.MyOncePerRequestFilter[urls]/**=myFilter1</code></pre><p><code>Filter</code> 可以在 <code>[main]</code> 或 <code>[filters]</code> 部分注册，然后在 <code>[urls]</code> 部分配置 <code>url</code> 与 <code>filter</code> 的映射关系即可。</p><h2 id="扩展-PathMatchingFilter"><a href="#扩展-PathMatchingFilter" class="headerlink" title="扩展 PathMatchingFilter"></a>扩展 PathMatchingFilter</h2><p><code>PathMatchingFilter</code> 继承了 <code>AdviceFilter</code>，提供了 <code>url</code> 模式过滤的功能，如果需要对指定的请求进行处理，可以扩展 <code>PathMatchingFilter</code>：</p><pre><code class="java">public class MyPathMatchingFilter extends PathMatchingFilter {    @Override    protected boolean onPreHandle(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception {        System.out.println(&quot;url matches,config is &quot; + Arrays.toString((String[])mappedValue));        return true;    }}</code></pre><pre><code class="ini">[filters]myFilter3=com.github.zhangkaitao.shiro.chapter8.web.filter.MyPathMatchingFilter[urls]/**= myFilter3[config]</code></pre><p><code>/**</code> 就是注册给 <code>PathMatchingFilter</code> 的 <code>url</code> 模式，<strong><code>config</code> 就是拦截器的配置参数，多个之间逗号分隔</strong>，<code>onPreHandle</code> 使用 <code>mappedValue</code> 接收参数值。</p><h1 id="默认拦截器"><a href="#默认拦截器" class="headerlink" title="默认拦截器"></a>默认拦截器</h1><table><thead><tr><th align="center">默认拦截器名</th><th align="center">拦截器类</th><th align="center">说明（括号里的表示默认值）</th></tr></thead><tbody><tr><td align="center"><strong>身份验证相关的</strong></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"><code>authc</code></td><td align="center">org.apache.shiro.web.filter.authc.FormAuthenticationFilter</td><td align="center">基于表单的拦截器；如 <code>/**=authc</code>，如果没有登录会跳到相应的登录页面登录；主要属性：<br/>1. <code>usernameParam</code>：表单提交的用户名参数名（ username）；<br/>2. <code>passwordParam</code>：表单提交的密码参数名（password）；<br/>3. <code>rememberMeParam</code>：表单提交的密码参数名（rememberMe）；<br/>4. <code>loginUrl</code>：登录页面地址（<code>/login.jsp</code>）；<br/>5. <code>successUrl</code>：登录成功后的默认重定向地址；<br/>6. <code>failureKeyAttribute</code>：登录失败后错误信息存储 key（shiroLoginFailure）；</td></tr><tr><td align="center"><code>authcBasic</code></td><td align="center">org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter</td><td align="center">Basic HTTP 身份验证拦截器，主要属性：<code>applicationName</code>：弹出登录框显示的信息（application）；</td></tr><tr><td align="center"><code>logout</code></td><td align="center">org.apache.shiro.web.filter.authc.LogoutFilter</td><td align="center">退出拦截器，主要属性：<code>redirectUrl</code>：退出成功后重定向的地址（/）;示例 <code>/logout=logout</code></td></tr><tr><td align="center"><code>user</code></td><td align="center">org.apache.shiro.web.filter.authc.UserFilter</td><td align="center">用户拦截器，用户已经身份验证/记住我登录的都可；示例 <code>/**=user</code></td></tr><tr><td align="center"><code>anon</code></td><td align="center">org.apache.shiro.web.filter.authc.AnonymousFilter</td><td align="center">匿名拦截器，即不需要登录即可访问；一般用于静态资源过滤；示例 <code>/static/**=anon</code></td></tr><tr><td align="center"><strong>授权相关的</strong></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"><code>roles</code></td><td align="center">org.apache.shiro.web.filter.authz.RolesAuthorizationFilter</td><td align="center">角色授权拦截器，验证用户是否拥有所有角色；主要属性：<code>loginUrl</code>：登录页面地址（<code>/login.jsp</code>）；<code>unauthorizedUrl</code>：未授权后重定向的地址；示例 <code>/admin/**=roles[admin]</code></td></tr><tr><td align="center"><code>perms</code></td><td align="center">org.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter</td><td align="center">权限授权拦截器，验证用户是否拥有所有权限；属性和 <code>roles</code> 一样；示例 <code>/user/**=perms[&quot;user:create&quot;]</code></td></tr><tr><td align="center"><code>port</code></td><td align="center">org.apache.shiro.web.filter.authz.PortFilter</td><td align="center">端口拦截器，主要属性：<code>port</code>（80）：可以通过的端口；示例 <code>/test= port[80]</code>，如果用户访问该页面是非 80，将自动将请求端口改为 80 并重定向到该 80 端口，其他路径/参数等都一样</td></tr><tr><td align="center"><code>rest</code></td><td align="center">org.apache.shiro.web.filter.authz.HttpMethodPermissionFilter</td><td align="center">rest 风格拦截器，自动根据请求方法构建权限字符串（<code>GET=read</code>, <code>POST=create</code>,<code>PUT=update</code>, <code>DELETE=delete</code>, <code>HEAD=read</code>, <code>TRACE=read</code>, <code>OPTIONS=read</code>, <code>MKCOL=create</code>）构建权限字符串；示例 <code>/users=rest[user]</code>，会自动拼出 <code>user:read,user:create,user:update,user:delete</code> 权限字符串进行权限匹配（所有都得匹配，isPermittedAll）；</td></tr><tr><td align="center"><code>ssl</code></td><td align="center">org.apache.shiro.web.filter.authz.SslFilter</td><td align="center">SSL 拦截器，只有请求协议是 https 才能通过；否则自动跳转会 https 端口（443）；其他和 port 拦截器一样；</td></tr><tr><td align="center"><strong>其他</strong></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"><code>noSessionCreation</code></td><td align="center">org.apache.shiro.web.filter.session.NoSessionCreationFilter</td><td align="center">不创建会话拦截器，调用 <code>subject.getSession(false)</code> 不会有什么问题，但是如果 <code>subject.getSession(true)</code> 将抛出 <code>DisabledSessionException</code> 异常；</td></tr></tbody></table><p>这些默认的拦截器会自动注册，可以直接在 ini 配置文件中通过 <code>拦截器名.属性</code> 设置其属性：</p><pre><code class="ini">perms.unauthorizedUrl=/unauthorized;如果某个拦截器不想使用了可以直接通过如下配置直接禁用perms.enabled=false</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Shiro </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《跟我学Shiro》笔记07-与Web集成</title>
      <link href="/2018/04/14/%E3%80%8A%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%E3%80%8B%E7%AC%94%E8%AE%B007-%E4%B8%8EWeb%E9%9B%86%E6%88%90/"/>
      <url>/2018/04/14/%E3%80%8A%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%E3%80%8B%E7%AC%94%E8%AE%B007-%E4%B8%8EWeb%E9%9B%86%E6%88%90/</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文地址：<a href="http://jinnianshilongnian.iteye.com/blog/2024723" target="_blank" rel="noopener">第七章 与Web集成——《跟我学Shiro》</a><br>目录贴： <a href="http://jinnianshilongnian.iteye.com/blog/2018398" target="_blank" rel="noopener">跟我学Shiro目录贴</a><br>源码：<a href="https://github.com/zhangkaitao/shiro-example" target="_blank" rel="noopener">https://github.com/zhangkaitao/shiro-example</a></p></blockquote><h1 id="使用了-jetty-maven-plugin-和-tomcat7-maven-plugin-插件"><a href="#使用了-jetty-maven-plugin-和-tomcat7-maven-plugin-插件" class="headerlink" title="使用了 jetty-maven-plugin 和 tomcat7-maven-plugin 插件"></a>使用了 jetty-maven-plugin 和 tomcat7-maven-plugin 插件</h1><pre><code class="xml">&lt;build&gt;    &lt;finalName&gt;chapter7&lt;/finalName&gt;    &lt;plugins&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.mortbay.jetty&lt;/groupId&gt;            &lt;artifactId&gt;jetty-maven-plugin&lt;/artifactId&gt;            &lt;version&gt;8.1.8.v20121106&lt;/version&gt;            &lt;configuration&gt;                &lt;webAppConfig&gt;                    &lt;contextPath&gt;/${project.build.finalName}&lt;/contextPath&gt;                &lt;/webAppConfig&gt;            &lt;/configuration&gt;        &lt;/plugin&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;            &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;            &lt;version&gt;2.2&lt;/version&gt;            &lt;configuration&gt;                &lt;path&gt;/${project.build.finalName}&lt;/path&gt;            &lt;/configuration&gt;        &lt;/plugin&gt;    &lt;/plugins&gt;&lt;/build&gt;</code></pre><p>这样可以直接使用 <code>mvn jetty:run</code> 或 <code>mvn tomcat7:run</code> 直接运行 webapp 了。然后通过 URL <a href="http://localhost:8080/chapter7/" target="_blank" rel="noopener">http://localhost:8080/chapter7/</a> 访问即可。</p><a id="more"></a><h1 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h1><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;    &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;    &lt;version&gt;3.0.1&lt;/version&gt;    &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;    &lt;artifactId&gt;shiro-web&lt;/artifactId&gt;    &lt;version&gt;1.2.2&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>Servlet3 的知识可以参考 <a href="https://github.com/zhangkaitao/servlet3-showcase" target="_blank" rel="noopener">https://github.com/zhangkaitao/servlet3-showcase</a> 及 Servlet3 规范 <a href="http://www.iteye.com/blogs/subjects/Servlet-3-1。" target="_blank" rel="noopener">http://www.iteye.com/blogs/subjects/Servlet-3-1。</a></p><h1 id="ShiroFilter-入口"><a href="#ShiroFilter-入口" class="headerlink" title="ShiroFilter 入口"></a>ShiroFilter 入口</h1><p><code>Shiro 1.2</code> 开始引入了 <code>Environment/WebEnvironment</code> 的概念，即由它们的实现提供相应的 <code>SecurityManager</code> 及其相应的依赖。<code>ShiroFilter</code> 会自动找到 <code>Environment</code> 然后获取相应的依赖。</p><pre><code class="xml">&lt;listener&gt;    &lt;listener-class&gt;org.apache.shiro.web.env.EnvironmentLoaderListener&lt;/listener-class&gt;&lt;/listener&gt;&lt;!-- 通过 EnvironmentLoaderListener 来创建相应的 WebEnvironment，并自动绑定到 ServletContext，默认使用 IniWebEnvironment 实现。 --&gt;&lt;context-param&gt;    &lt;param-name&gt;shiroEnvironmentClass&lt;/param-name&gt;    &lt;param-value&gt;org.apache.shiro.web.env.IniWebEnvironment&lt;/param-value&gt;&lt;/context-param&gt;&lt;context-param&gt;    &lt;param-name&gt;shiroConfigLocations&lt;/param-name&gt;    &lt;param-value&gt;classpath:shiro.ini&lt;/param-value&gt;    &lt;!-- 默认先从 /WEB-INF/shiro.ini，如果没有找 classpath:shiro.ini --&gt;&lt;/context-param&gt;&lt;filter&gt;    &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt;    &lt;filter-class&gt;org.apache.shiro.web.servlet.ShiroFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt;    &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;</code></pre><h1 id="INI-配置"><a href="#INI-配置" class="headerlink" title="INI 配置"></a>INI 配置</h1><pre><code class="ini">[main];默认是 /login.jspauthc.loginUrl=/loginroles.unauthorizedUrl=/unauthorizedperms.unauthorizedUrl=/unauthorizedlogout.redirectUrl=/login[users]zhang=123,adminwang=123[roles]admin=user:*,menu:*[urls]/logout2=logout/login=anon/logout=anon/unauthorized=anon/static/**=anon/authenticated=authc/role=authc,roles[admin]/permission=authc,perms[&quot;user:create&quot;]</code></pre><p>其中最重要的就是 <code>[urls]</code> 部分的配置，其格式是：<code>url=拦截器[参数]，拦截器[参数]</code>；即如果当前请求的 url 匹配 <code>[urls]</code> 部分的某个 url 模式，将会执行其配置的拦截器。比如 <code>anon</code> 拦截器表示匿名访问（即不需要登录即可访问）；<code>authc</code> 拦截器表示需要身份认证通过后才能访问；<code>roles[admin]</code> 拦截器表示需要有 admin 角色授权才能访问；而 <code>perms[&quot;user:create&quot;]</code> 拦截器表示需要有 <code>user:create</code> 权限才能访问。</p><h1 id="url-模式使用-Ant-风格模式"><a href="#url-模式使用-Ant-风格模式" class="headerlink" title="url 模式使用 Ant 风格模式"></a>url 模式使用 Ant 风格模式</h1><p>Ant 路径通配符支持 <code>?、*、**</code>，注意通配符匹配不包括目录分隔符 <code>/</code> ：</p><ul><li><p><code>?</code>：匹配一个字符，如 <code>/admin?</code> 将匹配 <code>/admin1</code>，但不匹配 <code>/admin</code> 或 <code>/admin12</code>；</p></li><li><p><code>*</code>：匹配零个或多个字符串，如 <code>/admin*</code> 将匹配 <code>/admin</code>、<code>/admin123</code>，但不匹配 <code>/admin/1</code>；</p></li><li><p><code>**</code>：匹配路径中的零个或多个路径，如 <code>/admin/**</code> 将匹配 <code>/admin/a</code> 或 <code>/admin/a/b</code>。</p></li></ul><h1 id="url-模式匹配顺序"><a href="#url-模式匹配顺序" class="headerlink" title="url 模式匹配顺序"></a>url 模式匹配顺序</h1><p>url 模式匹配顺序是<strong>按照在配置中的声明顺序匹配</strong>，即从头开始使用第一个匹配的 url 模式对应的拦截器链。如：</p><pre><code class="ini">/bb/**=filter1/bb/aa=filter2/**=filter3</code></pre><p>如果请求的 url 是 <code>/bb/aa</code>，因为按照声明顺序进行匹配，那么将使用 <code>filter1</code> 进行拦截。</p><h1 id="身份验证（登录）"><a href="#身份验证（登录）" class="headerlink" title="身份验证（登录）"></a>身份验证（登录）</h1><h2 id="首先配置需要身份验证的-url"><a href="#首先配置需要身份验证的-url" class="headerlink" title="首先配置需要身份验证的 url"></a>首先配置需要身份验证的 url</h2><pre><code class="ini">/authenticated=authc/role=authc,roles[admin]/permission=authc,perms[&quot;user:create&quot;]</code></pre><p>即访问这些地址时会首先判断用户有没有登录，如果<strong>没有登录默会跳转到登录页面</strong>，默认是 <code>/login.jsp</code>，可以通过在 <code>[main]</code> 部分通过如下配置修改：</p><pre><code class="ini">authc.loginUrl=/login</code></pre><h2 id="登录-Servlet"><a href="#登录-Servlet" class="headerlink" title="登录 Servlet"></a>登录 Servlet</h2><pre><code class="java">@WebServlet(name = &quot;loginServlet&quot;, urlPatterns = &quot;/login&quot;)public class LoginServlet extends HttpServlet {    // doGet 请求时展示登录页面    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        req.getRequestDispatcher(&quot;/WEB-INF/jsp/login.jsp&quot;).forward(req, resp);    }    // doPost 时进行登录，登录时收集 username/password 参数，然后提交给 Subject 进行登录。如果有错误再返回到登录页面；    // 否则跳转到登录成功页面（此处应该返回到访问登录页面之前的那个页面，或者没有上一个页面时访问主页）    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        String error = null;        String username = req.getParameter(&quot;username&quot;);        String password = req.getParameter(&quot;password&quot;);        Subject subject = SecurityUtils.getSubject();        UsernamePasswordToken token = new UsernamePasswordToken(username, password);        token.setRememberMe(true);        try {            subject.login(token);        } catch (UnknownAccountException e) {            error = &quot;用户名/密码错误&quot;;        } catch (IncorrectCredentialsException e) {            error = &quot;用户名/密码错误&quot;;        } catch (AuthenticationException e) {            // 其他错误，比如锁定，如果想单独处理请单独 catch 处理            error = &quot;其他错误：&quot; + e.getMessage();        }        if(error != null) { // 出错了，返回登录页面            req.setAttribute(&quot;error&quot;, error);            req.getRequestDispatcher(&quot;/WEB-INF/jsp/login.jsp&quot;).forward(req, resp);        } else { // 登录成功            req.getRequestDispatcher(&quot;/WEB-INF/jsp/loginSuccess.jsp&quot;).forward(req, resp);        }    }}</code></pre><h1 id="基于-Basic-的拦截器身份验证"><a href="#基于-Basic-的拦截器身份验证" class="headerlink" title="基于 Basic 的拦截器身份验证"></a>基于 Basic 的拦截器身份验证</h1><p>web.xml，把 <code>shiroConfigLocations</code> 改为 <code>shiro-basicfilterlogin.ini</code> 即可</p><pre><code class="ini">[main]authcBasic.applicationName=please login; ………省略 users[urls]/role=authcBasic,roles[admin]</code></pre><p><code>authcBasic</code> 是 <code>org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter</code> 类型的实例，其用于实现基于 <code>Basic</code> 的身份验证；<code>applicationName</code> 用于弹出的登录框显示信息使用，如图：</p><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20180414150029.png" alt="弹出的登录框显示信息"></p><p><code>[urls]</code> 部分配置了 <code>/role</code> 地址需要走 <code>authcBasic</code> 拦截器，即如果访问 <code>/role</code> 时还没有通过身份验证那么将弹出如上图的对话框进行登录，登录成功即可访问。</p><h1 id="基于表单的拦截器身份验证"><a href="#基于表单的拦截器身份验证" class="headerlink" title="基于表单的拦截器身份验证"></a>基于表单的拦截器身份验证</h1><p>web.xml，把 <code>shiroConfigLocations</code> 改为 <code>shiro-formfilterlogin.ini</code> 即可。</p><pre><code class="ini">[main]authc.loginUrl=/formfilterloginauthc.usernameParam=usernameauthc.passwordParam=passwordauthc.successUrl=/authc.failureKeyAttribute=shiroLoginFailure[urls]/role=authc,roles[admin]</code></pre><p>authc 是 <code>org.apache.shiro.web.filter.authc.FormAuthenticationFilter</code> 类型的实例，其用于实现基于表单的身份验证；</p><ul><li><code>loginUrl</code> 指定当身份验证时的登录表单；</li><li><code>usernameParam</code> 指定登录表单提交的用户名参数名；</li><li><code>passwordParam</code> 指定登录表单提交的密码参数名；</li><li><code>successUrl</code> 指定登录成功后重定向的默认地址（默认是 <code>/</code> ）（<strong>如果有上一个地址会自动重定向带该地址</strong>）；</li><li><code>failureKeyAttribute</code> 指定登录失败时的 request 属性 key（默认 <code>shiroLoginFailure</code>）；这样可以在登录表单得到该错误 key 显示相应的错误消息；</li></ul><pre><code class="java">@WebServlet(name = &quot;formFilterLoginServlet&quot;, urlPatterns = &quot;/formfilterlogin&quot;)public class FormFilterLoginServlet extends HttpServlet {    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        doPost(req, resp);    }    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        String errorClassName = (String)req.getAttribute(&quot;shiroLoginFailure&quot;);        if(UnknownAccountException.class.getName().equals(errorClassName)) {            req.setAttribute(&quot;error&quot;, &quot;用户名/密码错误&quot;);        } else if(IncorrectCredentialsException.class.getName().equals(errorClassName)) {            req.setAttribute(&quot;error&quot;, &quot;用户名/密码错误&quot;);        } else if(errorClassName != null) {            req.setAttribute(&quot;error&quot;, &quot;未知错误：&quot; + errorClassName);        }        req.getRequestDispatcher(&quot;/WEB-INF/jsp/formfilterlogin.jsp&quot;).forward(req, resp);    }}</code></pre><p>输入 <a href="http://localhost:8080/chapter7/role" target="_blank" rel="noopener">http://localhost:8080/chapter7/role</a> ，会跳转到 <code>/formfilterlogin</code> 登录表单，提交表单如果 <code>authc</code> 拦截器登录成功后，<strong>会直接重定向会之前的地址 <code>/role</code></strong>；假设我们直接访问 <code>/formfilterlogin</code> 的话登录成功将直接到默认的 successUrl。</p><h1 id="授权（角色-权限验证）"><a href="#授权（角色-权限验证）" class="headerlink" title="授权（角色/权限验证）"></a>授权（角色/权限验证）</h1><pre><code class="ini">[main]roles.unauthorizedUrl=/unauthorizedperms.unauthorizedUrl=/unauthorized [urls]/role=authc,roles[admin]/permission=authc,perms[&quot;user:create&quot;]</code></pre><p>通过 <code>unauthorizedUrl</code> 属性指定如果授权失败时重定向到的地址。</p><p><code>roles</code> 是 <code>org.apache.shiro.web.filter.authz.RolesAuthorizationFilter</code> 类型的实例，通过参数指定访问时需要的角色，如 <code>[admin]</code>，如果有多个使用 <code>,</code> 分割，且验证时是 <code>hasAllRole</code> 验证，即且的关系。</p><p><code>Perms</code> 是 <code>org.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter</code> 类型的实例，和 <code>roles</code> 类似，只是验证权限字符串。</p><h2 id="RoleServlet"><a href="#RoleServlet" class="headerlink" title="RoleServlet"></a>RoleServlet</h2><pre><code class="java">@WebServlet(name = &quot;roleServlet&quot;, urlPatterns = &quot;/role&quot;)public class RoleServlet extends HttpServlet {    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        Subject subject = SecurityUtils.getSubject();        subject.checkRole(&quot;admin&quot;);        req.setAttribute(&quot;subject&quot;,subject);        req.getRequestDispatcher(&quot;/WEB-INF/jsp/hasRole.jsp&quot;).forward(req, resp);    }}</code></pre><h2 id="PermissionServlet"><a href="#PermissionServlet" class="headerlink" title="PermissionServlet"></a>PermissionServlet</h2><pre><code class="java">@WebServlet(name = &quot;permissionServlet&quot;, urlPatterns = &quot;/permission&quot;)public class PermissionServlet extends HttpServlet {    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        Subject subject = SecurityUtils.getSubject();        subject.checkPermission(&quot;user:create&quot;);        req.getRequestDispatcher(&quot;/WEB-INF/jsp/hasPermission.jsp&quot;).forward(req, resp);    }}</code></pre><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>首先访问 <a href="http://localhost:8080/chapter7/login" target="_blank" rel="noopener">http://localhost:8080/chapter7/login</a> ，使用帐号 <code>zhang/123</code> 进行登录，再访问 <code>/role</code> 或 <code>/permission</code> 时会跳转到成功页面（因为其授权成功了）；如果使用帐号 <code>wang/123</code> 登录成功后访问这两个地址会跳转到 <code>/unauthorized</code> 即没有授权页面。</p><h1 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h1><pre><code class="ini">/logout=anon</code></pre><p>指定 <code>/logout</code> 使用 <code>anon</code> 拦截器即可，即不需要登录即可访问。</p><h2 id="LogoutServlet"><a href="#LogoutServlet" class="headerlink" title="LogoutServlet"></a>LogoutServlet</h2><pre><code class="java">@WebServlet(name = &quot;logoutServlet&quot;, urlPatterns = &quot;/logout&quot;)public class LogoutServlet extends HttpServlet {    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        SecurityUtils.getSubject().logout();        req.getRequestDispatcher(&quot;/WEB-INF/jsp/logoutSuccess.jsp&quot;).forward(req, resp);    }}</code></pre><p>Shiro 也提供了 <code>logout</code> 拦截器用于退出，其是 <code>org.apache.shiro.web.filter.authc.LogoutFilter</code> 类型的实例，我们可以在 <code>shiro.ini</code> 配置文件中通过如下配置完成退出：</p><pre><code class="ini">[main]logout.redirectUrl=/login[urls]/logout2=logout</code></pre><p>通过 <code>logout.redirectUrl</code> 指定退出后重定向的地址；通过 <code>/logout2=logout</code> 指定退出 url 是 <code>/logout2</code>。这样当我们登录成功后然后访问 <code>/logout2</code> 即可退出。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Shiro </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《跟我学Shiro》笔记06-Realm及相关对象</title>
      <link href="/2018/04/13/%E3%80%8A%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%E3%80%8B%E7%AC%94%E8%AE%B006-Realm%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%AF%B9%E8%B1%A1/"/>
      <url>/2018/04/13/%E3%80%8A%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%E3%80%8B%E7%AC%94%E8%AE%B006-Realm%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文地址：<a href="http://jinnianshilongnian.iteye.com/blog/2022468" target="_blank" rel="noopener">第六章 Realm及相关对象——《跟我学Shiro》</a><br>目录贴： <a href="http://jinnianshilongnian.iteye.com/blog/2018398" target="_blank" rel="noopener">跟我学Shiro目录贴</a><br>源码：<a href="https://github.com/zhangkaitao/shiro-example" target="_blank" rel="noopener">https://github.com/zhangkaitao/shiro-example</a></p></blockquote><h1 id="Realm"><a href="#Realm" class="headerlink" title="Realm"></a>Realm</h1><pre><code class="java">public class UserRealm extends AuthorizingRealm {    private UserService userService = new UserServiceImpl();    @Override    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {        String username = (String)principals.getPrimaryPrincipal();        SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo();        authorizationInfo.setRoles(userService.findRoles(username));        authorizationInfo.setStringPermissions(userService.findPermissions(username));        return authorizationInfo;    }    @Override    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {        String username = (String)token.getPrincipal();        User user = userService.findByUsername(username);        if(user == null) {            throw new UnknownAccountException(); // 没找到帐号        }        if(Boolean.TRUE.equals(user.getLocked())) {            throw new LockedAccountException(); // 帐号锁定        }        // 交给 AuthenticatingRealm 使用 CredentialsMatcher 进行密码匹配，如果觉得人家的不好可以自定义实现        SimpleAuthenticationInfo authenticationInfo = new SimpleAuthenticationInfo(                user.getUsername(), // 用户名                user.getPassword(), // 密码                ByteSource.Util.bytes(user.getCredentialsSalt()), // salt=username+salt                getName()  // realm name        );        return authenticationInfo;    }}</code></pre><a id="more"></a><ol><li><code>UserRealm</code> 父类 <code>AuthorizingRealm</code> 将获取 <code>Subject</code> 相关信息分成两步：获取身份验证信息（<code>doGetAuthenticationInfo</code>）及授权信息（<code>doGetAuthorizationInfo</code>）；</li><li><code>doGetAuthenticationInfo</code> 获取身份验证相关信息：首先根据传入的用户名获取 User 信息；然后如果 user 为空，那么抛出没找到帐号异常 <code>UnknownAccountException</code>；如果 user 找到但锁定了抛出锁定异常 <code>LockedAccountException</code>；最后生成 <code>AuthenticationInfo</code> 信息，交给间接父类 <code>AuthenticatingRealm</code> 使用 <code>CredentialsMatcher</code> 进行判断密码是否匹配，如果不匹配将抛出密码错误异常 <code>IncorrectCredentialsException</code>；另外如果密码重试此处太多将抛出超出重试次数异常 <code>ExcessiveAttemptsException</code>；在组装 <code>SimpleAuthenticationInfo</code> 信息时，需要传入：身份信息（用户名）、凭据（密文密码）、盐（username+salt），<code>CredentialsMatcher</code> 使用盐加密传入的明文密码和此处的密文密码进行匹配。</li><li><code>doGetAuthorizationInfo</code> 获取授权信息：<code>PrincipalCollection</code> 是一个身份集合，因为我们现在就一个 <code>Realm</code>，所以直接调用 <code>getPrimaryPrincipal</code> 得到之前传入的用户名即可；然后根据用户名调用 <code>UserService</code> 接口获取角色及权限信息。</li></ol><h1 id="AuthenticationToken"><a href="#AuthenticationToken" class="headerlink" title="AuthenticationToken"></a>AuthenticationToken</h1><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20180414105018.png" alt="AuthenticationToken"></p><p><code>AuthenticationToken</code> 用于收集用户提交的身份（如用户名）及凭据（如密码）：</p><pre><code class="java">public interface AuthenticationToken extends Serializable {    Object getPrincipal(); //身份    Object getCredentials(); //凭据}</code></pre><p>扩展接口 <code>RememberMeAuthenticationToken</code>：提供了 <code>boolean isRememberMe()</code> 现“记住我”的功能；</p><p>扩展接口是 <code>HostAuthenticationToken</code>：提供了 <code>String getHost()</code> 方法用于获取用户“主机”的功能。</p><p>Shiro 提供了一个直接拿来用的 <code>UsernamePasswordToken</code>，用于实现用户名/密码 Token 组，另外其实现了 <code>RememberMeAuthenticationToken</code> 和 <code>HostAuthenticationToken</code>，可以实现记住我及主机验证的支持。</p><h1 id="AuthenticationInfo"><a href="#AuthenticationInfo" class="headerlink" title="AuthenticationInfo"></a>AuthenticationInfo</h1><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20180414105415.png" alt="AuthenticationInfo"></p><p><code>AuthenticationInfo</code> 有两个作用：</p><ol><li>如果 <code>Realm</code> 是 <code>AuthenticatingRealm</code> 子类，则提供给 <code>AuthenticatingRealm</code> 内部使用的 <code>CredentialsMatcher</code> 进行凭据验证；（如果没有继承它需要在自己的 <code>Realm</code> 中自己实现验证）；</li><li>提供给 <code>SecurityManager</code> 来创建 <code>Subject</code>（提供身份信息）；</li></ol><p><code>MergableAuthenticationInfo</code> 用于提供在多 <code>Realm</code> 时合并 <code>AuthenticationInfo</code> 的功能，主要合并 <code>Principal</code>、如果是其他的如 <code>credentialsSalt</code>，会用后边的信息覆盖前边的。</p><p>比如 <code>HashedCredentialsMatcher</code>，在验证时会判断 <code>AuthenticationInfo</code> 是否是 <code>SaltedAuthenticationInfo</code> 子类，来获取盐信息。</p><p><code>Account</code> 相当于我们之前的 User，<code>SimpleAccount</code> 是其一个实现；在 <code>IniRealm</code>、<code>PropertiesRealm</code> 这种静态创建帐号信息的场景中使用，这些 <code>Realm</code> 直接继承了 <code>SimpleAccountRealm</code>，而 <code>SimpleAccountRealm</code> 提供了相关的 API 来动态维护 <code>SimpleAccount</code>；即可以通过这些 API 来动态增删改查 <code>SimpleAccount</code>；动态增删改查角色/权限信息。及如果您的帐号不是特别多，可以使用这种方式，具体请参考 <code>SimpleAccountRealm Javadoc</code>。</p><p>其他情况一般返回 <code>SimpleAuthenticationInfo</code> 即可。</p><h1 id="PrincipalCollection"><a href="#PrincipalCollection" class="headerlink" title="PrincipalCollection"></a>PrincipalCollection</h1><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20180414110048.png" alt="PrincipalCollection"></p><p>因为我们可以在 Shiro 中同时配置多个 <code>Realm</code>，所以呢身份信息可能就有多个；因此其提供了 <code>PrincipalCollection</code> 用于聚合这些身份信息：</p><pre><code class="java">public interface PrincipalCollection extends Iterable, Serializable {    Object getPrimaryPrincipal(); // 得到主要的身份    &lt;T&gt; T oneByType(Class&lt;T&gt; type); // 根据身份类型获取第一个    &lt;T&gt; Collection&lt;T&gt; byType(Class&lt;T&gt; type); // 根据身份类型获取一组    List asList(); // 转换为 List    Set asSet(); // 转换为 Set    Collection fromRealm(String realmName); // 根据 Realm 名字获取    Set&lt;String&gt; getRealmNames(); // 获取所有身份验证通过的 Realm 名字    boolean isEmpty(); // 判断是否为空}</code></pre><p>因为 <code>PrincipalCollection</code> 聚合了多个，此处最需要注意的是 <code>getPrimaryPrincipal</code>，如果只有一个 <code>Principal</code> 那么直接返回即可，如果有多个 <code>Principal</code>，则返回第一个（因为内部使用 Map 存储，所以可以认为是返回任意一个）；<code>oneByType / byType</code>根据凭据的类型返回相应的 <code>Principal</code>；<code>fromRealm</code> 根据 <code>Realm</code> 名字（每个 <code>Principal</code> 都与一个 <code>Realm</code> 关联）获取相应的 <code>Principal</code>。</p><h2 id="MutablePrincipalCollection"><a href="#MutablePrincipalCollection" class="headerlink" title="MutablePrincipalCollection"></a>MutablePrincipalCollection</h2><p><code>MutablePrincipalCollection</code> 是一个可变的 <code>PrincipalCollection</code> 接口，即提供了如下可变方法：</p><pre><code class="java">public interface MutablePrincipalCollection extends PrincipalCollection {    void add(Object principal, String realmName); // 添加 Realm-Principal 的关联    void addAll(Collection principals, String realmName); // 添加一组 Realm-Principal 的关联    void addAll(PrincipalCollection principals); // 添加 PrincipalCollection    void clear(); // 清空}</code></pre><p>目前 Shiro 只提供了一个实现 <code>SimplePrincipalCollection</code>，还记得之前的 <code>AuthenticationStrategy</code> 实现嘛，用于在多 <code>Realm</code> 时判断是否满足条件的，在大多数实现中（继承了 <code>AbstractAuthenticationStrategy</code>）<code>afterAttempt</code> 方法会进行 <code>AuthenticationInfo</code>（实现了 <code>MergableAuthenticationInfo</code>）的 <code>merge</code>，比如 <code>SimpleAuthenticationInfo</code> 会合并多个 <code>Principal</code> 为一个 <code>PrincipalCollection</code>。</p><pre><code class="java">@Testpublic void test() {    // 因为 Realm 里没有进行验证，所以相当于每个 Realm 都身份验证成功了    login(&quot;classpath:shiro-multirealm.ini&quot;, &quot;zhang&quot;, &quot;123&quot;);    Subject subject = SecurityUtils.getSubject();    // 获取 Primary Principal（即所谓的第一个）    Object primaryPrincipal1 = subject.getPrincipal();    PrincipalCollection princialCollection = subject.getPrincipals();    Object primaryPrincipal2 = princialCollection.getPrimaryPrincipal();    // 但是因为多个 Realm 都返回了 Principal，所以此处到底是哪个是不确定的，这里应该是相同    Assert.assertEquals(primaryPrincipal1, primaryPrincipal2);    // 获取所有身份验证成功的 Realm 名字，返回 a b c    Set&lt;String&gt; realmNames = princialCollection.getRealmNames();    System.out.println(realmNames);    // 因为 MyRealm1 和 MyRealm2 返回的凭据都是 zhang，所以排重了    Set&lt;Object&gt; principals = princialCollection.asSet(); // asList 和 asSet 的结果一样    System.out.println(principals);    // 根据 Realm 名字获取    Collection&lt;User&gt; users = princialCollection.fromRealm(&quot;c&quot;);    System.out.println(users);    // 因为 Realm 名字可以重复，所以可能多个身份，建议 Realm 名字尽量不要重复}</code></pre><h1 id="AuthorizationInfo"><a href="#AuthorizationInfo" class="headerlink" title="AuthorizationInfo"></a>AuthorizationInfo</h1><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20180414112121.png" alt="AuthorizationInfo 授权"></p><p><code>AuthorizationInfo</code> 用于聚合授权信息的：</p><pre><code class="java">public interface AuthorizationInfo extends Serializable {    Collection&lt;String&gt; getRoles(); // 获取角色字符串信息    Collection&lt;String&gt; getStringPermissions(); // 获取权限字符串信息    Collection&lt;Permission&gt; getObjectPermissions(); // 获取 Permission 对象信息}</code></pre><p>当我们使用 <code>AuthorizingRealm</code> 时，如果身份验证成功，在进行授权时就通过 <code>doGetAuthorizationInfo</code> 方法获取角色/权限信息用于授权验证。</p><p>Shiro 提供了一个实现 <code>SimpleAuthorizationInfo</code>，大多数时候使用这个即可。</p><p>对于 <code>Account</code> 及 <code>SimpleAccount</code>，之前的 <code>AuthenticationInfo</code> 已经介绍过了，用于 <code>SimpleAccountRealm</code> 子类，实现动态角色/权限维护的。</p><h1 id="Subject"><a href="#Subject" class="headerlink" title="Subject"></a>Subject</h1><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20180414112513.png" alt="AuthenticationInfo"></p><p><code>Subject</code> 是 Shiro 的核心对象，基本所有身份验证、授权都是通过 <code>Subject</code> 完成。</p><p><code>Subject</code> 自己不会实现相应的身份验证/授权逻辑，而是通过 <code>DelegatingSubject</code> 委托给 <code>SecurityManager</code> 实现；及可以理解为 <code>Subject</code> 是一个面门。</p><p>对于 <code>Subject</code> 的构建一般没必要我们去创建；一般通过 <code>SecurityUtils.getSubject()</code> 获取：</p><pre><code class="java">public static Subject getSubject() {    Subject subject = ThreadContext.getSubject();    if (subject == null) {        subject = (new Subject.Builder()).buildSubject();        ThreadContext.bind(subject);    }    return subject;}// 即首先查看当前线程是否绑定了 Subject，如果没有通过 Subject.Builder 构建一个然后绑定到现场返回。</code></pre><p>如果想自定义创建，可以通过：</p><pre><code class="java">new Subject.Builder().principals(身份).authenticated(true/false).buildSubject()</code></pre><p>这种可以创建相应的 <code>Subject</code> 实例了，然后自己绑定到线程即可。在 <code>new Builder()</code> 时如果没有传入 <code>SecurityManager</code>，自动调用 <code>SecurityUtils.getSecurityManager</code> 获取；也可以自己传入一个实例。</p><h2 id="身份信息获取"><a href="#身份信息获取" class="headerlink" title="身份信息获取"></a>身份信息获取</h2><pre><code class="java">Object getPrincipal(); // Primary PrincipalPrincipalCollection getPrincipals(); // PrincipalCollection</code></pre><h2 id="身份验证"><a href="#身份验证" class="headerlink" title="身份验证"></a>身份验证</h2><pre><code class="java">void login(AuthenticationToken token) throws AuthenticationException;boolean isAuthenticated(); // 登录成功，返回 trueboolean isRemembered(); // 通过记住我功能登录，返回 true</code></pre><p>通过 <code>login</code> 登录，如果登录失败将抛出相应的 <code>AuthenticationException</code>，如果登录成功调用 <code>isAuthenticated</code> 就会返回 true，即已经通过身份验证；如果 <code>isRemembered</code> 返回 true，表示是通过记住我功能登录的而不是调用 <code>login</code> 方法登录的。<strong><code>isAuthenticated/isRemembered</code> 是互斥的</strong>，即如果其中一个返回 true，另一个返回 false。</p><h2 id="角色授权验证"><a href="#角色授权验证" class="headerlink" title="角色授权验证"></a>角色授权验证</h2><pre><code class="java">boolean hasRole(String roleIdentifier);boolean[] hasRoles(List&lt;String&gt; roleIdentifiers);boolean hasAllRoles(Collection&lt;String&gt; roleIdentifiers);void checkRole(String roleIdentifier) throws AuthorizationException;void checkRoles(Collection&lt;String&gt; roleIdentifiers) throws AuthorizationException;void checkRoles(String... roleIdentifiers) throws AuthorizationException;</code></pre><p><code>hasRole*</code> 进行角色验证，验证后返回 <code>true/false</code>；而 <code>checkRole*</code> 验证失败时抛出 <code>AuthorizationException</code> 异常。</p><h2 id="权限授权验证"><a href="#权限授权验证" class="headerlink" title="权限授权验证"></a>权限授权验证</h2><pre><code class="java">boolean isPermitted(String permission);boolean isPermitted(Permission permission);boolean[] isPermitted(String... permissions);boolean[] isPermitted(List&lt;Permission&gt; permissions);boolean isPermittedAll(String... permissions);boolean isPermittedAll(Collection&lt;Permission&gt; permissions);void checkPermission(String permission) throws AuthorizationException;void checkPermission(Permission permission) throws AuthorizationException;void checkPermissions(String... permissions) throws AuthorizationException;void checkPermissions(Collection&lt;Permission&gt; permissions) throws AuthorizationException;</code></pre><p><code>isPermitted*</code> 进行权限验证，验证后返回 <code>true/false</code>；而 <code>checkPermission*</code> 验证失败时抛出 <code>AuthorizationException</code>。</p><h2 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h2><pre><code class="java">ession getSession(); // 相当于 getSession(true)Session getSession(boolean create);</code></pre><p>类似于 Web 中的会话。如果登录成功就相当于建立了会话，接着可以使用 <code>getSession</code> 获取；如果 <code>create=false</code> 如果没有会话将返回 null，而 <code>create=true</code> 如果没有会话会强制创建一个。</p><h2 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h2><pre><code class="java">void logout();</code></pre><h2 id="RunAs"><a href="#RunAs" class="headerlink" title="RunAs"></a>RunAs</h2><pre><code class="java">void runAs(PrincipalCollection principals) throws NullPointerException, IllegalStateException;boolean isRunAs();PrincipalCollection getPreviousPrincipals();PrincipalCollection releaseRunAs();</code></pre><ul><li><code>RunAs</code> 即实现“允许 A 假设为 B 身份进行访问”；</li><li>通过调用 <code>subject.runAs(b)</code> 进行访问；</li><li>接着调用 <code>subject.getPrincipals</code> 将获取到 B 的身份；</li><li>此时调用 <code>isRunAs</code> 将返回 true；而 A 的身份需要通过 <code>subject. getPreviousPrincipals</code> 获取；</li><li>如果不需要 <code>RunAs</code> 了调用 <code>subject.releaseRunAs</code> 即可。</li></ul><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><pre><code class="java">&lt;V&gt; V execute(Callable&lt;V&gt; callable) throws ExecutionException;void execute(Runnable runnable);&lt;V&gt; Callable&lt;V&gt; associateWith(Callable&lt;V&gt; callable);Runnable associateWith(Runnable runnable);</code></pre><p>实现线程之间的 <code>Subject</code> 传播，因为 <code>Subject</code> 是线程绑定的；因此在多线程执行中需要传播到相应的线程才能获取到相应的 <code>Subject</code>。最简单的办法就是通过 <code>execute(runnable/callable 实例)</code> 直接调用；或者通过 <code>associateWith(runnable/callable 实例)</code> 得到一个包装后的实例；它们都是通过：1、把当前线程的 <code>Subject</code> 绑定过去；2、在线程执行结束后自动释放。</p><h2 id="一般使用"><a href="#一般使用" class="headerlink" title="一般使用"></a>一般使用</h2><ol><li>身份验证（login）</li><li>授权（<code>hasRole*/isPermitted*或checkRole*/checkPermission*</code>）</li><li>将相应的数据存储到会话（Session）</li><li>切换身份（RunAs）/多线程身份传播</li><li>退出</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Shiro </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《跟我学Shiro》笔记05-编码加密</title>
      <link href="/2018/04/12/%E3%80%8A%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%E3%80%8B%E7%AC%94%E8%AE%B005-%E7%BC%96%E7%A0%81%E5%8A%A0%E5%AF%86/"/>
      <url>/2018/04/12/%E3%80%8A%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%E3%80%8B%E7%AC%94%E8%AE%B005-%E7%BC%96%E7%A0%81%E5%8A%A0%E5%AF%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文地址：<a href="http://jinnianshilongnian.iteye.com/blog/2021439" target="_blank" rel="noopener">第五章 编码/加密——《跟我学Shiro》</a><br>目录贴： <a href="http://jinnianshilongnian.iteye.com/blog/2018398" target="_blank" rel="noopener">跟我学Shiro目录贴</a><br>源码：<a href="https://github.com/zhangkaitao/shiro-example" target="_blank" rel="noopener">https://github.com/zhangkaitao/shiro-example</a></p></blockquote><h1 id="编码-解码"><a href="#编码-解码" class="headerlink" title="编码/解码"></a>编码/解码</h1><p>Shiro 提供了 <code>base64</code> 和 <code>16 进制字符串</code>编码/解码的 API 支持，方便一些编码解码操作。Shiro 内部的一些数据的存储/表示都使用了 base64 和 16 进制字符串。</p><a id="more"></a><pre><code class="java">@Testpublic void testBase64() {    String str = &quot;hello&quot;;    String base64Encoded = Base64.encodeToString(str.getBytes());    String str2 = Base64.decodeToString(base64Encoded);    Assert.assertEquals(str, str2);}@Testpublic void testHex() {    String str = &quot;hello&quot;;    String base64Encoded = Hex.encodeToString(str.getBytes());    String str2 = new String(Hex.decode(base64Encoded.getBytes()));    Assert.assertEquals(str, str2);}// CodecSupport 类，提供了 toBytes(str, &quot;utf-8&quot;) / toString(bytes, &quot;utf-8&quot;)用于在 byte 数组与 String 之间转换。@Testpublic void testCodecSupport() {    String str = &quot;hello&quot;;    byte[] bytes = CodecSupport.toBytes(str, &quot;utf-8&quot;);    String str2 = CodecSupport.toString(bytes, &quot;utf-8&quot;);    Assert.assertEquals(str, str2);}</code></pre><h1 id="散列算法"><a href="#散列算法" class="headerlink" title="散列算法"></a>散列算法</h1><p>散列算法一般用于生成数据的摘要信息，是一种不可逆的算法，一般适合存储密码之类的数据，常见的散列算法如 <code>MD5</code>、<code>SHA</code> 等。一般进行散列时<strong>最好提供一个 <code>salt</code>（盐）</strong>，比如加密密码 <code>admin</code>，产生的散列值是 <code>21232f297a57a5a743894a0e4a801fc3</code>，可以到一些 md5 解密网站很容易的通过散列值得到密码 admin，即如果直接对密码进行散列相对来说破解更容易，此时我们可以加一些只有系统知道的干扰数据，如用户名和 ID（即盐）；这样散列的对象是 <code>密码 + 用户名 + ID</code>，这样生成的散列值相对来说更难破解。</p><pre><code class="java">@Testpublic void testMd5Sha() {    String str = &quot;hello&quot;;    String salt = &quot;123&quot;;    String md5 = new Md5Hash(str, salt).toString(); // 还可以转换为 toBase64()/toHex()    System.out.println(md5);    String sha1 = new Sha1Hash(str, salt).toString();    System.out.println(sha1);    String sha256 = new Sha256Hash(str, salt).toString();    String sha384 = new Sha384Hash(str, salt).toString();    String sha512 = new Sha512Hash(str, salt).toString();    // Shiro 还提供了通用的散列支持，内部使用 Java 的 MessageDigest    String simpleHash = new SimpleHash(&quot;SHA-1&quot;, str, salt).toString();}</code></pre><p>为了方便使用，Shiro 提供了 <code>HashService</code>，默认提供了 <code>DefaultHashService</code> 实现。</p><pre><code class="java">@Testpublic void testHashService() {    DefaultHashService hashService = new DefaultHashService(); // 默认算法 SHA-512    hashService.setHashAlgorithmName(&quot;SHA-512&quot;);    hashService.setPrivateSalt(new SimpleByteSource(&quot;123&quot;)); // 私盐，默认无    hashService.setGeneratePublicSalt(true); // 是否生成公盐，默认 false    hashService.setRandomNumberGenerator(new SecureRandomNumberGenerator()); // 用于生成公盐。默认就这个    hashService.setHashIterations(1); // 生成 Hash 值的迭代次数    HashRequest request = new HashRequest.Builder()            .setAlgorithmName(&quot;MD5&quot;).setSource(ByteSource.Util.bytes(&quot;hello&quot;))            .setSalt(ByteSource.Util.bytes(&quot;123&quot;)).setIterations(2).build();    String hex = hashService.computeHash(request).toHex();    System.out.println(hex);}</code></pre><ol><li>首先创建一个 <code>DefaultHashService</code>，默认使用 <code>SHA-512</code> 算法；</li><li>可以通过 <code>hashAlgorithmName</code> 属性修改算法；</li><li>可以通过 <code>privateSalt</code> 设置一个私盐，其在散列时自动与用户传入的公盐混合产生一个新盐；</li><li>可以通过 <code>generatePublicSalt</code> 属性在用户没有传入公盐的情况下是否生成公盐；</li><li>可以设置 <code>randomNumberGenerator</code> 用于生成公盐；</li><li>可以设置 <code>hashIterations</code> 属性来修改默认加密迭代次数；</li><li>需要构建一个 <code>HashRequest</code>，传入算法、数据、公盐、迭代次数。</li></ol><pre><code class="java">@Testpublic void testRandom() {    // 生成随机数    SecureRandomNumberGenerator randomNumberGenerator = new SecureRandomNumberGenerator();    randomNumberGenerator.setSeed(&quot;123&quot;.getBytes()); // 生成随机数的种子，这么设置可以使得每次生成的一样，如果不需要这样，注释即可。    System.out.println(randomNumberGenerator.nextBytes().toHex());  // 23ae809ddacaf96af0fd78ed04b6a265}</code></pre><h1 id="加密-解密"><a href="#加密-解密" class="headerlink" title="加密/解密"></a>加密/解密</h1><p>Shiro 还提供对称式加密/解密算法的支持，如 AES、Blowfish 等；当前还没有提供对非对称加密/解密算法支持，未来版本可能提供。</p><p>AES 仅支持 16, 24 或 32 字节的密钥大小，一般为 16 字节，<a href="https://stackoverflow.com/questions/29354133/how-to-fix-invalid-aes-key-length" target="_blank" rel="noopener">https://stackoverflow.com/questions/29354133/how-to-fix-invalid-aes-key-length</a></p><p>如果要支持24 或 32 字节的密钥大小，<a href="https://stackoverflow.com/questions/6481627/java-security-illegal-key-size-or-default-parameters" target="_blank" rel="noopener">https://stackoverflow.com/questions/6481627/java-security-illegal-key-size-or-default-parameters</a></p><pre><code class="java">String text = &quot;hello&quot;;@Testpublic void testAesCipherService() {    AesCipherService aesCipherService = new AesCipherService();    aesCipherService.setKeySize(128); // 设置 key 长度    // 生成 key    Key key = aesCipherService.generateNewKey();    // 加密 这里的 key 只能是 16, 24 或 32 位 key.getEncoded() 可以替换为 &quot;1234567812345678&quot;.getBytes()    String encrptText = aesCipherService.encrypt(text.getBytes(), key.getEncoded()).toHex();    // 解密    String text2 = new String(aesCipherService.decrypt(Hex.decode(encrptText), key.getEncoded()).getBytes());    Assert.assertEquals(text, text2);}@Testpublic void testBlowfishCipherService() {    BlowfishCipherService blowfishCipherService = new BlowfishCipherService();    blowfishCipherService.setKeySize(128);    // 生成 key    Key key = blowfishCipherService.generateNewKey();    // 加密    String encrptText = blowfishCipherService.encrypt(text.getBytes(), key.getEncoded()).toHex();    // 解密    String text2 = new String(blowfishCipherService.decrypt(Hex.decode(encrptText), key.getEncoded()).getBytes());    Assert.assertEquals(text, text2);}@Testpublic void testDefaultBlockCipherService() throws Exception {    // 对称加密，使用 Java 的 JCA（javax.crypto.Cipher）加密 API，常见的如 &#39;AES&#39;, &#39;Blowfish&#39;    DefaultBlockCipherService cipherService = new DefaultBlockCipherService(&quot;AES&quot;);    cipherService.setKeySize(128);    // 生成 key    Key key = cipherService.generateNewKey();    // 加密    String encrptText = cipherService.encrypt(text.getBytes(), key.getEncoded()).toHex();    // 解密    String text2 = new String(cipherService.decrypt(Hex.decode(encrptText), key.getEncoded()).getBytes());    Assert.assertEquals(text, text2);}</code></pre><p>加密/解密相关知识可参考 snowolf 的博客 <a href="http://snowolf.iteye.com/category/68576" target="_blank" rel="noopener">http://snowolf.iteye.com/category/68576</a></p><h1 id="PasswordService-CredentialsMatcher"><a href="#PasswordService-CredentialsMatcher" class="headerlink" title="PasswordService/CredentialsMatcher"></a>PasswordService/CredentialsMatcher</h1><p>Shiro 提供了 <code>PasswordService</code> 及 <code>CredentialsMatcher</code> 用于提供加密密码及验证密码服务。</p><pre><code class="java">public interface PasswordService {    // 输入明文密码得到密文密码    String encryptPassword(Object plaintextPassword) throws IllegalArgumentException;}</code></pre><pre><code class="java">public interface CredentialsMatcher {    // 匹配用户输入的 token 的凭证（未加密）与系统提供的凭证（已加密）    boolean doCredentialsMatch(AuthenticationToken token, AuthenticationInfo info);}</code></pre><p>Shiro 默认提供了 <code>PasswordService</code> 实现： <code>DefaultPasswordService</code>；<code>CredentialsMatcher</code> 实现： <code>PasswordMatcher</code> 及 <code>HashedCredentialsMatcher</code>（更强大）。</p><h2 id="DefaultPasswordService-配合-PasswordMatcher-实现简单的密码加密与验证服务"><a href="#DefaultPasswordService-配合-PasswordMatcher-实现简单的密码加密与验证服务" class="headerlink" title="DefaultPasswordService 配合 PasswordMatcher 实现简单的密码加密与验证服务"></a>DefaultPasswordService 配合 PasswordMatcher 实现简单的密码加密与验证服务</h2><h3 id="定义-Realm"><a href="#定义-Realm" class="headerlink" title="定义 Realm"></a>定义 Realm</h3><pre><code class="java">public class MyRealm extends AuthorizingRealm {    private PasswordService passwordService;    public void setPasswordService(PasswordService passwordService) {        this.passwordService = passwordService;    }    @Override    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {        return null;    }    @Override    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {        return new SimpleAuthenticationInfo(                &quot;wu&quot;,                passwordService.encryptPassword(&quot;123&quot;),                getName());    }}</code></pre><p>为了方便，直接注入一个 <code>passwordService</code> 来加密密码，实际使用时需要在 Service 层使用 <code>passwordService</code> 加密密码并存到数据库。</p><h3 id="ini-配置"><a href="#ini-配置" class="headerlink" title="ini 配置"></a>ini 配置</h3><pre><code class="ini">[main]passwordService=org.apache.shiro.authc.credential.DefaultPasswordServicehashService=org.apache.shiro.crypto.hash.DefaultHashServicepasswordService.hashService=$hashServicehashFormat=org.apache.shiro.crypto.hash.format.Shiro1CryptFormatpasswordService.hashFormat=$hashFormathashFormatFactory=org.apache.shiro.crypto.hash.format.DefaultHashFormatFactorypasswordService.hashFormatFactory=$hashFormatFactorypasswordMatcher=org.apache.shiro.authc.credential.PasswordMatcherpasswordMatcher.passwordService=$passwordServicemyRealm=com.github.zhangkaitao.shiro.chapter5.hash.realm.MyRealmmyRealm.passwordService=$passwordServicemyRealm.credentialsMatcher=$passwordMatchersecurityManager.realms=$myRealm</code></pre><ol><li><code>passwordService</code> 使用 <code>DefaultPasswordService</code>，如果有必要也可以自定义；</li><li><code>hashService</code> 定义散列密码使用的 <code>HashService</code>，默认使用 <code>DefaultHashService</code>（默认 SHA-512 算法）；</li><li><code>hashFormat</code> 用于对散列出的值进行格式化，默认使用 <code>Shiro1CryptFormat</code>，另外提供了 <code>Base64Format</code> 和 <code>HexFormat</code>，对于有 <code>salt</code> 的密码请自定义实现 <code>ParsableHashFormat</code> 然后把 <code>salt</code> 格式化到散列值中；</li><li><code>hashFormatFactory</code> 用于根据散列值得到散列的密码和 <code>salt</code>；因为如果使用如 SHA 算法，那么会生成一个 <code>salt</code>，此 <code>salt</code> 需要保存到散列后的值中以便之后与传入的密码比较时使用；默认使用 <code>DefaultHashFormatFactory</code>；</li><li><code>passwordMatcher</code> 使用 <code>PasswordMatcher</code>，其是一个 <code>CredentialsMatcher</code> 实现；</li><li>将 <code>credentialsMatcher</code> 赋值给 <code>myRealm</code>，<code>myRealm</code> 间接继承了 <code>AuthenticatingRealm</code>，其在调用 <code>getAuthenticationInfo</code> 方法获取到 <code>AuthenticationInfo</code> 信息后，会使用 <code>credentialsMatcher</code> 来验证凭据是否匹配，如果不匹配将抛出 <code>IncorrectCredentialsException</code> 异常。</li></ol><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><pre><code class="java">@Testpublic void testPasswordServiceWithMyRealm() {    login(&quot;classpath:shiro-passwordservice.ini&quot;, &quot;wu&quot;, &quot;123&quot;);}</code></pre><h2 id="HashedCredentialsMatcher-实现密码验证服务"><a href="#HashedCredentialsMatcher-实现密码验证服务" class="headerlink" title="HashedCredentialsMatcher 实现密码验证服务"></a>HashedCredentialsMatcher 实现密码验证服务</h2><p>Shiro 提供了 <code>CredentialsMatcher</code> 的散列实现 <code>HashedCredentialsMatcher</code>，和之前的 <code>PasswordMatcher</code> 不同的是，它只用于密码验证，且可以提供自己的盐，而不是随机生成盐，且生成密码散列值的算法需要自己写，因为能提供自己的盐。</p><h3 id="生成密码散列值"><a href="#生成密码散列值" class="headerlink" title="生成密码散列值"></a>生成密码散列值</h3><p>此处我们使用 MD5 算法，&quot;密码+盐（用户名+随机数）&quot; 的方式生成散列值：</p><pre><code class="java">@Testpublic void testGeneratePassword() {    String algorithmName = &quot;md5&quot;;    String username = &quot;liu&quot;;    String password = &quot;123&quot;;    String salt1 = username;    String salt2 = new SecureRandomNumberGenerator().nextBytes().toHex();    int hashIterations = 2;    SimpleHash hash = new SimpleHash(algorithmName, password, salt1 + salt2, hashIterations);    String encodedPassword = hash.toHex();    Assert.assertEquals(hash.getSalt()+&quot;&quot;, Base64.encodeToString((salt1+salt2).getBytes()));}</code></pre><p>如果要写用户模块，需要在新增用户/重置密码时使用如上算法保存密码，<strong>将生成的密码及 salt2 存入数据库</strong>（因为我们的散列算法是：<strong><code>md5(md5(密码+username+salt2))</code></strong>）。</p><h3 id="使用-JdbcRealm"><a href="#使用-JdbcRealm" class="headerlink" title="使用 JdbcRealm"></a>使用 JdbcRealm</h3><p>如果使用 <code>JdbcRealm</code>，需要修改获取用户信息（包括盐）的 sql：<code>select password, password_salt from users where username = ?</code>，而我们的盐是由 <code>username+password_salt</code> 组成，所以需要通过如下 ini 配置（shiro-jdbc-hashedCredentialsMatcher.ini）修改：</p><pre><code class="ini">[main]credentialsMatcher=org.apache.shiro.authc.credential.HashedCredentialsMatchercredentialsMatcher.hashAlgorithmName=md5credentialsMatcher.hashIterations=2credentialsMatcher.storedCredentialsHexEncoded=truedataSource=com.alibaba.druid.pool.DruidDataSourcedataSource.driverClassName=com.mysql.jdbc.DriverdataSource.url=jdbc:mysql://localhost:3306/shirodataSource.username=rootdataSource.password=123456jdbcRealm=org.apache.shiro.realm.jdbc.JdbcRealmjdbcRealm.dataSource=$dataSourcejdbcRealm.permissionsLookupEnabled=truejdbcRealm.saltStyle=COLUMNjdbcRealm.authenticationQuery=select password, concat(username,password_salt) from users where username = ?jdbcRealm.credentialsMatcher=$credentialsMatchersecurityManager.realms=$jdbcRealm</code></pre><ol><li><code>saltStyle</code> 表示<strong>使用密码+盐的机制</strong>，<code>authenticationQuery</code> 第一列是密码，第二列是盐；</li><li>通过 <code>authenticationQuery</code> 指定密码及盐查询 SQL；</li></ol><p>此处还要注意 Shiro 默认使用了 <code>apache commons BeanUtils</code>，默认是不进行 Enum 类型转型的，此时需要自己注册一个 Enum 转换器 <code>BeanUtilsBean.getInstance().getConvertUtils().register(new EnumConverter(), JdbcRealm.SaltStyle.class);</code>，如下：</p><pre><code class="java">@Testpublic void testHashedCredentialsMatcherWithJdbcRealm() {    BeanUtilsBean.getInstance().getConvertUtils().register(new EnumConverter(), JdbcRealm.SaltStyle.class);    // 使用 testGeneratePassword 生成的散列密码    login(&quot;classpath:shiro-jdbc-hashedCredentialsMatcher.ini&quot;, &quot;liu&quot;, &quot;123&quot;);}private class EnumConverter extends AbstractConverter {    @Override    protected String convertToString(final Object value) throws Throwable {        return ((Enum) value).name();    }    @Override    protected Object convertToType(final Class type, final Object value) throws Throwable {        return Enum.valueOf(type, value.toString());    }    @Override    protected Class getDefaultType() {        return null;    }}</code></pre><h3 id="使用自定义-Realm"><a href="#使用自定义-Realm" class="headerlink" title="使用自定义 Realm"></a>使用自定义 Realm</h3><h4 id="生成-Realm"><a href="#生成-Realm" class="headerlink" title="生成 Realm"></a>生成 Realm</h4><pre><code class="java">public class MyRealm2 extends AuthorizingRealm {    @Override    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {        return null;    }    @Override    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {        String username = &quot;liu&quot;; // 用户名及 salt1        String salt2 = &quot;0072273a5d87322163795118fdd7c45e&quot;;        String password = &quot;be320beca57748ab9632c4121ccac0db&quot;; // 加密后的密码，将上文中 testGeneratePassword() 方法，salt2 改为固定，即可得到该值        SimpleAuthenticationInfo ai = new SimpleAuthenticationInfo(username, password, getName());        ai.setCredentialsSalt(ByteSource.Util.bytes(username+salt2)); // 盐是用户名+随机数        return ai;    }}</code></pre><p>此处就是把<code>生成密码散列值</code>中生成的相应数据组装为 <code>SimpleAuthenticationInfo</code>，通过 <code>SimpleAuthenticationInfo</code> 的 <code>credentialsSalt</code> 设置盐，<code>HashedCredentialsMatcher</code> 会自动识别这个盐。</p><h4 id="ini配置"><a href="#ini配置" class="headerlink" title="ini配置"></a>ini配置</h4><pre><code class="ini">; shiro-hashedCredentialsMatcher.ini[main]credentialsMatcher=org.apache.shiro.authc.credential.HashedCredentialsMatchercredentialsMatcher.hashAlgorithmName=md5credentialsMatcher.hashIterations=2credentialsMatcher.storedCredentialsHexEncoded=truemyRealm=com.github.zhangkaitao.shiro.chapter5.hash.realm.MyRealm2myRealm.credentialsMatcher=$credentialsMatchersecurityManager.realms=$myRealm</code></pre><ol><li>通过 <code>credentialsMatcher.hashAlgorithmName=md5</code> 指定散列算法为 md5，需要和生成密码时的一样；</li><li><code>credentialsMatcher.hashIterations=2</code>，散列迭代次数，需要和生成密码时的意义；</li><li><code>credentialsMatcher.storedCredentialsHexEncoded=true</code> 表示是否存储散列后的密码为 16 进制，需要和生成密码时的一样，默认是 base64；</li></ol><p>此处最需要注意的就是 <code>HashedCredentialsMatcher</code> 的算法需要和生成密码时的算法一样。另外 <code>HashedCredentialsMatcher</code> 会自动根据 <code>AuthenticationInfo</code> 的类型是否是 <code>SaltedAuthenticationInfo</code> 来获取 <code>credentialsSalt</code> 盐。</p><h4 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h4><pre><code class="java">@Testpublic void testHashedCredentialsMatcherWithMyRealm2() {    // 使用 testGeneratePassword 生成的散列密码    login(&quot;classpath:shiro-hashedCredentialsMatcher.ini&quot;, &quot;liu&quot;, &quot;123&quot;);}</code></pre><h2 id="密码重试次数限制"><a href="#密码重试次数限制" class="headerlink" title="密码重试次数限制"></a>密码重试次数限制</h2><p>如在 1 个小时内密码最多重试 5 次，如果尝试次数超过 5 次就锁定 1 小时，1 小时后可再次重试，如果还是重试失败，可以锁定如 1 天，以此类推，防止密码被暴力破解。我们通过继承 <code>HashedCredentialsMatcher</code>，且使用 <code>Ehcache</code> 记录重试次数和超时时间。</p><pre><code class="java">// com.github.zhangkaitao.shiro.chapter5.hash.credentials.RetryLimitHashedCredentialsMatcherpublic class RetryLimitHashedCredentialsMatcher extends HashedCredentialsMatcher {    private Ehcache passwordRetryCache;    public RetryLimitHashedCredentialsMatcher() {        CacheManager cacheManager = CacheManager.newInstance(CacheManager.class.getClassLoader().getResource(&quot;ehcache.xml&quot;));        passwordRetryCache = cacheManager.getCache(&quot;passwordRetryCache&quot;);    }    @Override    public boolean doCredentialsMatch(AuthenticationToken token, AuthenticationInfo info) {        String username = (String)token.getPrincipal();        // retry count + 1        Element element = passwordRetryCache.get(username);        if(element == null) {            element = new Element(username , new AtomicInteger(0));            passwordRetryCache.put(element);        }        AtomicInteger retryCount = (AtomicInteger)element.getObjectValue();        if(retryCount.incrementAndGet() &gt; 5) {            // if retry count &gt; 5 throw            throw new ExcessiveAttemptsException();        }        boolean matches = super.doCredentialsMatch(token, info);        if(matches) {            // clear retry count            passwordRetryCache.remove(username);        }        return matches;    }}</code></pre><pre><code class="xml">&lt;!-- ehcache.xml --&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;ehcache name=&quot;es&quot;&gt;    &lt;diskStore path=&quot;java.io.tmpdir&quot;/&gt;    &lt;!-- 登录记录缓存 锁定 10 分钟 --&gt;    &lt;cache name=&quot;passwordRetryCache&quot;           maxEntriesLocalHeap=&quot;2000&quot;           eternal=&quot;false&quot;           timeToIdleSeconds=&quot;3600&quot;           timeToLiveSeconds=&quot;0&quot;           overflowToDisk=&quot;false&quot;           statistics=&quot;true&quot;&gt;    &lt;/cache&gt;&lt;/ehcache&gt;</code></pre><p>如上代码逻辑比较简单，即如果密码输入正确清除 <code>cache</code> 中的记录；否则 <code>cache</code> 中的重试次数 +1，如果超出 5 次那么抛出异常表示超出重试次数了。</p><h3 id="ini-配置文件"><a href="#ini-配置文件" class="headerlink" title="ini 配置文件"></a>ini 配置文件</h3><pre><code class="ini">[main]credentialsMatcher=com.github.zhangkaitao.shiro.chapter5.hash.credentials.RetryLimitHashedCredentialsMatchercredentialsMatcher.hashAlgorithmName=md5credentialsMatcher.hashIterations=2credentialsMatcher.storedCredentialsHexEncoded=truemyRealm=com.github.zhangkaitao.shiro.chapter5.hash.realm.MyRealm2myRealm.credentialsMatcher=$credentialsMatchersecurityManager.realms=$myRealm</code></pre><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><pre><code class="java">@Test(expected = ExcessiveAttemptsException.class)public void testRetryLimitHashedCredentialsMatcherWithMyRealm() {    for(int i = 1; i &lt;= 5; i++) {        try {            login(&quot;classpath:shiro-retryLimitHashedCredentialsMatcher.ini&quot;, &quot;liu&quot;, &quot;234&quot;);        } catch (Exception e) {/*ignore*/}    }    login(&quot;classpath:shiro-retryLimitHashedCredentialsMatcher.ini&quot;, &quot;liu&quot;, &quot;234&quot;);}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Shiro </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《跟我学Shiro》笔记04-INI配置</title>
      <link href="/2018/04/11/%E3%80%8A%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%E3%80%8B%E7%AC%94%E8%AE%B004-INI%E9%85%8D%E7%BD%AE/"/>
      <url>/2018/04/11/%E3%80%8A%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%E3%80%8B%E7%AC%94%E8%AE%B004-INI%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文地址：<a href="http://jinnianshilongnian.iteye.com/blog/2020820" target="_blank" rel="noopener">第四章 INI配置——《跟我学Shiro》</a><br>目录贴： <a href="http://jinnianshilongnian.iteye.com/blog/2018398" target="_blank" rel="noopener">跟我学Shiro目录贴</a><br>源码：<a href="https://github.com/zhangkaitao/shiro-example" target="_blank" rel="noopener">https://github.com/zhangkaitao/shiro-example</a></p></blockquote><h1 id="根对象-SecurityManager"><a href="#根对象-SecurityManager" class="headerlink" title="根对象 SecurityManager"></a>根对象 SecurityManager</h1><p>Shiro 是从根对象 <code>SecurityManager</code> 进行身份验证和授权的；也就是<strong>所有操作都是自它开始的</strong>，这个对象是线程安全且真个应用只需要一个即可，因此 Shiro 提供了 <code>SecurityUtils</code> 让我们绑定它为全局的，方便后续操作。</p><p>因为 <strong>Shiro 的类都是 POJO 的</strong>，因此都很容易放到任何 IoC 容器管理。但是和一般的 IOC 容器的区别在于，Shiro 从根对象 <code>securityManager</code> 开始导航；Shiro 支持的依赖注入：public 空参构造器对象的创建、setter 依赖注入。</p><a id="more"></a><h2 id="纯-Java-代码写法"><a href="#纯-Java-代码写法" class="headerlink" title="纯 Java 代码写法"></a>纯 Java 代码写法</h2><pre><code class="java">// com.github.zhangkaitao.shiro.chapter4.NonConfigurationCreateTest@Testpublic void test() {    DefaultSecurityManager securityManager = new DefaultSecurityManager();    // 设置 authenticator    ModularRealmAuthenticator authenticator = new ModularRealmAuthenticator();    authenticator.setAuthenticationStrategy(new AtLeastOneSuccessfulStrategy());    securityManager.setAuthenticator(authenticator);    // 设置 authorizer    ModularRealmAuthorizer authorizer = new ModularRealmAuthorizer();    authorizer.setPermissionResolver(new WildcardPermissionResolver());    securityManager.setAuthorizer(authorizer);    // 设置 Realm    DruidDataSource ds = new DruidDataSource();    ds.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);    ds.setUrl(&quot;jdbc:mysql://localhost:3306/shiro&quot;);    ds.setUsername(&quot;root&quot;);    ds.setPassword(&quot;123456&quot;);    JdbcRealm jdbcRealm = new JdbcRealm();    jdbcRealm.setDataSource(ds);    jdbcRealm.setPermissionsLookupEnabled(true);    securityManager.setRealms(Arrays.asList((Realm) jdbcRealm));    // 将 SecurityManager 设置到 SecurityUtils 方便全局使用    SecurityUtils.setSecurityManager(securityManager);    Subject subject = SecurityUtils.getSubject();    UsernamePasswordToken token = new UsernamePasswordToken(&quot;zhang&quot;, &quot;123&quot;);    subject.login(token);    Assert.assertTrue(subject.isAuthenticated());}</code></pre><h2 id="等价的-INI-配置"><a href="#等价的-INI-配置" class="headerlink" title="等价的 INI 配置"></a>等价的 INI 配置</h2><pre><code class="ini">[main]; 覆盖默认的 securityManager; securityManager=org.apache.shiro.mgt.DefaultSecurityManager; authenticatorauthenticator=org.apache.shiro.authc.pam.ModularRealmAuthenticatorauthenticationStrategy=org.apache.shiro.authc.pam.AtLeastOneSuccessfulStrategyauthenticator.authenticationStrategy=$authenticationStrategysecurityManager.authenticator=$authenticator; authorizerauthorizer=org.apache.shiro.authz.ModularRealmAuthorizerpermissionResolver=org.apache.shiro.authz.permission.WildcardPermissionResolverauthorizer.permissionResolver=$permissionResolversecurityManager.authorizer=$authorizer; realmdataSource=com.alibaba.druid.pool.DruidDataSourcedataSource.driverClassName=com.mysql.jdbc.DriverdataSource.url=jdbc:mysql://localhost:3306/shirodataSource.username=rootdataSource.password=123456jdbcRealm=org.apache.shiro.realm.jdbc.JdbcRealmjdbcRealm.dataSource=$dataSourcejdbcRealm.permissionsLookupEnabled=truesecurityManager.realms=$jdbcRealm</code></pre><ol><li>对象名=全限定类名，相对于调用 public 无参构造器创建对象</li><li>对象名.属性名=值，相当于调用 setter 方法设置常量值</li><li>对象名.属性名=$对象引用，相当于调用 setter 方法设置对象引用</li></ol><p>测试代码</p><pre><code class="java">// com.github.zhangkaitao.shiro.chapter4.ConfigurationCreateTest@Testpublic void test() {    Factory&lt;org.apache.shiro.mgt.SecurityManager&gt; factory =            new IniSecurityManagerFactory(&quot;classpath:shiro-config.ini&quot;);    org.apache.shiro.mgt.SecurityManager securityManager = factory.getInstance();    // 将 SecurityManager 设置到 SecurityUtils 方便全局使用    SecurityUtils.setSecurityManager(securityManager);    Subject subject = SecurityUtils.getSubject();    UsernamePasswordToken token = new UsernamePasswordToken(&quot;zhang&quot;, &quot;123&quot;);    subject.login(token);    Assert.assertTrue(subject.isAuthenticated());}</code></pre><p>如上代码是从 Shiro INI 配置中获取相应的 securityManager 实例：</p><ol><li><p>默认情况先创建一个名字为 <code>securityManager</code>，类型为 <code>org.apache.shiro.mgt.DefaultSecurityManager</code> 的默认的 <code>SecurityManager</code>，如果想自定义，只需要在 ini 配置文件中指定 <code>securityManager= SecurityManager 实现类</code>即可，名字必须为 <code>securityManager</code>，它是起始的根；</p></li><li><p><code>IniSecurityManagerFactory</code> 是创建 <code>securityManager</code> 的工厂，其需要一个 ini 配置文件路径，其支持 <code>classpath:</code>（类路径）、 <code>file:</code>（文件系统）、 <code>url:</code>（网络）三种路径格式，默认是文件系统；</p></li><li><p>接着获取 <code>SecuriyManager</code> 实例，后续步骤和之前的一样。</p></li></ol><h1 id="INI-配置"><a href="#INI-配置" class="headerlink" title="INI 配置"></a>INI 配置</h1><p>ini 配置文件类似于 Java 中的 properties（key=value），不过提供了将 key/value 分类的特性，key 是每个部分不重复即可，而不是整个配置文件。如下是 INI 配置分类：</p><h2 id="main-部分"><a href="#main-部分" class="headerlink" title="[main] 部分"></a>[main] 部分</h2><pre><code class="ini">[main]; 提供了对根对象 securityManager 及其依赖的配置securityManager=org.apache.shiro.mgt.DefaultSecurityManager; ...securityManager.realms=$jdbcRealm; byte 数组 setter 注入; base64 byte[]authenticator.bytes=aGVsbG8=; 后边的覆盖前边的注入authenticator.bytes=0x68656c6c6f; hex byte[]authenticator.bytes=0x68656c6c6f; Array/Set/List setter 注入，多个之间通过 &quot;,&quot; 分割authenticator.array=1,2,3authenticator.set=$jdbcRealm,$jdbcRealm; Map setter 注入，即格式是：map=key:value,key:value，可以注入常量及引用值，常量的话都看作字符串（即使有泛型也不会自动造型）。authenticator.map=$jdbcRealm:$jdbcRealm,1:1,key:abc</code></pre><h2 id="其他部分"><a href="#其他部分" class="headerlink" title="其他部分"></a>其他部分</h2><pre><code class="ini">[users]; 提供了对用户/密码及其角色的配置，用户名=密码，角色 1，角色 2username=password,role1,role2[roles]; 提供了角色及权限之间关系的配置，角色=权限 1，权限 2role1=permission1,permission2[urls]; 用于 web，提供了对 web url 拦截相关的配置，url= 拦截器[参数]，拦截器/index.html = anon/admin/** = authc, roles[admin], perms[&quot;permission1&quot;]</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Shiro </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《跟我学Shiro》笔记03-授权</title>
      <link href="/2018/04/10/%E3%80%8A%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%E3%80%8B%E7%AC%94%E8%AE%B003-%E6%8E%88%E6%9D%83/"/>
      <url>/2018/04/10/%E3%80%8A%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%E3%80%8B%E7%AC%94%E8%AE%B003-%E6%8E%88%E6%9D%83/</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文地址：<a href="http://jinnianshilongnian.iteye.com/blog/2020017" target="_blank" rel="noopener">第三章 授权——《跟我学Shiro》</a><br>目录贴： <a href="http://jinnianshilongnian.iteye.com/blog/2018398" target="_blank" rel="noopener">跟我学Shiro目录贴</a><br>源码：<a href="https://github.com/zhangkaitao/shiro-example" target="_blank" rel="noopener">https://github.com/zhangkaitao/shiro-example</a></p></blockquote><h1 id="授权-访问控制"><a href="#授权-访问控制" class="headerlink" title="授权(访问控制)"></a>授权(访问控制)</h1><p><strong>授权</strong>，也叫访问控制，即在应用中控制谁能访问哪些资源（如访问页面/编辑数据/页面操作等）。在授权中需了解的几个关键对象：主体（Subject）、资源（Resource）、权限（Permission）、角色（Role）。</p><ul><li><p><strong>主体</strong>，即访问应用的用户，在 Shiro 中使用 Subject 代表该用户。用户只有授权后才允许访问相应的资源。</p></li><li><p><strong>资源</strong>，在应用中用户可以访问的任何东西，比如访问 JSP 页面、查看/编辑某些数据、访问某个业务方法、打印文本等等都是资源。用户只要授权后才能访问。</p></li><li><p><strong>权限</strong>，安全策略中的原子授权单位，通过权限我们可以表示在应用中用户有没有操作某个资源的权力。即权限表示在应用中用户能不能访问某个资源，如：查看/新增/修改/删除用户数据（即很多时候都是 CRUD（增查改删）式权限控制）</p></li></ul><a id="more"></a><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><p><strong>角色</strong>代表了操作集合，可以理解为权限的集合，一般情况下我们会赋予用户角色而不是权限，即这样用户可以拥有一组权限，赋予权限时比较方便。典型的如：项目经理、技术总监、CTO、开发工程师等都是角色，不同的角色拥有一组不同的权限。</p><p><strong>隐式角色</strong>：即直接通过角色来验证用户有没有操作权限，如在应用中 CTO、技术总监、开发工程师可以使用打印机，假设某天不允许开发工程师使用打印机，此时需要从应用中删除相应代码；再如在应用中 CTO、技术总监可以查看用户、查看权限；突然有一天不允许技术总监查看用户、查看权限了，需要在相关代码中把技术总监角色从判断逻辑中删除掉；即粒度是以角色为单位进行访问控制的，粒度较粗；如果进行修改可能造成多处代码修改。</p><p><strong>显示角色</strong>：在程序中通过权限控制谁能访问某个资源，角色聚合一组权限集合；这样假设哪个角色不能访问某个资源，只需要从角色代表的权限集合中移除即可；无须修改多处代码；即粒度是以资源/实例为单位的；粒度较细。</p><h2 id="授权方式"><a href="#授权方式" class="headerlink" title="授权方式"></a>授权方式</h2><h3 id="编程式"><a href="#编程式" class="headerlink" title="编程式"></a>编程式</h3><p>通过写 <code>if/else</code> 授权代码块完成：</p><pre><code class="java">Subject subject = SecurityUtils.getSubject();if(subject.hasRole(&quot;admin&quot;)) {    //有权限} else {    //无权限}</code></pre><h3 id="注解式"><a href="#注解式" class="headerlink" title="注解式"></a>注解式</h3><p>通过在执行的 Java 方法上放置相应的注解完成，没有权限将抛出相应的异常：</p><pre><code class="java">@RequiresRoles(&quot;admin&quot;)public void hello() {    //有权限}</code></pre><h3 id="JSP-GSP-标签"><a href="#JSP-GSP-标签" class="headerlink" title="JSP/GSP 标签"></a>JSP/GSP 标签</h3><p>在 JSP/GSP 页面通过相应的标签完成：</p><pre><code class="jsp">&lt;shiro:hasRole name=&quot;admin&quot;&gt;&lt;!— 有权限 —&gt;&lt;/shiro:hasRole&gt;</code></pre><h2 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h2><h3 id="基于角色的访问控制（隐式角色）"><a href="#基于角色的访问控制（隐式角色）" class="headerlink" title="基于角色的访问控制（隐式角色）"></a>基于角色的访问控制（隐式角色）</h3><p>ini 配置文件（shiro-role.ini）</p><pre><code class="ini">[users]zhang=123,role1,role2wang=123,role1</code></pre><p>规则即：<strong><code>用户名=密码,角色1，角色2</code></strong>，如果需要在应用中判断用户是否有相应角色，就需要在相应的 Realm 中返回角色信息，也就是说 Shiro 不负责维护用户-角色信息，需要应用提供，Shiro 只是提供相应的接口方便验证，后续会介绍如何动态的获取用户角色。</p><h4 id="测试用例（隐式角色）"><a href="#测试用例（隐式角色）" class="headerlink" title="测试用例（隐式角色）"></a>测试用例（隐式角色）</h4><pre><code class="java">@Test(expected = UnauthorizedException.class)public void testHasRole() {    login(&quot;classpath:shiro-role.ini&quot;, &quot;zhang&quot;, &quot;123&quot;);    // 判断拥有角色：role1    Assert.assertTrue(subject().hasRole(&quot;role1&quot;));    // 判断拥有角色：role1 and role2    Assert.assertTrue(subject().hasAllRoles(Arrays.asList(&quot;role1&quot;, &quot;role2&quot;)));    // 判断拥有角色：role1 and role2 and !role3    boolean[] result = subject().hasRoles(Arrays.asList(&quot;role1&quot;, &quot;role2&quot;, &quot;role3&quot;));    Assert.assertEquals(true, result[0]);    Assert.assertEquals(true, result[1]);    Assert.assertEquals(false, result[2]);    // 断言拥有角色：role1    subject().checkRole(&quot;role1&quot;);    // 断言拥有角色：role1 and role3 失败抛出异常    subject().checkRoles(&quot;role1&quot;, &quot;role3&quot;);}</code></pre><h3 id="基于资源的访问控制（显示角色）"><a href="#基于资源的访问控制（显示角色）" class="headerlink" title="基于资源的访问控制（显示角色）"></a>基于资源的访问控制（显示角色）</h3><p>在 ini 配置文件配置用户拥有的角色及角色-权限关系（shiro-permission.ini）</p><pre><code class="ini">[users]zhang=123,role1,role2wang=123,role1[roles]; 对资源 user 拥有 create、update 权限role1=user:create,user:update; 对资源 user 拥有 create、delete 权限role2=user:create,user:delete</code></pre><p>规则：<code>用户名=密码，角色1，角色2</code>，<code>角色=权限1，权限2</code>，即首先根据用户名找到角色，然后根据角色再找到权限；即角色是权限集合；Shiro 同样不进行权限的维护，需要我们通过 Realm 返回相应的权限信息。只需要维护 <code>用户——角色</code> 之间的关系即可。</p><h4 id="测试用例（显示角色）"><a href="#测试用例（显示角色）" class="headerlink" title="测试用例（显示角色）"></a>测试用例（显示角色）</h4><pre><code class="java">// com.github.zhangkaitao.shiro.chapter3.PermissionTest@Test(expected = UnauthorizedException.class)public void testIsPermitted() {    login(&quot;classpath:shiro-permission.ini&quot;, &quot;zhang&quot;, &quot;123&quot;);    // 判断拥有权限：user:create    Assert.assertTrue(subject().isPermitted(&quot;user:create&quot;));    // 判断拥有权限：user:update and user:delete    Assert.assertTrue(subject().isPermittedAll(&quot;user:update&quot;, &quot;user:delete&quot;));    // 判断没有权限：user:view    Assert.assertFalse(subject().isPermitted(&quot;user:view&quot;));    // 断言拥有权限：user:create    subject().checkPermission(&quot;user:create&quot;);    // 断言拥有权限：user:delete and user:update    subject().checkPermissions(&quot;user:delete&quot;, &quot;user:update&quot;);    // 断言拥有权限：user:view 失败抛出异常    subject().checkPermissions(&quot;user:view&quot;);}</code></pre><h2 id="Permission"><a href="#Permission" class="headerlink" title="Permission"></a>Permission</h2><p><strong>字符串通配符权限</strong>，规则：<code>资源标识符:操作:对象实例ID</code>，即对哪个资源的哪个实例可以进行什么操作。其默认支持通配符权限字符串，<code>:</code> 表示资源/操作/实例的分割； <code>,</code> 表示操作的分割； <code>*</code> 表示任意资源/操作/实例。</p><h3 id="单个资源权限"><a href="#单个资源权限" class="headerlink" title="单个资源权限"></a>单个资源权限</h3><pre><code class="java">// 单个资源单个权限// role3=system:user:updatesubject().checkPermissions(&quot;system:user:update&quot;); // 用户拥有资源&quot;system:user&quot;的&quot;update&quot;权限// 单个资源多个权限// role41=system:user:update,system:user:deletesubject().checkPermissions(&quot;system:user:update&quot;, &quot;system:user:delete&quot;);// 如上可以简写成：// role42=&quot;system:user:update,delete&quot;subject().checkPermissions(&quot;system:user:update,delete&quot;);// 通过 &quot;system:user:update,delete&quot; 验证 &quot;system:user:update, system:user:delete&quot; 是没问题的，但是反过来是规则不成立。// 单个资源全部权限// role51=&quot;system:user:create,update,delete,view&quot;subject().checkPermissions(&quot;system:user:create,delete,update,view&quot;);// 如上可以简写成// role52=system:user:* (推荐)// role53=system:user (简写)subject().checkPermissions(&quot;system:user:*&quot;);subject().checkPermissions(&quot;system:user&quot;);// 通过 &quot;system:user:*&quot; 验证 &quot;system:user:create,delete,update:view&quot; 可以，但是反过来是不成立的。</code></pre><p>通过 <code>system:user:update,delete</code> 验证 <code>system:user:update,system:user:delete</code> 是没问题的，但是反过来是规则不成立。</p><pre><code class="java">// role41=system:user:update,system:user:deletesubject().checkPermissions(&quot;system:user:update&quot;, &quot;system:user:delete&quot;);subject().checkPermissions(&quot;system:user:update,delete&quot;); // 报错</code></pre><h3 id="所有资源全部权限"><a href="#所有资源全部权限" class="headerlink" title="所有资源全部权限"></a>所有资源全部权限</h3><pre><code class="java">// role61=*:viewsubject().checkPermissions(&quot;user:view&quot;);</code></pre><p>用户拥有所有资源的 <code>view</code> 所有权限。假设判断的权限是 <code>system:user:view</code>，那么<strong>需要 <code>role5=*:*:view</code> 这样写才行</strong>。</p><h3 id="实例级别的权限"><a href="#实例级别的权限" class="headerlink" title="实例级别的权限"></a>实例级别的权限</h3><pre><code class="java">// 单个实例单个权限// role71=user:view:1  // 对资源 user 的 1 实例拥有 view 权限subject().checkPermissions(&quot;user:view:1&quot;);// 单个实例多个权限// role72=&quot;user:update,delete:1&quot; // 对资源 user 的 1 实例拥有 update、delete 权限subject().checkPermissions(&quot;user:delete,update:1&quot;);subject().checkPermissions(&quot;user:update:1&quot;, &quot;user:delete:1&quot;);// 单个实例所有权限// role73=user:*:1 // 对资源 user 的 1 实例拥有所有权限subject().checkPermissions(&quot;user:update:1&quot;, &quot;user:delete:1&quot;, &quot;user:view:1&quot;);// 所有实例单个权限// role74=user:auth:* // 对资源 user 的所有实例拥有 auth 权限subject().checkPermissions(&quot;user:auth:1&quot;, &quot;user:auth:2&quot;);// 所有实例所有权限// role75=user:*:* // 对资源 user 的所有实例拥有所有权限subject().checkPermissions(&quot;user:view:1&quot;, &quot;user:auth:2&quot;);</code></pre><h3 id="Shiro-对权限字符串缺失部分的处理"><a href="#Shiro-对权限字符串缺失部分的处理" class="headerlink" title="Shiro 对权限字符串缺失部分的处理"></a>Shiro 对权限字符串缺失部分的处理</h3><p>如 <code>user:view</code> 等价于 <code>user:view:*</code>；而 <code>organization</code> 等价于 <code>organization:*</code> 或者 <code>organization:*:*</code>。可以这么理解，这种方式实现了前缀匹配。</p><p>另外如 <code>user:*</code> 可以匹配如 <code>user:delete</code> 、 <code>user:delete</code> 可以匹配如 <code>user:delete:1</code>、<code>user:*:1</code> 可以匹配如 <code>user:view:1</code>、<code>user</code> 可以匹配 <code>user:view</code> 或 <code>user:view:1</code> 等。即 <code>*</code> 可以匹配所有，不加 <code>*</code> 可以进行前缀匹配；但是如 <code>*:view</code> 不能匹配 <code>system:user:view</code> ，需要使用 <code>*:*:view</code> ，即<strong>后缀匹配必须指定前缀（多个冒号就需要多个 <code>*</code> 来匹配）</strong>。</p><h3 id="WildcardPermission"><a href="#WildcardPermission" class="headerlink" title="WildcardPermission"></a>WildcardPermission</h3><pre><code class="java">// 如下两种方式是等价的subject().checkPermission(&quot;menu:view:1&quot;);subject().checkPermission(new WildcardPermission(&quot;menu:view:1&quot;));</code></pre><h2 id="授权流程"><a href="#授权流程" class="headerlink" title="授权流程"></a>授权流程</h2><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20180409142920.png" alt="授权流程"></p><ol><li>首先调用 <code>Subject.isPermitted*/hasRole*</code> 接口，其会委托给 <code>SecurityManager</code>，而 <code>SecurityManager</code> 接着会委托给 <code>Authorizer</code>；</li><li><code>Authorizer</code> 是真正的授权者，如果我们调用如 <code>isPermitted(&quot;user:view&quot;)</code>，其首先会通过 <code>PermissionResolver</code> 把字符串转换成相应的 <code>Permission</code> 实例；</li><li>在进行授权之前，其会调用相应的 <code>Realm</code> 获取 <code>Subject</code> 相应的角色/权限用于匹配传入的角色/权限；</li><li><code>Authorizer</code> 会判断 <code>Realm</code> 的角色/权限是否和传入的匹配，如果有多个 <code>Realm</code>，会委托给 <code>ModularRealmAuthorizer</code> 进行循环判断，如果匹配如 <code>isPermitted*/hasRole*</code> 会返回 <code>true</code>，否则返回 <code>false</code> 表示授权失败。</li></ol><p><code>ModularRealmAuthorizer</code> 进行多 <code>Realm</code> 匹配流程：</p><ol><li>首先检查相应的 <code>Realm</code> 是否实现了实现了 <code>Authorizer</code>；</li><li>如果实现了 <code>Authorizer</code>，那么接着调用其相应的 <code>isPermitted*/hasRole*</code> 接口进行匹配；</li><li>如果有一个 <code>Realm</code> 匹配那么将返回 <code>true</code>，否则返回 <code>false</code>。</li></ol><p>如果 <code>Realm</code> 进行授权的话，应该继承 <code>AuthorizingRealm</code>，其流程是：</p><ol><li>如果调用 <code>hasRole*</code>，则直接获取 <code>AuthorizationInfo.getRoles()</code> 与传入的角色比较即可；</li><li>首先如果调用如 <code>isPermitted(&quot;user:view&quot;)</code>，首先通过 <code>PermissionResolver</code> 将权限字符串转换成相应的 <code>Permission</code> 实例，默认使用 <code>WildcardPermissionResolver</code>，即转换为通配符的 <code>WildcardPermission</code>；</li><li>通过 <code>AuthorizationInfo.getObjectPermissions()</code> 得到 <code>Permission</code> 实例集合；通过 <code>AuthorizationInfo. getStringPermissions()</code> 得到字符串集合并通过 <code>PermissionResolver</code> 解析为 <code>Permission</code> 实例；然后获取用户的角色，并通过 <code>RolePermissionResolver</code> 解析角色对应的权限集合（默认没有实现，可以自己提供）；</li><li>接着调用 <code>Permission.implies(Permission p)</code> 逐个与传入的权限比较，如果有匹配的则返回 <code>true</code>，否则 <code>false</code>。</li></ol><h2 id="Authorizer、PermissionResolver-及-RolePermissionResolver"><a href="#Authorizer、PermissionResolver-及-RolePermissionResolver" class="headerlink" title="Authorizer、PermissionResolver 及 RolePermissionResolver"></a>Authorizer、PermissionResolver 及 RolePermissionResolver</h2><p><code>Authorizer</code> 的职责是进行授权（访问控制），是 Shiro API 中授权核心的入口点，其提供了相应的角色/权限判断接口，具体请参考其 Javadoc。</p><p><code>SecurityManager</code> 继承了 <code>Authorizer</code> 接口，且提供了 <code>ModularRealmAuthorizer</code> 用于多 <code>Realm</code> 时的授权匹配。</p><p><code>PermissionResolver</code> 用于解析权限字符串到 <code>Permission</code> 实例。</p><p><code>RolePermissionResolver</code> 用于根据角色解析相应的权限集合。</p><h3 id="更改-Authorizer-实现"><a href="#更改-Authorizer-实现" class="headerlink" title="更改 Authorizer 实现"></a>更改 <code>Authorizer</code> 实现</h3><p>我们可以通过如下 ini 配置更改 <code>Authorizer</code> 实现：</p><p>对于 <code>ModularRealmAuthorizer</code>，相应的 <code>AuthorizingSecurityManager</code> 会在初始化完成后自动将相应的 <code>realm</code> 设置进去，我们也可以通过调用其 <code>setRealms()</code> 方法进行设置。对于实现自己的 <code>authorizer</code> 可以参考 <code>ModularRealmAuthorizer</code> 实现即可，在此就不提供示例了。</p><h4 id="ini-配置更改"><a href="#ini-配置更改" class="headerlink" title="ini 配置更改"></a>ini 配置更改</h4><pre><code class="ini">[main]; 自定义 authorizerauthorizer=org.apache.shiro.authz.ModularRealmAuthorizer; 自定义 permissionResolver; 设置 ModularRealmAuthorizer 的 permissionResolver，其会自动设置到相应的 Realm 上（其实现了 PermissionResolverAware 接口）; permissionResolver=org.apache.shiro.authz.permission.WildcardPermissionResolverpermissionResolver=com.github.zhangkaitao.shiro.chapter3.permission.BitAndWildPermissionResolverauthorizer.permissionResolver=$permissionResolver; 自定义 rolePermissionResolver; 设置 ModularRealmAuthorizer 的 rolePermissionResolver，其会自动设置到相应的 Realm 上（其实现了 RolePermissionResolverAware 接口）rolePermissionResolver=com.github.zhangkaitao.shiro.chapter3.permission.MyRolePermissionResolverauthorizer.rolePermissionResolver=$rolePermissionResolversecurityManager.authorizer=$authorizer; 自定义 realm 一定要放在 securityManager.authorizer 赋值之后（因为调用 setRealms 会将 realms 设置给 authorizer，; 并给各个 Realm 设置 permissionResolver 和 rolePermissionResolver）realm=com.github.zhangkaitao.shiro.chapter3.realm.MyRealmsecurityManager.realms=$realm</code></pre><p>设置 <code>securityManager</code> 的 <code>realms</code> 一定要放到最后，因为在调用 <code>SecurityManager.setRealms</code> 时会将 <code>realms</code> 设置给 <code>authorizer</code>，并为各个 <code>Realm</code> 设置 <code>permissionResolver</code> 和 <code>rolePermissionResolver</code>。另外，不能使用 <code>IniSecurityManagerFactory</code> 创建的 <code>IniRealm</code>，因为其初始化顺序的问题可能造成后续的初始化 <code>Permission</code> 造成影响。</p><h4 id="定义-BitAndWildPermissionResolver-及-BitPermission"><a href="#定义-BitAndWildPermissionResolver-及-BitPermission" class="headerlink" title="定义 BitAndWildPermissionResolver 及 BitPermission"></a>定义 BitAndWildPermissionResolver 及 BitPermission</h4><p><code>BitPermission</code> 用于实现位移方式的权限，如规则是：</p><p>权限字符串格式：<strong><code>+资源字符串+权限位+实例ID</code></strong>；以 <code>+</code> 开头中间通过 <code>+</code> 分割；权限：<code>0</code> 表示所有权限；<code>1</code> 新增（二进制：0001）、<code>2</code> 修改（二进制：0010）、<code>4</code> 删除（二进制：0100）、<code>8</code> 查看（二进制：1000）；如 <code>+user+10</code> 表示对资源 user 拥有修改/查看权限。</p><pre><code class="java">public class BitPermission implements Permission {    private String resourceIdentify;    private int permissionBit;    private String instanceId;    public BitPermission(String permissionString) {        String[] array = permissionString.split(&quot;\\+&quot;);        if(array.length &gt; 1) {            resourceIdentify = array[1];        }        if(StringUtils.isEmpty(resourceIdentify)) {            resourceIdentify = &quot;*&quot;;        }        if(array.length &gt; 2) {            permissionBit = Integer.valueOf(array[2]);        }        if(array.length &gt; 3) {            instanceId = array[3];        }        if(StringUtils.isEmpty(instanceId)) {            instanceId = &quot;*&quot;;        }    }    @Override    public boolean implies(Permission p) {        if(!(p instanceof BitPermission)) {            return false;        }        BitPermission other = (BitPermission) p;        if(!(&quot;*&quot;.equals(this.resourceIdentify) || this.resourceIdentify.equals(other.resourceIdentify))) {            return false;        }        if(!(this.permissionBit ==0 || (this.permissionBit &amp; other.permissionBit) != 0)) {            return false;        }        if(!(&quot;*&quot;.equals(this.instanceId) || this.instanceId.equals(other.instanceId))) {            return false;        }        return true;    }    @Override    public String toString() {        return &quot;BitPermission{&quot; +                &quot;resourceIdentify=&#39;&quot; + resourceIdentify + &#39;\&#39;&#39; +                &quot;, permissionBit=&quot; + permissionBit +                &quot;, instanceId=&#39;&quot; + instanceId + &#39;\&#39;&#39; +                &#39;}&#39;;    }}</code></pre><p><code>Permission</code> 接口提供了 <code>boolean implies(Permission p)</code> 方法用于判断权限匹配的；</p><pre><code class="java">public class BitAndWildPermissionResolver implements PermissionResolver {    @Override    public Permission resolvePermission(String permissionString) {        if(permissionString.startsWith(&quot;+&quot;)) {            return new BitPermission(permissionString);        }        return new WildcardPermission(permissionString);    }}</code></pre><p><code>BitAndWildPermissionResolver</code> 实现了 <code>PermissionResolver</code> 接口，并根据权限字符串是否以 <code>+</code> 开头来解析权限字符串为 <code>BitPermission</code> 或 <code>WildcardPermission</code>。</p><h4 id="定义-MyRolePermissionResolver"><a href="#定义-MyRolePermissionResolver" class="headerlink" title="定义 MyRolePermissionResolver"></a>定义 MyRolePermissionResolver</h4><p><code>RolePermissionResolver</code> 用于根据角色字符串来解析得到权限集合。</p><pre><code class="java">public class MyRolePermissionResolver implements RolePermissionResolver {    @Override    public Collection&lt;Permission&gt; resolvePermissionsInRole(String roleString) {        if(&quot;role1&quot;.equals(roleString)) {            return Arrays.asList((Permission)new WildcardPermission(&quot;menu:*&quot;));        }        return null;    }}</code></pre><p>此处的实现很简单，如果用户拥有 role1，那么就返回一个 <code>menu:*</code> 的权限。</p><h4 id="自定义-Realm"><a href="#自定义-Realm" class="headerlink" title="自定义 Realm"></a>自定义 Realm</h4><pre><code class="java">public class MyRealm extends AuthorizingRealm {    // 表示根据用户身份获取授权信息    @Override    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {        SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo();        authorizationInfo.addRole(&quot;role1&quot;);        authorizationInfo.addRole(&quot;role2&quot;);        authorizationInfo.addObjectPermission(new BitPermission(&quot;+user1+10&quot;));        authorizationInfo.addObjectPermission(new WildcardPermission(&quot;user1:*&quot;));        authorizationInfo.addStringPermission(&quot;+user2+10&quot;);        authorizationInfo.addStringPermission(&quot;user2:*&quot;);        return authorizationInfo;    }    // 表示获取身份验证信息    @Override    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {        String username = (String)token.getPrincipal();  // 得到用户名        String password = new String((char[])token.getCredentials()); // 得到密码        if(!&quot;zhang&quot;.equals(username)) {            throw new UnknownAccountException(); // 如果用户名错误        }        if(!&quot;123&quot;.equals(password)) {            throw new IncorrectCredentialsException(); // 如果密码错误        }        // 如果身份认证验证成功，返回一个 AuthenticationInfo 实现；        return new SimpleAuthenticationInfo(username, password, getName());    }}</code></pre><p>另外我们还可以使用 <code>JdbcRealm</code>，需要设置 <code>jdbcRealm.permissionsLookupEnabled</code> 为 <code>true</code> 来开启权限查询。</p><p>此次还要注意就是不能把我们自定义的如 <code>+user1+10</code> 配置到 ini 配置文件，即使有 <code>IniRealm</code> 完成，因为 <code>IniRealm</code> 在 new 完成后就会解析这些权限字符串，默认使用了 <code>WildcardPermissionResolver</code> 完成，即此处是一个设计权限，如果采用生命周期（如使用初始化方法）的方式进行加载就可以解决我们自定义 <code>permissionResolver</code> 的问题。</p><h4 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h4><pre><code class="java">@Testpublic void testIsPermitted() {    login(&quot;classpath:shiro-authorizer.ini&quot;, &quot;zhang&quot;, &quot;123&quot;);    // 判断拥有权限：user:create    Assert.assertTrue(subject().isPermitted(&quot;user1:update&quot;));    Assert.assertTrue(subject().isPermitted(&quot;user1:update&quot;));    // 通过二进制位的方式表示权限    Assert.assertTrue(subject().isPermitted(&quot;+user1+2&quot;)); // 新增权限    Assert.assertTrue(subject().isPermitted(&quot;+user1+8&quot;)); // 查看权限    Assert.assertTrue(subject().isPermitted(&quot;+user2+10&quot;)); // 新增及查看    Assert.assertFalse(subject().isPermitted(&quot;+user1+4&quot;)); // 没有删除权限    Assert.assertTrue(subject().isPermitted(&quot;menu:view&quot;)); // 通过MyRolePermissionResolver解析得到的权限}</code></pre><p>通过如上步骤可以实现自定义权限验证了。另外因为不支持 <code>hasAnyRole/isPermittedAny</code> 这种方式的授权，可以参考一篇<a href="http://jinnianshilongnian.iteye.com/blog/1864800" target="_blank" rel="noopener">《简单 shiro 扩展实现 NOT、AND、OR 权限验证 》</a>进行简单的扩展完成这个需求，在这篇文章中通过重写 <code>AuthorizingRealm</code> 里的验证逻辑实现的。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Shiro </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《跟我学Shiro》笔记02-身份验证</title>
      <link href="/2018/04/09/%E3%80%8A%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%E3%80%8B%E7%AC%94%E8%AE%B002-%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81/"/>
      <url>/2018/04/09/%E3%80%8A%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%E3%80%8B%E7%AC%94%E8%AE%B002-%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81/</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文地址：<a href="http://jinnianshilongnian.iteye.com/blog/2019547" target="_blank" rel="noopener">第二章 身份验证——《跟我学Shiro》</a><br>目录贴： <a href="http://jinnianshilongnian.iteye.com/blog/2018398" target="_blank" rel="noopener">跟我学Shiro目录贴</a><br>源码：<a href="https://github.com/zhangkaitao/shiro-example" target="_blank" rel="noopener">https://github.com/zhangkaitao/shiro-example</a></p></blockquote><h1 id="身份验证"><a href="#身份验证" class="headerlink" title="身份验证"></a>身份验证</h1><p><strong>身份验证</strong>，即在应用中谁能证明他就是他本人。一般提供如他们的身份ID一些标识信息来表明他就是他本人，如提供身份证，用户名/密码来证明。</p><p>在 shiro 中，用户需要提供 principals（身份）和 credentials（证明）给 shiro，从而应用能验证用户身份：</p><p><strong><code>principals</code></strong>：身份，即主体的标识属性，可以是任何东西，如用户名、邮箱等，唯一即可。一个主体可以有多个principals，但只有一个 Primary principals，一般是用户名/密码/手机号。</p><p><strong><code>credentials</code></strong>：证明/凭证，即只有主体知道的安全值，如密码/数字证书等。</p><p>最常见的 <code>principals</code> 和 <code>credentials</code> 组合就是<strong>用户名/密码</strong>了。接下来先进行一个基本的身份认证。</p><p>另外两个相关的概念是之前提到的 <strong><code>Subject</code></strong> 及 <strong><code>Realm</code></strong>，分别是主体及验证主体的数据源。</p><a id="more"></a><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><pre><code class="xml">&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;junit&lt;/groupId&gt;        &lt;artifactId&gt;junit&lt;/artifactId&gt;        &lt;version&gt;4.9&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;commons-logging&lt;/groupId&gt;        &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;        &lt;version&gt;1.1.3&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;        &lt;artifactId&gt;shiro-core&lt;/artifactId&gt;        &lt;version&gt;1.2.2&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><h1 id="登录-退出"><a href="#登录-退出" class="headerlink" title="登录/退出"></a>登录/退出</h1><p>1、首先准备一些用户身份/凭据（<code>shiro.ini</code>）</p><pre><code class="ini">[users]zhang=123wang=123</code></pre><p>此处使用 ini 配置文件，通过 <code>[users]</code> <strong>指定了两个主体</strong>：zhang/123、wang/123。</p><p>2、测试用例（com.github.zhangkaitao.shiro.chapter2.LoginLogoutTest）</p><pre><code class="java">@Testpublic void testHelloworld() {    // 1、获取 SecurityManager 工厂，此处使用 Ini 配置文件初始化 SecurityManager    Factory&lt;org.apache.shiro.mgt.SecurityManager&gt; factory =            new IniSecurityManagerFactory(&quot;classpath:shiro.ini&quot;);    // 2、得到 SecurityManager 实例 并绑定给 SecurityUtils，这是一个全局设置，设置一次即可    org.apache.shiro.mgt.SecurityManager securityManager = factory.getInstance();    SecurityUtils.setSecurityManager(securityManager);    // 3、通过 SecurityUtils 得到 Subject，其会自动绑定到当前线程；如果在 web 环境在请求结束时需要解除绑定；    // 得到 Subject 及创建用户名/密码身份验证 Token（即用户身份/凭证）    Subject subject = SecurityUtils.getSubject();    UsernamePasswordToken token = new UsernamePasswordToken(&quot;zhang&quot;, &quot;123&quot;);    try {        // 4、调用 subject.login 方法进行登录，其会自动委托给 SecurityManager.login 方法进行登录，即身份验证        subject.login(token);    } catch (AuthenticationException e) {        // 5、身份验证失败        /*          如果身份验证失败请捕获AuthenticationException或其子类，常见的如：          DisabledAccountException（禁用的帐号）          LockedAccountException（锁定的帐号）          UnknownAccountException（错误的帐号）          ExcessiveAttemptsException（登录失败次数过多）          IncorrectCredentialsException （错误的凭证）          ExpiredCredentialsException（过期的凭证）          等，具体请查看其继承关系；        */    }    Assert.assertEquals(true, subject.isAuthenticated()); // 断言用户已经登录    // 6、退出，其会自动委托给SecurityManager.logout方法退出    subject.logout();}</code></pre><h1 id="身份认证流程"><a href="#身份认证流程" class="headerlink" title="身份认证流程"></a>身份认证流程</h1><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20180408202058.png" alt="身份认证流程"></p><p>流程如下：</p><ol><li><p>首先调用 <code>Subject.login(token)</code> 进行登录，其会自动委托给 <code>SecurityManager</code>，调用之前必须通过 <code>SecurityUtils.setSecurityManager()</code> 设置；</p></li><li><p><code>SecurityManager</code> 负责真正的身份验证逻辑；它会委托给 <code>Authenticator</code> 进行身份验证；</p></li><li><p><code>Authenticator</code> 才是真正的身份验证者，Shiro API 中核心的身份认证入口点，此处可以自定义插入自己的实现；</p></li><li><p><code>Authenticator</code> 可能会委托给相应的 <code>AuthenticationStrategy</code> 进行多 <code>Realm</code> 身份验证，默认 <code>ModularRealmAuthenticator</code> 会调用 <code>AuthenticationStrategy</code> 进行多 <code>Realm</code> 身份验证；</p></li><li><p><code>Authenticator</code> 会把相应的 <code>token</code> 传入 <code>Realm</code>，从 <code>Realm</code> 获取身份验证信息，如果没有返回/抛出异常表示身份验证失败了。此处可以配置多个 <code>Realm</code>，将按照相应的顺序及策略进行访问。</p></li></ol><h1 id="Realm"><a href="#Realm" class="headerlink" title="Realm"></a>Realm</h1><p><strong><code>Realm</code></strong>：域，Shiro 从 <code>Realm</code> 获取安全数据（如用户、角色、权限），就是说 <code>SecurityManager</code> 要验证用户身份，那么它需要从 <code>Realm</code> 获取相应的用户进行比较以确定用户身份是否合法；也需要从 <code>Realm</code> 得到用户相应的角色/权限进行验证用户是否能进行操作；可以把 <code>Realm</code> 看成 <code>DataSource</code>，即<strong>安全数据源</strong>。如我们之前的 ini 配置方式将使用 <code>org.apache.shiro.realm.text.IniRealm</code>。</p><h2 id="自定义Realm实现"><a href="#自定义Realm实现" class="headerlink" title="自定义Realm实现"></a>自定义Realm实现</h2><pre><code class="java">// com.github.zhangkaitao.shiro.chapter2.realm.MyRealm1public class MyRealm1 implements Realm {    // 返回一个唯一的 Realm 名字    @Override    public String getName() {        return &quot;myrealm1&quot;;    }    // 判断此 Realm 是否支持此 Token    @Override    public boolean supports(AuthenticationToken token) {        // 仅支持 UsernamePasswordToken 类型的 Token        return token instanceof UsernamePasswordToken;    }    // 根据 Token 获取认证信息    @Override    public AuthenticationInfo getAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {        String username = (String)token.getPrincipal();  // 得到用户名        String password = new String((char[])token.getCredentials()); // 得到密码        if(!&quot;zhang&quot;.equals(username)) {            throw new UnknownAccountException(); // 如果用户名错误        }        if(!&quot;123&quot;.equals(password)) {            throw new IncorrectCredentialsException(); // 如果密码错误        }        // 如果身份认证验证成功，返回一个 AuthenticationInfo 实现；        return new SimpleAuthenticationInfo(username, password, getName());    }}</code></pre><p><strong>ini 配置文件</strong>指定自定义 <code>Realm</code> 实现(shiro-realm.ini)</p><pre><code class="ini">[main]; 声明一个 realmmyRealm1=com.github.zhangkaitao.shiro.chapter2.realm.MyRealm1; 指定 securityManager 的 realms 实现，通过 $name 来引入之前的 realm 定义securityManager.realms=$myRealm1</code></pre><p>测试用例请参考 com.github.zhangkaitao.shiro.chapter2.LoginLogoutTest 的 testCustomRealm 测试方法，只需要把之前的 shiro.ini 配置文件改成 shiro-realm.ini 即可</p><h2 id="多-Realm-配置"><a href="#多-Realm-配置" class="headerlink" title="多 Realm 配置"></a>多 Realm 配置</h2><p>ini 配置文件（shiro-multi-realm.ini）</p><pre><code class="ini">[main]; 声明一个 realmmyRealm1=com.github.zhangkaitao.shiro.chapter2.realm.MyRealm1myRealm2=com.github.zhangkaitao.shiro.chapter2.realm.MyRealm2; 指定 securityManager 的 realms 实现securityManager.realms=$myRealm1,$myRealm2</code></pre><p><code>securityManager</code> 会按照 <code>realms</code> 指定的顺序进行身份认证。此处我们使用显示指定顺序的方式指定了 <code>Realm</code> 的顺序，如果删除 <code>securityManager.realms=$myRealm1,$myRealm2</code>，那么 <code>securityManager</code> 会按照 <code>realm</code> 声明的顺序进行使用 <strong>（即无需设置 realms 属性，其会自动发现）</strong>，当我们显示指定 <code>realm</code> 后，其他没有指定 <code>realm</code> 将被忽略，如<code>securityManager.realms=$myRealm1</code>，那么 <code>myRealm2</code> 不会被自动设置进去。</p><h2 id="Shiro-默认提供的-Realm"><a href="#Shiro-默认提供的-Realm" class="headerlink" title="Shiro 默认提供的 Realm"></a>Shiro 默认提供的 Realm</h2><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20180408203427.png" alt="Realm继承关系"></p><p>一般继承 <code>AuthorizingRealm</code>（授权）即可；其继承了 <code>AuthenticatingRealm</code>（即身份验证），而且也间接继承了 <code>CachingRealm</code>（带有缓存实现）。其中主要默认实现如下：</p><p><strong>org.apache.shiro.realm.text.IniRealm</strong>：<code>[users]</code> 部分指定用户名/密码及其角色；<code>[roles]</code> 部分指定角色即权限信息；</p><p><strong>org.apache.shiro.realm.text.PropertiesRealm</strong>： <code>user.username=password,role1,role2</code> 指定用户名/密码及其角色；<code>role.role1=permission1,permission2</code> 指定角色及权限信息；</p><p><strong>org.apache.shiro.realm.jdbc.JdbcRealm</strong>：通过 sql 查询相应的信息，如 <code>select password from users where username = ?</code> 获取用户密码， <code>select password, password_salt from users where username = ?</code> 获取用户密码及盐； <code>select role_name from user_roles where username = ?</code> 获取用户角色； <code>select permission from roles_permissions where role_name = ?</code> 获取角色对应的权限信息；也可以调用相应的 api 进行自定义 sql；</p><h2 id="JDBC-Realm-使用"><a href="#JDBC-Realm-使用" class="headerlink" title="JDBC Realm 使用"></a>JDBC Realm 使用</h2><p>本文将使用 mysql 数据库及 druid 连接池。</p><h3 id="maven-依赖"><a href="#maven-依赖" class="headerlink" title="maven 依赖"></a>maven 依赖</h3><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;    &lt;version&gt;5.1.25&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;druid&lt;/artifactId&gt;    &lt;version&gt;1.0.11&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="创建数据库表"><a href="#创建数据库表" class="headerlink" title="创建数据库表"></a>创建数据库表</h3><p>到数据库shiro下建三张表：users（用户名/密码）、user_roles（用户/角色）、roles_permissions（角色/权限），并添加一个用户记录，用户名/密码为zhang/123；</p><pre><code class="sql">drop database if exists shiro;create database shiro;use shiro;create table users (  id bigint auto_increment,  username varchar(100),  password varchar(128),  password_salt varchar(100),  constraint pk_users primary key(id)) charset=utf8 ENGINE=InnoDB;create unique index idx_users_username on users(username);create table user_roles(  id bigint auto_increment,  username varchar(100),  role_name varchar(100),  constraint pk_user_roles primary key(id)) charset=utf8 ENGINE=InnoDB;create unique index idx_user_roles on user_roles(username, role_name);create table roles_permissions(  id bigint auto_increment,  role_name varchar(100),  permission varchar(100),  constraint pk_roles_permissions primary key(id)) charset=utf8 ENGINE=InnoDB;create unique index idx_roles_permissions on roles_permissions(role_name, permission);insert into users(username,password)values(&#39;zhang&#39;,&#39;123&#39;);</code></pre><h3 id="ini-配置（shiro-jdbc-realm-ini）"><a href="#ini-配置（shiro-jdbc-realm-ini）" class="headerlink" title="ini 配置（shiro-jdbc-realm.ini）"></a>ini 配置（shiro-jdbc-realm.ini）</h3><pre><code class="ini">[main]jdbcRealm=org.apache.shiro.realm.jdbc.JdbcRealmdataSource=com.alibaba.druid.pool.DruidDataSourcedataSource.driverClassName=com.mysql.jdbc.DriverdataSource.url=jdbc:mysql://localhost:3306/shirodataSource.username=rootdataSource.password=123jdbcRealm.dataSource=$dataSourcesecurityManager.realms=$jdbcRealm</code></pre><ol><li><p><strong>变量名</strong>=全限定类名会自动创建一个类实例</p></li><li><p><strong>变量名.属性</strong>=值 自动调用相应的setter方法进行赋值</p></li><li><p><strong>$变量名</strong> 引用之前的一个对象实例</p></li><li><p>测试代码请参照 com.github.zhangkaitao.shiro.chapter2.LoginLogoutTest 的 testJDBCRealm 方法，和之前的没什么区别（只用修改 ini 配置文件）。</p></li></ol><h1 id="Authenticator-及-AuthenticationStrategy"><a href="#Authenticator-及-AuthenticationStrategy" class="headerlink" title="Authenticator 及 AuthenticationStrategy"></a>Authenticator 及 AuthenticationStrategy</h1><p>Authenticator 的职责是验证用户帐号，是 Shiro API 中身份验证核心的入口点：</p><pre><code class="java">public AuthenticationInfo authenticate(AuthenticationToken authenticationToken)            throws AuthenticationException;</code></pre><p>如果验证成功，将返回 <code>AuthenticationInfo</code> 验证信息；此信息中包含了身份及凭证；如果验证失败将抛出相应的 <code>AuthenticationException</code> 实现。</p><h2 id="AuthenticationStrategy-默认实现"><a href="#AuthenticationStrategy-默认实现" class="headerlink" title="AuthenticationStrategy 默认实现"></a>AuthenticationStrategy 默认实现</h2><p><code>SecurityManager</code> 接口继承了 <code>Authenticator</code>，另外还有一个 <code>ModularRealmAuthenticator</code> 实现，其委托给多个 <code>Realm</code> 进行验证，验证规则通过 <code>AuthenticationStrategy</code> 接口指定，默认提供的实现：</p><ul><li><p><strong><code>FirstSuccessfulStrategy</code></strong>：只要有一个 <code>Realm</code> 验证成功即可，只返回第一个 <code>Realm</code> 身份验证成功的认证信息，其他的忽略；</p></li><li><p><strong><code>AtLeastOneSuccessfulStrategy</code></strong>：只要有一个 <code>Realm</code> 验证成功即可，和 <code>FirstSuccessfulStrategy</code> 不同，返回所有 <code>Realm</code> 身份验证成功的认证信息；</p></li><li><p><strong><code>AllSuccessfulStrategy</code></strong>：所有 <code>Realm</code> 验证成功才算成功，且返回所有 <code>Realm</code> 身份验证成功的认证信息，如果有一个失败就失败了。</p></li></ul><p><code>ModularRealmAuthenticator</code> 默认使用 <code>AtLeastOneSuccessfulStrategy</code> 策略。</p><h2 id="测试-AuthenticationStrategy-默认实现"><a href="#测试-AuthenticationStrategy-默认实现" class="headerlink" title="测试 AuthenticationStrategy 默认实现"></a>测试 AuthenticationStrategy 默认实现</h2><h3 id="三个-realm"><a href="#三个-realm" class="headerlink" title="三个 realm"></a>三个 realm</h3><ul><li>myRealm1：用户名/密码为 zhang/123 时成功，且返回身份/凭据为 zhang/123；(代码见上文)</li><li>myRealm2：用户名/密码为 wang/123 时成功，且返回身份/凭据为 wang/123(代码将上文的 &#39;zhang&#39; 修改为 &#39;wang&#39;)；</li><li>myRealm3：用户名/密码为 zhang/123 时成功，且返回身份/凭据为 <a href="mailto:zhang@163.com" target="_blank" rel="noopener">zhang@163.com</a>/123，和 myRealm1 不同的是返回时的身份变了；</li></ul><pre><code class="java">// com.github.zhangkaitao.shiro.chapter2.realm.myRealm3public class MyRealm3 implements Realm {    @Override    public String getName() {        return &quot;myrealm3&quot;;    }    @Override    public boolean supports(AuthenticationToken token) {        return token instanceof UsernamePasswordToken; // 仅支持 UsernamePasswordToken 类型的 Token    }    @Override    public AuthenticationInfo getAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {        String username = (String)token.getPrincipal();  // 得到用户名        String password = new String((char[])token.getCredentials()); // 得到密码        if(!&quot;zhang&quot;.equals(username)) {            throw new UnknownAccountException(); // 如果用户名错误        }        if(!&quot;123&quot;.equals(password)) {            throw new IncorrectCredentialsException(); // 如果密码错误        }        // 如果身份认证验证成功，返回一个 AuthenticationInfo 实现；        return new SimpleAuthenticationInfo(username + &quot;@163.com&quot;, password, getName());    }}</code></pre><h3 id="ini-配置文件"><a href="#ini-配置文件" class="headerlink" title="ini 配置文件"></a>ini 配置文件</h3><p>shiro-authenticator-all-success.ini</p><pre><code class="ini">[main]; 指定 securityManager的authenticator 实现authenticator=org.apache.shiro.authc.pam.ModularRealmAuthenticatorsecurityManager.authenticator=$authenticator; 指定 securityManager.authenticator 的 authenticationStrategyallSuccessfulStrategy=org.apache.shiro.authc.pam.AllSuccessfulStrategysecurityManager.authenticator.authenticationStrategy=$allSuccessfulStrategymyRealm1=com.github.zhangkaitao.shiro.chapter2.realm.MyRealm1myRealm2=com.github.zhangkaitao.shiro.chapter2.realm.MyRealm2myRealm3=com.github.zhangkaitao.shiro.chapter2.realm.MyRealm3securityManager.realms=$myRealm1,$myRealm3; shiro-authenticator-all-fail.ini，这个修改 securityManager.realms; securityManager.realms=$myRealm1,$myRealm2</code></pre><h3 id="首先通用化登录逻辑"><a href="#首先通用化登录逻辑" class="headerlink" title="首先通用化登录逻辑"></a>首先通用化登录逻辑</h3><pre><code class="java">// com.github.zhangkaitao.shiro.chapter2.AuthenticatorTestprivate void login(String configFile) {    // 1、获取 SecurityManager 工厂，此处使用 Ini 配置文件初始化 SecurityManager    Factory&lt;org.apache.shiro.mgt.SecurityManager&gt; factory =            new IniSecurityManagerFactory(configFile);    // 2、得到 SecurityManager 实例 并绑定给 SecurityUtils    org.apache.shiro.mgt.SecurityManager securityManager = factory.getInstance();    SecurityUtils.setSecurityManager(securityManager);    // 3、得到 Subject 及创建用户名/密码身份验证 Token（即用户身份/凭证）    Subject subject = SecurityUtils.getSubject();    UsernamePasswordToken token = new UsernamePasswordToken(&quot;zhang&quot;, &quot;123&quot;);    subject.login(token);}</code></pre><h3 id="测试-AllSuccessfulStrategy-成功"><a href="#测试-AllSuccessfulStrategy-成功" class="headerlink" title="测试 AllSuccessfulStrategy 成功"></a>测试 AllSuccessfulStrategy 成功</h3><pre><code class="java">@Testpublic void testAllSuccessfulStrategyWithSuccess() {    login(&quot;classpath:shiro-authenticator-all-success.ini&quot;);    Subject subject = SecurityUtils.getSubject();    // 得到一个身份集合，其包含了 Realm 验证成功的身份信息    PrincipalCollection principalCollection = subject.getPrincipals();    Assert.assertEquals(2, principalCollection.asList().size());}@Afterpublic void tearDown() throws Exception {    ThreadContext.unbindSubject(); // 退出时请解除绑定 Subject 到线程 否则对下次测试造成影响}</code></pre><h3 id="测试-AllSuccessfulStrategy-失败"><a href="#测试-AllSuccessfulStrategy-失败" class="headerlink" title="测试 AllSuccessfulStrategy 失败"></a>测试 AllSuccessfulStrategy 失败</h3><pre><code class="java">@Test(expected = UnknownAccountException.class)public void testAllSuccessfulStrategyWithFail() {    login(&quot;classpath:shiro-authenticator-all-fail.ini&quot;);}</code></pre><h3 id="测试-AtLeastOneSuccessfulStrategy-成功"><a href="#测试-AtLeastOneSuccessfulStrategy-成功" class="headerlink" title="测试 AtLeastOneSuccessfulStrategy 成功"></a>测试 AtLeastOneSuccessfulStrategy 成功</h3><pre><code class="ini">; 修改上文 ini 配置文件中allSuccessfulStrategy=org.apache.shiro.authc.pam.AtLeastOneSuccessfulStrategysecurityManager.realms=$myRealm1,$myRealm2,$myRealm3</code></pre><pre><code class="java">@Testpublic void testAtLeastOneSuccessfulStrategyWithSuccess() {    login(&quot;classpath:shiro-authenticator-atLeastOne-success.ini&quot;);    Subject subject = SecurityUtils.getSubject();    // 得到一个身份集合，其包含了所有 Realm 验证成功的身份信息    PrincipalCollection principalCollection = subject.getPrincipals();    Assert.assertEquals(2, principalCollection.asList().size());}</code></pre><h3 id="测试-FirstSuccessfulStrategy-成功"><a href="#测试-FirstSuccessfulStrategy-成功" class="headerlink" title="测试 FirstSuccessfulStrategy 成功"></a>测试 FirstSuccessfulStrategy 成功</h3><pre><code class="ini">; 修改上文 ini 配置文件中allSuccessfulStrategy=org.apache.shiro.authc.pam.FirstSuccessfulStrategysecurityManager.realms=$myRealm1,$myRealm2,$myRealm3</code></pre><pre><code class="java">@Testpublic void testFirstOneSuccessfulStrategyWithSuccess() {    login(&quot;classpath:shiro-authenticator-first-success.ini&quot;);    Subject subject = SecurityUtils.getSubject();    // 得到一个身份集合，其包含了第一个 Realm 验证成功的身份信息    PrincipalCollection principalCollection = subject.getPrincipals();    Assert.assertEquals(1, principalCollection.asList().size());}</code></pre><h2 id="自定义-AuthenticationStrategy-实现"><a href="#自定义-AuthenticationStrategy-实现" class="headerlink" title="自定义 AuthenticationStrategy 实现"></a>自定义 AuthenticationStrategy 实现</h2><p>自定义实现时一般继承 <code>org.apache.shiro.authc.pam.AbstractAuthenticationStrategy</code> 即可。</p><p>只能有一个 Realm 验证成功</p><pre><code class="java">// com.github.zhangkaitao.shiro.chapter2.authenticator.strategy.OnlyOneAuthenticatorStrategypublic class OnlyOneAuthenticatorStrategy extends AbstractAuthenticationStrategy {    // 在所有 Realm 验证之前调用    @Override    public AuthenticationInfo beforeAllAttempts(Collection&lt;? extends Realm&gt; realms, AuthenticationToken token) throws AuthenticationException {        return new SimpleAuthenticationInfo(); // 返回一个权限的认证信息    }    // 在每个 Realm 之前调用    @Override    public AuthenticationInfo beforeAttempt(Realm realm, AuthenticationToken token, AuthenticationInfo aggregate) throws AuthenticationException {        return aggregate; // 返回之前合并的    }    // 在每个 Realm 之后调用    @Override    public AuthenticationInfo afterAttempt(Realm realm, AuthenticationToken token, AuthenticationInfo singleRealmInfo, AuthenticationInfo aggregateInfo, Throwable t) throws AuthenticationException {        AuthenticationInfo info;        if (singleRealmInfo == null) {            info = aggregateInfo;        } else {            if (aggregateInfo == null) {                info = singleRealmInfo;            } else {                info = merge(singleRealmInfo, aggregateInfo); // 合并                if(info.getPrincipals().getRealmNames().size() &gt; 1) {                    System.out.println(info.getPrincipals().getRealmNames());                    throw new AuthenticationException(&quot;Authentication token of type [&quot; + token.getClass() + &quot;] &quot; +                            &quot;could not be authenticated by any configured realms.  Please ensure that only one realm can &quot; +                            &quot;authenticate these tokens.&quot;);                }            }        }        return info;    }    // 在所有 Realm 之后调用    @Override    public AuthenticationInfo afterAllAttempts(AuthenticationToken token, AuthenticationInfo aggregate) throws AuthenticationException {        return aggregate;    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Shiro </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《跟我学Shiro》笔记01-Shiro简介</title>
      <link href="/2018/04/09/%E3%80%8A%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%E3%80%8B%E7%AC%94%E8%AE%B001-Shiro%E7%AE%80%E4%BB%8B/"/>
      <url>/2018/04/09/%E3%80%8A%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%E3%80%8B%E7%AC%94%E8%AE%B001-Shiro%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文地址：<a href="http://jinnianshilongnian.iteye.com/blog/2018936" target="_blank" rel="noopener">第一章 Shiro简介——《跟我学Shiro》</a><br>目录贴： <a href="http://jinnianshilongnian.iteye.com/blog/2018398" target="_blank" rel="noopener">跟我学Shiro目录贴</a><br>源码：<a href="https://github.com/zhangkaitao/shiro-example" target="_blank" rel="noopener">https://github.com/zhangkaitao/shiro-example</a></p></blockquote><h1 id="Shiro-简介"><a href="#Shiro-简介" class="headerlink" title="Shiro 简介"></a>Shiro 简介</h1><p><code>Shiro</code> 可以帮助我们完成：认证、授权、加密、会话管理、与 Web 集成、缓存等。这不就是我们想要的嘛，而且 <code>Shiro</code> 的 <code>API</code> 也是非常简单；其基本功能点如下图所示：</p><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20180408192549.png" alt="Shiro基本功能点"></p><ul><li><code>Authentication</code> ：身份认证/登录，验证用户是不是拥有相应的身份；</li><li><code>Authorization：</code> ：授权，即权限验证，验证某个已认证的用户是否拥有某个权限；即判断用户是否能做事情，常见的如：验证某个用户是否拥有某个角色。或者细粒度的验证某个用户对某个资源是否具有某个权限；</li><li><code>Session Manager</code>：会话管理，即用户登录后就是一次会话，在没有退出之前，它的所有信息都在会话中；会话可以是普通 JavaSE 环境的，也可以是如 Web 环境的；</li><li><code>Cryptography</code>：加密，保护数据的安全性，如密码加密存储到数据库，而不是明文存储；</li><li><code>Web Support</code>：Web 支持，可以非常容易的集成到 Web 环境；</li><li><code>Caching</code>：缓存，比如用户登录后，其用户信息、拥有的角色/权限不必每次去查，这样可以提高效率；</li><li><code>Concurrency</code>：shiro 支持多线程应用的并发验证，即如在一个线程中开启另一个线程，能把权限自动传播过去；</li><li><code>Testing</code>：提供测试支持；</li><li><code>Run As</code>：允许一个用户假装为另一个用户（如果他们允许）的身份进行访问；</li><li><code>Remember Me</code>：记住我，这个是非常常见的功能，即一次登录后，下次再来的话不用登录了。</li></ul><p><strong>记住一点，<code>Shiro</code> 不会去维护用户、维护权限；这些需要我们自己去设计/提供；然后通过相应的接口注入给 <code>Shiro</code> 即可。</strong></p><a id="more"></a><p>从应用程序角度的来观察如何使用 <code>Shiro</code> 完成工作。如下图：</p><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20180408194816.png" alt="Shiro外部架构"></p><p>可以看到：应用代码直接交互的对象是 <code>Subject</code>，也就是说 <code>Shiro</code> 的对外 API 核心就是 <code>Subject</code>；<br>其每个 API 的含义：</p><ul><li><strong><code>Subject</code></strong>：主体，代表了当前“用户”，这个用户不一定是一个具体的人，与当前应用交互的任何东西都是 <code>Subject</code>，如网络爬虫，机器人等；即一个抽象概念；所有 <code>Subject</code> 都绑定到 <code>SecurityManager</code>，与 <code>Subject</code> 的所有交互都会委托给 <code>SecurityManager</code>；可以把 <code>Subject</code> 认为是一个门面；<code>SecurityManager</code> 才是实际的执行者；</li><li><strong><code>SecurityManager</code></strong>：安全管理器；即所有与安全有关的操作都会与 <code>SecurityManager</code> 交互；且它管理着所有 <code>Subject</code>；可以看出它是 <code>Shiro</code> 的核心，它负责与后边介绍的其他组件进行交互，如果学习过 SpringMVC，你可以把它看成 DispatcherServlet 前端控制器；</li><li><strong><code>Realm</code></strong>：域，<code>Shiro</code> 从 <code>Realm</code> 获取安全数据（如用户、角色、权限），就是说 <code>SecurityManager</code> 要验证用户身份，那么它需要从 <code>Realm</code> 获取相应的用户进行比较以确定用户身份是否合法；也需要从 Realm 得到用户相应的角色/权限进行验证用户是否能进行操作；可以把 <code>Realm</code> 看成 <code>DataSource</code>，即安全数据源。</li></ul><p>也就是说对于我们而言，最简单的一个 <code>Shiro</code> 应用：</p><ol><li>应用代码通过 <code>Subject</code> 来进行认证和授权，而 <code>Subject</code> 又委托给 <code>SecurityManager</code>；</li><li>我们需要给 <code>Shiro</code> 的 <code>SecurityManager</code> 注入 <code>Realm</code>，从而让 <code>SecurityManager</code> 能得到合法的用户及其权限进行判断。</li></ol><p>接下来我们来从 <code>Shiro</code> 内部来看下 <code>Shiro</code> 的架构，如下图所示：</p><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20180408195624.png" alt="Shiro 内部架构"></p><ul><li><p><strong><code>Subject</code></strong>：主体，可以看到主体可以是任何可以与应用交互的“用户”；</p></li><li><p><strong><code>SecurityManager</code></strong>：相当于 SpringMVC 中的 DispatcherServlet 或者 Struts2 中的 FilterDispatcher；是 Shiro 的心脏；所有具体的交互都通过 SecurityManager 进行控制；它管理着所有 Subject、且负责进行认证和授权、及会话、缓存的管理。</p></li><li><p><strong><code>Authenticator</code></strong>：认证器，负责主体认证的，这是一个扩展点，如果用户觉得 Shiro 默认的不好，可以自定义实现；其需要认证策略（Authentication Strategy），即什么情况下算用户认证通过了；</p></li><li><p><strong><code>Authrizer</code></strong>：授权器，或者访问控制器，用来决定主体是否有权限进行相应的操作；即控制着用户能访问应用中的哪些功能；</p></li><li><p><strong><code>Realm</code></strong>：可以有1个或多个 Realm，可以认为是安全实体数据源，即用于获取安全实体的；可以是 JDBC 实现，也可以是 LDAP 实现，或者内存实现等等；由用户提供；注意：Shiro 不知道你的用户/权限存储在哪及以何种格式存储；所以我们一般在应用中都需要实现自己的 Realm；</p></li><li><p><strong><code>SessionManager</code></strong>：如果写过 Servlet 就应该知道 Session 的概念，Session 呢需要有人去管理它的生命周期，这个组件就是 SessionManager；而 Shiro 并不仅仅可以用在 Web 环境，也可以用在如普通的 JavaSE 环境、EJB 等环境；所有呢，Shiro 就抽象了一个自己的 Session 来管理主体与应用之间交互的数据；这样的话，比如我们在 Web 环境用，刚开始是一台 Web 服务器；接着又上了台 EJB 服务器；这时想把两台服务器的会话数据放到一个地方，这个时候就可以实现自己的分布式会话（如把数据放到 Memcached 服务器）；</p></li><li><p><strong><code>SessionDAO</code></strong>：DAO 大家都用过，数据访问对象，用于会话的 CRUD，比如我们想把 Session 保存到数据库，那么可以实现自己的 SessionDAO，通过如 JDBC 写到数据库；比如想把 Session 放到 Memcached 中，可以实现自己的 Memcached SessionDAO；另外 SessionDAO 中可以使用 Cache 进行缓存，以提高性能；</p></li><li><p><strong><code>CacheManager</code></strong>：缓存控制器，来管理如用户、角色、权限等的缓存的；因为这些数据基本上很少去改变，放到缓存中后可以提高访问的性能；</p></li><li><p><strong><code>Cryptography</code></strong>：密码模块，Shiro 提高了一些常见的加密组件用于如密码加密/解密的。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Shiro </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC Test</title>
      <link href="/2018/04/01/SpringMVC%20Test/"/>
      <url>/2018/04/01/SpringMVC%20Test/</url>
      
        <content type="html"><![CDATA[<h2 id="Please-initialize-the-log4j-system-properly"><a href="#Please-initialize-the-log4j-system-properly" class="headerlink" title="Please initialize the log4j system properly"></a>Please initialize the log4j system properly</h2><pre><code class="shell">log4j:WARN No appenders could be found for logger (org.springframework.test.context.junit4.SpringJUnit4ClassRunner).log4j:WARN Please initialize the log4j system properly.log4j:WARN See http://logging.apache.org/log4j/1.2/faq.html#noconfig for more info.</code></pre><p>遇到这个错，把 <code>log4j.properties</code> 放在 <code>classpath</code> 下，如 <code>src</code> 或 <code>resources</code> 下面。</p><a id="more"></a><h2 id="加入依赖包"><a href="#加入依赖包" class="headerlink" title="加入依赖包"></a>加入依赖包</h2><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;com.jayway.restassured&lt;/groupId&gt;    &lt;artifactId&gt;spring-mock-mvc&lt;/artifactId&gt;    &lt;version&gt;2.4.0&lt;/version&gt;    &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.hibernate&lt;/groupId&gt;    &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;    &lt;version&gt;5.2.4.Final&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;    &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;    &lt;version&gt;3.1.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.mockito&lt;/groupId&gt;    &lt;artifactId&gt;mockito-all&lt;/artifactId&gt;    &lt;version&gt;1.9.5&lt;/version&gt;    &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;</code></pre><h2 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h2><pre><code class="java">import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;import org.junit.Before;import org.junit.Test;import org.junit.runner.RunWith;import org.mockito.MockitoAnnotations;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.http.MediaType;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import org.springframework.test.context.web.WebAppConfiguration;import org.springframework.test.web.servlet.MockMvc;import org.springframework.test.web.servlet.MvcResult;import org.springframework.test.web.servlet.ResultActions;import org.springframework.test.web.servlet.setup.MockMvcBuilders;import org.springframework.web.context.WebApplicationContext;@RunWith(SpringJUnit4ClassRunner.class)@WebAppConfiguration(value = &quot;src/main/webapp&quot;) // 默认就是 src/main/webapp@ContextConfiguration(locations = {&quot;classpath:config/spring/spring-mvc.xml&quot;,&quot;classpath:config/spring/applicationContext.xml&quot;})//java.lang.AssertionError: Status expected:&lt;200&gt; but was:&lt;404&gt;  没加spring-mvc.xmlpublic class LogManagerActionTest2 {    @Autowired    private WebApplicationContext wac;    private MockMvc mockMvc;    @Before    public void setUp() {        MockitoAnnotations.initMocks(this);        this.mockMvc = MockMvcBuilders.webAppContextSetup(this.wac).dispatchOptions(true).build();    }    @Test    public void test() throws Exception {        String actual = &quot;{\&quot;orderNumber\&quot;: \&quot;4955\&quot;,\&quot;orderVersion\&quot;: \&quot;1\&quot;}&quot;;        String expect = &quot;{\&quot;orderNumber\&quot;: \&quot;4956\&quot;,\&quot;orderVersion\&quot;: \&quot;1\&quot;}&quot;;        ResultActions resultActions = this.mockMvc                .perform(get(&quot;/getSystemLog&quot;)                .accept(MediaType.TEXT_HTML_VALUE)                // .param(&quot;actual&quot;, actual)                // .param(&quot;expect&quot;, expect)                ).andDo(print()) // 包含 下面的 reponse 打印结果                .andExpect(status().isOk());//               .andExpect(redirectedUrl(&quot;/getSystemLog.do&quot;)) // 如果返回结果是重定向，重定向的url//               .andExpect(content().contentType(&quot;application/json&quot;))//               .andExpect(jsonPath(&quot;$&quot;, hasSize(1)))//               .andExpect(jsonPath(&quot;$[0].field&quot;).value(&quot;orderNumber&quot;))//               .andExpect(jsonPath(&quot;$[0].actual&quot;).value(&quot;4955&quot;))//               .andExpect(jsonPath(&quot;$[0].expected&quot;).value(&quot;4956&quot;));        // 关于JsonPath的使用请参考http://goessner.net/articles/JsonPath/        MvcResult mvcResult = resultActions.andReturn();        System.out.println(&quot;status :\t&quot; + mvcResult.getResponse().getStatus());        String resposne = mvcResult.getResponse().getContentAsString();        System.out.println(&quot;reponse :\t&quot; + resposne);    }}</code></pre><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p>更为全面的参考 <a href="http://jinnianshilongnian.iteye.com/blog/2004660" target="_blank" rel="noopener">Spring MVC测试框架详解——服务端测试</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JUnit </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Test 整合JUnit 4</title>
      <link href="/2018/04/01/Spring%20Test%20%E6%95%B4%E5%90%88JUnit%204/"/>
      <url>/2018/04/01/Spring%20Test%20%E6%95%B4%E5%90%88JUnit%204/</url>
      
        <content type="html"><![CDATA[<h2 id="加入依赖包"><a href="#加入依赖包" class="headerlink" title="加入依赖包"></a>加入依赖包</h2><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;junit&lt;/groupId&gt;    &lt;artifactId&gt;junit&lt;/artifactId&gt;    &lt;version&gt;4.12&lt;/version&gt;    &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-test&lt;/artifactId&gt;    &lt;version&gt;4.2.9.RELEASE&lt;/version&gt;    &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;</code></pre><p>等其他 Spring 相关其他依赖包。</p><a id="more"></a><h2 id="创建测试类"><a href="#创建测试类" class="headerlink" title="创建测试类"></a>创建测试类</h2><h3 id="基类"><a href="#基类" class="headerlink" title="基类"></a>基类</h3><p>用来加载配置文件。</p><pre><code class="java">@RunWith(SpringJUnit4ClassRunner.class)  //使用junit4进行测试// 加载配置文件，可以使用通配符 *// @ContextConfiguration({&quot;/spring/*.xml&quot;}) // 加载 spring 文件夹下所有 xml 文件@ContextConfiguration({&quot;/spring/app*.xml&quot;})// 如果加入以下代码，所有继承该类的测试类都会遵循该配置，也可以不加，在测试类的方法加上控制事务// 下面两个注解可以加在测试类上，或测试方法上。// @Transactional// @Rollback(true) // 默认就是true，无论测试通不通过都会已这个为主。true 会回滚。public class BaseJunit4Test {}</code></pre><h3 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h3><pre><code class="java">public class LogManagerDaoTest extends BaseJunit4Test {    @Resource    private LogManagerDao dao;    @Test    @Transactional // 标明此方法需使用事务    @Rollback(true) // 标明使用完此方法后事务回滚    public void saveTest() {        LogManagerBean bean = new LogManagerBean();        bean.setLogcontent(&quot;测试&quot;);        dao.insertLog(bean);    }}</code></pre><h2 id="事物始终无法回滚"><a href="#事物始终无法回滚" class="headerlink" title="事物始终无法回滚"></a>事物始终无法回滚</h2><p>测试代码如果继承了 <code>AbstractJUnit4SpringContextTests</code>，在 <code>AbstractJUnit4SpringContextTests</code> 中已经存在事务,并且默认事务是自动提交，它覆盖了后来在方法中配置的事务，另外就是在测试类已经使用了 <code>@RunWith</code>，所以测试类无需再继承 <code>AbstractJUnit4SpringContextTests</code></p><br>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JUnit </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUnit 4学习笔记（下）</title>
      <link href="/2018/03/31/JUnit%204%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
      <url>/2018/03/31/JUnit%204%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="JUnit-4-参数化测试"><a href="#JUnit-4-参数化测试" class="headerlink" title="JUnit 4 参数化测试"></a>JUnit 4 参数化测试</h1><p>Junit 4 参数化测试 允许通过变化范围的参数值来测试方法。参数擦测试可以通过以下简单的步骤实现：</p><ol><li>对测试类添加注解 <code>@RunWith(Parameterized.class)</code>。</li><li>将需要使用变化范围参数值测试的参数定义为私有变量。</li><li>使用上一步骤声明的私有变量作为入参，创建构造函数。</li><li>创建一个使用 <code>@Parameters</code> 注解的公共静态方法，它将需要测试的各种变量值通过集合的形式返回。</li><li>使用定义的私有变量定义测试方法。</li></ol><a id="more"></a><p><code>EvenNumberCheckerTest</code> 类 对 <code>EvenNumberChecker</code> 类进行参数化测试：</p><pre><code class="java">import static org.junit.Assert.*;import java.util.Arrays;import java.util.Collection;import org.junit.Test;import org.junit.runner.RunWith;import org.junit.runners.Parameterized;import org.junit.runners.Parameterized.Parameters;// Step 1 对测试类添加注解 @RunWith(Parameterized.class)@RunWith(Parameterized.class)public class EvenNumberCheckerTest {    // Step 2: 将需要使用变化范围参数值测试的参数定义为私有变量    private int inputNumber;    private boolean isEven;    // Step 3: 使用上一步骤声明的私有变量作为入参，创建构造函数    public EvenNumberCheckerTest(int inputNumber, boolean isEven) {        super();        this.inputNumber = inputNumber;        this.isEven = isEven;    }    // Step 4: 创建一个使用@Parameters注解的公共静态方法，它将需要测试的各种变量值通过集合的形式返回。    @Parameters    public static Collection&lt;Object[]&gt; data() {        Object[][] data = new Object[][]{                {2, true},                {5, false},                {10, true}        };        return Arrays.asList(data);    }    @Test    public void test() {        System.out.println(&quot;inputNumber: &quot; + inputNumber + &quot;; isEven: &quot; + isEven);        EvenNumberChecker evenNumberChecker = new EvenNumberChecker();        // Step 5: 使用定义的私有变量定义测试方法        boolean actualResult = evenNumberChecker.isEven(inputNumber);        assertEquals(isEven, actualResult);    }}class EvenNumberChecker {    /**     * 校验输入的数字是否为偶数     */    public boolean isEven(int i) {        if (i % 2 == 0) {            return true;        } else {            return false;        }    }}</code></pre><h1 id="测试套件"><a href="#测试套件" class="headerlink" title="测试套件"></a>测试套件</h1><p>JUnit 4 允许通过使用测试套件类批量运行测试类，为一套测试类创建一个测试套件，要为测试类添加注解：<code>@RunWith(Suite.class)</code>，<code>@SuiteClasses(TestClass1.class, TestClass2.class)</code>。</p><p>当运行时，所有包含在 <code>@SuiteClasses</code> 注解内的所有测试类都会被执行。</p><h2 id="测试类1"><a href="#测试类1" class="headerlink" title="测试类1"></a>测试类1</h2><pre><code class="java">import org.junit.Test;import static org.junit.Assert.assertEquals;public class GeometryTest {    @Test    public void testSquareArea() {        Geometry geometry = new Geometry();        int actualResult = geometry.squareArea(2);        int expectedResult = 4;        assertEquals(expectedResult, actualResult);    }}class Geometry {    public int squareArea(int length) {        return length * length;    }}</code></pre><h2 id="测试类2"><a href="#测试类2" class="headerlink" title="测试类2"></a>测试类2</h2><pre><code class="java">import org.junit.Test;import static org.junit.Assert.assertEquals;public class ArithmeticTest {    @Test    public void testAdd() {        Arithmetic arithmetic = new Arithmetic();        int actualResult = arithmetic.add(1, 2);        int expectedResult = 3;        assertEquals(expectedResult, actualResult);    }}class Arithmetic {    public int add(int i, int j) {        return i + j;    }}</code></pre><h2 id="测试套件类"><a href="#测试套件类" class="headerlink" title="测试套件类"></a>测试套件类</h2><pre><code class="java">import org.junit.runner.RunWith;import org.junit.runners.Suite;@RunWith(Suite.class)@Suite.SuiteClasses({ArithmeticTest.class, GeometryTest.class})public class AllTests {}</code></pre><h1 id="超时测试"><a href="#超时测试" class="headerlink" title="超时测试"></a>超时测试</h1><h2 id="使用-Timeout-注解"><a href="#使用-Timeout-注解" class="headerlink" title="使用 @Timeout 注解"></a>使用 @Timeout 注解</h2><pre><code class="java">public class TimeoutTest {    // 测试结果会是失败    @Test(timeout = 200) // 毫秒    public void testTimeout() {        while (true);    }}</code></pre><h2 id="测试类的所有方法应用-Timeout-规则"><a href="#测试类的所有方法应用-Timeout-规则" class="headerlink" title="测试类的所有方法应用 Timeout 规则"></a>测试类的所有方法应用 Timeout 规则</h2><p>Timeout Rule 中设置的超时时间应用于整个测试过程，包括任何的 <code>@Before</code> 与 <code>@After</code> 方法。</p><pre><code class="java">public class TimeoutRuleTest {    /**     * Rule 应用该类所有方法     */    @Rule    public Timeout timeout = new Timeout(1000); // 毫秒    /*    @Rule    public final TestRule globalTimeout = Timeout.millis(20); // 毫秒    @Rule    public final TestRule globalTimeout = Timeout.seconds(2); // 秒    */    @Test    public void testTimeout1() {        while (true) ;    }    @Test    public void testTimeout2() {        while (true) ;    }}</code></pre><h2 id="测试执行顺序"><a href="#测试执行顺序" class="headerlink" title="测试执行顺序"></a>测试执行顺序</h2><p>从4.1.1版本开始，JUnit 默认使用一种确定的、非不可预测的顺序来调用测试方法（<code>MethodSorters.DEFAULT</code>）。如果想改变它，可以在测试类上加上 <code>@FixMethodOrder</code> 注解，并指定一种可用的 <code>MethodSorters</code>。<br>有下面几种：</p><ol><li><code>@FixMethodOrder(MethodSorters.JVM)</code>：使用Java虚拟机返回的顺序。可能导致每次执行的顺序不同。</li><li><code>@FixMethodOrder(MethodSorters.NAME_ASCENDING)</code>：使用测试方法名的字典序。</li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote><p><a href="https://blog.csdn.net/luanlouis/article/details/37560783" target="_blank" rel="noopener">Junit 4 Tutorials(Junit 4 教程)</a></p><p><a href="https://blog.csdn.net/swt369/article/details/78056367" target="_blank" rel="noopener">JUnit4 wiki翻译</a></p></blockquote><br>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JUnit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUnit 4学习笔记（上）</title>
      <link href="/2018/03/31/JUnit%204%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
      <url>/2018/03/31/JUnit%204%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="JUnit-4-简介"><a href="#JUnit-4-简介" class="headerlink" title="JUnit 4 简介"></a>JUnit 4 简介</h1><p>测试框架是最流行的 Java 单元测试框架。JUnit 被用来开发对 Java 类的单元测试。它就是一个类包，提供了各种方法来测试 Java 类中的方法(method)。</p><a id="more"></a><h1 id="JUnit-4-特性"><a href="#JUnit-4-特性" class="headerlink" title="JUnit 4 特性"></a>JUnit 4 特性</h1><ol><li>简单的注解，提供书写 <code>JUnit</code> 测试的基本特性</li><li>断言方法(<code>Assert Methods</code>)比较测试的方法执行结果值和期望值</li><li><code>@Ignore</code> 注解，忽略测试方法或者测试类的执行</li><li>期望异常测试</li><li>超时测试,测试方法的执行时间</li><li>测试组件，一起运行一些测试类</li><li>参数化测试，以不同的输入参数值测试方法</li></ol><h1 id="Eclipse-中的-JUnit-视图窗口"><a href="#Eclipse-中的-JUnit-视图窗口" class="headerlink" title="Eclipse 中的 JUnit 视图窗口"></a>Eclipse 中的 JUnit 视图窗口</h1><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20180329135907.png" alt="Eclipse 中的 JUnit 视图窗口"></p><ol><li>① Runs：显示了执行了的 jUnit 测试用例(方法)总数</li><li>② Errors：显示结果为 error/exception 的测试用例总数</li><li>③ Failures：显示测试用例执行失败总数</li><li>④ Failure Trace：展示 error/exception or failure trace</li><li>⑤ Show Failures Only：只显示失败的用例信息</li><li>⑥ Scroll Lock：scroll lock</li><li>⑦ Rerun Test：重新运行测试用例</li><li>⑧ Rerun Test – Failure First：重新运行测试用例，先执行失败了的测试用例</li><li>⑨ Stop JUnit Test Run：停止单元测试</li><li>⑩ Test Run History：显示测试用例运行历史</li></ol><h1 id="JUnit4-注解"><a href="#JUnit4-注解" class="headerlink" title="JUnit4 注解"></a>JUnit4 注解</h1><h2 id="BeforeClass注解"><a href="#BeforeClass注解" class="headerlink" title="@BeforeClass注解"></a>@BeforeClass注解</h2><p>被 <code>@BeforeClass</code> 注解的方法会是：只被执行一次，运行 JUnit 测试类时第一个被执行的方法。</p><p>这样的方法被用作执行计算代价很大的任务，如打开数据库连接。被 <code>@BeforeClass</code> 注解的方法应该是静态的（即 static 类型的）。</p><h2 id="AfterClass注解"><a href="#AfterClass注解" class="headerlink" title="@AfterClass注解"></a>@AfterClass注解</h2><p>被 <code>@AfterClass</code> 注解的方法应是：只被执行一次，运行 JUnit 测试类是最后一个被执行的方法</p><p>该类型的方法被用作执行类似关闭数据库连接的任务。被 <code>@AfterClass</code> 注解的方法应该是静态的（即 static类型的）。</p><h2 id="Before注解"><a href="#Before注解" class="headerlink" title="@Before注解"></a>@Before注解</h2><p>被 <code>@Before</code> 注解的方法应是：JUnit 测试类中的<strong>任意一个测试方法执行前</strong>都会执行此方法。</p><p>该类型的方法可以被用来为测试方法初始化所需的资源。</p><h2 id="After注解"><a href="#After注解" class="headerlink" title="@After注解"></a>@After注解</h2><p>被 <code>@After</code> 注解的方法应是：JUnit 测试类中的<strong>任意一个测试方法执行后</strong>都会执行此方法, 即使被 <code>@Test</code> 或 <code>@Before</code> 修饰的测试方法抛出异常</p><p>该类型的方法被用来关闭由 <code>@Before</code> 注解修饰的测试方法打开的资源。</p><h2 id="Test-注解"><a href="#Test-注解" class="headerlink" title="@Test 注解"></a>@Test 注解</h2><p>被 <code>@Test</code> 注解的测试方法包含了真正的测试代码，并且会被 JUnit 应用为要测试的方法。<code>@Test</code> 注解有两个可选的参数：</p><ol><li><code>expected</code> 表示此测试方法执行后应该抛出的异常，（值是异常名）。</li><li><code>timeout</code> 检测测试方法的执行时间。</li></ol><pre><code class="java">import static org.junit.Assert.assertEquals;import org.junit.After;import org.junit.AfterClass;import org.junit.Before;import org.junit.BeforeClass;import org.junit.Test;public class ArithmeticTest {    @BeforeClass    public static void setUpClass() {        // one time setup method        System.out.println(&quot;@BeforeClass - executed only one time and is first method to be executed&quot;);    }    @AfterClass    public static void tearDownClass() {        // one time tear down method        System.out.println(&quot;@AfterClass - executed only one time and is last method to be executed&quot;);    }    @Before    public void setUp() {        // set up method executed before every test method        System.out.println(&quot;@Before - executed before every test method&quot;);    }    @After    public void tearDown() {        // tear down method executed after every test method        System.out.println(&quot;@After - executed after every test method&quot;);    }    @Test    public void testAdd() {        Arithmetic arithmetic = new Arithmetic();        int actualResult = arithmetic.add(3, 4);        int expectedResult = 7;        assertEquals(expectedResult, actualResult);        System.out.println(&quot;@Test - defines test method&quot;);    }    // 多个Test 会多次执行 @Before @After    @Test    public void testAdd2() {        System.out.println(&quot;@Test - testAdd2 method&quot;);    }}class Arithmetic {    public int add(int i, int j) {        return i + j;    }}</code></pre><p>控制台打印结果：</p><pre><code class="java">@BeforeClass - executed only one time and is first method to be executed@Before - executed before every test method@Test - testAdd method@After - executed after every test method@Before - executed before every test method@Test - testAdd2 method@After - executed after every test method@AfterClass - executed only one time and is last method to be executed</code></pre><h2 id="Ignore-注解"><a href="#Ignore-注解" class="headerlink" title="@Ignore 注解"></a>@Ignore 注解</h2><p>这个注释是用来忽略有关不需要执行的测试的。可以在方法上，也可以在类上。</p><h1 id="JUnit-4-断言方法"><a href="#JUnit-4-断言方法" class="headerlink" title="JUnit 4 断言方法"></a>JUnit 4 断言方法</h1><p>JUnit 4 断言方法允许检查测试方法的期望结果值和真实返回值。JUnit 的 <code>org.junit.Assert</code> 类提供了各种断言方法来写 JUnit 测试。这些方法被用来检查方法的真实结果值和期望值。下列一些有用的断言方法列表，并且以下方法存在大量重载方法：</p><table><thead><tr><th align="center">Method</th><th align="center">Description</th></tr></thead><tbody><tr><td align="center">assertNull(java.lang.Object object)</td><td align="center">检查对象是否为空</td></tr><tr><td align="center">assertNotNull(java.lang.Object object)</td><td align="center">检查对象是否不为空</td></tr><tr><td align="center">assertEquals(long expected, long actual)</td><td align="center">检查long类型的值是否相等</td></tr><tr><td align="center">assertEquals(double expected, double actual, double delta)</td><td align="center">检查指定精度的double值是否相等</td></tr><tr><td align="center">assertFalse(boolean condition)</td><td align="center">检查条件是否为假</td></tr><tr><td align="center">assertTrue(boolean condition)</td><td align="center">检查条件是否为真</td></tr><tr><td align="center">assertSame(java.lang.Object expected, java.lang.Object actual)</td><td align="center">检查两个对象引用是否引用同一对象（即对象是否相等）</td></tr><tr><td align="center">assertNotSame(java.lang.Object unexpected, java.lang.Object actual)</td><td align="center">检查两个对象引用是否不引用统一对象(即对象不等)</td></tr></tbody></table><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><pre><code class="java">import org.junit.Test;import java.util.ArrayList;import java.util.List;import static org.junit.Assert.*;public class ArithmeticTest {    @Test    public void testAssertNull() {        String str = null;        assertNull(str);    }    @Test    public void testAssertNotNull() {        String str = &quot;hello Java!!&quot;;        assertNotNull(str);    }    @Test    public void testAssertEqualsLong() {        long long1 = 2;        long long2 = 2;        assertEquals(long1, long2);    }    @Test    public void testAssertEqualsDouble() {        // test case is successfull as double1 and double 2        // differ by 0.001 which is less than our specified delta        double double1 = 1.236;        double double2 = 1.237;        double delta = 0.002;        assertEquals(double1, double2, delta);    }    @Test    public void testAssertTrue() {        List&lt;String&gt; list = new ArrayList&lt;String&gt;();        assertTrue(list.isEmpty());    }    @Test    public void testAssertFalse() {        List&lt;String&gt; list = new ArrayList&lt;String&gt;();        list.add(&quot;hello&quot;);        assertFalse(list.isEmpty());    }    @Test    public void testAssertSame() {        String str1 = &quot;hello world!!&quot;;        String str2 = &quot;hello world!!&quot;;        assertSame(str2, str1);    }    @Test    public void testAssertNotSame() {        String str1 = &quot;hello world!!&quot;;        String str3 = &quot;hello Java!!&quot;;        assertNotSame(str1, str3);    }}</code></pre><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote><p><a href="https://blog.csdn.net/luanlouis/article/details/37560783" target="_blank" rel="noopener">Junit 4 Tutorials(Junit 4 教程)</a></p><p><a href="https://blog.csdn.net/swt369/article/details/78056367" target="_blank" rel="noopener">JUnit4 wiki翻译</a></p></blockquote><br>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JUnit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Java编程思想》笔记12-通过异常处理错误</title>
      <link href="/2018/03/28/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B%E7%AC%94%E8%AE%B012-%E9%80%9A%E8%BF%87%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E9%94%99%E8%AF%AF/"/>
      <url>/2018/03/28/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B%E7%AC%94%E8%AE%B012-%E9%80%9A%E8%BF%87%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E9%94%99%E8%AF%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="异常处理的两种基本模型"><a href="#异常处理的两种基本模型" class="headerlink" title="异常处理的两种基本模型"></a>异常处理的两种基本模型</h1><ol><li>终止模型，Java 和 C++ 支持。假设错误非常关键，程序无法返回到异常发生的地方继续执行。</li><li>恢复模型，异常处理程序的工作是修正错误，然后重新调用出问题的方法，并认为第二次能成功。<br> 如果 Java 想要实现类似恢复的行为，可以在遇见错误时不要抛出，而是调用方法来修正该错误。或者把 try 块放在 while 循环里，这样可以不断的进入 try 块中，直到得到满意的结果。</li></ol><h1 id="异常说明（throws）"><a href="#异常说明（throws）" class="headerlink" title="异常说明（throws）"></a>异常说明（throws）</h1><p>可以声明方法抛出异常，实际并不抛出。好处是为异常占个位置，以后就可以抛出这种异常而不用修改已有代码。在定义抽象基类和接口时这种能力很重要，<strong>这样子类或接口实现就可以抛出这些预先声明的异常</strong>。</p><a id="more"></a><h1 id="栈轨迹"><a href="#栈轨迹" class="headerlink" title="栈轨迹"></a>栈轨迹</h1><p>printStackTrace() 方法所提供的信息可以通过 getStackTrace() 方法来直接访问。这个方法将返回一个由栈轨迹中的元素所构成的数组。</p><p>fillInStackTrace() 重新抛出异常，更新调用栈信息。</p><pre><code class="java">public class Rethrowing {  public static void f() throws Exception {    System.out.println(&quot;originating the exception in f()&quot;);    throw new Exception(&quot;thrown from f()&quot;);  }  public static void g() throws Exception {    try {      f();    } catch(Exception e) {      System.out.println(&quot;Inside g(),e.printStackTrace()&quot;);      e.printStackTrace(System.out);      throw e; // 把当前对象重新抛出，printStackTrace() 方法显示的将是原来异常抛出点的调用栈信息，而非重新抛出点的信息。    }  }  public static void h() throws Exception {    try {      f();    } catch(Exception e) {      System.out.println(&quot;Inside h(),e.printStackTrace()&quot;);      e.printStackTrace(System.out);      throw (Exception)e.fillInStackTrace(); // 更新调用栈信息。也可以抛出新的异常。    }  }  public static void main(String[] args) {    try {      g();    } catch(Exception e) {      System.out.println(&quot;main: printStackTrace()&quot;);      e.printStackTrace(System.out);      for(StackTraceElement ste : e.getStackTrace()) // 栈轨迹          System.out.println(&quot;栈轨迹:&quot;+ste);    }    try {      h();    } catch(Exception e) {      System.out.println(&quot;main: printStackTrace()&quot;);      e.printStackTrace(System.out);    }  }} /* Output:originating the exception in f()Inside g(),e.printStackTrace()java.lang.Exception: thrown from f()    at exceptions.Rethrowing.f(Rethrowing.java:8)    at exceptions.Rethrowing.g(Rethrowing.java:12)    at exceptions.Rethrowing.main(Rethrowing.java:30)main: printStackTrace()java.lang.Exception: thrown from f()    at exceptions.Rethrowing.f(Rethrowing.java:8)    at exceptions.Rethrowing.g(Rethrowing.java:12)    at exceptions.Rethrowing.main(Rethrowing.java:30)栈轨迹:exceptions.Rethrowing.f(Rethrowing.java:8)栈轨迹:exceptions.Rethrowing.g(Rethrowing.java:12)栈轨迹:exceptions.Rethrowing.main(Rethrowing.java:30)originating the exception in f()Inside h(),e.printStackTrace()java.lang.Exception: thrown from f()    at exceptions.Rethrowing.f(Rethrowing.java:8)    at exceptions.Rethrowing.h(Rethrowing.java:21)    at exceptions.Rethrowing.main(Rethrowing.java:38)main: printStackTrace()java.lang.Exception: thrown from f()    at exceptions.Rethrowing.h(Rethrowing.java:25)    at exceptions.Rethrowing.main(Rethrowing.java:38)*///:~</code></pre><h1 id="异常链"><a href="#异常链" class="headerlink" title="异常链"></a>异常链</h1><p>想要在捕获一个异常后抛出另一个异常，并且把原始的异常的信息保存下来，这被称为<strong>异常链</strong>。</p><p>所有 Throwable 的子类在构造器中都可以接受一个 cause 对象作为参数。这个 cause 就用来表示原始异常，这样通过把原始异常传递给新的异常，就使得即使在当前位置创建并抛出新的异常，也能通过这个异常链追踪到异常最初发生的位置。在 Throwable 的子类中，只有三种基本的异常类提供了带 cause 参数的构造器。它们是 Error，Exception 和 RuntimeException。如果要把其他类型的异常链接起来，应该使用 <code>initCause()</code> 方法而不是构造器。</p><pre><code class="java">class DynamicFieldsException extends Exception {}public class DynamicFields {  public void setField(String id, Object value) throws DynamicFieldsException {    if(value == null) {      DynamicFieldsException dfe = new DynamicFieldsException();      dfe.initCause(new NullPointerException());      throw dfe;    }  }  public static void main(String[] args) {    DynamicFields df = new DynamicFields();    try {      df.setField(&quot;number3&quot;, null);    } catch(DynamicFieldsException e) {      e.printStackTrace(System.out);    }  }} /* Output:exceptions.DynamicFieldsException    at exceptions.DynamicFields.setField(DynamicFields.java:18)    at exceptions.DynamicFields.main(DynamicFields.java:27)Caused by: java.lang.NullPointerException    at exceptions.DynamicFields.setField(DynamicFields.java:19)    ... 1 more*///:~</code></pre><h1 id="缺陷：异常丢失"><a href="#缺陷：异常丢失" class="headerlink" title="缺陷：异常丢失"></a>缺陷：异常丢失</h1><pre><code class="java">class VeryImportantException extends Exception {  public String toString() {    return &quot;A very important exception!&quot;;  }}class HoHumException extends Exception {  public String toString() {    return &quot;A trivial exception&quot;;  }}public class LostMessage {  void f() throws VeryImportantException {    throw new VeryImportantException();  }  void dispose() throws HoHumException {    throw new HoHumException();  }  public static void main(String[] args) {    try {      LostMessage lm = new LostMessage();      try {        lm.f(); // 丢失异常 VeryImportantException      } finally {//      try {          lm.dispose(); // 把这句也加上 try 块，就不会丢失了//      }catch(Exception e) {//        System.out.println(e);//      }      }    } catch(Exception e) {      System.out.println(e);    }  }} /* Output:A trivial exception*///:~</code></pre><p>另一种丢失方式，从 finally 字句中返回。</p><pre><code class="java">// 没有任何输出public class ExceptionSilencer {  public static void main(String[] args) {    try {      throw new RuntimeException();    } finally {      return;    }  }}</code></pre><h1 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h1><p>子类的构造器可以抛出任何异常，但 throws 必须包含父类构造器的异常说明。且不能捕获父类构造器抛出的异常（有隐式 super()，super()必须在子类构造器的第一行，所以无法捕获）。</p><br>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java编程思想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Java编程思想》笔记11-持有对象</title>
      <link href="/2018/03/28/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B%E7%AC%94%E8%AE%B011-%E6%8C%81%E6%9C%89%E5%AF%B9%E8%B1%A1/"/>
      <url>/2018/03/28/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B%E7%AC%94%E8%AE%B011-%E6%8C%81%E6%9C%89%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="Arrays-asList"><a href="#Arrays-asList" class="headerlink" title="Arrays.asList"></a>Arrays.asList</h1><p><code>Arrays.asList</code>（非 List 类型的集合对象/可变参数的对象）；方法可以将传递的参数转变为 List 集合。如：<code>Arrays.asList(new Object1(),new Object2(),…);</code></p><p>注意：<code>Arrays.asList()</code> 方法转换后的 List 对象是一个 size 不能改变的对象（底层是数组），如果对该对象做增加或者删除元素操作时，将会报错。</p><pre><code class="java">// Snow 是Light，Heavy的父类List&lt;Snow&gt; snow = Arrays.&lt;Snow&gt;asList(new Light(), new Heavy());// 不加 &lt;Snow&gt; 会报错List&lt;Snow&gt; snow3 = new ArrayList&lt;Snow&gt;();Collections.addAll(snow3, new Light(), new Heavy());// Collections.addAll() 可以根据第一个参数了解到目标类型</code></pre><a id="more"></a><h1 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h1><pre><code class="java">// 按照字母顺序排序Set&lt;String&gt; words = new TreeSet&lt;Strings&gt;(String.CASE_INSENSITIVE_ORDER)</code></pre><h1 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h1><p>“栈”通常是指“先进后出”（LIFO）的容器。</p><p>LinkedList 具有能够实现栈的所有功能的方法，因此可以直接将 LinkedList 作为栈使用。</p><pre><code class="java">public class Stack&lt;T&gt; {  private LinkedList&lt;T&gt; storage = new LinkedList&lt;T&gt;();  public void push(T v) { storage.addFirst(v); }  public T peek() { return storage.getFirst(); }  public T pop() { return storage.removeFirst(); }  public boolean empty() { return storage.isEmpty(); }  public String toString() { return storage.toString(); }}</code></pre><p>如果只需要栈的行为，使用继承就不合适了，所以这里使用组合。</p><p>java.util.Stack 使用了继承（Vector），所以一般不使用。</p><h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><p>队列是一个典型的先进先出（FIFO）的容器。</p><p>LinkedList 实现了 Queue 接口。因此可用作 Queue 的一种实现（向上转型为 Queue） 。</p><pre><code class="java">public class QueueDemo {    public static void printQ(Queue queue) {        while (queue.peek() != null) {            System.out.print(queue.remove() + &quot; &quot;);        }        System.out.println();    }    public static void main(String[] args) {        Queue&lt;Integer&gt; queue = new LinkedList&lt;Integer&gt;();        Random rand = new Random(47);        for (int i = 0; i &lt; 10; i++) {            queue.offer(rand.nextInt(i + 10));        }        printQ(queue);        Queue&lt;Character&gt; qc = new LinkedList&lt;Character&gt;();        for (char c : &quot;Brontosaurus&quot;.toCharArray()) {            qc.offer(c);        }        printQ(qc);    }}/* Output:8 1 1 1 5 14 3 1 0 1B r o n t o s a u r u s*///:~</code></pre><h1 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h1><p>队列规则：给定一组队列中的元素，确定下一个弹出队列的元素的规则 。FIFO 是典型的一种规则，声明的是下一个元素应该是等待时间最长的元素。</p><p><strong>优先级队列</strong>：下一个元素是最需要的元素（优先级最高的元素）。 Java SE5添加了这种队列。</p><p>offer() 插入一个对象到 PriorityQueue 时，会在队列中被排序 （实际上依赖于具体实现，典型的是插入时排序，但也可以在移除时选择最重要的元素，如果对象的优先级在队列等待时可以改变，那算法的选择就很重要）。默认排序使用对象的自然顺序，但可以通过提供 Comparator（如Collections.reverseOrder()，Java SE5）改变这个顺序。peek()、poll() 和 remove() 可以获得优先级最高的元素 （对于内置类型，最小值拥有最高优先级）。</p><p>如果要在PriorityQueue使用自定义类型，就需要添加额外的功能以提供自然顺序，或者提供自己的 Comparator。<code>public PriorityQueue(Comparator&lt;? super E&gt; comparator)</code>。</p><pre><code class="java">public class PriorityQueueDemo {  public static void main(String[] args) {    PriorityQueue&lt;Integer&gt; priorityQueue = new PriorityQueue&lt;Integer&gt;();    Random rand = new Random(47);    for(int i = 0; i &lt; 10; i++)      priorityQueue.offer(rand.nextInt(i + 10));    QueueDemo.printQ(priorityQueue);    List&lt;Integer&gt; ints = Arrays.asList(25, 22, 20, 18, 14, 9, 3, 1, 1, 2, 3, 9, 14, 18, 21, 23, 25);    priorityQueue = new PriorityQueue&lt;Integer&gt;(ints);    QueueDemo.printQ(priorityQueue);    priorityQueue = new PriorityQueue&lt;Integer&gt;(ints.size(), Collections.reverseOrder());    priorityQueue.addAll(ints);    QueueDemo.printQ(priorityQueue);  }} /* Output:0 1 1 1 1 1 3 5 8 141 1 2 3 3 9 9 14 14 18 18 20 21 22 23 25 2525 25 23 22 21 20 18 18 14 14 9 9 3 3 2 1 1*///:~</code></pre><br>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java编程思想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Java编程思想》笔记10-内部类</title>
      <link href="/2018/03/28/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B%E7%AC%94%E8%AE%B010-%E5%86%85%E9%83%A8%E7%B1%BB/"/>
      <url>/2018/03/28/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B%E7%AC%94%E8%AE%B010-%E5%86%85%E9%83%A8%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p>可以将一个类的定义放在另一个类的定义内部，这就是内部类。</p><pre><code class="java">public class Outer {    class Inner {        Inner() {System.out.println(&quot;Hello I am Inner Class!&quot;);}        public Outter outer(){            return Outter.this; // 返回外部类对象        }    }    Inner getInner(){return new Inner();}    Outer(){System.out.println(&quot;Hello I am Outer Class!&quot;);}    public static void main(String[] args) {        Outer outer=new Outer();        Inner myInner=outer.getInner(); // 实例化内部类，方法一        Inner newInner=outer.new Inner(); // 实例化内部类，方法二    }}</code></pre><a id="more"></a><ul><li>在初始化外部类 Outer 的时候，并不会自动初始化内部类 Inner。</li><li>如果 Inner 类不是静态的，要实例化内部 Inner 类，必须通过外部 Outer 类的实例。</li><li>非静态内部类自动拥有对其外部类所有成员的访问权。</li><li>内部类持有对外部类对象引用的语法：<code>外部类名称.this</code>。</li><li>private 内部类，可以完全隐藏实现的细节。</li></ul><h2 id="在方法和作用域内的内部类"><a href="#在方法和作用域内的内部类" class="headerlink" title="在方法和作用域内的内部类"></a>在方法和作用域内的内部类</h2><p>方法内部，称为局部内部类。<br>作用域方面，如果内部类声明在if条件语句下作用域中，那超出这个域也是不可用的。</p><h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>匿名类没有命名的构造器（类本身就没有名字），可以通过实例初始化来完成构造器的功能。</p><p>匿名内部类从 JDK8 开始能访问非 final 的参数了<br>JDK8 之前为保护外部类的变量不被破坏，Java 硬性规定匿名内部类只能访问 final 类型的外部对象。但从 JDK8 开始，访问非 final 对象编译器也不会报错了。但匿名内部类内部<strong>仍然不能改变这些对象</strong>，因为匿名内部类内部会对这些对象做一份拷贝。所有操作都在这个镜像上进行。</p><h2 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h2><p>静态内部类</p><p>普通的内部类不能有 static 数据和 static 字段，也不能包含嵌套类。但是嵌套类可以包含这些。</p><p>接口的内部类，嵌套类可以作为接口的一部分。</p><h2 id="为什么需要内部类"><a href="#为什么需要内部类" class="headerlink" title="为什么需要内部类"></a>为什么需要内部类</h2><p>每个内部类都能独立地继承自一个（接口的）实现，所以无论外部类是否已经继承了某个（接口的）实现，对于内部类都没有影响。可以有效的实现了多重继承。</p><p>如果拥有的是抽象的类或具体的类，而不是接口，那就只能使用内部类才能实现多重继承。</p><pre><code class="java">class D {}abstract class E {}class Z extends D {  E makeE() { return new E() {}; }}public class MultiImplementation {  static void takesD(D d) {}  static void takesE(E e) {}  public static void main(String[] args) {    Z z = new Z();    takesD(z);    takesE(z.makeE());  }}</code></pre><ul><li>内部类可以有多个实例，每个实例可以拥有独立于外部类对象的不同信息；</li><li>一个外部类可以有多个内部类，每个内部类可以以不同的方式实现同一个接口或者继承同一个类；</li><li>内部类实例创建时刻并不受到外部类对象创建的限制；</li><li>用内部类不会制造“is-a”关系的混乱，每个内部类都是个实体。</li></ul><h2 id="闭包和回调"><a href="#闭包和回调" class="headerlink" title="闭包和回调"></a>闭包和回调</h2><p><strong>闭包</strong>是一种可调用的对象，它记录了来自创建它的作用域的一些信息。内部类是一种面向对象的闭包，不仅包含了外部类的信息，而且通过包含一个指向外部类对象的引用，可以操作所有成员，包括private。</p><p><strong>回调</strong>，通过其它对象携带的信息，可以在稍后的某个时刻调用初始对象。回调的价值在于灵活性，可以在运行时决定需要调用的方法。 GUI编程将体现得更明显。</p><h2 id="继承内部类"><a href="#继承内部类" class="headerlink" title="继承内部类"></a>继承内部类</h2><pre><code class="java">class Outer {    class Inner {}}public class InheritInner extends Outer.Inner {    //! InheritInner() {} // Won’t compile    InheritInner(Outer o) {        o.super();    }}</code></pre><h2 id="内部类可以被覆盖吗"><a href="#内部类可以被覆盖吗" class="headerlink" title="内部类可以被覆盖吗"></a>内部类可以被覆盖吗</h2><p>继承外部类，如果直接再定义一遍内部类，并不会覆盖原有内部类。若想覆盖原有内部类，必须连同外部类一起，同时显式地继承内部类，然后再重写内部类子类的方法。</p><pre><code class="java">class Outer {    class Inner {        public innerMethod(){System.out.println(&quot;Outer.Inner.innerMethod()&quot;)}    }}public class InheritOuter extends Outer {    public class InheritInner extends Outer.Inner {        public innerMethod(){System.out.println(&quot;InheritOuter.InheritInner.innerMethod()&quot;)}    }}</code></pre><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><p>局部内部类不能有访问限定符；有访问局部final变量和外部类所有成员的权限；可以有命名的构造器；在方法外不能访问。</p><p>绝大部分情况下，可以用匿名类来替代局部内部类，除非：</p><ul><li>需要命名的构造器，或者需要重载构造器</li><li>需要多个内部类的对象</li></ul><br>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java编程思想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Java编程思想》笔记09-接口</title>
      <link href="/2018/03/27/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B%E7%AC%94%E8%AE%B009-%E6%8E%A5%E5%8F%A3/"/>
      <url>/2018/03/27/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B%E7%AC%94%E8%AE%B009-%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<p>优先使用类，而不是接口，除非有充分的必要。</p><p>接口：可以是 <code>public</code> 或 <code>default</code> 只具有包访问权限。</p><p>字段：必 <code>public static final</code>。<br>接口中定义的字段默认都是静态常量。哪怕没有显示声明。</p><p>方法：必 <code>public abstract</code>。<br>接口中所有的方法都是 <code>public abstract</code> 的。哪怕我们没有显式地写出来。</p><a id="more"></a><h1 id="组合接口时的命名冲突"><a href="#组合接口时的命名冲突" class="headerlink" title="组合接口时的命名冲突"></a>组合接口时的命名冲突</h1><pre><code class="java">//: interfaces/InterfaceCollision.javapackage interfaces;interface I1 { void f(); }interface I2 { int f(int i); }interface I3 { int f(); }class C { public int f() { return 1; } }class C2 implements I1, I2 {    public void f() {}    public int f(int i) {return 1;} // overloaded}class C3 extends C implements I2 {    public int f(int i) {return 1;} // overloaded}class C4 extends C implements I3 {    // Identical, no problem:    public int f() {return 1;}}// Methods differ only by return type://! class C5 extends C implements I1 {}//! interface I4 extends I1, I3 {} ///:~</code></pre><p>既然允许一个类同时继承多个接口，接口的方法名称很容易重复。Java 以方法名和参数来区分不同方法。只要有相同的方法名和参数，就被认为是同一个方法。</p><p>所以，最好<strong>根本不要让不同接口里，有同名的方法</strong>。</p><br>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java编程思想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Java编程思想》笔记08-多态</title>
      <link href="/2018/03/27/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B%E7%AC%94%E8%AE%B008-%E5%A4%9A%E6%80%81/"/>
      <url>/2018/03/27/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B%E7%AC%94%E8%AE%B008-%E5%A4%9A%E6%80%81/</url>
      
        <content type="html"><![CDATA[<p>在面向对象的程序设计语言中，<strong>多态</strong>是继数据<strong>抽象</strong>和<strong>继承</strong>之后的第三基本特征。</p><p>多态也称作<strong>动态绑定</strong>、<strong>后期绑定</strong>或<strong>运行时绑定</strong>。</p><a id="more"></a><h1 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h1><p>将一个方法调用同一个方法主体关联起来被称作<strong>绑定</strong>。</p><p>若在程序执行前进行绑定（如果有的话，由编译器和连接程序实现），叫做<strong>前期绑定</strong>。C语言只有前期绑定。</p><p>后期绑定也叫做动态绑定或运行时绑定。含义就是在运行时根据对象的类型进行绑定。</p><p><code>Java</code> 中除了 <code>static</code> 方法和 <code>final</code> 方法（<strong><code>private</code> 方法</strong>属于** <code>final</code> 方法<strong>）之外，</strong>其他所有方法都是后期绑定**。</p><h1 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h1><h2 id="“覆盖”私有方法"><a href="#“覆盖”私有方法" class="headerlink" title="“覆盖”私有方法"></a>“覆盖”私有方法</h2><p>私有方法不可以被覆盖，但子类中存在于父类私有方法名称一致时，也不会报错，但多态会无效。</p><p>所以子类中最好<strong>不要存在于父类私有方法名称一致的方法</strong>。</p><h2 id="域于静态方法"><a href="#域于静态方法" class="headerlink" title="域于静态方法"></a>域于静态方法</h2><p>多态只对“方法”有效，对“字段”无效。子类向父类转型后，直接访问字段，返回值是父类的字段值。一般所有的字段都是 private，所以一般不会有什么影响。同样最好<strong>不要给基类和子类设置同名字段</strong>，也不会出现问题。</p><p>如果某个方法是静态的，它的行为就不具有多态性。因为静态方法是于类，而并非与单个的对象关联的。</p><h2 id="final-方法"><a href="#final-方法" class="headerlink" title="final 方法"></a>final 方法</h2><p>可以防止其他人覆盖该方法，更重要的一点是<strong>可以有效的“关闭”动态绑定</strong>，或者说，告诉编译器不需要对其进行动态绑定。</p><h1 id="继承与清理"><a href="#继承与清理" class="headerlink" title="继承与清理"></a>继承与清理</h1><p>销毁的顺序应该和初始化的顺序相反，先清理子类，再清理父类。</p><p>如 <code>Android</code> 中 <code>Activity</code> 的 <code>onDestroy</code> 方法。</p><pre><code class="java">@Overrideprotected final void onDestroy() {    doDestroy();    super.onDestroy();}</code></pre><p>如果成员对象中存在于其它一个或多个对象共享的情况，问题就复杂了。这种情况下，也许就必须使用<strong>引用计数</strong>来跟踪仍旧访问着共享对象的对象数量了，当共享它的对象全部 dispose，引用计数为 0 时，才会 dispose。</p><pre><code class="java">//: polymorphism/ReferenceCounting.javapackage polymorphism; /* Added by Eclipse.py */// Cleaning up shared member objects.import static net.mindview.util.Print.*;class Shared {    private int refcount = 0;    private static long counter = 0;    private final long id = counter++;    public Shared() {        print(&quot;Creating &quot; + this);    }    public void addRef() {        refcount++;    }    protected void dispose() {        if (--refcount == 0)            print(&quot;Disposing &quot; + this);    }    public String toString() {        return &quot;Shared &quot; + id;    }}class Composing {    private Shared shared;    private static long counter = 0;    private final long id = counter++;    public Composing(Shared shared) {        print(&quot;Creating &quot; + this);        this.shared = shared;        this.shared.addRef();    }    protected void dispose() {        print(&quot;disposing &quot; + this);        shared.dispose();    }    public String toString() {        return &quot;Composing &quot; + id;    }}public class ReferenceCounting {    public static void main(String[] args) {        Shared shared = new Shared();        Composing[] composing = { new Composing(shared), new Composing(shared),                new Composing(shared), new Composing(shared),                new Composing(shared) };        for (Composing c : composing)            c.dispose();    }} /* * Output: * Creating Shared 0 * Creating Composing 0 * Creating Composing 1 * Creating Composing 2 * Creating Composing 3 * Creating Composing 4 * disposing Composing 0 * disposing Composing 1 * disposing Composing 2 * disposing Composing 3 * disposing Composing 4 * Disposing Shared 0 */// :~</code></pre><h1 id="构造器内部的多态方法的行为"><a href="#构造器内部的多态方法的行为" class="headerlink" title="构造器内部的多态方法的行为"></a>构造器内部的多态方法的行为</h1><p>如果在一个构造器的内部调用正在构造的对象的某个动态绑定方法，那会发生什么情况呢？</p><pre><code class="java">class Glyph{    void draw(){System.out.println(&quot;Glyph.draw()&quot;);}    Glyph(){        draw();    }}class RoundGlyph extends Glyph{    private int radius = 1;    Roundglyph(int r){        radius = r;        System.out.println(&quot;Roundglyph.Roundglyph(), radius=&quot; + radius);    }    void draw(){        System.out.println(&quot;Roundglyph.draw(), radius=&quot; + radius);    }}public class PolyConstructors{    public static void main(String[] args){        new RoundGlyph(5);    }}/* output:Roundglyph.draw(), radius=0Roundglyph.RoundGlyph(), radius=5*/</code></pre><p>基类 Glyph 的构造器调用 draw() 方法时，<strong>radius 还没有被初始化，不是 1，而是 0</strong>。这可能导致程序无法正常运转。</p><h2 id="重提类的初始化顺序"><a href="#重提类的初始化顺序" class="headerlink" title="重提类的初始化顺序"></a>重提类的初始化顺序</h2><ol><li><strong>在其他任何事物发生之前，将分配给对象的存储空间初始化成二进制的 0</strong>。</li><li>子类默认递归调用基类构造函数</li><li>成员字段和成员函数初始化，优先处理静态成员</li><li>最后调用自身构造函数</li></ol><h2 id="编写构造器时有一条有效的准则"><a href="#编写构造器时有一条有效的准则" class="headerlink" title="编写构造器时有一条有效的准则"></a>编写构造器时有一条有效的准则</h2><p><strong>“用尽可能简单的方法使对象进入正常状态；如果可以的话，避免调用其它方法”。</strong>构造器中唯一能够安全调用的那些方法是基类中的 final 方法（也适用于 private 方法，它们自动属于 final 方法）</p><h1 id="协变返回类型"><a href="#协变返回类型" class="headerlink" title="协变返回类型"></a>协变返回类型</h1><p><code>Java SE5</code> 中添加了协变返回类型，它表示<strong>在子类中的被覆盖方法可以返回基类方法的返回类型的某种子类型</strong>。</p><br>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java编程思想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Java编程思想》笔记07-复用类</title>
      <link href="/2018/03/19/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B%E7%AC%94%E8%AE%B007-%E5%A4%8D%E7%94%A8%E7%B1%BB/"/>
      <url>/2018/03/19/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B%E7%AC%94%E8%AE%B007-%E5%A4%8D%E7%94%A8%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="怎么用组合和继承？慎用继承！"><a href="#怎么用组合和继承？慎用继承！" class="headerlink" title="怎么用组合和继承？慎用继承！"></a>怎么用组合和继承？慎用继承！</h1><p>到底是用组合好，还是继承好。无法简单地下结论。作者给出两者形象化的思考：</p><ol><li>“<strong>继承</strong>”：<code>IS-A</code> 关系。就是使用某个现有通用类，有通用的一组接口，只是开发出一个特定版本。比如通用类是车-&gt;公共汽车。</li><li>“<strong>组合</strong>”：<code>HAS-A</code> 关系。本质不是同一个东西，接口基本不一样，我们只是想用某些功能。比如发动机-&gt;车。</li></ol><p>“继承”在实战中并不太常用。不应该尽可能地使用继承，而是要慎重。用之前需要问自己一个问题：<strong>是否需要从导出类向基类进行向上转型</strong>？只有必须向上转型的情况才需要用继承。</p><p>所以正确的习惯是：优先考虑“组合”或“代理”。只在确实必要时才考虑“继承”。</p><a id="more"></a><h1 id="final"><a href="#final" class="headerlink" title="final"></a>final</h1><p><code>final</code> 关键字，意味着这个字段，只能被赋值一次！</p><ol><li><strong>基本型</strong>加 <code>final</code> 关键字，成为常量。</li><li><strong>对象</strong>使用 <code>final</code> 关键字很奇怪，只是引用不能再重新指向另一个对象，但对象本事还是能改的。</li><li><strong>全局静态常量</strong>，一般像这样带 <code>public static final</code> 关键字修饰基本型，就是典型的公开静态常量。不但编译时就确认它的值，而且全局独一份儿，而且所有包都可以访问。</li><li><strong><code>final</code> 参数</strong>，<code>java</code> 传递参数的时候传递的不是参数的拷贝，函数内部可以直接改变参数的值。如果给函数传递参数的饿时候加上 <code>final</code>，函数内不能改变参数的值。这个特性主要用来向<strong>匿名内部类</strong>中传递参数用。</li><li><strong>方法</strong>被声明称 <code>final</code> 方法，继承它的子类就不能对父类中的此方法进行重写，覆盖。</li><li><strong>类中的 <code>private</code> 方法</strong>，都相当于 <code>final</code> 方法，因为它对外部类来说不可见，所以没人能够重写它。</li><li><strong>类</strong>前被加上 <code>final</code> 之后，此类无法再被继承。</li></ol><br>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java编程思想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Java编程思想》笔记06-访问权限控制</title>
      <link href="/2018/03/19/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B%E7%AC%94%E8%AE%B006-%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/"/>
      <url>/2018/03/19/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B%E7%AC%94%E8%AE%B006-%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="类访问权限"><a href="#类访问权限" class="headerlink" title="类访问权限"></a>类访问权限</h1><ol><li>一个编译单元（文件）只能有一个 <code>public</code> 类。</li><li>编译单元的 <code>public</code> 类必须与文件同名，包括大小写。</li><li>可能编译单元根本没有 <code>public</code> 类，此时文件名可以任意。不常用。</li></ol><p>类可用的权限应该是 <code>public</code> 和 <code>package access</code>的。不可以是 <code>protected</code> 和 <code>private</code> 。</p><p>注意，<strong>内部类</strong>可以为 <code>protected</code> 和 <code>private</code>。</p><br>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java编程思想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Java编程思想》笔记05-初始化与清理</title>
      <link href="/2018/03/19/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B%E7%AC%94%E8%AE%B005-%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86/"/>
      <url>/2018/03/19/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B%E7%AC%94%E8%AE%B005-%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="finalize-函数"><a href="#finalize-函数" class="headerlink" title="finalize 函数"></a>finalize 函数</h1><p>一旦垃圾回收器准备好释放对象占用的空间，将先调用其 <code>finalize()</code> 方法，并在下一次垃圾回收动作发生时，才会真正的回收对象占用的空间。</p><ol><li>对象可能不被垃圾回收回收。</li><li>垃圾回收不等于“析构”。</li><li>垃圾回收只与内存有关。</li></ol><p><code>System.gc()</code>，建议虚拟机现在执行一次垃圾回收</p><a id="more"></a><h1 id="枚举型"><a href="#枚举型" class="headerlink" title="枚举型"></a>枚举型</h1><pre><code class="java">public enum Spiciness {    NOT, MILD, MEDIUM, HOT, FLAMING}</code></pre><p><code>ordinal()</code> 方法表示某个 <code>enum</code> 常量声明顺序</p><p><code>values()</code> 方法按照 <code>enum</code> 常量的声明顺序，产生由这些常量值构成的数组。</p><pre><code class="java">public class EnumTest {    public static void main(String[] args) {        Spiciness hot = Spiciness.HOT;        System.out.println(hot); // HOT        for (Spiciness s: Spiciness.values()) {            System.out.println(s + &quot;:&quot; + s.ordinal());        }    }}// NOT:0// MILD:1// MEDIUM:2// HOT:3// FLAMING:4</code></pre><br>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java编程思想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Java编程思想》笔记04-控制执行流程</title>
      <link href="/2018/03/19/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B%E7%AC%94%E8%AE%B004-%E6%8E%A7%E5%88%B6%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/"/>
      <url>/2018/03/19/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B%E7%AC%94%E8%AE%B004-%E6%8E%A7%E5%88%B6%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>练习10：吸血鬼数字是指位数为偶数的数字，可以由一对数字相乘而得到，而这对数字各包含乘积的一半位数的数字，其中从最初的数字中选取的数字可以任意排序。以两个 0 结尾的数字是不允许的。写一个程序，找出所有 4 位数的吸血鬼数字。</p><pre><code class="java">public class E10_Vampire {    public static void main(String[] args) {        int[] startDigit = new int[4];        int[] productDigit = new int[4];        for (int num1 = 10; num1 &lt;= 99; num1++)            for (int num2 = num1; num2 &lt;= 99; num2++) {                // Pete Hartley&#39;s theoretical result:                // If x·y is a vampire number then                // x·y == x+y (mod 9)                if ((num1 * num2) % 9 != (num1 + num2) % 9)                    continue;                int product = num1 * num2;                startDigit[0] = num1 / 10;                startDigit[1] = num1 % 10;                startDigit[2] = num2 / 10;                startDigit[3] = num2 % 10;                productDigit[0] = product / 1000;                productDigit[1] = (product % 1000) / 100;                productDigit[2] = product % 1000 % 100 / 10;                productDigit[3] = product % 1000 % 100 % 10;                int count = 0;                for (int x = 0; x &lt; 4; x++) {                    for (int y = 0; y &lt; 4; y++) {                        if (productDigit[x] == startDigit[y]) {                            count++;                            productDigit[x] = -1;                            startDigit[y] = -2;                            if (count == 4)                                System.out.println(num1 + &quot; * &quot; + num2                                        + &quot; : &quot; + product);                        }                    }                }            }    }}</code></pre><blockquote><p>根据 <code>Pete Hartley</code> 的数学公式: 如果 <code>x*y</code> 是吸血鬼数，那么 <code>x*y == x+y (mod 9)</code>。</p></blockquote><br>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java编程思想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Java编程思想》笔记03-操作符</title>
      <link href="/2018/03/19/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B%E7%AC%94%E8%AE%B003-%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
      <url>/2018/03/19/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B%E7%AC%94%E8%AE%B003-%E6%93%8D%E4%BD%9C%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h1><p>在创建 Random 对象时提供种子（用于随机数生成器的初始化值，随机数生成器对于特定的种子值总是产生相同的随机数列）。</p><pre><code class="java">import java.util.Random;public class RandomTest {    public static void main(String[] args) {        // 多次执行该程序，总是打印58        Random random = new Random(47);        System.out.println(random.nextInt(100));    }}</code></pre><a id="more"></a><h1 id="指数计数法"><a href="#指数计数法" class="headerlink" title="指数计数法"></a>指数计数法</h1><pre><code class="java">public class ExpTest {    public static void main(String[] args) {        float expFloat = 1.39e-43f;        expFloat = 1.39E-43f;        System.out.println(expFloat); // 1.39E-43        double expDoble = 47e47d;        double expDoble2 = 47e47;        System.out.println(expDoble); // 4.7E48    }}</code></pre><h1 id="位操作"><a href="#位操作" class="headerlink" title="位操作"></a>位操作</h1><h2 id="按位操作符"><a href="#按位操作符" class="headerlink" title="按位操作符"></a>按位操作符</h2><p><strong>正数</strong>的<strong>原码</strong>，<strong>补码</strong>，<strong>反码</strong>都相同，都等于它本身。</p><p><strong>负数的补码</strong>是：符号位为 1，其余各位求反，末位加 1。<strong>负数的反码</strong>是:符号位为 1，其余各位求反，但末位不加 1。也就是说，反码末位加上 1 就是补码。</p><p>任何信息在计算机中都是以二进制的形式保存的，<code>&amp;</code>、<code>|</code>、<code>^</code>除了可以作为逻辑运算符，也可以做为位算符。<br>它们对两个操作数中的每一个二进制位都进行运算，0 当做 false，1 当做 true。</p><p><code>&amp;</code> ：将两个二进制数每一位进行 &amp; 运算，两边都为 1 结果才为 1，只要有一边是 0，结果就为 0。<br><code>|</code> ：将两个二进制数每一位进行 | 运算，两边都为 0 结果才为 0，只要有一边是 1，结果就为 1。<br><code>^</code> ：将两个二进制数每一位进行 ^ 运算，只要两边不同结果就为 1，相同则为 0。<strong><code>^</code> 两次 结果为原数 <code>6 ^ 3 ^ 3 = 6</code></strong>。<br><code>~</code> ：取反操作符，一元操作符，按位“非”生成与输入位相反的值——若输入 0，则输出 1；输入 1，则输出 0。</p><h2 id="移位操作符"><a href="#移位操作符" class="headerlink" title="移位操作符"></a>移位操作符</h2><p><code>&lt;&lt;</code> ：左移，将二进制的每一位向左移，低位补 0。左移几位就相当于乘以 2 的几次方。<br><code>&gt;&gt;</code> ：右移，将二进制的每一位向右移，原来高位是 0 就补 0，原来高位是 1 就补 1。右移几位就相当于除以 2 的几次方。<br><code>&gt;&gt;&gt;</code> ：无无符号右移，将二进制的每一位向右移，高位补 0。正数移动没区别，负数移动后变为正数。</p><h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><p>Integer 类提供进制转换的方法。</p><pre><code class="java">static String toBinaryString(int i)        以二进制（基数 2）无符号整数形式返回一个整数参数的字符串表示形式。static String toHexString(int i)        以十六进制（基数 16）无符号整数形式返回一个整数参数的字符串表示形式。static String toOctalString(int i)        以八进制（基数 8）无符号整数形式返回一个整数参数的字符串表示形式。</code></pre><br>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java编程思想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Beautiful Soup4 学习</title>
      <link href="/2018/03/18/Beautiful-Soup-%E5%AD%A6%E4%B9%A0/"/>
      <url>/2018/03/18/Beautiful-Soup-%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><a href="http://www.crummy.com/software/BeautifulSoup/" target="_blank" rel="noopener">Beautiful Soup</a> 是一个可以从 HTML 或 XML 文件中提取数据的 Python 库。它能够通过你喜欢的转换器实现惯用的文档导航、查找、修改文档的方式。Beautiful Soup 会帮你节省数小时甚至数天的工作时间。</p><a id="more"></a><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><pre><code class="shell">$ easy_install beautifulsoup4$ pip install beautifulsoup4</code></pre><h1 id="安装解析器"><a href="#安装解析器" class="headerlink" title="安装解析器"></a>安装解析器</h1><p><code>Beautiful Soup</code>支持 <code>Python</code> 标准库中的 <code>HTML</code> 解析器，还支持一些第三方的解析器,其中一个是 <a href="http://lxml.de/" target="_blank" rel="noopener">lxml</a>。根据操作系统不同，可以选择下列方法来安装 <code>lxml</code>：</p><pre><code class="shell">$ easy_install lxml$ pip install lxml</code></pre><p>另一个可供选择的解析器是纯Python实现的 <a href="http://code.google.com/p/html5lib/" target="_blank" rel="noopener">html5lib</a>，<code>html5lib</code> 的解析方式与浏览器相同，可以选择下列方法来安装 <code>html5lib</code>：</p><pre><code class="shell">$ easy_install html5lib$ pip install html5lib</code></pre><table><thead><tr><th align="center">解析器</th><th align="center">使用方法</th><th align="center">优势</th><th align="center">劣势</th></tr></thead><tbody><tr><td align="center">Python标准库</td><td align="center">BeautifulSoup(markup, &quot;html.parser&quot;)</td><td align="center">Python的内置标准库 <br/> 执行速度适中 <br/> 文档容错能力强</td><td align="center">Python 2.7.3 or 3.2.2)前<br/>的版本中文档容错能力差</td></tr><tr><td align="center">lxml HTML 解析器</td><td align="center">BeautifulSoup(markup, &quot;lxml&quot;)</td><td align="center">速度快<br/> 文档容错能力强</td><td align="center">需要安装C语言库</td></tr><tr><td align="center">lxml XML 解析器</td><td align="center">BeautifulSoup(markup, [&quot;lxml-xml&quot;])<br/> BeautifulSoup(markup, &quot;xml&quot;)</td><td align="center">速度快<br/> 唯一支持XML的解析器</td><td align="center">需要安装C语言库</td></tr><tr><td align="center">html5lib</td><td align="center">BeautifulSoup(markup, &quot;html5lib&quot;)</td><td align="center">最好的容错性<br/> 以浏览器的方式解析文档<br/> 生成HTML5格式的文档</td><td align="center">速度慢<br/> 不依赖外部扩展</td></tr></tbody></table><h1 id="Beautiful-Soup-对象"><a href="#Beautiful-Soup-对象" class="headerlink" title="Beautiful Soup 对象"></a>Beautiful Soup 对象</h1><pre><code class="py">from bs4 import BeautifulSoupsoup = BeautifulSoup(open(&quot;index.html&quot;), &quot;lxml&quot;) # 打开本地文件soup = BeautifulSoup(&quot;&lt;html&gt;data&lt;/html&gt;&quot;, &quot;lxml&quot;)# 官网上的例子，可以不加 &quot;lxml&quot;，实际使用不加会报错print(soup.prettify()) # 美化输出&quot;&quot;&quot;&lt;html&gt; &lt;body&gt;  &lt;p&gt;   data  &lt;/p&gt; &lt;/body&gt;&lt;/html&gt;&quot;&quot;&quot;</code></pre><h2 id="Tag"><a href="#Tag" class="headerlink" title="Tag"></a>Tag</h2><pre><code class="py">soup = BeautifulSoup(&#39;&lt;b class=&quot;boldest&quot;&gt;Extremely bold&lt;/b&gt;&#39;, &quot;lxml&quot;)tag = soup.bprint(tag) # &lt;b class=&quot;boldest&quot;&gt;Extremely bold&lt;/b&gt;print(type(tag)) # &lt;class &#39;bs4.element.Tag&#39;&gt;</code></pre><h3 id="name-属性"><a href="#name-属性" class="headerlink" title="name 属性"></a>name 属性</h3><p>可以多次调用 <code>tag.name.name</code></p><pre><code class="py">print(tag.name) # btag.name = &quot;blockquote&quot; # 修改print(tag) # &lt;blockquote class=&quot;boldest&quot;&gt;Extremely bold&lt;/blockquote&gt;</code></pre><h3 id="Attributes-属性"><a href="#Attributes-属性" class="headerlink" title="Attributes 属性"></a>Attributes 属性</h3><p><code>tag</code> 的 <code>Attributes</code> 属性的操作方法与<strong>字典</strong>相同。</p><pre><code class="py">print(tag[&#39;class&#39;]) # [&#39;boldest&#39;]print(tag.attrs) # {&#39;class&#39;: [&#39;boldest&#39;]}# 修改tag[&#39;class&#39;] = &#39;verybold&#39;tag[&#39;id&#39;] = 1print(tag) # &lt;blockquote class=&quot;verybold&quot; id=&quot;1&quot;&gt;Extremely bold&lt;/blockquote&gt;# 删除del tag[&#39;class&#39;]del tag[&#39;id&#39;]print(tag) # &lt;blockquote&gt;Extremely bold&lt;/blockquote&gt;# 访问不存在的属性print(tag[&#39;class&#39;]) # 报错print(tag.get(&#39;class&#39;)) # None</code></pre><h3 id="多值属性"><a href="#多值属性" class="headerlink" title="多值属性"></a>多值属性</h3><p>如果转换的文档是XML格式，那么 tag 中不包含多值属性。</p><p>最常见的多值的属性是 <code>class</code> (一个 tag 可以有多个 CSS 的 class). 还有一些属性 <code>rel</code>，<code>rev</code>，<code>accept-charset</code>，<code>headers</code>，<code>accesskey</code>。在 Beautiful Soup 中多值属性的返回类型是 list：</p><pre><code class="py">css_soup = BeautifulSoup(&#39;&lt;p class=&quot;body strikeout&quot;&gt;&lt;/p&gt;&#39;, &quot;lxml&quot;)print(css_soup.p[&#39;class&#39;]) # [&quot;body&quot;, &quot;strikeout&quot;]css_soup = BeautifulSoup(&#39;&lt;p class=&quot;body&quot;&gt;&lt;/p&gt;&#39;, &quot;lxml&quot;)print(css_soup.p[&#39;class&#39;]) # [&quot;body&quot;]</code></pre><p>将 tag 转换成字符串时，多值属性会合并为一个值</p><pre><code class="py">rel_soup = BeautifulSoup(&#39;&lt;p&gt;Back to the &lt;a rel=&quot;index&quot;&gt;homepage&lt;/a&gt;&lt;/p&gt;&#39;, &quot;lxml&quot;)print(rel_soup.a[&#39;rel&#39;]) # [&#39;index&#39;]rel_soup.a[&#39;rel&#39;] = [&#39;index&#39;, &#39;contents&#39;]print(rel_soup.p) # &lt;p&gt;Back to the &lt;a rel=&quot;index contents&quot;&gt;homepage&lt;/a&gt;&lt;/p&gt;</code></pre><h2 id="NavigableString"><a href="#NavigableString" class="headerlink" title="NavigableString"></a>NavigableString</h2><p>字符串常被包含在 tag 内。Beautiful Soup 用 NavigableString 类来包装 tag 中的字符串。</p><p>下面的一段 HTML 代码将作为例子被多次用到。</p><pre><code class="py">html_doc = &quot;&quot;&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p class=&quot;title&quot;&gt;&lt;b&gt;The Dormouse&#39;s story&lt;/b&gt;&lt;/p&gt;&lt;p class=&quot;story&quot;&gt;Once upon a time there were three little sisters; and their names were&lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,&lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; and&lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;;and they lived at the bottom of a well.&lt;/p&gt;&lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;&quot;&quot;&quot;</code></pre><pre><code class="py">soup = BeautifulSoup(html_doc, &quot;lxml&quot;)print(soup.p.b.string) # The Dormouse&#39;s storysoup.p.b.string.replace_with(&quot;No longer bold&quot;) # 替换print(soup.p.b.string) # No longer boldsoup.p.b.string = &quot;The Dormouse&#39;s story&quot; # 替换print(soup.p.b.string) # The Dormouse&#39;s story</code></pre><p>如果想在 <code>Beautiful Soup</code> 之外使用 <code>NavigableString</code> 对象，需要调用 <code>unicode()</code></p><pre><code class="py">unicode_string = unicode(tag.string)print(unicode_string) # u&#39;Extremely bold&#39;print(type(unicode_string)) # &lt;type &#39;unicode&#39;&gt;</code></pre><h2 id="BeautifulSoup"><a href="#BeautifulSoup" class="headerlink" title="BeautifulSoup"></a>BeautifulSoup</h2><p><code>BeautifulSoup</code> 对象表示的是一个文档的全部内容。大部分时候，可以把它当作 <code>Tag</code> 对象</p><pre><code class="py">print(soup.name) # [document]</code></pre><h2 id="Comment"><a href="#Comment" class="headerlink" title="Comment"></a>Comment</h2><p><code>Comment</code> 对象是一个特殊类型的 <code>NavigableString</code> 对象，注释及特殊字符串对象。</p><pre><code class="py">markup = &quot;&lt;b&gt;&lt;!--Hey, buddy. Want to buy a used parser?--&gt;&lt;/b&gt;&quot;soup = BeautifulSoup(markup, &quot;lxml&quot;)comment = soup.b.stringprint(type(comment)) # &lt;class &#39;bs4.element.Comment&#39;&gt;print(comment) # Hey, buddy. Want to buy a used parser?</code></pre><h2 id="其他对象"><a href="#其他对象" class="headerlink" title="其他对象"></a>其他对象</h2><p><code>CData</code>，<code>ProcessingInstruction</code>，<code>Declaration</code>，<code>Doctype</code> 与 <code>Comment</code> 对象类似，这些类都是 <code>NavigableString</code> 的子类，只是添加了一些额外的方法的字符串独享。下面是用 <code>CDATA</code> 来替代注释的例子：</p><pre><code class="py">from bs4 import CDatacdata = CData(&quot;A CDATA block&quot;)comment.replace_with(cdata)print(soup.b) # &lt;b&gt;&lt;![CDATA[A CDATA block]]&gt;&lt;/b&gt;</code></pre><h1 id="遍历文档树"><a href="#遍历文档树" class="headerlink" title="遍历文档树"></a>遍历文档树</h1><h2 id="子节点"><a href="#子节点" class="headerlink" title="子节点"></a>子节点</h2><p>通过点取属性的方式只能获得当前名字的第一个 tag：</p><pre><code class="py">soup.a# &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;</code></pre><p>如果想要得到所有的 <code>&lt;a&gt;</code> 标签，或是通过名字得到比一个 <code>tag</code> 更多的内容的时候，就可以用 <code>find_all()</code></p><pre><code class="py">soup.find_all(&#39;a&#39;)# [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</code></pre><h3 id="contents-将子节点以列表的方式输出"><a href="#contents-将子节点以列表的方式输出" class="headerlink" title=".contents 将子节点以列表的方式输出"></a>.contents 将子节点以列表的方式输出</h3><p>tag 的 <code>.contents</code> 属性可以将 tag 的子节点以列表的方式输出：</p><pre><code class="py">head_tag = soup.headhead_tag# &lt;head&gt;&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;&lt;/head&gt;head_tag.contents# [&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;]head_tag.contents[0]# &lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;head_tag.contents[0].contents# [u&#39;The Dormouse&#39;s story&#39;]</code></pre><p><code>BeautifulSoup</code> 对象本身一定会包含子节点，也就是说 <code>&lt;html&gt;</code> 标签也是 <code>BeautifulSoup</code> 对象的子节点：</p><pre><code class="py">len(soup.contents)# 1soup.contents[0].name# u&#39;html&#39;</code></pre><h3 id="children-子节点进行循环"><a href="#children-子节点进行循环" class="headerlink" title=".children 子节点进行循环"></a>.children 子节点进行循环</h3><p>通过 <code>tag</code> 的 <code>.children</code> 生成器,可以对 <code>tag</code> 的子节点进行循环：</p><pre><code class="py">for child in head_tag.contents[0].children:    print(child)    # The Dormouse&#39;s story</code></pre><h3 id="descendants-子孙节点进行递归循环"><a href="#descendants-子孙节点进行递归循环" class="headerlink" title=".descendants 子孙节点进行递归循环"></a>.descendants 子孙节点进行递归循环</h3><pre><code class="py">for child in head_tag.descendants:    print(child)    # &lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;    # The Dormouse&#39;s storylen(list(soup.children))# 1len(list(soup.descendants)) # 子孙节点 多# 25</code></pre><h3 id="string"><a href="#string" class="headerlink" title=".string"></a>.string</h3><p>如果 tag 只有<strong>一个</strong> <code>NavigableString</code> 类型子节点，那么这个 tag 可以使用 <code>.string</code> 得到子节点。</p><pre><code class="py">head_tag.contents[0].string# u&#39;The Dormouse&#39;s story&#39;</code></pre><p>如果 tag 包含了多个子节点，tag 就无法确定 <code>.string</code> 方法应该调用哪个子节点的内容，<code>.string</code> 的输出结果是 <code>None</code>。</p><pre><code class="py">print(soup.html.string)# None</code></pre><h3 id="strings-和-stripped-strings"><a href="#strings-和-stripped-strings" class="headerlink" title=".strings 和 stripped_strings"></a>.strings 和 stripped_strings</h3><p>如果 tag 中包含多个字符串，可以使用 <code>.strings</code> 来循环获取：</p><pre><code class="py">for string in soup.find_all(&#39;p&#39;)[1].strings:    print(repr(string))&quot;&quot;&quot;&#39;Once upon a time there were three little sisters; and their names were\n&#39;&#39;Elsie&#39;&#39;,\n&#39;&#39;Lacie&#39;&#39; and\n&#39;&#39;Tillie&#39;&#39;;\nand they lived at the bottom of a well.&#39;&quot;&quot;&quot;</code></pre><p>使用 <code>.stripped_strings</code> 可以去除多余空白内容，全部是空格的行会被忽略掉，段首和段末的空白会被删除。</p><h2 id="父节点"><a href="#父节点" class="headerlink" title="父节点"></a>父节点</h2><h3 id="parent"><a href="#parent" class="headerlink" title=".parent"></a>.parent</h3><p><code>&lt;head&gt;</code> 标签是 <code>&lt;title&gt;</code> 标签的父节点：</p><pre><code class="py">title_tag = soup.titletitle_tag# &lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;title_tag.parent# &lt;head&gt;&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;&lt;/head&gt;</code></pre><p>文档 title 的<strong>字符串也有父节点</strong>：<code>&lt;title&gt;</code> 标签</p><pre><code class="py">title_tag.string.parent# &lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;# 文档的顶层节点比如&lt;html&gt;的父节点是 BeautifulSoup 对象:html_tag = soup.htmltype(html_tag.parent)# &lt;class &#39;bs4.BeautifulSoup&#39;&gt;# BeautifulSoup 对象的 .parent 是None:print(soup.parent)# None</code></pre><h3 id="parents"><a href="#parents" class="headerlink" title=".parents"></a>.parents</h3><p>通过元素的 <code>.parents</code> 属性可以递归得到元素的所有父辈节点,下面的例子使用了 <code>.parents</code> 方法遍历了 <code>&lt;a&gt;</code> 标签到根节点的所有节点。</p><pre><code class="py">link = soup.alink# &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;for parent in link.parents:    if parent is None:        print(parent)    else:        print(parent.name)# p# body# html# [document]# None</code></pre><h2 id="兄弟节点"><a href="#兄弟节点" class="headerlink" title="兄弟节点"></a>兄弟节点</h2><h3 id="next-sibling-和-previous-sibling"><a href="#next-sibling-和-previous-sibling" class="headerlink" title=".next_sibling 和 .previous_sibling"></a>.next_sibling 和 .previous_sibling</h3><pre><code class="py">soup.a.next_sibling # 结果是第一个&lt;a&gt;标签和第二个&lt;a&gt;标签之间的顿号和换行符# u&#39;,\n&#39;soup.a.previous_sibling# Once upon a time there were three little sisters; and their names wereprint(soup.b.previous_sibling) # 没有返回 None# None</code></pre><h3 id="next-siblings-和-previous-siblings"><a href="#next-siblings-和-previous-siblings" class="headerlink" title=".next_siblings 和 .previous_siblings"></a>.next_siblings 和 .previous_siblings</h3><p>通过 <code>.next_siblings</code> 和 <code>.previous_siblings</code> 属性可以对当前节点的兄弟节点迭代输出：</p><pre><code class="py">for sibling in soup.a.next_siblings:    print(repr(sibling))    # u&#39;,\n&#39;    # &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;    # u&#39; and\n&#39;    # &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;    # u&#39;; and they lived at the bottom of a well.&#39;    # Nonefor sibling in soup.find(id=&quot;link3&quot;).previous_siblings:    print(repr(sibling))    # &#39; and\n&#39;    # &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;    # u&#39;,\n&#39;    # &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;    # u&#39;Once upon a time there were three little sisters; and their names were\n&#39;    # None</code></pre><h2 id="回退和前进"><a href="#回退和前进" class="headerlink" title="回退和前进"></a>回退和前进</h2><p>HTML 解析器把这一串字符串转换成一连串的事件： “打开 <code>&lt;html&gt;</code> 标签”，”打开一个 <code>&lt;head&gt;</code> 标签”，”打开一个 <code>&lt;title&gt;</code> 标签”，”添加一段字符串”，”关闭 <code>&lt;title&gt;</code> 标签”，”打开 <code>&lt;p&gt;</code> 标签”，等等。</p><p>Beautiful Soup 提供了重现解析器初始化过程的方法。（不含关闭标签）</p><h3 id="next-element-和-previous-element"><a href="#next-element-和-previous-element" class="headerlink" title=".next_element 和 .previous_element"></a>.next_element 和 .previous_element</h3><p><code>.next_element</code> 属性指向解析过程中下一个被解析的对象：</p><pre><code class="py">soup.find(&quot;a&quot;, id=&quot;link3&quot;).next_sibling# &#39;; and they lived at the bottom of a well.&#39;soup.find(&quot;a&quot;, id=&quot;link3&quot;).next_element# u&#39;Tillie&#39;</code></pre><p><code>.previous_element</code> 属性刚好与 <code>.next_element</code> 相反，它指向当前被解析的对象的前一个解析对象：</p><pre><code class="py">soup.find(&quot;a&quot;, id=&quot;link3&quot;).previous_element# u&#39; and\n&#39;soup.find(&quot;a&quot;, id=&quot;link3&quot;).previous_element.next_element# &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;</code></pre><h3 id="next-elements-和-previous-elements"><a href="#next-elements-和-previous-elements" class="headerlink" title=".next_elements 和 .previous_elements"></a>.next_elements 和 .previous_elements</h3><p>通过 <code>.next_elements</code> 和 <code>.previous_elements</code> 的迭代器就可以向前或向后访问文档的解析内容，就好像文档正在被解析一样：</p><pre><code class="py">for element in soup.find(&quot;a&quot;, id=&quot;link3&quot;).next_elements:    print(repr(element))# u&#39;Tillie&#39;# u&#39;;\nand they lived at the bottom of a well.&#39;# u&#39;\n\n&#39;# &lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;# u&#39;...&#39;# u&#39;\n&#39;# None</code></pre><h1 id="搜索文档树"><a href="#搜索文档树" class="headerlink" title="搜索文档树"></a>搜索文档树</h1><h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p>过滤器可以被用在 tag 的 name 中，节点的属性中，字符串中或他们的混合中。</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>Beautiful Soup会查找与字符串完整匹配的标签。</p><pre><code class="py">soup.find_all(&#39;b&#39;)# [&lt;b&gt;The Dormouse&#39;s story&lt;/b&gt;]</code></pre><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>如果传入正则表达式作为参数，Beautiful Soup 会通过正则表达式的 <code>match()</code> 来匹配内容。下面例子中找出所有以 <code>b</code> 开头的标签，这表示 <code>&lt;body&gt;</code> 和 <code>&lt;b&gt;</code> 标签都应该被找到：</p><pre><code class="py">import refor tag in soup.find_all(re.compile(&quot;^b&quot;)):    print(tag.name)# body# b</code></pre><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>如果传入列表参数，Beautiful Soup 会将与列表中任一元素匹配的内容返回。下面代码找到文档中所有 <code>&lt;a&gt;</code> 标签和 <code>&lt;b&gt;</code> 标签：</p><pre><code class="py">soup.find_all([&quot;a&quot;, &quot;b&quot;])# [&lt;b&gt;The Dormouse&#39;s story&lt;/b&gt;,#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</code></pre><h3 id="True"><a href="#True" class="headerlink" title="True"></a>True</h3><p><code>True</code> 可以匹配任何值，下面代码查找到所有的 tag，但是不会返回字符串节点</p><pre><code class="py">for tag in soup.find_all(True):    print(tag.name)# html# head# title# body# p# b# p# a# a# a# p</code></pre><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>如果没有合适过滤器，那么还可以定义一个方法，方法只接受一个元素参数，如果这个方法返回 <code>True</code> 表示当前元素匹配并且被找到，如果不是则反回 <code>False</code></p><p>下面方法校验了当前元素，如果包含 <code>class</code> 属性却不包含 <code>id</code> 属性，那么将返回 <code>True</code>:</p><pre><code class="py">def has_class_but_no_id(tag):    return tag.has_attr(&#39;class&#39;) and not tag.has_attr(&#39;id&#39;)</code></pre><p>将这个方法作为参数传入 <code>find_all()</code> 方法，将得到所有 <code>&lt;p&gt;</code> 标签:</p><pre><code class="py">soup.find_all(has_class_but_no_id)# [&lt;p class=&quot;title&quot;&gt;&lt;b&gt;The Dormouse&#39;s story&lt;/b&gt;&lt;/p&gt;,#  &lt;p class=&quot;story&quot;&gt;Once upon a time there were...&lt;/p&gt;,#  &lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;]</code></pre><h2 id="find-all"><a href="#find-all" class="headerlink" title="find_all()"></a>find_all()</h2><blockquote><p>find_all( name , attrs , recursive , string , **kwargs )</p></blockquote><h3 id="name-参数"><a href="#name-参数" class="headerlink" title="name 参数"></a>name 参数</h3><p><code>name 参数</code> 可以查找所有名字为 name 的 tag。</p><p>用法如上，<code>name 参数</code> 的值可以使任一类型的 <strong>过滤器</strong>。</p><h3 id="keyword-参数"><a href="#keyword-参数" class="headerlink" title="keyword 参数"></a>keyword 参数</h3><p>如果一个指定名字的参数不是搜索内置的参数名，搜索时会把该参数当作指定名字 tag 的属性来搜索。</p><pre><code class="py">soup.find_all(id=&#39;link2&#39;, href=re.compile(&quot;lacie&quot;))# [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;]</code></pre><p>搜索指定名字的属性时可以使用的参数值包括 <strong>字符串，正则表达式，列表，True</strong>。</p><h3 id="attrs-参数"><a href="#attrs-参数" class="headerlink" title="attrs 参数"></a>attrs 参数</h3><p>有些 tag 属性在搜索不能使用，可以通过 <code>find_all()</code> 方法的 <code>attrs</code> 参数定义一个字典参数来搜索包含特殊属性的 tag：</p><pre><code class="py">data_soup = BeautifulSoup(&#39;&lt;div data-foo=&quot;value&quot;&gt;foo!&lt;/div&gt;&#39;, &quot;lxml&quot;)data_soup.find_all(data-foo=&quot;value&quot;)# SyntaxError: keyword can&#39;t be an expressiondata_soup.find_all(attrs={&quot;data-foo&quot;: &quot;value&quot;})# [&lt;div data-foo=&quot;value&quot;&gt;foo!&lt;/div&gt;]</code></pre><h3 id="按CSS类名搜索"><a href="#按CSS类名搜索" class="headerlink" title="按CSS类名搜索"></a>按CSS类名搜索</h3><p>标识 CSS 类名的关键字 <code>class</code> 在 Python 中是保留字，使用 <code>class</code> 做参数会导致语法错误。所以可以使用 <code>class_</code>。</p><pre><code class="py">soup.find_all(&quot;a&quot;, class_=&quot;sister&quot;, id=&quot;link2&quot;)# [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;]</code></pre><p>当然也可以使用<code>attrs</code> 参数，<code>soup.find_all(&quot;a&quot;, attrs={&quot;class&quot;: &quot;sister&quot;})</code>。</p><h3 id="string-参数"><a href="#string-参数" class="headerlink" title="string 参数"></a>string 参数</h3><p>通过 <code>string 参数</code>可以搜搜文档中的字符串内容。<code>string 参数</code>接受 <strong>字符串，正则表达式，列表，True，方法</strong> 。</p><pre><code class="py">def is_the_only_string_within_a_tag(s):    &quot;&quot;&quot;Return True if this string is the only child of its parent tag.&quot;&quot;&quot;    return (s == s.parent.string)print(soup.find_all(string=is_the_only_string_within_a_tag))# [&quot;The Dormouse&#39;s story&quot;, &quot;The Dormouse&#39;s story&quot;, &#39;Elsie&#39;, &#39;Lacie&#39;, &#39;Tillie&#39;, &#39;...&#39;]soup.find_all(&quot;a&quot;, string=&quot;Elsie&quot;)# [&lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;]</code></pre><h3 id="limit-参数"><a href="#limit-参数" class="headerlink" title="limit 参数"></a>limit 参数</h3><p>使用 <code>limit 参数</code>限制返回结果的数量。</p><pre><code class="py">print(soup.find_all(&quot;a&quot;, limit=2))# [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;]</code></pre><h3 id="recursive-参数"><a href="#recursive-参数" class="headerlink" title="recursive 参数"></a>recursive 参数</h3><p>调用 tag 的 <code>find_all()</code> 方法时，Beautiful Soup 会检索当前 tag 的所有子孙节点，如果只想搜索 tag 的直接子节点，可以使用参数 <code>recursive=False</code>。</p><pre><code class="py">soup.html.find_all(&quot;title&quot;)# [&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;]soup.html.find_all(&quot;title&quot;, recursive=False)# []</code></pre><h3 id="像调用-find-all-一样调用tag"><a href="#像调用-find-all-一样调用tag" class="headerlink" title="像调用 find_all() 一样调用tag"></a>像调用 find_all() 一样调用tag</h3><p>BeautifulSoup 对象和 tag 对象可以被当作一个方法来使用，这个方法的执行结果与调用这个对象的 find_all() 方法相同，下面两行代码是等价的：</p><pre><code class="py">soup.find_all(&quot;a&quot;)soup(&quot;a&quot;)soup.a # 相当于 soup.find(&quot;a&quot;)soup.title.find_all(string=True)soup.title(string=True)</code></pre><h3 id="find"><a href="#find" class="headerlink" title="find()"></a>find()</h3><p>相当于使用 <code>find_all()</code> 方法并设置 <code>limit=1</code> 参数。<br>唯一的区别是 <code>find_all()</code> 方法的返回结果是值包含一个元素的列表，而 <code>find()</code> 方法直接返回结果。<code>find_all()</code> 方法没有找到目标是返回空列表，<code>find()</code> 方法找不到目标时，返回 <code>None</code></p><h2 id="find-parents-和-find-parent"><a href="#find-parents-和-find-parent" class="headerlink" title="find_parents() 和 find_parent()"></a>find_parents() 和 find_parent()</h2><p><code>find_all()</code> 和 <code>find()</code> 只搜索当前节点的所有子节点，孙子节点等。<code>find_parents()</code> 和 <code>find_parent()</code> 用来搜索当前节点的父辈节点，搜索方法与普通 tag 的搜索方法相同，搜索文档搜索文档包含的内容。</p><h2 id="find-next-siblings-和-find-next-sibling"><a href="#find-next-siblings-和-find-next-sibling" class="headerlink" title="find_next_siblings() 和 find_next_sibling()"></a>find_next_siblings() 和 find_next_sibling()</h2><p>这2个方法通过 <code>.next_siblings</code> 属性对当 tag 的所有后面解析的兄弟 tag 节点进行迭代， <code>find_next_siblings()</code> 方法返回所有符合条件的后面的兄弟节点，<code>find_next_sibling()</code> 只返回符合条件的后面的第一个 tag 节点。</p><h2 id="find-previous-siblings-和-find-previous-sibling"><a href="#find-previous-siblings-和-find-previous-sibling" class="headerlink" title="find_previous_siblings() 和 find_previous_sibling()"></a>find_previous_siblings() 和 find_previous_sibling()</h2><p>这2个方法通过 <code>.previous_siblings</code> 属性对当前 tag 的前面解析的兄弟 tag 节点进行迭代，<code>find_previous_siblings()</code> 方法返回所有符合条件的前面的兄弟节点，<code>find_previous_sibling()</code> 方法返回第一个符合条件的前面的兄弟节点。</p><h2 id="find-all-next-和-find-next"><a href="#find-all-next-和-find-next" class="headerlink" title="find_all_next() 和 find_next()"></a>find_all_next() 和 find_next()</h2><p>这2个方法通过 <code>.next_elements</code> 属性对当前tag的之后的 tag 和字符串进行迭代，<code>find_all_next()</code> 方法返回所有符合条件的节点，<code>find_next()</code> 方法返回第一个符合条件的节点。</p><h2 id="find-all-previous-和-find-previous"><a href="#find-all-previous-和-find-previous" class="headerlink" title="find_all_previous() 和 find_previous()"></a>find_all_previous() 和 find_previous()</h2><p>这2个方法通过 <code>.previous_elements</code> 属性对当前节点前面的 tag 和字符串进行迭代，<code>find_all_previous()</code> 方法返回所有符合条件的节点，<code>find_previous()</code> 方法返回第一个符合条件的节点。</p><h1 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h1><p>Beautiful Soup 支持大部分的<a href="http://www.w3.org/TR/CSS2/selector.html" target="_blank" rel="noopener">CSS选择器</a>， 在 Tag 或 BeautifulSoup 对象的 <code>.select()</code> 方法中传入字符串参数，即可使用 CSS 选择器的语法找到 tag。</p><pre><code class="py">soup.select(&quot;title&quot;)# [&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;]soup.select(&quot;p:nth-of-type(3)&quot;)# [&lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;]# 同时用多种CSS选择器查询元素soup.select(&quot;#link1,#link2&quot;)# [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;]# 返回查找到的元素的第一个soup.select_one(&quot;.sister&quot;)# &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;</code></pre><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p><a href="http://beautifulsoup.readthedocs.io/zh_CN/latest/#id44" target="_blank" rel="noopener">修改文档树</a>，<a href="http://beautifulsoup.readthedocs.io/zh_CN/latest/#id48" target="_blank" rel="noopener">输出</a>，<a href="http://beautifulsoup.readthedocs.io/zh_CN/latest/#id55" target="_blank" rel="noopener">编码</a>，<a href="http://beautifulsoup.readthedocs.io/zh_CN/latest/#id64" target="_blank" rel="noopener">解析部分文档</a>等，详情可看官方文档。</p><blockquote><p><a href="http://beautifulsoup.readthedocs.io/zh_CN/latest/" target="_blank" rel="noopener">官方文档</a></p></blockquote><br>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VSCode 使用</title>
      <link href="/2018/03/18/VSCode%20%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/"/>
      <url>/2018/03/18/VSCode%20%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="禁用-GPU-硬件加速"><a href="#禁用-GPU-硬件加速" class="headerlink" title="禁用 GPU 硬件加速"></a>禁用 GPU 硬件加速</h1><p>因为使用 <code>TeamViewer</code> 时，对于开启硬件加速的应用无法显示。</p><p>解决办法是在启动时加 <code>--disable-gpu</code> 参数，如：</p><pre><code class="shell">&quot;C:\Program Files (x86)\Microsoft VS Code\Code.exe&quot; --disable-gpu</code></pre><blockquote><p><a href="https://www.zhihu.com/question/57583720/answer/153467759" target="_blank" rel="noopener">atom，vs2017、vscode 在 win10 下界面显示模糊怎么办？ - 包包的回答 - 知乎</a></p></blockquote><a id="more"></a><h1 id="常用设置"><a href="#常用设置" class="headerlink" title="常用设置"></a>常用设置</h1><pre><code class="json">{    // &quot;editor.wordWrap&quot;: &quot;on&quot;,  // 自动换行    &quot;workbench.statusBar.visible&quot;: true,  // 控制工作台底部状态栏的可见性    &quot;workbench.activityBar.visible&quot;: false, // 控制工作台中活动栏的可见性（左侧）    &quot;editor.fontFamily&quot;: &quot;&#39;Fira Code&#39;,Consolas,&#39;Microsoft Yahei&#39;,  &#39;Courier New&#39;, monospace&quot;,    &quot;editor.fontLigatures&quot;: true,  // 启用或禁用字体连字    &quot;editor.fontSize&quot;:18,    &quot;editor.minimap.enabled&quot;:false,  // 控制是否显示缩略图    &quot;workbench.startupEditor&quot;: &quot;newUntitledFile&quot;,  // 在没有从上一会话中恢复出信息的情况下，控制启动时显示的编辑器。新建空白文件    &quot;files.autoGuessEncoding&quot;: true,  // 在文件打开时尝试猜测字符集编码。可以按语言对此项进行配置    &quot;sync.gist&quot;: &quot;0d930e43a4a9c8709005dXXXXXX&quot;,  // 使用 Settings Sync 扩展，进行同步    // &quot;sync.autoUpload&quot;: true,    &quot;workbench.colorTheme&quot;: &quot;Material Theme Ocean&quot;,  // Material Theme 扩展，主题    // tab长度    &quot;editor.tabSize&quot;: 4,    // 启用后，将在保存文件时剪裁尾随空格。    &quot;files.trimTrailingWhitespace&quot;: true,    // 配置 glob 模式以排除文件和文件夹。    &quot;files.exclude&quot;: {      &quot;**/.git&quot;: true,      &quot;**/.svn&quot;: true,      &quot;**/.DS_Store&quot;: true,      &quot;**/.idea&quot;: true    },}</code></pre><h1 id="常用插件"><a href="#常用插件" class="headerlink" title="常用插件"></a>常用插件</h1><ol><li><a href="https://marketplace.visualstudio.com/items?itemName=MS-CEINTL.vscode-language-pack-zh-hans" target="_blank" rel="noopener">适用于 VS Code 的中文（简体）语言包</a></li><li>设置同步 <a href="https://marketplace.visualstudio.com/items?itemName=Shan.code-settings-sync" target="_blank" rel="noopener">Settings Sync</a></li><li>翻译 <a href="https://marketplace.visualstudio.com/items?itemName=intellsmi.comment-translate" target="_blank" rel="noopener">Comment Translate</a></li><li><a href="https://marketplace.visualstudio.com/items?itemName=vscode-icons-team.vscode-icons" target="_blank" rel="noopener">vscode-icons</a></li><li>Markdown 语法支持 <a href="https://marketplace.visualstudio.com/items?itemName=yzhang.markdown-all-in-one" target="_blank" rel="noopener">Markdown All in One</a></li><li>Markdown 预览增强 <a href="https://marketplace.visualstudio.com/items?itemName=shd101wyy.markdown-preview-enhanced" target="_blank" rel="noopener">Markdown Preview Enhanced</a></li><li>Markdown 样式检查 <a href="https://marketplace.visualstudio.com/items?itemName=DavidAnson.vscode-markdownlint" target="_blank" rel="noopener">markdownlint</a></li><li>外观主题 <a href="https://marketplace.visualstudio.com/items?itemName=Equinusocio.vsc-material-theme" target="_blank" rel="noopener">Material Theme</a></li><li>二进制文件查看 <a href="https://marketplace.visualstudio.com/items?itemName=slevesque.vscode-hexdump" target="_blank" rel="noopener">hexdump for VSCode</a></li><li>IDEA 快捷键 <a href="https://marketplace.visualstudio.com/items?itemName=k--kato.intellij-idea-keybindings" target="_blank" rel="noopener">IntelliJ IDEA Keybindings</a></li><li>代码智能提示 <a href="https://marketplace.visualstudio.com/items?itemName=VisualStudioExptTeam.vscodeintellicode" target="_blank" rel="noopener">Visual Studio IntelliCode</a></li><li>Java 编程 <a href="https://marketplace.visualstudio.com/items?itemName=vscjava.vscode-java-pack" target="_blank" rel="noopener">Java Extension Pack</a>，该插件会安装多个插件</li><li>Python 编程 <a href="https://marketplace.visualstudio.com/items?itemName=ms-python.python" target="_blank" rel="noopener">Python</a></li></ol><h1 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h1><h2 id="隐藏左边栏"><a href="#隐藏左边栏" class="headerlink" title="隐藏左边栏"></a>隐藏左边栏</h2><p>查看--&gt; 外观--&gt; 切换侧边栏</p><p>快捷键 Ctrl+B</p><p>因与 Markdown 的快捷键冲突，个人修改为 Alt+B</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VSCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java大数操作（BigInteger，BigDecimal）</title>
      <link href="/2018/03/17/Java%20%E5%A4%A7%E6%95%B0%E6%93%8D%E4%BD%9C%EF%BC%88BigInteger%EF%BC%8CBigDecimal%EF%BC%89/"/>
      <url>/2018/03/17/Java%20%E5%A4%A7%E6%95%B0%E6%93%8D%E4%BD%9C%EF%BC%88BigInteger%EF%BC%8CBigDecimal%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="BigInteger"><a href="#BigInteger" class="headerlink" title="BigInteger"></a>BigInteger</h1><p>不可变的任意精度的整数。所有操作中，都以二进制补码形式表示 <code>BigInteger</code>（如 <code>Java</code> 的基本整数类型）。<code>BigInteger</code> 提供所有 <code>Java</code> 的基本整数操作符的对应物，并提供 <code>java.lang.Math</code> 的<strong>所有相关方法</strong>。另外，<code>BigInteger</code> 还提供以下运算：模算术、GCD 计算、质数测试、素数生成、位操作以及一些其他操作。</p><a id="more"></a><h2 id="创建一个BigInteger-常用方式"><a href="#创建一个BigInteger-常用方式" class="headerlink" title="创建一个BigInteger 常用方式"></a>创建一个BigInteger 常用方式</h2><p>（1）使用构造函数</p><pre><code class="java">// 将 BigInteger 的十进制字符串表示形式转换为 BigInteger。BigInteger base = new BigInteger(&quot;16&quot;);</code></pre><p>（2）静态方法</p><pre><code class="java">// 返回其值等于指定 long 的值的 BigInteger。// 返回 BigInteger，如果值在 -16-16 之间，那么返回的 BigInteger是同一个对象。BigInteger base = BigInteger.valueOf(16);System.out.println(BigInteger.valueOf(16) == BigInteger.valueOf(16));//trueSystem.out.println(BigInteger.valueOf(17) == BigInteger.valueOf(17));//falseSystem.out.println(BigInteger.valueOf(-16) == BigInteger.valueOf(-16));//trueSystem.out.println(BigInteger.valueOf(-17) == BigInteger.valueOf(-17));//false</code></pre><h2 id="常见运算操作方法"><a href="#常见运算操作方法" class="headerlink" title="常见运算操作方法"></a>常见运算操作方法</h2><pre><code class="java">import java.math.BigInteger;public class BigIntegerDemo1 {    public static void main(String[] args) {        BigInteger bi1 = new BigInteger(&quot;123456789&quot;);  // 声明BigInteger对象        BigInteger bi2 = new BigInteger(&quot;987654321&quot;);  // 声明BigInteger对象        System.out.println(&quot;加法操作：&quot; + bi2.add(bi1));    // 加法操作        System.out.println(&quot;减法操作：&quot; + bi2.subtract(bi1));   // 减法操作        System.out.println(&quot;乘法操作：&quot; + bi2.multiply(bi1));   // 乘法操作        System.out.println(&quot;除法操作：&quot; + bi2.divide(bi1)); // 除法操作        BigInteger result[] = bi2.divideAndRemainder(bi1); // 求出余数的除法操作        System.out.println(&quot;商是：&quot; + result[0] + &quot;；余数是：&quot; + result[1]);        System.out.println(&quot;最大数：&quot; + bi2.max(bi1));  // 求出最大数        System.out.println(&quot;最小数：&quot; + bi2.min(bi1));  // 求出最小数    }}</code></pre><h1 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h1><p>不可变的、任意精度的有符号十进制数。</p><h2 id="创建一个BigDecimal常用方式"><a href="#创建一个BigDecimal常用方式" class="headerlink" title="创建一个BigDecimal常用方式"></a>创建一个BigDecimal常用方式</h2><p>（1）使用构造函数</p><pre><code class="java">BigDecimal b1 = new BigDecimal(&quot;12.1&quot;);</code></pre><p>（2）静态方法</p><pre><code class="java">// 参数是 double 类型BigDecimal b2 = BigDecimal.valueOf(12.1);</code></pre><h2 id="常见运算操作方法-1"><a href="#常见运算操作方法-1" class="headerlink" title="常见运算操作方法"></a>常见运算操作方法</h2><pre><code class="java">import java.math.BigDecimal;public class BigDecimalDemo {    public static void main(String[] args) {        BigDecimal b1 = new BigDecimal(&quot;10.345&quot;);        BigDecimal b2 = new BigDecimal(&quot;3.333&quot;);        System.out.println(&quot;加法运算：&quot; + b1.add(b2)); // 13.678        System.out.println(&quot;减法运算：&quot; + b1.subtract(b2)); // 7.012        System.out.println(&quot;乘法运算：&quot; + b1.multiply(b2)); // 34.479885        // System.out.println(&quot;除法运算：&quot; + b1.divide(b2) // 报错，            // 返回一个 BigDecimal，其值为 (this / divisor)，其首选标度为 (this.scale() - divisor.scale())；            // 如果无法表示准确的商值（因为它有无穷的十进制扩展），则抛出 ArithmeticException。        System.out.println(&quot;除法运算：&quot; + b1.divide(b2, 3, BigDecimal.ROUND_HALF_EVEN)); // 3.104        System.out.println(&quot;除法运算：&quot; + b1.divide(b2, BigDecimal.ROUND_HALF_EVEN)); // 3.104，其标度为 this.scale()。        System.out.println(&quot;加法运算：&quot; + MyMath.round(MyMath.add(10.345, 3.333), 1)); // 13.7        System.out.println(&quot;减法运算：&quot; + MyMath.round(MyMath.sub(10.345, 3.333), 3)); // 7.012        System.out.println(&quot;乘法运算：&quot; + MyMath.round(MyMath.mul(10.345, 3.333), 4)); // 34.4799        System.out.println(&quot;除法运算：&quot; + MyMath.div(10.345, 3.333, 3)); // 3.104    }}class MyMath {    public static double add(double d1, double d2) { // 进行加法计算        BigDecimal b1 = new BigDecimal(d1);        BigDecimal b2 = new BigDecimal(d2);        return b1.add(b2).doubleValue(); // 将此 BigDecimal 转换为 double。    }    public static double sub(double d1, double d2) { // 进行减法计算        BigDecimal b1 = new BigDecimal(d1);        BigDecimal b2 = new BigDecimal(d2);        return b1.subtract(b2).doubleValue();    }    public static double mul(double d1, double d2) { // 进行乘法计算        BigDecimal b1 = new BigDecimal(d1);        BigDecimal b2 = new BigDecimal(d2);        return b1.multiply(b2).doubleValue();    }    public static double div(double d1, double d2, int len) { // 进行除法计算        BigDecimal b1 = new BigDecimal(d1);        BigDecimal b2 = new BigDecimal(d2);        return b1.divide(b2, len, BigDecimal.ROUND_HALF_UP).doubleValue();    }    /*    进行四舍五入     */    public static double round(double d, int len) {        BigDecimal b1 = new BigDecimal(d);        BigDecimal b2 = new BigDecimal(1); // 技巧        return b1.divide(b2, len, BigDecimal.ROUND_HALF_UP).doubleValue();    }}</code></pre><h2 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h2><pre><code class="java">BigDecimal divide(BigDecimal divisor)          返回一个 BigDecimal，其值为 (this / divisor)，其首选标度为 (this.scale() - divisor.scale())；          如果无法表示准确的商值（因为它有无穷的十进制扩展），则抛出 ArithmeticException。BigDecimal divide(BigDecimal divisor, int roundingMode)          返回一个 BigDecimal，其值为 (this / divisor)，其标度为 this.scale()。BigDecimal divide(BigDecimal divisor, int scale, int roundingMode)          返回一个 BigDecimal，其值为 (this / divisor)，其标度为指定标度scale。</code></pre><h2 id="舍入模式"><a href="#舍入模式" class="headerlink" title="舍入模式"></a>舍入模式</h2><pre><code class="java">static int ROUND_CEILING          接近正无穷大的舍入模式。static int ROUND_DOWN          接近零的舍入模式。static int ROUND_FLOOR          接近负无穷大的舍入模式。static int ROUND_HALF_DOWN          向“最接近的”数字舍入，如果与两个相邻数字的距离相等，则为上舍入的舍入模式。static int ROUND_HALF_EVEN          向“最接近的”数字舍入，如果与两个相邻数字的距离相等，则向相邻的偶数舍入。static int ROUND_HALF_UP          向“最接近的”数字舍入，如果与两个相邻数字的距离相等，则为向上舍入的舍入模式。static int ROUND_UNNECESSARY          断言请求的操作具有精确的结果，因此不需要舍入。static int ROUND_UP          舍入远离零的舍入模式。</code></pre><h2 id="华为机试题"><a href="#华为机试题" class="headerlink" title="华为机试题"></a>华为机试题</h2><p>写出一个程序，接受一个十六进制的数值字符串，输出该数值的十进制字符串。（多组同时输入 ）</p><pre><code class="java">import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.math.BigInteger;public class BinHexOct {    public static void main(String[] args) {        test2();    }    /*    直接使用的JavaAPI--Integer提供的方法，将十六进制进行转换     */    private static void test1() {        BufferedReader bufr = new BufferedReader(new InputStreamReader(System.in));        String line;        try {            while ((line = bufr.readLine()) != null) {                line = line.substring(2);                int result = Integer.parseInt(line, 16);                System.out.println(result);            }        } catch (IOException e) {            e.printStackTrace();        }    }    /*    处理大数的情况     */    public static void test2() {        BufferedReader bufr = new BufferedReader(new InputStreamReader(System.in));        String line;        BigInteger base = new BigInteger(&quot;16&quot;);        try {            while ((line = bufr.readLine()) != null) {                line = line.substring(2);                //int result = Integer.parseInt(line, 16);                BigInteger result = new BigInteger(&quot;0&quot;);                for (int i = 0; i &lt; line.length(); i++) {                    char ch = line.charAt(line.length() - 1 - i);                    if (ch &gt;= &#39;A&#39; &amp;&amp; ch &lt;= &#39;F&#39;) {                        //pow n的m次幂，返回 BigInteger                        BigInteger tmp = base.pow(i).multiply(new BigInteger(Integer.toString((ch - &#39;A&#39; + 10))));                        result = result.add(tmp);                    } else {                        BigInteger tmp = base.pow(i).multiply(new BigInteger(Character.toString(ch)));                        result = result.add(tmp);                    }                }                System.out.println(result);            }        } catch (IOException e) {            e.printStackTrace();        }    }}</code></pre><blockquote><p><a href="http://blog.csdn.net/zhongkelee/article/details/52289163" target="_blank" rel="noopener">http://blog.csdn.net/zhongkelee/article/details/52289163</a><br><a href="https://docs.oracle.com/javase/7/docs/api/java/math/BigInteger.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/7/docs/api/java/math/BigInteger.html</a><br><a href="https://docs.oracle.com/javase/7/docs/api/java/math/BigDecimal.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/7/docs/api/java/math/BigDecimal.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Java编程思想》笔记02-一切都是对象</title>
      <link href="/2018/03/15/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B%E7%AC%94%E8%AE%B002-%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1/"/>
      <url>/2018/03/15/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B%E7%AC%94%E8%AE%B002-%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-中-5-个存放数据的地方"><a href="#Java-中-5-个存放数据的地方" class="headerlink" title="Java 中 5 个存放数据的地方"></a>Java 中 5 个存放数据的地方</h1><ol><li><p><strong>寄存器(Registers)</strong>：位于 CPU 内部，是速度最快的存储区，但是数量和容量有限。在 Java 中不能直接操作寄存器。</p></li><li><p><strong>栈(Stack)</strong>：栈位于通用随机访问存储器 (General random-access memory，RAM，内存) 中，通过处理器的栈指针访问，栈指针从栈顶向栈底分配内存，从栈底向栈顶释放内存。栈是仅次于寄存器的速度第二快的存储器，在 Java 程序中，一般的 8 种基本类型数据和对象的引用通常存放在栈内存中，不通过 new 关键字的字符串对象也是存放在栈的字符串池中。栈的优势是，存取速度比堆要快，仅次于寄存器，栈数据可以共享。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。</p></li><li><p><strong>堆(Heap)</strong>：也是位于通用随机访问存储器 (General random-access memory，RAM，内存) 中的共享内存池。Java 的堆是一个运行时数据区，类的对象从中分配空间，凡是通过 new 关键字创建的对象都存放在堆内存中，它们不需要程序代码来显式的释放。堆是由垃圾回收来负责的，堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，因为它是在运行时动态分配内存的，Java 的垃圾收集器会自动收走这些不再使用的数据。但缺点是，由于要在运行时动态分配内存，存取速度较慢。</p></li><li><p><strong>常量存储器(Constant storage)</strong>：Java 中的常量是存放在系统内嵌的只读存储器中(read-only memory, ROM)的。</p></li><li><p><strong>非随机存储器(Non-RAM storage)</strong>：对于流对象和持久化对象，通常存放在程序外的存储器，如硬盘。</p></li></ol><a id="more"></a><h1 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h1><p>基本类型的变量并非引用，直接存储“值”，并置于堆栈中。</p><p>Java 中，没有无符号数，基本类型占用空间的大小也不会像其它语言随机器硬件架构变化。</p><table><thead><tr><th align="center">基本类型</th><th align="center">大小</th><th align="center">默认值</th><th align="center">最小值</th><th align="center">最大值</th><th align="center">包装器类型</th></tr></thead><tbody><tr><td align="center">boolean</td><td align="center">-</td><td align="center">false</td><td align="center">-</td><td align="center">-</td><td align="center">Boolean</td></tr><tr><td align="center">char</td><td align="center">16 bits</td><td align="center">&#39;\u0000&#39;(null)</td><td align="center">Unicode 0</td><td align="center">Unicode $2^{16}$-1</td><td align="center">Character</td></tr><tr><td align="center">byte</td><td align="center">8 bits</td><td align="center">(byte)0</td><td align="center">-128</td><td align="center">+127</td><td align="center">Byte</td></tr><tr><td align="center">short</td><td align="center">16 bits</td><td align="center">(short)0</td><td align="center">-$2^{15}$</td><td align="center">+$2^{15}$-1</td><td align="center">Short</td></tr><tr><td align="center">int</td><td align="center">32 bits</td><td align="center">0</td><td align="center">-$2^{31}$</td><td align="center">+$2^{31}$-1</td><td align="center">Integer</td></tr><tr><td align="center">long</td><td align="center">64 bits</td><td align="center">0L</td><td align="center">-$2^{63}$</td><td align="center">+$2^{63}$-1</td><td align="center">Long</td></tr><tr><td align="center">float</td><td align="center">32 bits</td><td align="center">0.0f</td><td align="center"><a href="https://zh.wikipedia.org/wiki/IEEE_754" target="_blank" rel="noopener">IEEE754</a></td><td align="center">IEEE754</td><td align="center">Float</td></tr><tr><td align="center">double</td><td align="center">16 bits</td><td align="center">0.0d</td><td align="center">IEEE754</td><td align="center">IEEE754</td><td align="center">Double</td></tr><tr><td align="center">void</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">Void</td></tr></tbody></table><h1 id="注释和嵌入式文档"><a href="#注释和嵌入式文档" class="headerlink" title="注释和嵌入式文档"></a>注释和嵌入式文档</h1><p>只能为 <code>public</code> 和 <code>protected</code> 成员进行文档注释。</p><p>不要在嵌入式 <code>html</code> 中使用标题标签 <code>&lt;h1&gt;&lt;hr&gt;</code> 等。因为 <code>javadoc</code> 会插入这类标签，避免冲突。</p><p>一些标签示例</p><ol><li><strong>@see</strong>：引用其他类，该标签允许用户引用其他类的文档 <code>@see classname</code>。</li><li><strong>{@link package.class#member label}</strong>：该标签与<code>@see</code>相似，只是它用于行内，并且使用 &quot;lable&quot; 作为超链接文本而不用 &quot;See Also&quot;。</li><li><strong>{@docRoot}</strong>：该标签产生到文档根目录的相对路径，用于文档树页面的显式超链接。</li><li><strong>{@inheritDoc}</strong>：该标签从当前这个类的最直接的基类中继承相关文档到当前的文档注释中</li><li><strong>@version</strong></li><li><strong>@author</strong></li><li><strong>@since</strong>：该标签允许你指定程序代码最早的使用版本</li><li><strong>@param</strong>：该标签用于方法文档中</li><li><strong>@return</strong></li><li><strong>@throws</strong></li><li><strong>@deprecated</strong>：在 <code>Java SE5</code> 中，被<code>@Deprecated</code> 注解所替代</li></ol><h1 id="用javadoc命令生成注释文档"><a href="#用javadoc命令生成注释文档" class="headerlink" title="用javadoc命令生成注释文档"></a>用javadoc命令生成注释文档</h1><p>基本命令</p><pre><code class="shell">javadoc [options] [packagenames] [sourcefiles] [@files]</code></pre><p>如果什么options也设置，直接给[packagenames] [sourcefiles]两个参数。下面我指定了com.test包里的SayHello类。</p><pre><code class="shell">javadoc com.test ~/java/com/test/SayHello.java</code></pre><p>递归生成整个项目的注释文档</p><p>为了更有序地更完整地生成整个项目的注释文档，有三个重要的 <code>Option</code> 需要设定：</p><pre><code class="shell">javadoc -d /yourdocpath -subpackages /packagename -sourcepath /yoursourcepath</code></pre><ul><li><strong>-d</strong>： 指定API文档的输出目录，默认是当前目录。建议总是指定该参数。</li><li><strong>-subpackages</strong>： 以递归的方式处理各子包。关键参数！如果不使用本参数，每次只能处理一个子包（或需手工列出所有子包）。</li><li><strong>-sourcepath</strong>： 指定源代码路径，默认是当前目录。 此参数通常是必须的。</li></ul><p>下面这条命令可以递归生成我整个<code>~/java</code>根目录下所有代码的注释文档，然后存放在<code>~/java/doc</code>目录下。<code>-author</code>和<code>-version</code>可以让<code>javadoc</code>自动收录我<code>@author</code>和<code>@version</code>标签的内容。</p><pre><code class="shell">javadoc -d ~/java/doc -subpackages . -sourcepath ~/java/ -author -version</code></pre><br>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java编程思想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Java编程思想》笔记01-对象导论</title>
      <link href="/2018/03/13/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B%E7%AC%94%E8%AE%B001-%E5%AF%B9%E8%B1%A1%E5%AF%BC%E8%AE%BA/"/>
      <url>/2018/03/13/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B%E7%AC%94%E8%AE%B001-%E5%AF%B9%E8%B1%A1%E5%AF%BC%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="Java中的4种访问制权限"><a href="#Java中的4种访问制权限" class="headerlink" title="Java中的4种访问制权限"></a>Java中的4种访问制权限</h1><ol><li><code>public</code>：最大访问控制权限，对所有的类都可见。</li><li><code>protect</code>：同一包可见，不在同一个包的所有子类也可见。</li><li><code>default</code>：包访问权限，即同一个包中的类可以可见。默认不显式指定访问控制权限时就是default包访问控制权限。</li><li><code>private</code>：最严格俄访问控制权限，仅该类本身可见，对外一切类都不可以访问(反射机制可以访问)。</li></ol><a id="more"></a><h1 id="复用具体实现"><a href="#复用具体实现" class="headerlink" title="复用具体实现"></a>复用具体实现</h1><p>新的类可以由任意数量、任意类型的其他对象以任意可以实现新的类中想要的功能的方式所组成。因为是在使用现有的类合成新的类，所以这种概念被称为<strong>组合</strong>（composition），如果组合是动态发生的，那么它通常被称为<strong>聚合</strong>（aggregation）。组合经常被视为”<code>has-a</code>”（拥有）关系，就像我们常说的”汽车拥有引擎”一样。</p><p>在建立新类时，应该<strong>首先考虑组合</strong>，因为它更加简单灵活。</p><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>有两种方法可以使基类与导出类产生差异。第一种方法非常直接：直接在导出类中添加新方法。应该仔细考虑是否存在基类也需要这些额外方法的可能性。</p><p>第二种也是更重要的一种使导出类和基类之间产生差异的方法是改变现有基类的方法的行为，这被称之为<strong>覆盖</strong>（overriding）那个方法。</p><p>如果继承只覆盖基类的方法（而并不添加在基类中没有的新方法），就意味着导出类和基类是完全相同的类型，因为它们具有完全相同的接口。结果可以用一个导出类对象来完全替代一个基类对象。这可以被视为纯粹替代，通常称之为替代原则。这种情况下的基类与导出类之间的关系称为<code>is-a</code>（是一个）关系，因为可以说”一个圆形就是一个几何形状”。判断是否继承，就是要确定是否可以用<code>is-a</code>来描述类之间的关系，并使之具有实际意义。</p><p>有时必须在导出类型中添加新的接口元素，这样也就扩展了接口。这个新的类型仍然可以替代基类，但是这种替代并不完美，因为基类无法访问新添加的方法。这种情况可以描述为<code>is-like-a</code>（像是一个）关系。新类型具有旧类型的接口，但是它还包含其他方法，所以不能说它们完全相同。</p><p>只使用纯粹替代的方式是很好的设计,但是实际上有些时候导出类还是会需要添加新的接口。</p><h1 id="伴随多态的可互换对象"><a href="#伴随多态的可互换对象" class="headerlink" title="伴随多态的可互换对象"></a>伴随多态的可互换对象</h1><p>面向对象程序设计语言使用了<strong>后期绑定</strong>的概念。当向对象发送消息时，被调用的代码直到运行时才能确定。</p><p>把将导出类看做是它的基类的过程称为<strong>向上转型</strong>（upcasting）。代码只与基类交互，而和具体类型信息是分离的。</p><p><strong>向下转型</strong>：<br>向下类型转换是将父类类型强制转换为子类类型，转换过后父类中不可见的子类特性又恢复可见性，向下类型转换时，编译器无法自动检测是否类型兼容，往往会产生类型转换错误的运行时异常，通常不安全。</p><h1 id="单根继承结构"><a href="#单根继承结构" class="headerlink" title="单根继承结构"></a>单根继承结构</h1><p>除了C++以外的所有OOP语言都是单根继承。</p><h1 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h1><p>Java提供了List（用于存储序列），Map（也被称为关联数组，用来建立对象之间的关联），Set（每种对象类型只持有一个），以及诸如队列、树、堆栈等更多的构件。不同容器提供了不同类型的接口和外部行为；不同的容器对于某些操作具有不同的效率。例如ArrayList和LinkedList，选取元素时，LinkedList会比较低效，但是插入元素时，相对要高效。</p><p>如非确切地知道对象的类型，否则向下转型是不安全的。</p><p>Java SE5中加入了参数化类型，即泛型。</p><h1 id="对象的创建和生命期"><a href="#对象的创建和生命期" class="headerlink" title="对象的创建和生命期"></a>对象的创建和生命期</h1><p>Java完全采用了动态内存分配方式，在被称为堆（heap）的内存池中动态地创建对象，堆带来了灵活性，但是存储分配需要更多时间。由垃圾回收器决定何时回收对象。</p><h1 id="异常处理：处理错误"><a href="#异常处理：处理错误" class="headerlink" title="异常处理：处理错误"></a>异常处理：处理错误</h1><p>异常处理就像是与程序正常执行路径并行的、在错误发生时执行的另一条路径。因为它是另一条完全分离的执行路径，所以它不会干扰正常的执行代码。这往往使得代码编写变得简单，因为不需要被迫定期检查错误。此外，被抛出的异常不像方法返回的错误值和方法设置的用来表示错误条件的标志位那样可以被忽略。异常不能被忽略，所以它保证一定会在某处得到处理。</p><h1 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h1><p>隐患：共享资源。如果有多个并行任务都要访问同一项资源，那么就会出问题。对于共享资源，需要加锁。</p><br>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java编程思想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 复制文件的方法</title>
      <link href="/2018/03/10/Java%20%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2018/03/10/Java%20%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>原文：<a href="http://blog.csdn.net/zmyde2010/article/details/6024496" target="_blank" rel="noopener">http://blog.csdn.net/zmyde2010/article/details/6024496</a></p><h1 id="最快的方法"><a href="#最快的方法" class="headerlink" title="最快的方法"></a>最快的方法</h1><p>不考虑多线程优化，单线程文件复制最快的方法是(文件越大该方法越有优势，一般比常用方法快30+%):</p><pre><code class="java">private static void nioTransferCopy(File source, File target) {    FileChannel in = null;    FileChannel out = null;    FileInputStream inStream = null;    FileOutputStream outStream = null;    try {        inStream = new FileInputStream(source);        outStream = new FileOutputStream(target);        in = inStream.getChannel();        out = outStream.getChannel();        in.transferTo(0, in.size(), out);    } catch (IOException e) {        e.printStackTrace();    } finally {        try {            if(inStream != null){                inStream.close();            }            if(in != null){                in.close();            }            if(outStream != null){                outStream.close();            }            if(out != null){                out.close();            }        } catch (IOException e) {            e.printStackTrace();        }    }}</code></pre><a id="more"></a><h1 id="监测复制进度"><a href="#监测复制进度" class="headerlink" title="监测复制进度"></a>监测复制进度</h1><p>如果需要监测复制进度，可以用第二快的方法(留意buffer的大小，对速度有很大影响):</p><pre><code class="java">private static void nioBufferCopy(File source, File target) {    FileChannel in = null;    FileChannel out = null;    FileInputStream inStream = null;    FileOutputStream outStream = null;    try {        inStream = new FileInputStream(source);        outStream = new FileOutputStream(target);        in = inStream.getChannel();        out = outStream.getChannel();        ByteBuffer buffer = ByteBuffer.allocate(4096);        while (in.read(buffer) != -1) {            buffer.flip();            out.write(buffer);            buffer.clear();        }    } catch (IOException e) {        e.printStackTrace();    } finally {        try {            if(inStream != null){                inStream.close();            }            if(in != null){                in.close();            }            if(outStream != null){                outStream.close();            }            if(out != null){                out.close();            }        } catch (IOException e) {            e.printStackTrace();        }    }}</code></pre><h1 id="常用的方法1"><a href="#常用的方法1" class="headerlink" title="常用的方法1"></a>常用的方法1</h1><pre><code class="java">private static void customBufferBufferedStreamCopy(File source, File target) {    InputStream fis = null;    OutputStream fos = null;    try {        fis = new BufferedInputStream(new FileInputStream(source));        fos = new BufferedOutputStream(new FileOutputStream(target));        byte[] buf = new byte[4096];        int i;        while ((i = fis.read(buf)) != -1) {            fos.write(buf, 0, i);        }    } catch (Exception e) {        e.printStackTrace();    } finally {        try {            if(fis != null){                fis.close();            }            if(fos != null){                fos.close();            }        } catch (IOException e) {            e.printStackTrace();        }    }}</code></pre><h1 id="常用的方法2"><a href="#常用的方法2" class="headerlink" title="常用的方法2"></a>常用的方法2</h1><pre><code class="java">private static void customBufferStreamCopy(File source, File target) {    InputStream fis = null;    OutputStream fos = null;    try {        fis = new FileInputStream(source);        fos = new FileOutputStream(target);        byte[] buf = new byte[4096];        int i;        while ((i = fis.read(buf)) != -1) {            fos.write(buf, 0, i);        }    } catch (Exception e) {        e.printStackTrace();    } finally {        try {            if(fis != null){                fis.close();            }            if(fos != null){                fos.close();            }        } catch (IOException e) {            e.printStackTrace();        }    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB字符串数值比较</title>
      <link href="/2018/03/07/MongoDB%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E5%80%BC%E6%AF%94%E8%BE%83/"/>
      <url>/2018/03/07/MongoDB%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E5%80%BC%E6%AF%94%E8%BE%83/</url>
      
        <content type="html"><![CDATA[<p>想要作数字大小的比较，MongoDB中存放的类型为String，所以无法使用</p><blockquote><p><code>db.getCollection(&#39;facecompar&#39;).count({comparscores:{\$gt:13,\$lt:122}})</code><br>或<br><code>db.getCollection(&#39;facecompar&#39;).count({comparscores:{$gt:&#39;13&#39;,$lt:&#39;122&#39;}})</code><br>&quot;45&quot; 将不在该范围内</p></blockquote><p>正确的方式</p><pre><code class="shell">&gt; db.getCollection(&#39;facecompar&#39;).count(&quot;this.comparscores&gt;13 &amp;&amp; this.comparscores&lt;122&quot;)</code></pre><p>注意该方式性能较低</p><p>参考地址</p><blockquote><p><a href="https://cnodejs.org/topic/515e863d6d382773065411d5" target="_blank" rel="noopener">https://cnodejs.org/topic/515e863d6d382773065411d5</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> MongoDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>删除右键中的“上传到有道云”</title>
      <link href="/2018/03/03/%E5%88%A0%E9%99%A4%E5%8F%B3%E9%94%AE%20%E4%B8%8A%E4%BC%A0%E5%88%B0%E6%9C%89%E9%81%93%E4%BA%91/"/>
      <url>/2018/03/03/%E5%88%A0%E9%99%A4%E5%8F%B3%E9%94%AE%20%E4%B8%8A%E4%BC%A0%E5%88%B0%E6%9C%89%E9%81%93%E4%BA%91/</url>
      
        <content type="html"><![CDATA[<p>创建文件<code>1.reg</code>，添加以下内容</p><pre><code class="shell">Windows Registry Editor Version 5.00[-HKEY_LOCAL_MACHINE\SOFTWARE\Classes\*\shell\YNote][-HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Directory\shell\YNote][-HKEY_CLASSES_ROOT\*\shell\YNote][-HKEY_CLASSES_ROOT\Directory\shell\YNote]</code></pre><p>双击执行</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring事务配置切点</title>
      <link href="/2018/02/27/Spring%E4%BA%8B%E5%8A%A1%E9%85%8D%E7%BD%AE%E5%88%87%E7%82%B9/"/>
      <url>/2018/02/27/Spring%E4%BA%8B%E5%8A%A1%E9%85%8D%E7%BD%AE%E5%88%87%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<p>详细介绍：<a href="http://jinnianshilongnian.iteye.com/blog/1415606" target="_blank" rel="noopener">Spring 之AOP AspectJ切入点语法详解（最全了，不需要再去其他地找了）</a></p><h2 id="execution"><a href="#execution" class="headerlink" title="execution"></a>execution</h2><p>使用“execution(方法表达式)”匹配方法执行；如：<code>execution(* cn.javass..*.*(..))</code></p><a id="more"></a><table border="1" cellspacing="0" style="cursor: default;" cellpadding="0"><tbody><tr><td style="font-size: 14px; cursor: text;" width="268"><p style="padding: 0px;"><strong>模式</strong></p></td><td style="font-size: 14px; cursor: text;" width="288"><p style="padding: 0px;"><strong>描述</strong></p></td></tr><tr><td style="font-size: 14px; cursor: text;" width="268"><p style="padding: 0px;">public * *(..)</p></td><td style="font-size: 14px; cursor: text;" width="288"><p style="padding: 0px;">任何公共方法的执行</p></td></tr><tr><td style="font-size: 14px; cursor: text;" width="268"><p style="padding: 0px;">* cn.javass..IPointcutService.*()</p></td><td style="font-size: 14px; cursor: text;" width="288"><p style="padding: 0px;">cn.javass包及所有子包下IPointcutService接口中的任何无参方法</p></td></tr><tr><td style="font-size: 14px; cursor: text;" width="268"><p style="padding: 0px;">* cn.javass..*.*(..)</p></td><td style="font-size: 14px; cursor: text;" width="288"><p style="padding: 0px;">cn.javass包及所有子包下任何类的任何方法</p></td></tr><tr><td style="font-size: 14px; cursor: text;" width="268"><p style="padding: 0px;">* cn.javass..IPointcutService.*(*)</p></td><td style="font-size: 14px; cursor: text;" width="288"><p style="padding: 0px;">cn.javass包及所有子包下IPointcutService接口的任何只有一个参数方法</p></td></tr><tr><td style="font-size: 14px; cursor: text;" width="268"><p style="padding: 0px;">* (!cn.javass..IPointcutService+).*(..)</p></td><td style="font-size: 14px; cursor: text;" width="288"><p style="padding: 0px;">非“cn.javass包及所有子包下IPointcutService接口及子类型”的任何方法</p></td></tr><tr><td style="font-size: 14px; cursor: text;" width="268"><p style="padding: 0px;">* cn.javass..IPointcutService+.*()</p></td><td style="font-size: 14px; cursor: text;" width="288"><p style="padding: 0px;">cn.javass包及所有子包下IPointcutService接口及子类型的的任何无参方法</p></td></tr><tr><td style="font-size: 14px; cursor: text;" width="268"><p style="padding: 0px;">* cn.javass..IPointcut*.test*(java.util.Date)</p></td><td style="font-size: 14px; cursor: text;" width="288"><p style="padding: 0px;">cn.javass包及所有子包下IPointcut前缀类型的的以test开头的只有一个参数类型为java.util.Date的方法，注意该匹配是根据方法签名的参数类型进行匹配的，而不是根据执行时传入的参数类型决定的</p><p style="padding: 0px;">如定义方法：public void test(Object obj);即使执行时传入java.util.Date，也不会匹配的；</p></td></tr><tr><td style="font-size: 14px; cursor: text;" width="268"><p style="padding: 0px;">* cn.javass..IPointcut*.test*(..)&nbsp; throws</p><p style="padding: 0px;">&nbsp;IllegalArgumentException, ArrayIndexOutOfBoundsException</p></td><td style="font-size: 14px; cursor: text;" width="288"><p style="padding: 0px;">cn.javass包及所有子包下IPointcut前缀类型的的任何方法，且抛出IllegalArgumentException和ArrayIndexOutOfBoundsException异常</p></td></tr><tr><td style="font-size: 14px; cursor: text;" width="268"><p style="padding: 0px;">* (cn.javass..IPointcutService+</p><p style="padding: 0px;">&amp;&amp; java.io.Serializable+).*(..)</p></td><td style="font-size: 14px; cursor: text;" width="288"><p style="padding: 0px;">任何实现了cn.javass包及所有子包下IPointcutService接口和java.io.Serializable接口的类型的任何方法</p></td></tr><tr><td style="font-size: 14px; cursor: text;" width="268"><p style="padding: 0px;">@java.lang.Deprecated * *(..)</p></td><td style="font-size: 14px; cursor: text;" width="288"><p style="padding: 0px;">任何持有@java.lang.Deprecated注解的方法</p></td></tr><tr><td style="font-size: 14px; cursor: text;" width="268"><p style="padding: 0px;">@java.lang.Deprecated @cn.javass..Secure &nbsp;* *(..)</p></td><td style="font-size: 14px; cursor: text;" width="288"><p style="padding: 0px;">任何持有@java.lang.Deprecated和@cn.javass..Secure注解的方法</p></td></tr><tr><td style="font-size: 14px; cursor: text;" width="268"><p style="padding: 0px;">@(java.lang.Deprecated || cn.javass..Secure) * *(..)</p></td><td style="font-size: 14px; cursor: text;" width="288"><p style="padding: 0px;">任何持有@java.lang.Deprecated或@ cn.javass..Secure注解的方法</p></td></tr><tr><td style="font-size: 14px; cursor: text;" width="268"><p style="padding: 0px;">(@cn.javass..Secure &nbsp;*)&nbsp; *(..)</p></td><td style="font-size: 14px; cursor: text;" width="288"><p style="padding: 0px;">任何返回值类型持有@cn.javass..Secure的方法</p></td></tr><tr><td style="font-size: 14px; cursor: text;" width="268"><p style="padding: 0px;">* &nbsp;(@cn.javass..Secure *).*(..)</p></td><td style="font-size: 14px; cursor: text;" width="288"><p style="padding: 0px;">任何定义方法的类型持有@cn.javass..Secure的方法</p></td></tr><tr><td style="font-size: 14px; cursor: text;" width="268"><p style="padding: 0px;">* *(@cn.javass..Secure (*) , @cn.javass..Secure (*))</p></td><td style="font-size: 14px; cursor: text;" width="288"><p style="padding: 0px;">任何签名带有两个参数的方法，且这个两个参数都被@ Secure标记了，</p><p style="padding: 0px;">如public void test(@Secure String str1,</p><p style="padding: 0px;">&nbsp;@Secure String str1);</p></td></tr><tr><td style="font-size: 14px; cursor: text;" width="268"><p style="padding: 0px;">* *((@ cn.javass..Secure *))或</p><p style="padding: 0px;">* *(@ cn.javass..Secure *)</p></td><td style="font-size: 14px; cursor: text;" width="288"><p style="padding: 0px;">任何带有一个参数的方法，且该参数类型持有@ cn.javass..Secure；</p><p style="padding: 0px;">如public void test(Model model);且Model类上持有@Secure注解</p></td></tr><tr><td style="font-size: 14px; cursor: text;" width="268"><p style="padding: 0px;">* *(</p><p style="padding: 0px;">@cn.javass..Secure (@cn.javass..Secure *) ,</p><p style="padding: 0px;">@ cn.javass..Secure (@cn.javass..Secure *))</p></td><td style="font-size: 14px; cursor: text;" width="288"><p style="padding: 0px;">任何带有两个参数的方法，且这两个参数都被@ cn.javass..Secure标记了；且这两个参数的类型上都持有@ cn.javass..Secure；</p><p style="padding: 0px;">&nbsp;</p></td></tr><tr><td style="font-size: 14px; cursor: text;" width="268"><p style="padding: 0px;">* *(</p><p style="padding: 0px;">java.util.Map&lt;cn.javass..Model, cn.javass..Model&gt;</p><p style="padding: 0px;">, ..)</p></td><td style="font-size: 14px; cursor: text;" width="288"><p style="padding: 0px;">任何带有一个java.util.Map参数的方法，且该参数类型是以&lt; cn.javass..Model, cn.javass..Model &gt;为泛型参数；注意只匹配第一个参数为java.util.Map,不包括子类型；</p><p style="padding: 0px;">如public void test(HashMap&lt;Model, Model&gt; map, String str);将不匹配，必须使用“* *(</p><p style="padding: 0px;">java.util.HashMap&lt;cn.javass..Model,cn.javass..Model&gt;</p><p style="padding: 0px;">, ..)”进行匹配；</p><p style="padding: 0px;">而public void test(Map map, int i);也将不匹配，因为泛型参数不匹配</p></td></tr><tr><td style="font-size: 14px; cursor: text;" width="268"><p style="padding: 0px;">* *(java.util.Collection&lt;@cn.javass..Secure *&gt;)</p></td><td style="font-size: 14px; cursor: text;" width="288"><p style="padding: 0px;">任何带有一个参数（类型为java.util.Collection）的方法，且该参数类型是有一个泛型参数，该泛型参数类型上持有@cn.javass..Secure注解；</p><p style="padding: 0px;">如public void test(Collection&lt;Model&gt; collection);Model类型上持有@cn.javass..Secure</p></td></tr></tbody></table><h2 id="多个execution"><a href="#多个execution" class="headerlink" title="多个execution"></a>多个execution</h2><pre><code class="xml">&lt;aop:config&gt;    &lt;!-- 配置多个切点，&amp;&amp; || ! --&gt;    &lt;aop:pointcut id=&quot;pc&quot; expression=&quot;execution(public * cn.javass.*.service.*.*(..)) || execution(public * cn.javass.*.*.service.*.*(..)) || execution(public * cn.javass.*.*.*.service.*.*(..))&quot; /&gt;    &lt;aop:advisor pointcut-ref=&quot;pc&quot; advice-ref=&quot;userTxAdvice&quot; /&gt;&lt;/aop:config&gt;</code></pre><p>其中，&amp;&amp;，||，! 可以写成 and，or，not。</p><p>还有一种做法，就是写多个aop:advisor：</p><pre><code class="xml">&lt;aop:advisor pointcut=&quot;execution(public * com.wtas.*.service.*.*(..))&quot; advice-ref=&quot;userTxAdvice&quot; /&gt;&lt;aop:advisor pointcut=&quot;execution(public * com.wtas.*.*.service.*.*(..))&quot; advice-ref=&quot;userTxAdvice&quot; /&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用阿里云 pip 源</title>
      <link href="/2017/12/17/%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91-pip-%E6%BA%90/"/>
      <url>/2017/12/17/%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91-pip-%E6%BA%90/</url>
      
        <content type="html"><![CDATA[<h2 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h2><p><a href="http://mirrors.aliyun.com/help/pypi" target="_blank" rel="noopener">http://mirrors.aliyun.com/help/pypi</a></p><h2 id="公网"><a href="#公网" class="headerlink" title="公网"></a>公网</h2><p>在<code>~/.pip/pip.conf</code>文件中添加或修改</p><pre><code>[global]index-url = http://mirrors.aliyun.com/pypi/simple/[install]trusted-host=mirrors.aliyun.com</code></pre><h2 id="内网"><a href="#内网" class="headerlink" title="内网"></a>内网</h2><p>在<code>~/.pip/pip.conf</code>文件中添加或修改</p><pre><code>[global]index-url = http://mirrors.aliyuncs.com/pypi/simple/[install]trusted-host=mirrors.aliyuncs.com</code></pre><h2 id="临时设置"><a href="#临时设置" class="headerlink" title="临时设置"></a>临时设置</h2><pre><code>pip install bottle -i http://mirrors.aliyuncs.com/pypi/simple --trusted-host mirrors.aliyuncs.com</code></pre><br>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python使用requests时遇到Failed to establish a new connection</title>
      <link href="/2017/12/17/Python%E4%BD%BF%E7%94%A8requests%E6%99%82%E9%81%87%E5%88%B0Failed-to-establish-a-new-connection/"/>
      <url>/2017/12/17/Python%E4%BD%BF%E7%94%A8requests%E6%99%82%E9%81%87%E5%88%B0Failed-to-establish-a-new-connection/</url>
      
        <content type="html"><![CDATA[<p><code>Python</code>使用<code>requests</code>时，开启太多的<code>connection</code>会遇到这样一个错误</p><pre><code class="python">requests.exceptions.ConnectionError: HTTPConnectionPool(host=&#39;xxxx&#39;, port=xxxx):    Max retries exceeded with url: /xxxx (Caused by NewConnectionError    (&#39;&lt;requests.packages.urllib3.connection.HTTPConnection object at 0x29b44d0&gt;:    Failed to establish a new connection:    [Errno 99] Cannot assign requested address&#39;,))</code></pre><a id="more"></a><p>在短时间使用多次<code>requests.post</code></p><p>修改如下</p><pre><code class="python">requests..get(&quot;http://...&quot;, headers={&#39;Connection&#39;:&#39;close&#39;})requests..post(&quot;http://...&quot;, headers={&#39;Connection&#39;:&#39;close&#39;})</code></pre><p><a href="http://terrence.logdown.com/posts/702737-python-use-requests-have-failed-to-establish-a-new-connection" target="_blank" rel="noopener">Python使用requests時遇到Failed to establish a new connection</a><br><br></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 解析 JSON</title>
      <link href="/2017/12/17/Python-%E8%A7%A3%E6%9E%90-JSON/"/>
      <url>/2017/12/17/Python-%E8%A7%A3%E6%9E%90-JSON/</url>
      
        <content type="html"><![CDATA[<h2 id="解析-JSON"><a href="#解析-JSON" class="headerlink" title="解析 JSON"></a>解析 JSON</h2><p>创建下面包含JSON数据的字符串</p><pre><code class="Python">json_string = &#39;{&quot;first_name&quot;: &quot;Guido&quot;, &quot;last_name&quot;:&quot;Rossum&quot;}&#39;</code></pre><p>它可以被这样解析<code>json.loads()</code>：</p><pre><code class="Python">import jsonparsed_json = json.loads(json_string)</code></pre><p>然后它可以像一个常规的字典那样使用:</p><pre><code class="Python">print(parsed_json[&#39;first_name&#39;])&quot;Guido&quot;</code></pre><a id="more"></a><h2 id="对象转为JSON"><a href="#对象转为JSON" class="headerlink" title="对象转为JSON"></a>对象转为JSON</h2><p><code>json.dumps()</code></p><pre><code class="Python">d = {    &#39;first_name&#39;: &#39;Guido&#39;,    &#39;second_name&#39;: &#39;Rossum&#39;,    &#39;titles&#39;: [&#39;BDFL&#39;, &#39;Developer&#39;],}print(json.dumps(d))&#39;{&quot;first_name&quot;: &quot;Guido&quot;, &quot;last_name&quot;: &quot;Rossum&quot;, &quot;titles&quot;: [&quot;BDFL&quot;, &quot;Developer&quot;]}&#39;</code></pre><br>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PIL 基本用法</title>
      <link href="/2017/12/17/PIL-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/"/>
      <url>/2017/12/17/PIL-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>PIL (Python Image Library) 是 Python 平台处理图片的事实标准，兼具强大的功能和简洁的 API。但只支持 python2。</p><h2 id="安装PIL，Python2"><a href="#安装PIL，Python2" class="headerlink" title="安装PIL，Python2"></a>安装PIL，Python2</h2><p>在 Debian/Ubuntu Linux 下直接通过 apt 安装：</p><pre><code class="shell">$ sudo apt-get install python-imaging</code></pre><p>Mac 和其他版本的 Linux 可以直接使用 easy_install 或 pip 安装，安装前需要把编译环境装好：</p><pre><code class="shell">$ sudo easy_install PIL</code></pre><p>如果安装失败，根据提示先把缺失的包（比如 openjpeg）装上。</p><p>Windows 平台就去<a href="http://pythonware.com/products/pil/" target="_blank" rel="noopener">PIL官方网站</a>下载 exe 安装包。</p><h2 id="Pillow，Python3"><a href="#Pillow，Python3" class="headerlink" title="Pillow，Python3"></a>Pillow，Python3</h2><p>Pillow 是 PIL 的一个派生分支，但如今已经发展成为比 PIL 本身更具活力的图像处理库。支持 python3</p><p>Pillow 的 Github 主页：<a href="https://github.com/python-pillow/Pillow" target="_blank" rel="noopener">https://github.com/python-pillow/Pillow</a></p><p>Pillow的文档：<a href="https://pillow.readthedocs.org/en/latest/handbook/index.html" target="_blank" rel="noopener">https://pillow.readthedocs.org/en/latest/handbook/index.html</a></p><p>Pillow的文档中文翻译(对应版本v2.4.0)：<a href="http://pillow-cn.readthedocs.io/zh_CN/latest/" target="_blank" rel="noopener">http://pillow-cn.readthedocs.io/zh_CN/latest/</a></p><p>安装</p><pre><code class="shell">pip install Pillow</code></pre><a id="more"></a><h2 id="操作图像"><a href="#操作图像" class="headerlink" title="操作图像"></a>操作图像</h2><p>来看看最常见的图像缩放操作，只需三四行代码：</p><pre><code class="python">import Image# 打开一个jpg图像文件，注意路径要改成你自己的:im = Image.open(&#39;/Users/michael/test.jpg&#39;)# 获得图像尺寸:w, h = im.size# 缩放到50%:im.thumbnail((w//2, h//2))# 把缩放后的图像用jpeg格式保存，也可以用作更改图片格式im.save(&#39;/Users/michael/thumbnail.jpg&#39;, &#39;jpeg&#39;)</code></pre><h2 id="查看实例"><a href="#查看实例" class="headerlink" title="查看实例"></a>查看实例</h2><p>使用 <code>show()</code> 方法来查看实例。注意，<code>PIL</code> 会将实例暂存为一个临时文件，而后打开它。</p><pre><code class="python">im.show()</code></pre><h2 id="模糊效果"><a href="#模糊效果" class="headerlink" title="模糊效果"></a>模糊效果</h2><pre><code class="python">from PIL import Image, ImageFilterim = Image.open(&#39;test.jpg&#39;)# 应用模糊滤镜:im2 = im.filter(ImageFilter.BLUR)im2.save(&#39;blur.jpg&#39;, &#39;jpeg&#39;)</code></pre><h2 id="查看实例的属性"><a href="#查看实例的属性" class="headerlink" title="查看实例的属性"></a>查看实例的属性</h2><p><code>Image</code> 类的实例有 5 个属性，分别是：</p><ul><li><code>format</code>: 以 string 返回图片档案的格式（JPG, PNG, BMP, None, etc.）；如果不是从打开文件得到的实例，则返回 None。</li><li><code>mode</code>: 以 string 返回图片的模式（RGB, CMYK, etc.）；完整的列表参见 <a href="http://effbot.org/imagingbook/concepts.htm#mode" target="_blank" rel="noopener">官方说明·图片模式列表</a></li><li><code>size</code>: 以二元 tuple 返回图片档案的尺寸 (width, height)</li><li><code>palette</code>: 仅当 mode 为 P 时有效，返回 ImagePalette 示例</li><li><code>info</code>: 以字典形式返回示例的信息</li></ul><h2 id="生成字母验证码图片"><a href="#生成字母验证码图片" class="headerlink" title="生成字母验证码图片"></a>生成字母验证码图片</h2><pre><code class="python">from PIL import Image, ImageDraw, ImageFont, ImageFilterimport random# 随机字母:def rndChar():    return chr(random.randint(65, 90))# 随机颜色1:def rndColor():    return (random.randint(64, 255), random.randint(64, 255), random.randint(64, 255))# 随机颜色2:def rndColor2():    return (random.randint(32, 127), random.randint(32, 127), random.randint(32, 127))# 240 x 60:width = 60 * 4height = 60image = Image.new(&#39;RGB&#39;, (width, height), (255, 255, 255))# 创建Font对象:font = ImageFont.truetype(&#39;Arial.ttf&#39;, 36)# 创建Draw对象:draw = ImageDraw.Draw(image)# 填充每个像素:for x in range(width):    for y in range(height):        draw.point((x, y), fill=rndColor())# 输出文字:for t in range(4):    draw.text((60 * t + 10, 10), rndChar(), font=font, fill=rndColor2())# 模糊:image = image.filter(ImageFilter.BLUR)image.save(&#39;code.jpg&#39;, &#39;jpeg&#39;);</code></pre><p>如果运行的时候报错：</p><pre><code>IOError: cannot open resource</code></pre><p>这是因为PIL无法定位到字体文件的位置，可以根据操作系统提供绝对路径，比如：</p><pre><code>&#39;/Library/Fonts/Arial.ttf&#39;</code></pre><p>要详细了解 PIL 的强大功能，请请参考<a href="http://effbot.org/imagingbook/" target="_blank" rel="noopener">PIL官方文档</a></p><p><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014320027235877860c87af5544f25a8deeb55141d60c5000" target="_blank" rel="noopener">PIL - 廖雪峰的官方网站</a></p><p><a href="https://liam0205.me/2015/04/22/pil-tutorial-basic-usage/" target="_blank" rel="noopener">PIL 简明教程 - 基本用法</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS 下安装 JDK</title>
      <link href="/2017/12/17/CentOS%E4%B8%8B%E5%AE%89%E8%A3%85JDK/"/>
      <url>/2017/12/17/CentOS%E4%B8%8B%E5%AE%89%E8%A3%85JDK/</url>
      
        <content type="html"><![CDATA[<p><code>JDK</code> 下载 <a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a></p><p>创建目录，解压缩</p><pre><code class="shell">mkdir /usr/javatar -zxvf jdk-8u151-linux-x64.tar.gz</code></pre><a id="more"></a><p>配置环境变量</p><pre><code class="shell">vi /etc/profile# 打开之后在文件末尾添加下面配置export JAVA_HOME=/usr/java/jdk1.8.0_151export JRE_HOME=$JAVA_HOME/jreexport PATH=$PATH:$JAVA_HOME/binexport CLASSPATH=./:$JAVA_HOME/lib:$JAVA_HOME/jre/lib</code></pre><p>使profile配置生效。</p><pre><code class="shell">source /etc/profile</code></pre><h2 id="Oracle-官网所有-JDK-历史版本下载地址"><a href="#Oracle-官网所有-JDK-历史版本下载地址" class="headerlink" title="Oracle 官网所有 JDK 历史版本下载地址"></a>Oracle 官网所有 JDK 历史版本下载地址</h2><p><a href="http://www.oracle.com/technetwork/java/archive-139210.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/archive-139210.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 学习笔记</title>
      <link href="/2017/12/17/Git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2017/12/17/Git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>Debian 或 Ubuntu Linux</p><pre><code class="shell">sudo apt-get install git</code></pre><a id="more"></a><h3 id="配置Git"><a href="#配置Git" class="headerlink" title="配置Git"></a>配置Git</h3><p>安装完成后，还需要最后一步设置，在命令行输入：</p><pre><code class="shell">$ git config --global user.name &quot;Your Name&quot;$ git config --global user.email &quot;email@example.com&quot;</code></pre><p>因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。</p><p>注意<code>git config</code>命令的<code>--global</code>参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。<br>每个仓库的Git配置文件都放在.git/config文件中</p><h3 id="配置别名"><a href="#配置别名" class="headerlink" title="配置别名"></a>配置别名</h3><pre><code class="shell"># st就表示status$ git config --global alias.st status</code></pre><h3 id="查看Git-的配置信息"><a href="#查看Git-的配置信息" class="headerlink" title="查看Git 的配置信息"></a>查看Git 的配置信息</h3><pre><code class="shell">git config --listgit config --global --list</code></pre><h3 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h3><pre><code class="shell"># 创建目录$ mkdir learngit$ cd learngit$ pwd/Users/michael/learngit$ git initInitialized empty Git repository in /Users/michael/learngit/.git/</code></pre><h3 id="把文件添加到仓库"><a href="#把文件添加到仓库" class="headerlink" title="把文件添加到仓库"></a>把文件添加到仓库</h3><pre><code class="shell">$ git add readme.txt# 一次提交多个文件$ git add file2.txt file3.txt# 提交当前目录下所有有改动的文件$ git add .这个文件被.gitignore忽略了，用-f 强制添加到Git$ git add -f App.class</code></pre><h3 id="把文件提交到仓库"><a href="#把文件提交到仓库" class="headerlink" title="把文件提交到仓库"></a>把文件提交到仓库</h3><pre><code class="shell">$ git commit -m &quot;wrote a readme file&quot;[master (root-commit) cb926e7] wrote a readme file 1 file changed, 2 insertions(+) create mode 100644 readme.txt</code></pre><p><code>-m</code>后面输入的是本次提交的说明</p><h3 id="查看仓库当前的状态"><a href="#查看仓库当前的状态" class="headerlink" title="查看仓库当前的状态"></a>查看仓库当前的状态</h3><pre><code class="shell">git status</code></pre><h3 id="查看文件差异"><a href="#查看文件差异" class="headerlink" title="查看文件差异"></a>查看文件差异</h3><pre><code class="shell">git diff readme.txt</code></pre><h3 id="查看历史记录"><a href="#查看历史记录" class="headerlink" title="查看历史记录"></a>查看历史记录</h3><pre><code class="shell">git log# 加上--pretty=oneline参数，每行显示一条记录git log --pretty=oneline# reset后的历史，(HEAD -&gt; master)指向的是当前的版本git log --graph --pretty=format:&#39;%h -%d %s (%cr)&#39; --abbrev-commit --reflog* b953931 - vwx (#2180) (1 weeks ago)* 946d053 - stu (#2178) (2 weeks ago)* bad5188 - pqr (#2179) (2 weeks ago)* e5970a5 - (HEAD -&gt; master) mno (#2183) (3 weeks ago)* 1b7c09a - jkl (#2190) (3 weeks ago)* 47d28ee - ghi (#2189) (3 weeks ago)* ebe8f55 - def (#2187) (3 weeks ago)* 7a16406 - abc (#2186) (3 weeks ago)</code></pre><h3 id="回退"><a href="#回退" class="headerlink" title="回退"></a>回退</h3><p>用<code>HEAD</code>表示当前版本，也就是最新的提交3628164...882e1e0，上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写成<code>HEAD~100</code>。</p><p>回退到上一个版本</p><pre><code class="shell"># windows下输入回车 需要再按下^$ git reset --hard HEAD^HEAD is now at ea34578 add distributed</code></pre><h3 id="丢弃工作区的修改"><a href="#丢弃工作区的修改" class="headerlink" title="丢弃工作区的修改"></a>丢弃工作区的修改</h3><p>只能恢复修改的文件，新增的文件不会被删除</p><p>一种是readme.txt自修改后还没有被放到暂存区，撤销修改就回到和版本库一模一样的状态；</p><pre><code class="shell">git checkout -- file# 恢复当前目录下全部文件git checkout -- .</code></pre><p>一种是readme.txt已经添加到暂存区后，又作了修改，撤销修改就回到<strong>添加到暂存区后的状态</strong>。<br>把暂存区的修改撤销掉（修改还在，只是不在暂存区里了，需要重新add，或者用checkout恢复至版本库里的状态）</p><pre><code class="shell">$ git reset HEAD readme.txtUnstaged changes after reset:M       readme.txt</code></pre><p>或者使用<code>git reset --hard head</code> 直接恢复至版本库里的状态</p><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p>从版本库中删除该文件，那就用命令<code>git rm</code>删掉，并且<code>git commit</code></p><p>删错了，恢复 <code>git checkout</code></p><h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><h4 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h4><p>由于你的本地 Git 仓库和 GitHub 仓库之间的传输是通过 SSH 加密的，所以，需要一点设置：</p><ol><li><p>创建 SSH Key。打开 Shell，创建 SSH Key：</p><pre><code class="shell"> ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</code></pre><p> 你需要把邮件地址换成你自己的邮件地址，然后设置密码。可以在用户主目录里找到 <code>.ssh</code> 目录，里面有 <code>id_rsa</code> 和 <code>id_rsa.pub</code> 两个文件，这两个就是 <code>SSH Key</code> 的秘钥对，<code>id_rsa</code> 是私钥，不能泄露出去，<code>id_rsa.pub</code> 是公钥，可以放心地告诉任何人。</p></li><li><p>登陆 GitHub，打开 <code>Account settings</code>，<code>SSH Keys</code> 页面，然后，点 <code>Add SSH Key</code>，填上任意 Title，在 Key 文本框里粘贴 <code>id_rsa.pub</code> 文件的内容</p></li><li><p>测试ssh key是否成功，使用命令“ssh -T <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>”，如果出现You’ve successfully authenticated, but GitHub does not provide shell access 。这就表示已成功连上github。</p></li></ol><h4 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h4><p>本地仓库关联远程库</p><pre><code class="shell"># 方式一git remote add origin git@github.com:用户名/仓库名.git# 方式二git remote add origin https://github.com/用户名/仓库名.git</code></pre><p>添加后，远程库的名字就是 origin，这是 Git 默认的叫法，也可以改成别的</p><p>把本地库的所有内容推送到远程库上：</p><pre><code class="shell">git push -u origin master</code></pre><p>第一次推送 master 分支时，加上了 -u 参数，Git 不但会把本地的 master 分支内容推送的远程新的 master 分支，还会把本地的 master 分支和远程的 master 分支关联起来，在以后的推送或者拉取时就可以简化命令。</p><pre><code class="shell">git push origin master</code></pre><p>如果要推送其他分支，比如 dev，就改成：</p><pre><code class="shell">$ git push origin dev</code></pre><p>在本地创建和远程分支对应的分支，使用</p><pre><code class="shell">git checkout -b branch-name origin/branch-name# 本地和远程分支的名称最好一致；</code></pre><p>本地分支和远程分支的链接关系创建，用命令</p><pre><code class="shell">git branch --set-upstream branch-name origin/branch-name</code></pre><h4 id="从远程抓取分支"><a href="#从远程抓取分支" class="headerlink" title="从远程抓取分支"></a>从远程抓取分支</h4><pre><code class="shell">git pull</code></pre><h4 id="从远程库克隆"><a href="#从远程库克隆" class="headerlink" title="从远程库克隆"></a>从远程库克隆</h4><pre><code class="shell">git clone https://github.com/用户名/仓库名.git</code></pre><h4 id="查看远程库的信息"><a href="#查看远程库的信息" class="headerlink" title="查看远程库的信息"></a>查看远程库的信息</h4><pre><code class="shell">$ git remoteorigin# 或者，用git remote -v显示更详细的信息：$ git remote -vorigin  git@github.com:****/****.git (fetch)origin  git@github.com:****/****.git (push)# 如果没有推送权限，就看不到push的地址。</code></pre><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><h4 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a>创建与合并分支</h4><h5 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h5><pre><code class="shell"># 创建dev分支$ git checkout -b devSwitched to a new branch &#39;dev&#39;# `git checkout`命令加上`-b`参数表示创建并切换，相当于以下两条命令：$ git branch dev$ git checkout devSwitched to branch &#39;dev&#39;# 用查看当前分支，列出所有分支，当前分支前面会标一个*号$ git branch* dev  master</code></pre><h5 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h5><p>...省略在 dev 分支新增文件 并提交</p><pre><code class="shell"># 切换回master分支：$ git checkout masterSwitched to branch &#39;master&#39;# 把dev分支的工作成果合并到master分支上$ git merge devUpdating d17efd8..fec145aFast-forward readme.txt |    1 + 1 file changed, 1 insertion(+)</code></pre><p><code>git merge</code>命令用于合并指定分支到当前分支</p><h5 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h5><pre><code class="shell">$ git branch -d devDeleted branch dev (was fec145a).</code></pre><h6 id="删除没有被合并过得分支"><a href="#删除没有被合并过得分支" class="headerlink" title="删除没有被合并过得分支"></a>删除没有被合并过得分支</h6><pre><code class="shell">git branch -D dev</code></pre><h5 id="查看分支合并情况"><a href="#查看分支合并情况" class="headerlink" title="查看分支合并情况"></a>查看分支合并情况</h5><p>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。<br>用带参数的git log也可以看到分支的合并情况：</p><pre><code class="shell">$ git log --graph --pretty=oneline --abbrev-commit*   59bc1cb conflict fixed|\| * 75a857c AND simple* | 400b400 &amp; simple|/* fec145a branch test...</code></pre><h4 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h4><p>合并分支时，如果可能，Git会用<code>Fast forward</code>模式，但这种模式下，删除分支后，会丢掉分支信息。</p><p>如果要强制禁用<code>Fast forward</code>模式，Git就会在merge时<strong>生成一个新的commit</strong>，这样，从分支历史上就可以看出分支信息。</p><pre><code class="shell">$ git merge --no-ff -m &quot;merge with no-ff&quot; devMerge made by the &#39;recursive&#39; strategy. readme.txt |    1 + 1 file changed, 1 insertion(+)# 用git log看看分支历史：$ git log --graph --pretty=oneline --abbrev-commit*   7825a50 merge with no-ff|\| * 6224937 add merge|/*   59bc1cb conflict fixed...</code></pre><h4 id="当前工作现场“储藏”起来"><a href="#当前工作现场“储藏”起来" class="headerlink" title="当前工作现场“储藏”起来"></a>当前工作现场“储藏”起来</h4><p>如果需要修改BUG，但是当前工作现场有修改的内容，而且不想提交，可以先“储藏”起来</p><pre><code class="shell">$ git stashSaved working directory and index state WIP on dev: 6224937 add mergeHEAD is now at 6224937 add merge</code></pre><p>用<code>git stash list</code> 命令看看“储藏”的内容：</p><pre><code class="shell">$ git stash liststash@{0}: WIP on dev: 6224937 add merge</code></pre><p>恢复一下，有两个办法：</p><p>一是用<code>git stash apply</code>恢复，但是恢复后，stash内容并不删除，你需要用<code>git stash drop</code>来删除；</p><p>另一种方式是用<code>git stash pop</code>，恢复的同时把stash内容也删了。</p><h3 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h3><h4 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h4><pre><code class="shell">$ git tag v1.0# 后面跟commit id 可以为之前的提交创建标签$ git tag v0.9 6224937# 用-a指定标签名，-m指定说明文字：$ git tag -a v0.1 -m &quot;version 0.1 released&quot; 3628164</code></pre><p>查看所有标签</p><pre><code class="shell">$ git tagv1.0</code></pre><p>查看标签信息</p><pre><code class="shell">$ git show &lt;tagname&gt;</code></pre><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><pre><code class="shell">$ git tag -d v0.1Deleted tag &#39;v0.1&#39; (was e078af9)</code></pre><p>创建的标签都只存储在本地，不会自动推送到远程。<br>如果要推送某个标签到远程：</p><pre><code class="shell">git push origin &lt;tagname&gt;# 一次性推送全部尚未推送到远程的本地标签$ git push origin --tags</code></pre><p>如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除：</p><pre><code class="shell">$ git tag -d v0.9Deleted tag &#39;v0.9&#39; (was 6224937)</code></pre><p>然后，从远程删除。删除命令也是push，但是格式如下：</p><pre><code class="shell">$ git push origin :refs/tags/v0.9To git@github.com:michaelliao/learngit.git - [deleted]         v0.9</code></pre><h3 id="速查表"><a href="#速查表" class="headerlink" title="速查表"></a>速查表</h3><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20171217161306.png" alt="Git 常用命令速查表"><br><br></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《大话数据结构》笔记08-二叉树&lt;下篇&gt;</title>
      <link href="/2017/12/09/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B%E7%AC%94%E8%AE%B008-%E4%BA%8C%E5%8F%89%E6%A0%912/"/>
      <url>/2017/12/09/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B%E7%AC%94%E8%AE%B008-%E4%BA%8C%E5%8F%89%E6%A0%912/</url>
      
        <content type="html"><![CDATA[<h1 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h1><h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2><p>规则是若二叉树为空，则空操作返回，否则先访问跟结点，然后前序遍历左子树，在前序遍历右子树。<br><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20180217210647.png" alt="ABDGHCEIF"></p><a id="more"></a><pre><code class="c">/* 二叉树的前序遍历递归算法 */void PreOrderTraverse (BiTree T){  if (T==NULL) {    return;  }  printf (&quot;%c&quot;, T-&gt;data); /* 显示结点数据，可以更改为其他对结点操作 */  PreOrderTraverse(T-&gt;lchild); /* 再先序遍历左子树 */  PreOrderTraverse(T-&gt;rchild); /* 最后先序遍历右子树 */}</code></pre><h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><p>规则是若二叉树为空，则空操作返回，否则从跟结点开始（并不是先访问根结点），中序遍历根结点的左子树，然后是访问右子树，最后中序遍历右子树。<br><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20180217211811.png" alt="GHDBIEFCA"></p><pre><code class="c">/* 二叉树的中序遍历递归算法 */void InOrderTraverse (BiTree T){  if (T==NULL) {    return;  }  InOrderTraverse(T-&gt;lchild); /* 中序遍历左子树 */  printf (&quot;%c&quot;, T-&gt;data); /* 显示结点数据，可以更改为其他对结点操作 */  InOrderTraverse(T-&gt;rchild); /* 最后中序遍历右子树 */}</code></pre><h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><p>规则是若二叉树为空，则空操作返回，否则从左到右先子叶后结点的方式遍历访问左右子树，最后事访问根结点。<br><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20180217212330.png" alt="GHDBIEFCA"></p><pre><code class="c">/* 二叉树的后序遍历递归算法 */void PostOrderTraverse (BiTree T){  if (T==NULL) {    return;  }  PostOrderTraverse(T-&gt;lchild); /* 先后序遍历左子树 */  PostOrderTraverse(T-&gt;rchild); /* 再后序遍历右子树 */  printf (&quot;%c&quot;, T-&gt;data); /* 显示结点数据，可以更改为其他对结点操作 */}</code></pre><h2 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h2><p>规则是若二叉树为空，则空操作返回，否则从树的第一层，也就是根结点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。<br><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20180217212844.png" alt="ABCDEFGHI"></p><h2 id="推到遍历结果"><a href="#推到遍历结果" class="headerlink" title="推到遍历结果"></a>推到遍历结果</h2><p>已知前序遍历序列和中序遍历序列，可以唯一确定一棵二叉树。<br>已知后序遍历序列和中序遍历序列，可以唯一确定一棵二叉树。<br>已知前序遍历序列和后序遍历序列，不能确定一棵二叉树。</p><h1 id="二叉树的建立"><a href="#二叉树的建立" class="headerlink" title="二叉树的建立"></a>二叉树的建立</h1><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20180217214907.png" alt="二叉树的建立"></p><p>前序序列 AB#D##C##，用键盘挨个输入。实现的算法如下：</p><pre><code class="c">/* 按前序输入二叉树中结点的值（一个字符） *//* #表示空树，构造二叉链表表示二叉树T。 */void CreateBiTree (BiTree *T) {  TElemType ch;  scanf(&quot;%c&quot;, &amp;ch);  if (ch==&#39;#&#39;){    *T=NULL;  }else{    *T=(BiTree)malloc(sizeof(BiTNode));    if(!*T){      exit(OVERFLOW);    }    (*T)-&gt;data=ch; /* 生成根结点 */    CreateBiTree(&amp;(*T)-&gt;lchild); /* 构造左子树 */    CreateBiTree(&amp;(*T)-&gt;rchild); /* 构造右子树 */  }}</code></pre><h1 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h1><p>中序遍历时得到 HDIBJEAFCG 这样的序列，可以知道结点 I 的前驱是 D，后继是 B。<br>指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树就称为线索二叉树（Threaded Binary Tree）。</p><br>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 大话数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《大话数据结构》笔记07-二叉树&lt;上篇&gt;</title>
      <link href="/2017/11/09/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B%E7%AC%94%E8%AE%B007-%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2017/11/09/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B%E7%AC%94%E8%AE%B007-%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>二叉树（Binary Tree）是 $n(n≥0)$个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根结点和两颗互不相交的、分别称为根结点的左子树和右子树组成。</p><a id="more"></a><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>每个结点最多有两颗子树</li><li>左子树和右子树是有顺序的</li><li>即使树中某个结点只有一颗子树，也需要区分它是左子树还是右子树。</li></ul><h2 id="五种基本形态"><a href="#五种基本形态" class="headerlink" title="五种基本形态"></a>五种基本形态</h2><ul><li>空二叉树</li><li>只有一个根结点</li><li>根结点只有左子树</li><li>根结点只有右子树</li><li>根结点既有左子树又有右子树</li></ul><h2 id="特殊二叉树"><a href="#特殊二叉树" class="headerlink" title="特殊二叉树"></a>特殊二叉树</h2><ul><li>斜树<br>所有的结点都只有左子树的二叉树叫左斜树。所有的结点都只有右子树的二叉树叫右斜树。这两者统称为斜树。<br><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20180208120028.png" alt="斜树"></li><li>满二叉树<br>在一棵二叉树中，如果所有的分支结点都存在左子树和右子树，并且<strong>所有叶子都在同一层上</strong>，这样的二叉树称为满二叉树。<br>满二叉树特点：<ul><li>叶子只能出现在最下一层</li><li>非叶子结点的度一定是2</li><li>同样深度的二叉树树中，满二叉树的结点个数最多，叶子数最多。<br><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20180208151615.png" alt="满二叉树"></li></ul></li><li>完全二叉树<br>对一棵具有 n 个结点的二叉树按层序编号，如果编号为 $i(1≤i≤n)$ 的结点与同样深度的满二叉树中编号为 i 的结点在二叉树的位置完全相同，则这棵二叉树称为完全二叉树。<br>满二叉树一定是一棵完全二叉树，但完全二叉树不一定是满二叉树。<br>完全二叉树特点：<ul><li>叶子结点只能出现在最下两层</li><li>最下层的叶子一定集中在左部连续位置</li><li>倒数二层，若有叶子结点，一定都在右部连续位置</li><li>如果结点度为 1，则该结点只有左孩子，既不存在只有右子树的情况</li><li>同样结点数的二叉树，完全二叉树的深度最小<br><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20180208152851.png" alt="完全二叉树"></li></ul></li></ul><h1 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h1><ol><li>在二叉树的第 i 层上至多有 $2^{i-1}$ 个结点 $(i≥1)$</li><li>深度为 k 的二叉树至多有 $2^k-1$ 个结点 $(k≥1)$</li><li>对任何一棵二叉树 T，如果其终端结点数为 $N_0$，度为 2 的结点数为 $N_2$，则 $N_0=N_2+1$。</li><li>具有 n 个结点的<strong>完全二叉树</strong>的深度为「$log_2 n$」$+1$ (「x」表示不大于 x 的最大整数)。</li><li>如果对一棵有 n 个结点的<strong>完全二叉树</strong>（其深度为「$log_2 n$」$+1$）的结点按层序编号（从第 1 层到第「$log_2 n$」$+1$层，每层从左到右），对任一结点 $i （1≤i≤n）$有：<ol><li>如果 $i=1$，则结点 $i$ 是二叉树的根，无双亲；如果 $i＞1$，则其双亲是结点「$i/2$」。</li><li>如果 $2i&gt;n$，则结点 $i$ 无左孩子（结点 $i$ 为叶子结点）；否则其左孩子是结点 $2i$。</li><li>如果 $2i+1&gt;n$，则结点 $i$ 无右孩子；否则其右孩子是结点 $2i+1$。</li></ol></li></ol><h1 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h1><h2 id="二叉树顺序存储结构"><a href="#二叉树顺序存储结构" class="headerlink" title="二叉树顺序存储结构"></a>二叉树顺序存储结构</h2><p>顺序存储结构一般只用于<strong>完全二叉树</strong>。如果不是完全二叉树会造成空间的浪费。<br><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20180217204907.png" alt="二叉树顺序存储结构"></p><h2 id="二叉链表"><a href="#二叉链表" class="headerlink" title="二叉链表"></a>二叉链表</h2><table style="width: 280px;"><thead><tr><th style="text-align:center;border: 2px solid #ddd;width: 140px;">lchild</th><th style="text-align:center;border: 2px solid #ddd;width: 140px;">data</th><th style="text-align:center;border: 2px solid #ddd;width: 140px;">rchild</th></tr></thead></table><p><code>data</code> 是数据域。<br><code>lchild</code> 和 <code>rchild</code> 都是指针域，分别存放左右孩子的指针。</p><pre><code class="c">/* 二叉树的二叉链表结点结构定义 */typedef struct BiTNode /* 结点结构 */ {    TElemType Data; /* 结点数据 */    struct BiTNode *lchild, *rchild; /* 左右孩子指针 */} BiTNode, *BiTree;</code></pre><br>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 大话数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript实现复制到剪贴板功能</title>
      <link href="/2017/10/13/JavaScript%E5%AE%9E%E7%8E%B0%E5%A4%8D%E5%88%B6%E5%88%B0%E5%89%AA%E8%B4%B4%E6%9D%BF%E5%8A%9F%E8%83%BD/"/>
      <url>/2017/10/13/JavaScript%E5%AE%9E%E7%8E%B0%E5%A4%8D%E5%88%B6%E5%88%B0%E5%89%AA%E8%B4%B4%E6%9D%BF%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<p>支持IE8-11，chrome，Firefox。</p><pre><code class="html">&lt;script&gt;function copyUrl(){    // 如果需要复制的部分不在textarea里，可以隐藏一个textarea    //$(&#39;#copytextarea&#39;).show();    var Url2=document.getElementById(&quot;copytextarea&quot;);    Url2.select(); // 选择对象    document.execCommand(&quot;Copy&quot;); // 执行浏览器复制命令    //$(&#39;#copytextarea&#39;).hide();    layer.tips(&#39;复制成功！&#39;, &#39;#copybutton&#39;);}&lt;/script&gt;&lt;textarea id=&quot;copytextarea&quot; &gt;内容&lt;/textarea&gt;&lt;a href=&quot;#&quot; id=&#39;copybutton&#39; onClick=&quot;copyUrl();return false;&quot;&gt;复制&lt;/a&gt;</code></pre><a id="more"></a><h2 id="开源JS库实现"><a href="#开源JS库实现" class="headerlink" title="开源JS库实现"></a>开源JS库实现</h2><p>支持版本 Chrome 42+，Edge 12+，Firefox 41+，IE 9+，Opera 29+，Safari 10+</p><p><a href="https://github.com/zenorocha/clipboard.js" target="_blank" rel="noopener">https://github.com/zenorocha/clipboard.js</a></p><br>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jQuery操作select的方法</title>
      <link href="/2017/10/01/jQuery%E6%93%8D%E4%BD%9Cselect%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2017/10/01/jQuery%E6%93%8D%E4%BD%9Cselect%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>以下面的html为例来说明：</p><pre><code class="html">&lt;select name=&quot;select&quot; id=&quot;select_id&quot;&gt;    &lt;option value=&quot;1&quot;&gt;11&lt;/option&gt;    &lt;option value=&quot;2&quot;&gt;22&lt;/option&gt;    &lt;option value=&quot;3&quot;&gt;33&lt;/option&gt;    &lt;option value=&quot;4&quot;&gt;44&lt;/option&gt;    &lt;option value=&quot;5&quot;&gt;55&lt;/option&gt;    &lt;option value=&quot;6&quot;&gt;66&lt;/option&gt;&lt;/select&gt;</code></pre><a id="more"></a><h3 id="设置Select的选中项"><a href="#设置Select的选中项" class="headerlink" title="设置Select的选中项"></a>设置Select的选中项</h3><pre><code class="js">$(&quot;#select_id&quot;).get(0).selectedIndex = 1; // 设置Select索引值为1的项选中$(&quot;#select_id&quot;).val(4); // 设置Select的Value值为4的项选中//设置select 选中的text，通常可以在select回填中使用var numId=33 //设置text==33的选中！var count=$(&quot;#select_id  option&quot;).length;for(var i=0;i&lt;count;i++){    if($(&quot;#select_id&quot;).get(0).options[i].text == numId) {        $(&quot;#select_id&quot;).get(0).options[i].selected = true;        break;   }}</code></pre><h3 id="获取Select选中项"><a href="#获取Select选中项" class="headerlink" title="获取Select选中项"></a>获取Select选中项</h3><pre><code class="js">var checkValue = $(&quot;#select_id&quot;).val(); // 获取Select选中项的Valuevar checkText = $(&quot;#select_id :selected&quot;).text();$(&quot;#select_id&quot;).find(&quot;option:selected&quot;).text(); // 获取Select选中项的Textvar checkIndex = $(&quot;#select_id&quot;).prop(&quot;selectedIndex&quot;);$(&quot;#select_id&quot;).get(0).selectedIndex; // 获取Select选中项的索引值var maxIndex =$(&quot;#select_id :last&quot;).get(0).index; // 获取Select最大的索引值</code></pre><h3 id="添加-删除Select的Option项"><a href="#添加-删除Select的Option项" class="headerlink" title="添加/删除Select的Option项"></a>添加/删除Select的Option项</h3><pre><code class="js">// 为Select追加一个Option(下拉项)$(&quot;#select_id&quot;).append(&quot;&lt;option value=&#39;新增&#39;&gt;新增option&lt;/option&gt;&quot;);// 为Select插入一个Option(第一个位置)$(&quot;#select_id&quot;).prepend(&quot;&lt;option value=&#39;请选择&#39;&gt;请选择&lt;/option&gt;&quot;);// 删除Select中索引值为1的Option(第二个)$(&quot;#select_id&quot;).get(0).remove(1);// 删除Select中索引值最大Option(最后一个)$(&quot;#select_id :last&quot;).remove();// 删除Select中Value=&#39;3&#39;的Option$(&quot;#select_id [value=&#39;3&#39;]&quot;).remove();$(&quot;#select_id&quot;).empty(); //清空</code></pre><br>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> jQuery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jQuery操作checkbox的方法</title>
      <link href="/2017/10/01/jQuery%E6%93%8D%E4%BD%9Ccheckbox%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2017/10/01/jQuery%E6%93%8D%E4%BD%9Ccheckbox%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>checkbox：复选框。<br>操作实例：<a href="https://blog-1252208501.cos.ap-beijing.myqcloud.com/jQuery%E6%93%8D%E4%BD%9Ccheckbox%E7%9A%84%E6%96%B9%E6%B3%95.html" target="_blank" rel="noopener">jQuery操作checkbox的方法</a></p><a id="more"></a><p>下面的html为例进行checkbox的操作。</p><pre><code class="html">&lt;input type=&quot;checkbox&quot; name=&quot;checkbox&quot; id=&quot;checkAll&quot; /&gt;全选/取消全选&lt;input type=&quot;checkbox&quot; name=&quot;checkbox&quot; id=&quot;id1&quot; value=&quot;1&quot; /&gt;1&lt;input type=&quot;checkbox&quot; name=&quot;checkbox&quot; id=&quot;id2&quot; value=&quot;2&quot; /&gt;2&lt;input type=&quot;checkbox&quot; name=&quot;checkbox&quot; id=&quot;id3&quot; value=&quot;3&quot; /&gt;3&lt;input type=&quot;checkbox&quot; name=&quot;checkbox&quot; id=&quot;id4&quot; value=&quot;4&quot; /&gt;4&lt;input type=&quot;checkbox&quot; name=&quot;checkbox&quot; id=&quot;id5&quot; value=&quot;5&quot; /&gt;5</code></pre><h2 id="选中checkbox"><a href="#选中checkbox" class="headerlink" title="选中checkbox"></a>选中checkbox</h2><p>由于和上篇一样的原因<a href="/2017/09/28/jQuery操作radio的方法/#选中radio存在的问题">jQuery操作radio的方法-选中radio存在的问题</a>，所以这里不再使用<code>attr</code>，从而使用<code>prop</code>。</p><pre><code class="js">var isSelected = $(&quot;#id3&quot;).prop(&quot;checked&quot;);//判断id=id3的那个复选框是否处于选中状态，选中则isSelected=true;否则isSelected=false;var isSelected = $(&quot;#id3&quot;).is(&quot;:checked&quot;);//判断id=id3的那个复选框是否处于选中状态，选中则isSelected=true;否则isSelected=false;$(&quot;#id3&quot;).prop(&quot;checked&quot;, true);//将id=id3的那个复选框选中，即打勾$(&quot;#id3&quot;).prop(&quot;checked&quot;, &#39;checked&#39;);//将id=id3的那个复选框选中，即打勾$(&quot;#id3&quot;).prop(&quot;checked&quot;, false);//将id=id3的那个复选框不选中，即不打勾$(&quot;#id3&quot;).prop(&quot;checked&quot;, &#39;&#39;);//将id=id3的那个复选框不选中，即不打勾$(&quot;input[name=checkbox][value=3]&quot;).prop(&quot;checked&quot;, &#39;checked&#39;);//将name=checkbox, value=3 的那个复选框选中，即打勾$(&quot;input[name=checkbox][value=3]&quot;).prop(&quot;checked&quot;, &#39;&#39;);//将name=checkbox, value=3 的那个复选框不选中，即不打勾$(&quot;input[type=checkbox][name=checkbox]&quot;).get(2).checked = true;//设置index = 2，即第三项为选中状态document.getElementById(&quot;checkAll&quot;).checked = true;//原生写法</code></pre><h2 id="获取当前选中的值"><a href="#获取当前选中的值" class="headerlink" title="获取当前选中的值"></a>获取当前选中的值</h2><pre><code class="js">var val = $(&quot;#id1&quot;).val();//获取指定id为id1的复选框的值$(&quot;input[type=checkbox][name=checkbox]:checked&quot;).each(function(){ //由于复选框一般选中的是多个,所以可以循环输出选中的值    alert($(this).val());});//原生写法var ids = document.getElementsByName(&quot;checkbox&quot;);for(var i=0;i&lt;ids.length;i++){    if(ids[i].checked){        alert(ids[i].value);    }}</code></pre><h2 id="全选和全不选"><a href="#全选和全不选" class="headerlink" title="全选和全不选"></a>全选和全不选</h2><pre><code class="js">$(&quot;#checkAll&quot;).click(function(){    if($(this).is(&quot;:checked&quot;)) {        $(&quot;input[name=&#39;checkbox&#39;]&quot;).each(function() {            this.checked = true;            //$(this).prop(&quot;checked&quot;, true); //同上一句        });    } else {        $(&quot;input[name=&#39;checkbox&#39;]&quot;).each(function() {            this.checked = false;            //$(this).prop(&quot;checked&quot;, false); //同上一句        });    }});</code></pre><h2 id="自动监听是否要选择全选框"><a href="#自动监听是否要选择全选框" class="headerlink" title="自动监听是否要选择全选框"></a>自动监听是否要选择全选框</h2><pre><code class="js">$(&quot;input[name=&#39;checkbox&#39;]&quot;).click(function() {    if($(this).is(&quot;:checked&quot;)) {        var flag = true;        $(&quot;input[name=&#39;checkbox&#39;]&quot;).each(function() {            if(this.checked==false) {                flag = false;            }        });        if(flag==true) {//两种方式均可            //document.getElementById(&quot;checkAll&quot;).checked = true;            $(&quot;#checkAll&quot;).prop(&quot;checked&quot;, true);        }    } else {        $(&quot;#checkAll&quot;).attr(&quot;checked&quot;, false);    }});</code></pre><br>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> jQuery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jQuery操作radio的方法</title>
      <link href="/2017/09/28/jQuery%E6%93%8D%E4%BD%9Cradio%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2017/09/28/jQuery%E6%93%8D%E4%BD%9Cradio%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>以下面的html为例：</p><pre><code class="html">&lt;input type=&quot;radio&quot; name=&quot;radio&quot; value=&quot;1&quot; /&gt;1&lt;input type=&quot;radio&quot; name=&quot;radio&quot; id=&quot;radio2&quot; value=&quot;2&quot; /&gt;2&lt;input type=&quot;radio&quot; name=&quot;radio&quot; value=&quot;3&quot; /&gt;3&lt;input type=&quot;radio&quot; name=&quot;radio&quot; value=&quot;4&quot; /&gt;4</code></pre><a id="more"></a><h2 id="选中radio"><a href="#选中radio" class="headerlink" title="选中radio"></a>选中radio</h2><pre><code class="js">// 选中第一个$(&quot;input[name=radio]:eq(0)&quot;).attr(&quot;checked&quot;,&#39;checked&#39;);// 设置id=radio2的一项为选中$(&quot;#radio2&quot;).attr(&quot;checked&quot;,&quot;checked&quot;);// 设置id=radio2的一项为不选中$(&quot;#radio2&quot;).removeAttr(&quot;checked&quot;);// 设置value = 2的一项为选中$(&quot;input[type=&#39;radio&#39;][name=&#39;radio&#39;][value=&#39;2&#39;]&quot;).attr(&quot;checked&quot;, &quot;checked&quot;);// 设置index = 1，即第二项为当前选中$(&quot;input[type=&#39;radio&#39;][name=&#39;radio&#39;]&quot;).get(1).checked = true;// id为radio2的一项处于选中状态则isChecked = &quot;checked&quot;, 否则isChecked = undefined;var isChecked = $(&quot;#radio2&quot;).attr(&quot;checked&quot;);</code></pre><h2 id="选中radio存在的问题"><a href="#选中radio存在的问题" class="headerlink" title="选中radio存在的问题"></a>选中radio存在的问题</h2><p>使用<code>$(&quot;#radio2&quot;).attr(&quot;checked&quot;,&quot;checked&quot;);</code>设置选中后，如果再使用该方法选中别的radio，就会出现没有一个处于选中状态。</p><blockquote><p>attribute 和 property 是不同的。</p><p>property 是 html 标签<strong>固有的属性</strong>，而 attribute 多是 html <strong>自定义属性</strong>。<br>attribute是 html 文档上<strong>标签属性</strong>，而 property 则是对应 DOM 元素的<strong>自身属性</strong>。</p><p>从操作方法上来看，attribute可以通过 DOM 规范的 <code>getAttribute</code> 和 <code>setAttribute</code>进行获取修改，而 property 可以通过对象访问属性的方式，或者 <code>[&quot; &quot;]</code>来修改获取。</p><p><code>jQuery</code> 获取或设置 attribute 用的是 <code>attr</code> ,获取或设置 property 用的是 <code>prop</code>。</p><p>作者：天天向上卡索<br>链接：<a href="http://www.jianshu.com/p/6ac7541b1f45" target="_blank" rel="noopener">http://www.jianshu.com/p/6ac7541b1f45</a><br>來源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote><h3 id="模拟点击"><a href="#模拟点击" class="headerlink" title="模拟点击"></a>模拟点击</h3><p>设置选中之后调用对象的<code>click()</code>方法</p><pre><code class="js">$(&quot;input:radio[name=&#39;radio&#39;][value=&#39;1&#39;]&quot;).click();</code></pre><h3 id="原生JS"><a href="#原生JS" class="headerlink" title="原生JS"></a>原生JS</h3><pre><code class="js">//checkdocument.getElementsByName(&quot;radio&quot;)[0].checked = true;//uncheckdocument.getElementsByName(&quot;radio&quot;)[0].checked = false;$(&quot;input[type=&#39;radio&#39;][name=&#39;radio&#39;]&quot;).get(1).checked = true;$(&quot;input[type=&#39;radio&#39;][name=&#39;radio&#39;]&quot;).[1].checked = true;</code></pre><h3 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h3><pre><code class="js">$(&quot;#radio2&quot;).prop(&quot;checked&quot;,true);</code></pre><h2 id="有多少个被选中"><a href="#有多少个被选中" class="headerlink" title="有多少个被选中"></a>有多少个被选中</h2><pre><code class="js">//name为radio的radio有多少个被选中$(&quot;input[type=&#39;radio&#39;][name=&#39;radio&#39;]:checked&quot;).length;</code></pre><h2 id="获取radio被选中项的值"><a href="#获取radio被选中项的值" class="headerlink" title="获取radio被选中项的值"></a>获取radio被选中项的值</h2><pre><code class="js">$(&#39;input[type=&quot;radio&quot;][name=&quot;radio&quot;]:checked&#39;).val();</code></pre><br>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> jQuery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo使用记录</title>
      <link href="/2017/09/13/Hexo%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/"/>
      <url>/2017/09/13/Hexo%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h2><p>使用 <code>npm</code> 完成 <code>Hexo</code> 的安装。</p><pre><code class="shell">&gt; $ npm install -g hexo-cli</code></pre><a id="more"></a><p>安装 <code>Hexo</code> 完成后，请执行下列命令，<code>Hexo</code> 将会在指定文件夹中新建所需要的文件。</p><pre><code class="shell">&gt; $ hexo init&gt; $ cd&gt; $ npm install</code></pre><p>安装<code>Sitemap</code>插件</p><blockquote><p>npm install hexo-generator-sitemap  --save</p></blockquote><p>安装<code>RSS</code>插件</p><blockquote><p>npm install hexo-generator-feed --save</p></blockquote><p>安装在浏览器上编写markdown插件，访问地址 <a href="http://localhost:4000/admin/" target="_blank" rel="noopener">http://localhost:4000/admin/</a></p><blockquote><p>npm install hexo-admin  --save</p></blockquote><p>安装支持<code>LaTeX</code>插件 <a href="https://github.com/hexojs/hexo-math" target="_blank" rel="noopener">hexo-math</a></p><blockquote><p>npm install hexo-math --save</p></blockquote><p>新版本需要修改<code>_config.yml</code>文件</p><pre><code class="yml">math:  engine: &#39;mathjax&#39;  mathjax:    src: &quot;//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;    config:      tex2jax:        inlineMath: [ [&#39;$&#39;,&#39;$&#39;], [&quot;\\(&quot;,&quot;\\)&quot;] ]        skipTags: [&#39;script&#39;, &#39;noscript&#39;, &#39;style&#39;, &#39;textarea&#39;, &#39;pre&#39;, &#39;code&#39;]        processEscapes: true      TeX:        equationNumbers:          autoNumber: &quot;AMS&quot;</code></pre><p><code>LaTeX</code> 语法</p><blockquote><p><a href="http://blog.csdn.net/lanxuezaipiao/article/details/44341645" target="_blank" rel="noopener">CSDN-markdown语法之如何使用LaTeX语法编写数学公式</a></p></blockquote><h2 id="archive页面分页设置"><a href="#archive页面分页设置" class="headerlink" title="archive页面分页设置"></a>archive页面分页设置</h2><blockquote><p><a href="https://github.com/iissnan/hexo-theme-next/issues/30" target="_blank" rel="noopener">https://github.com/iissnan/hexo-theme-next/issues/30</a><br><a href="https://github.com/hexojs/hexo-generator-archive" target="_blank" rel="noopener">https://github.com/hexojs/hexo-generator-archive</a></p></blockquote><p><code>_config.yml</code> 文件中的配置，这个配置控制所有的分页配置，包括首页、归档页、tag 分类页面。</p><blockquote><p>per_page: 10</p></blockquote><p>如果我们想对上面三个页面做独立的配置，需要安装插件进行功能支持。</p><blockquote><p>hexo-generator-index<br>hexo-generator-archive<br>hexo-generator-tag</p></blockquote><pre><code class="shell">npm install hexo-generator-archive --savenpm install hexo-generator-index --savenpm install hexo-generator-tag --save</code></pre><p>对应的 <code>_config.yml</code> 文件中添加如下配置</p><pre><code class="yml">index_generator:  per_page: 5archive_generator:  per_page: 20  ## 为 0 时表示不分页全展示  yearly: true  ## 按年生成归档  monthly: true ## 按月生成归档tag_generator:  per_page: 10</code></pre><h2 id="单引号显示异常"><a href="#单引号显示异常" class="headerlink" title="单引号显示异常"></a>单引号显示异常</h2><blockquote><p><a href="https://github.com/hexojs/hexo/issues/1981" target="_blank" rel="noopener">https://github.com/hexojs/hexo/issues/1981</a></p></blockquote><p>用的英文单引号，比如 &#39;Welcome&#39; to Hexo! ，显示在浏览器中就变成了‘Welcome’ to Hexo! ，单引号变成中文的了。</p><blockquote><p>如果用的是 <code>marked renderer</code> 的话，可以试试看关掉 <code>smartypants</code>？</p></blockquote><pre><code class="yml">marked:  smartypants: false</code></pre><blockquote><p><a href="https://github.com/hexojs/hexo-renderer-marked" target="_blank" rel="noopener">https://github.com/hexojs/hexo-renderer-marked</a></p></blockquote><p>修改 <code>_config.yml</code> 文件.</p><pre><code class="yml">marked:  gfm: true  pedantic: false  sanitize: false  tables: true  breaks: true  smartLists: true  smartypants: true  modifyAnchors: &#39;&#39;  autolink: true</code></pre><ul><li><code>gfm</code> - 使用 <code>GitHub</code>风格的<a href="https://help.github.com/articles/github-flavored-markdown" target="_blank" rel="noopener"><code>markdown</code></a></li><li><code>pedantic</code> - Conform to obscure parts of markdown.pl as much as possible. Don&#39;t fix any of the original markdown bugs or poor behavior.</li><li><code>sanitize</code> - 忽略已输入的任何 HTML。</li><li><code>tables</code> - Enable GFM <a href="https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet#wiki-tables" target="_blank" rel="noopener">tables</a>. This option requires the gfm option to be true.</li><li><code>breaks</code> - Enable GFM <a href="https://help.github.com/articles/github-flavored-markdown#newlines" target="_blank" rel="noopener">line breaks</a>. This option requires the gfm option to be true.</li><li><code>smartLists</code> - Use smarter list behavior than the original markdown.</li><li><code>smartypants</code> - Use &quot;smart&quot; typograhic punctuation for things like quotes and dashes.</li><li><code>modifyAnchors</code> - Use for transform anchorIds. if 1 to lowerCase and if 2 to upperCase.</li><li><code>autolink</code> - Enable autolink for URLs. E.g. <code>http://hexo.io</code> will become <code>&lt;a href=&quot;http://hexo.io&quot;&gt;http://hexo.io&lt;/a&gt;</code>.</li></ul><h2 id="br-标签过多问题"><a href="#br-标签过多问题" class="headerlink" title="br 标签过多问题"></a>br 标签过多问题</h2><pre><code class="yml">marked:    gfm: true    breaks: false</code></pre><blockquote><p><a href="https://github.com/hexojs/hexo/issues/1388#issuecomment-171513200" target="_blank" rel="noopener">https://github.com/hexojs/hexo/issues/1388#issuecomment-171513200</a></p></blockquote><p>会影响到普通文本，单个回车不会换行</p><pre><code class="text">123qwe</code></pre><p>渲染结果：123 qwe</p><h2 id="预览草稿"><a href="#预览草稿" class="headerlink" title="预览草稿"></a>预览草稿</h2><p>如果你希望强行预览草稿，更改配置文件 <code>_config.yml</code>：</p><blockquote><p>render_drafts: true</p></blockquote><p>或者如下方式启动 <code>server</code>：</p><blockquote><p>$ hexo server --drafts</p></blockquote><h2 id="创建一篇新文章"><a href="#创建一篇新文章" class="headerlink" title="创建一篇新文章"></a>创建一篇新文章</h2><pre><code class="shell">$ hexo new [layout] &lt;title&gt;</code></pre><p>在命令中指定文章的布局（<code>layout</code>），默认为 <code>post</code>。</p><p>默认布局：<code>post</code>、<code>page</code> 和 <code>draft</code>。</p><p>通过 <code>publish</code> 命令将草稿移动到 <code>source/_posts</code> 文件夹。</p><pre><code class="shell">$ hexo publish [layout] &lt;title&gt;</code></pre><h2 id="转义反引号"><a href="#转义反引号" class="headerlink" title="转义反引号"></a>转义反引号</h2><p>最外层连续两个反引号。</p><p><code>git archive master --format=zip &gt; `git describe master`.zip</code></p><h2 id="更换引用样式"><a href="#更换引用样式" class="headerlink" title="更换引用样式"></a>更换引用样式</h2><pre><code class="html">&lt;blockquote style=&quot;margin-top: 1em;margin-bottom: 1em;padding: 15px 15px 15px 1rem;color: rgb(129, 145, 152);border-left-width: 6px;border-left-color: rgb(220, 230, 240);background: rgb(242, 247, 251);font-family: -webkit-body;font-style: normal;&quot;&gt;&lt;ol style=&quot;margin-top: 0em;margin-bottom: 0em;&quot;&gt;&lt;li&gt;&lt;span&gt;内容1&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;内容2&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;内容3&lt;/span&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;</code></pre><blockquote style="margin-top: 1em;margin-bottom: 1em;padding: 15px 15px 15px 1rem;color: rgb(129, 145, 152);border-left-width: 6px;border-left-color: rgb(220, 230, 240);background: rgb(242, 247, 251);font-family: -webkit-body;font-style: normal;"><ol style="margin-top: 0em;margin-bottom: 0em;"><li><span>内容1</span></li><li><span>内容2</span></li><li><span>内容3</span></li></ol></blockquote><h2 id="TypeError-Cannot-set-property-39-lastIndex-39-of-undefined"><a href="#TypeError-Cannot-set-property-39-lastIndex-39-of-undefined" class="headerlink" title="TypeError: Cannot set property &#39;lastIndex&#39; of undefined"></a>TypeError: Cannot set property &#39;lastIndex&#39; of undefined</h2><p>解决方法：</p><p>在配置文件 <code>_config.yml</code> 中将 <code>highlight</code> 选项中的 <code>auto_detect</code> 设为 <code>false</code></p><blockquote><p><a href="https://github.com/hexojs/hexo/issues/1913" target="_blank" rel="noopener">https://github.com/hexojs/hexo/issues/1913</a></p></blockquote><h2 id="ERROR-Deployer-not-found-git"><a href="#ERROR-Deployer-not-found-git" class="headerlink" title="ERROR Deployer not found: git"></a>ERROR Deployer not found: git</h2><p>解决方法：</p><pre><code class="shell">npm install hexo-deployer-git --save</code></pre><h2 id="博客加密功能"><a href="#博客加密功能" class="headerlink" title="博客加密功能"></a>博客加密功能</h2><blockquote><p><a href="https://github.com/MikeCoder/hexo-blog-encrypt" target="_blank" rel="noopener">https://github.com/MikeCoder/hexo-blog-encrypt</a></p></blockquote><p>安装</p><blockquote><p>npm install --save hexo-blog-encrypt</p></blockquote><p>在 themes 下的 <code>_config.yml</code> 中启用该插件:</p><pre><code class="yml"># Securityencrypt: # hexo-blog-encrypt  enable: true</code></pre><p>然后在你的文章的头部添加上对应的字段，如 password, abstract, message</p><pre><code class="markdown">---title: Hello Worlddate: 2016-03-30 21:18:02password: mikemessiabstract: Something was encrypted, please enter password to read.message: Welcome to my blog, please enter password to read.---</code></pre><p><a href="https://github.com/MikeCoder/hexo-blog-encrypt/blob/master/ReadMe.zh.md#%E5%AF%B9-toc-%E8%BF%9B%E8%A1%8C%E5%8A%A0%E5%AF%86" target="_blank" rel="noopener">对 TOC 进行加密</a></p><p><a href="https://github.com/MikeCoder/hexo-blog-encrypt/blob/master/ReadMe.zh.md#%E4%BF%AE%E6%94%B9%E5%8A%A0%E5%AF%86%E6%A8%A1%E6%9D%BF" target="_blank" rel="noopener">修改加密模板</a></p><p><a href="https://github.com/MikeCoder/hexo-blog-encrypt/blob/master/ReadMe.zh.md#%E5%9B%9E%E8%B0%83" target="_blank" rel="noopener">回调</a></p><h2 id="Hexo-置顶及排序问题"><a href="#Hexo-置顶及排序问题" class="headerlink" title="Hexo 置顶及排序问题"></a>Hexo 置顶及排序问题</h2><blockquote><p><a href="https://yelog.org/2017/02/24/hexo-top-sort/" target="_blank" rel="noopener">https://yelog.org/2017/02/24/hexo-top-sort/</a></p></blockquote><p>重装了一次电脑，.md 文件通过 git 备份了，还原回来的时候，md 的创建时间都是一样的，所以文章列表就按照文章标题排序了。</p><p>安装插件命令： npm install hexo-generator-topindex --save</p><p>或者：<br>修改hexo的js代码<br>直接上操作，修改node_modules/hexo-generator-index/lib/generator.js</p><pre><code class="js">&#39;use strict&#39;;var pagination = require(&#39;hexo-pagination&#39;);module.exports = function(locals){  var config = this.config;  var posts = locals.posts;    posts.data = posts.data.sort(function(a, b) {        if(a.top &amp;&amp; b.top) { // 两篇文章top都有定义            if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排            else return b.top - a.top; // 否则按照top值降序排        }        else if(a.top &amp;&amp; !b.top) { // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233）            return -1;        }        else if(!a.top &amp;&amp; b.top) {            return 1;        }        else return b.date - a.date; // 都没定义按照文章日期降序排    });  var paginationDir = config.pagination_dir || &#39;page&#39;;  return pagination(&#39;&#39;, posts, {    perPage: config.index_generator.per_page,    layout: [&#39;index&#39;, &#39;archive&#39;],    format: paginationDir + &#39;/%d/&#39;,    data: {      __index: true    }  });};</code></pre><h3 id="设置置顶"><a href="#设置置顶" class="headerlink" title="设置置顶"></a>设置置顶</h3><p>给需要置顶的文章加入 top 参数，如下</p><pre><code class="md">---title: 每天一个linux命令date: 2017-01-23 11:41:48top: 1categories:- 运维tags:- linux命令---</code></pre><p>如果存在多个置顶文章，top 后的参数越大，越靠前。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《大话数据结构》笔记06-树</title>
      <link href="/2017/09/09/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B%E7%AC%94%E8%AE%B006-%E6%A0%91/"/>
      <url>/2017/09/09/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B%E7%AC%94%E8%AE%B006-%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h3 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h3><p>树（Tree）是 $n(n≥0)$ 个结点的有限集。$n=0$ 时称为空树。在任意一棵非空树中：<br>（1）有且仅有一个特定的称为根（Root）的结点；<br>（2）当 $n&gt;1$ 时，其余结点可分为 $m(m&gt;0)$ 个互不相交的有限集 $T_1、T_2、......、T_m$，其中每一个集合本身又是一棵树，并且称为根的子树（SubTree），如图所示：</p><a id="more"></a><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/5da0bb1e-9354-4005-ad6f-b7b30170f2c5.png" alt="树"></p><p>当$m&gt;1$时，子树没有限制，但他们一定不能相交。<br><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/dfb4e1a0-e70f-4f52-b213-3750a312ad34.png" alt="有相交的子树"></p><h3 id="结点分类"><a href="#结点分类" class="headerlink" title="结点分类"></a>结点分类</h3><p>结点拥有的子树数称为结点的<strong>度</strong>（Degree）。<br>度为 0 的结点称为<strong>叶节点</strong>（Leaf)或<strong>终端结点</strong>。<br>度不为 0 的结点称为<strong>非终端结点或分支结点</strong>。<br>除根结点之外，分支结点也称为<strong>内部结点</strong>。<br><strong>树的度</strong>是树内各结点的度的最大值。<br><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/dcae6ab8-77d9-4e43-af3b-dde5b0b6a3e2.png" alt="结点分类"><br>上图中这棵树结点的度的最大值是结点 D 的度为 3，所以树的度也为 3。</p><h3 id="结点间关系"><a href="#结点间关系" class="headerlink" title="结点间关系"></a>结点间关系</h3><p>结点的子树的根称为该结点的<strong>孩子</strong>（Child），相应地，该结点称为孩子的<strong>双亲</strong>（Parent）。同一个双亲的孩子之间互称为<strong>兄弟</strong>（Sibling）。结点的祖先是从根到该结点所经分支上的所有结点。反之，以某结点为根的子树中的任一结点都称为该结点的子孙。</p><h3 id="树的其他相关概念"><a href="#树的其他相关概念" class="headerlink" title="树的其他相关概念"></a>树的其他相关概念</h3><p><strong>结点的层次（Level）从根开始定义起，根为第一层，根的孩子为第二层。</strong>若某结点在第l层，则其子树就在第l+1层。其<strong>双亲在同一层的结点互为堂兄弟</strong>。显然下图中的D、E、F是堂兄弟，而G、H、I与J也是堂兄弟。<strong>树中结点的最大层次称为树的深度（Depth）或高度</strong>，当前树的深度为4。<br><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/7f82ae5f-455c-4deb-9ec6-430dc27607d4.png" alt="结点的层次"><br><strong>如果将树中结点的各子树看成从左至右是有次序的，不能互换的，则称该树为有序树，否则称为无序树。</strong></p><p><strong>森林（Forest）是 $m（m≥0）$ 棵互不相交的树的集合。</strong></p><p>对比线性表与树的结构，它们有很大的不同。</p><table><thead><tr><th align="center">线性结构</th><th align="center">树结构</th></tr></thead><tbody><tr><td align="center">第一个数据元素：无前驱</td><td align="center">根结点：无双亲，唯一</td></tr><tr><td align="center">最后一个数据元素：无后继</td><td align="center">叶节点：无孩子，可以多个</td></tr><tr><td align="center">中间元素：一个前驱一个后继</td><td align="center">中间结点：一个双亲多个孩子</td></tr></tbody></table><h3 id="树的抽象数据类型"><a href="#树的抽象数据类型" class="headerlink" title="树的抽象数据类型"></a>树的抽象数据类型</h3><pre><code class="c">ADT 树(tree)Data    树是由一个根结点和若干棵子树构成。树种结点具有相同数据类型及层次关系。Operation    InitTree(*T): 构造空树T。    DestroyTree(*T): 销毁树T。    CreateTree(*T, definition):按definition中给出树的定义来构造树。    ClearTree(*T): 若树T存在，则将树T清为空树。    TreeEmpty(T): 若T为空树，返回true，否则返回false。    TreeDepth(T): 返回T的深度。    Root(T): 返回T的根结点。    Value(T, cur_e): cur_e是树T中的一个结点，返回此结点的值。    Assign(T, cur_e, value): 跟树T的结点cur_e赋值为value。    Parent（T, cur_e): 若cur_e是树T的非根结点，则返回它的双亲，否则返回空。    LeftChild(T, cur_e): 若cur_e是树T的非根结点，则返回它的最左孩子，否则返回空。    RightSibling(T, cur_e): 若cur_e有右兄弟，则返回它的右兄弟，否则返回空。    InsertChild(*t, *p, i, c): 其中p指向树T的某个结点，i为所指结点p的度加上1，非空树c与T不相交，操作结果为插入c为树T中p指结点的第i棵子树。    DeleteChild(*T, *p, i): 其中p指向树T的某个结点，i为所指结点p的度，操作结果为删除T中p所指结点的第i棵树。endADT</code></pre><h3 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h3><h4 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h4><p><strong>在每个结点中，附设一个指示器指示其双亲结点在数组中的位置。</strong></p><table style="width: 240px;"><thead><tr><th style="text-align:center;border: 2px solid #ddd;width: 120px;">Data</th><th style="text-align:center;border: 2px solid #ddd;width: 120px;">parent</th></tr></thead></table><p><strong>其中data是数据域，存储结点的数据信息。而parent是指针域，存储该结点的双亲在数组中的下标。</strong><br>由于根结点是没有双亲的，所以我们约定根结点的位置域设置为-1。<br><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/8bd20237-293c-44e2-b154-d4025c9ec043.png" alt="双亲表示法"></p><pre><code class="c">/* 树的双亲表示法结点结构定义 */#define MAX_TREE_SIZE 100typedef int TElemType; /* 树结点的数据类型，整形 */typedef struct PTNode /* 结点结构 */{    TElemType Data; /* 结点数据 */    int parent; /* 双亲位置 */} PTNode;typedef struct /* 树结构 */{    PTNode nodes[MAX_TREE_SIZE]; /* 结点数组 */    int r, n; /* 根的位置和结点数 */} PTree;</code></pre><p><strong>优点：</strong>这样的存储结构，我们可以根据结点的parent指针很容易找到它的双亲结点。<br><strong>缺点：</strong>可如果我们要知道结点的孩子是什么，对不起，请遍历整个结构才行。</p><p>改进一下，我们增加一个结点最左边孩子的域，不妨叫它<strong>长子域</strong>，这样就可以很容易得到结点的孩子。如果没有孩子的结点，这个长子域就设置为-1<br><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/6964644d-c140-40fc-a334-ef3967665cd3.png" alt=""></p><p>另外一个问题场景，我们很关注各兄弟之间的关系，双亲表示法无法体现这样的关系，那我们怎么办？嗯，可以增加一个右兄弟域来体现兄弟关系，也就是说，每一个结点如果它存在右兄弟，则记录下右兄弟的下标。同样的，如果右兄弟不存在，则赋值为-1。</p><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/2a4cf2ec-60cf-4bf6-abef-83a1e84575fc.png" alt=""></p><p>但如果结点的孩子很多时，超过了 2 个。我们又关注结点的双亲、又关注结点的孩子、还关注结点的兄弟，而且对时间遍历要求还比较高，那么我们可以把此结构扩展为有双亲域、长子域、再有右兄弟域。<strong>存储结构的设计是一个非常灵活的过程。一个存储结构设计是否合理，取决于基于该存储结构的运算是否合适、是否方便，时间复杂度好不好等。</strong></p><h4 id="孩子表示法"><a href="#孩子表示法" class="headerlink" title="孩子表示法"></a>孩子表示法</h4><p>每个结点有多个指针域，其中每个指针指向一棵子树的根结点，我们把这种方法叫做<strong>多重链表表示法。</strong></p><p><strong>孩子表示法:把每个结点的孩子结点排列起来，以单链表作存储结构，则n个结点有n个孩子链表，如果是叶子结点则此单链表为空。然后n个头指针又组成一个线性表，采用顺序</strong>存储结构，存放进一个一维数组中，如图所示。<br><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20180208095659.png" alt="孩子表示法"></p><p><code>data</code> 是数据域 存储某个结点的数据信息。<br><code>firstchild</code> 是头指针域，存储该节点的孩子链表的头指针。<br><code>child</code> 是数据域，用来存储某个结点在表头数组中的下标。<br><code>next</code> 是指针域，用来存储指向某个结点的下一个孩子结点的指针。</p><pre><code class="C">/* 树的孩子表示法结构定义 */#define MAX_TREE_SIZE 100typedef struct CTNode { /* 孩子结点 */    int child;    struct CTNode *next;} *ChildPtr;typedef struct { /* 表头结构 */    TElemType data;    ChildPtr firstchild;} CTBox;typedef struct { /* 树结构 */    CTBox nodes[MAX_TREE_SIZE]; /* 结点数组 */    int r, n; /* 根的位置和结点数 */} CTree;</code></pre><p>这样的结构对于我们要查询某个结点的某个孩子，或者找某个结点的兄弟，只需要查询这个结点的孩子单链表即可。对于遍历整个树也是很方便的，对于结点的数组循环即可。</p><p>也可以把双亲表示法和孩子表示法综合一下，如图<br><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20180208104404.png" alt="双亲表示法和孩子表示法综合"></p><h4 id="孩子兄弟表示法"><a href="#孩子兄弟表示法" class="headerlink" title="孩子兄弟表示法"></a>孩子兄弟表示法</h4><p>任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的。因此，我们设置两个指针，分别指向改结点的<strong>第一个孩子</strong>和此结点的<strong>右兄弟</strong>。<br>这种表示法，给查找某个结点的某个孩子带来了方便。</p><table style="width: 280px;"><thead><tr><th style="text-align:center;border: 2px solid #ddd;width: 140px;">Data</th><th style="text-align:center;border: 2px solid #ddd;width: 140px;">firstchild</th><th style="text-align:center;border: 2px solid #ddd;width: 140px;">rightsib</th></tr></thead></table><p><code>data</code> 是数据域<br><code>firstchild</code> 是指针域，存储该结点的第一个孩子结点的存储地址<br><code>rightsib</code> 是指针域，存储该结点的右兄弟结点的存储地址。</p><pre><code class="C">/* 树的孩子兄弟表示法结构定义 */typedef struct CSNode {    TElemType data;    struct CSNode *firstchild, *rightsib;} CSNode, *CSTree;</code></pre><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20180208112253.png" alt="孩子兄弟表示法"></p><br>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 大话数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《大话数据结构》笔记05-串</title>
      <link href="/2017/09/09/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B%E7%AC%94%E8%AE%B005-%E4%B8%B2/"/>
      <url>/2017/09/09/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B%E7%AC%94%E8%AE%B005-%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="串，KMP模式匹配算法"><a href="#串，KMP模式匹配算法" class="headerlink" title="串，KMP模式匹配算法"></a>串，KMP模式匹配算法</h2><p>串（string）是由零个或多个字符串组成的有限序列。又名叫字符串。</p><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><p>串的链式存储结构除了在连接串与串操作时有一定方便之外，总的来说不如顺序存储灵活，性能也不如顺序结构好。（在高级语言中Java、Python等，串一般定义为不可变类型）</p><a id="more"></a><h3 id="朴素的模式匹配算法"><a href="#朴素的模式匹配算法" class="headerlink" title="朴素的模式匹配算法"></a>朴素的模式匹配算法</h3><p>从一个主串中找到一个子串的位置。</p><p>朴素算法的思想就是将目标串（主串）S的第一个字符与模式串（子串）T的第一个字符进行匹配，若相等，则继续比较S的第二个字符和 T的第二个字符；若不相等，则比较S的第二个字符和P的第一个字符，依次比较下去，直到得出最后的匹配结果。</p><h4 id="Java实现"><a href="#Java实现" class="headerlink" title="Java实现"></a>Java实现</h4><pre><code class="java">public static int index(char[] s, char[] t){    if(s.length&lt;t.length){        return -1;    }    int i = 0,j = 0;    for(;i&lt;s.length ;){        if(s[i] == t[j]){            i++; j++;        }else{            i = i-j+1;// i 回退到上次匹配首位的下一位            j = 0;// j 回退到子串的首位        }        if(j==t.length){            return i-t.length;        }    }    return -1;}</code></pre><p>该算法最坏情况下要进行 $M * ( N - M + 1)$ 次比较，时间复杂度为$O((n-m+1)*m)$。</p><h3 id="KMP模式匹配算法"><a href="#KMP模式匹配算法" class="headerlink" title="KMP模式匹配算法"></a>KMP模式匹配算法</h3><h4 id="KMP算法分析"><a href="#KMP算法分析" class="headerlink" title="KMP算法分析"></a>KMP算法分析</h4><p><a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html" target="_blank" rel="noopener">阮一峰老师</a>博客中的一篇文章来分析KMP算法的原理：有一个字符串&quot;BBC ABCDAB ABCDABCDABDE&quot;，我想知道，里面是否包含另一个字符串&quot;ABCDABD&quot;？</p><ol><li><p>首先，字符串&quot;BBC ABCDAB ABCDABCDABDE&quot;的第一个字符与搜索词&quot;ABCDABD&quot;的第一个字符，进行比较。因为B与A不匹配，所以搜索词后移一位。<br><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/b58a7b25-81de-4b46-bfcb-b7b15be14db1.png" alt=""></p></li><li><p>因为B与A不匹配，搜索词再往后移。<br><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/cb4d6d23-143e-40a2-87ff-2fbebd9ef21b.png" alt=""></p></li><li><p>就这样，直到字符串有一个字符，与搜索词的第一个字符相同为止。<br><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/f1c2ba3d-a53f-491d-bef1-a7137eaef68e.png" alt=""></p></li><li><p>接着比较字符串和搜索词的下一个字符，还是相同。<br><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/864523cb-60f9-4e3c-ae27-9ea186002cd5.png" alt=""></p></li><li><p>直到字符串有一个字符，与搜索词对应的字符不相同为止。<br><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/833cae7a-f8fa-4b35-aeeb-019c3d94b0c7.png" alt=""></p></li><li><p>这时，最自然的反应是，将搜索词整个后移一位，再从头逐个比较。这样做虽然可行，但是效率很差，因为你要把&quot;搜索位置&quot;移到已经比较过的位置，重比一遍。<br><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/69947c88-1ffc-464b-8ceb-8f77afae0b9f.png" alt=""></p></li><li><p>一个基本事实是，当空格与D不匹配时，你其实知道前面六个字符是&quot;ABCDAB&quot;。KMP算法的想法是，设法利用这个已知信息，不要把&quot;搜索位置&quot;移回已经比较过的位置，继续把它向后移，这样就提高了效率。<br><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/76b33200-1bd4-4ce5-8d90-988c0750d99f.png" alt=""></p></li><li><p>怎么做到这一点呢？可以针对搜索词，算出一张《部分匹配表》（Partial Match Table）。这张表是如何产生的，后面再介绍，这里只要会用就可以了。<br><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/8ac899b9-c086-4977-9a17-790ef04af0dd.png" alt=""></p></li><li><p>已知空格与D不匹配时，前面六个字符&quot;ABCDAB&quot;是匹配的。查表可知，最后一个匹配字符B对应的&quot;部分匹配值&quot;为2，因此按照下面的公式算出向后移动的位数：</p><blockquote><p>移动位数 = 已匹配的字符数 - 对应的部分匹配值</p></blockquote><p>因为 6 - 2 等于4，所以将搜索词向后移动4位。<br><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/72743034-7d56-48e7-8b79-b7021f68f0b4.png" alt=""></p></li><li><p>因为空格与Ｃ不匹配，搜索词还要继续往后移。这时，已匹配的字符数为2（&quot;AB&quot;），对应的&quot;部分匹配值&quot;为0。所以，移动位数 = 2 - 0，结果为 2，于是将搜索词向后移2位。<br><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/603b2df3-ee7c-4f3e-a39f-7206d6ab6a3f.png" alt=""></p></li><li><p>因为空格与A不匹配，继续后移一位。<br><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/7e21700c-dab5-4f78-99b5-b52db1c9d1dd.png" alt=""></p></li><li><p>逐位比较，直到发现C与D不匹配。于是，移动位数 = 6 - 2，继续将搜索词向后移动4位。<br><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/b438a577-03f2-4833-b3c4-0c3640d58179.png" alt=""></p></li><li><p>逐位比较，直到搜索词的最后一位，发现完全匹配，于是搜索完成。如果还要继续搜索（即找出全部匹配），移动位数 = 7 - 0，再将搜索词向后移动7位，这里就不再重复了。<br><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/d993e820-86e6-4cd8-bb24-3f17d482ea9c.png" alt=""></p></li><li><p>下面介绍《部分匹配表》是如何产生的。<br>首先，要了解两个概念：&quot;前缀&quot;和&quot;后缀&quot;。 &quot;前缀&quot;指除了最后一个字符以外，一个字符串的全部头部组合；&quot;后缀&quot;指除了第一个字符以外，一个字符串的全部尾部组合。<br><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/f1ebafda-f0a3-473d-91a4-1ea064d6297a.png" alt=""></p></li><li><p>&quot;部分匹配值&quot;就是&quot;前缀&quot;和&quot;后缀&quot;的最长的共有元素的长度。以&quot;ABCDABD&quot;为例，</p><blockquote><p>－ &quot;A&quot;的前缀和后缀都为空集，共有元素的长度为0；</p><p>－ &quot;AB&quot;的前缀为[A]，后缀为[B]，共有元素的长度为0；</p><p>－ &quot;ABC&quot;的前缀为[A, AB]，后缀为[BC, C]，共有元素的长度0；</p><p>－ &quot;ABCD&quot;的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]，共有元素的长度为0；</p><p>－ &quot;ABCDA&quot;的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为&quot;A&quot;，长度为1；</p><p>－ &quot;ABCDAB&quot;的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为&quot;AB&quot;，长度为2；</p><p>－ &quot;ABCDABD&quot;的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD, D]，共有元素的长度为0。</p></blockquote></li></ol><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/62ec39db-10a4-4dce-8006-170c8b528253.png" alt=""></p><ol start="16"><li>&quot;部分匹配&quot;的实质是，有时候，字符串头部和尾部会有重复。比如，&quot;ABCDAB&quot;之中有两个&quot;AB&quot;，那么它的&quot;部分匹配值&quot;就是2（&quot;AB&quot;的长度）。搜索词移动的时候，第一个&quot;AB&quot;向后移动4位（字符串长度-部分匹配值），就可以来到第二个&quot;AB&quot;的位置。<br><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/64c22a20-87ab-41f9-abd1-8e98196b2df8.png" alt=""></li></ol><h4 id="Java实现-1"><a href="#Java实现-1" class="headerlink" title="Java实现"></a>Java实现</h4><pre><code class="java">     /**     * KMP匹配字符串     * @param mainArr主串数组     * @param subArr子串数组     * @return 若匹配成功，返回下标，否则返回-1     */    public static int getMatchIndex(char[] mainArr, char[] subArr) {        int[] next = next(subArr);        System.out.println(&quot;next:&quot; + Arrays.toString(next));        int i = 0;        int j = 0;        while (i &lt;= mainArr.length - 1 &amp;&amp; j &lt;= subArr.length - 1) {            if (j == -1 || mainArr[i] == subArr[j]) {                i++;                j++;            } else {                j = next[j];            }        }        if (j &lt; subArr.length) {            return -1;        } else            return i - subArr.length; // 返回模式串在主串中的头下标    }    /**     * 获得一个next的数组     * @param subArr模式串数组     * @return next回退位置数组     */    public static int[] next(char[] subArr) {        int[] next = new int[subArr.length];        next[0] = -1;        int i = 0;        int j = -1;        while (i &lt; subArr.length - 1) {            if (j == -1 || subArr[i] == subArr[j]) {                i++;                j++;                if (subArr[i] != subArr[j]) {//加上这两句是改进后的nextval                    next[i] = j;                } else {//                    next[i] = next[j];//                }//            } else {                j = next[j];            }        }        return next;    }</code></pre><h4 id="KMP算法改进"><a href="#KMP算法改进" class="headerlink" title="KMP算法改进"></a>KMP算法改进</h4><pre><code class="java">if (subArr[i] != subArr[j]) {//加上这两句是改进后的nextval    next[i] = j;} else {//    next[i] = next[j];//}//</code></pre><h4 id="参考学习资料"><a href="#参考学习资料" class="headerlink" title="参考学习资料"></a>参考学习资料</h4><blockquote><p><a href="http://v.youku.com/v_show/id_XODYxNjExODQ=.html" target="_blank" rel="noopener">视频-严蔚敏数据结构11</a> 33分钟处 以及<a href="http://v.youku.com/v_show/id_XODYxNzIxMjg=.html" target="_blank" rel="noopener">视频-严蔚敏数据结构12</a><br><a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html" target="_blank" rel="noopener">阮一峰-字符串匹配的KMP算法</a><br><a href="http://blog.csdn.net/v_july_v/article/details/7041827" target="_blank" rel="noopener">从头到尾彻底理解KMP</a><br><a href="http://blog.csdn.net/zdp072/article/details/13161295" target="_blank" rel="noopener">大话数据结构十一：字符串的模式匹配（KMP算法）</a></p></blockquote><br>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 大话数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《大话数据结构》笔记04-栈与队列</title>
      <link href="/2017/09/09/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B%E7%AC%94%E8%AE%B004-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
      <url>/2017/09/09/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B%E7%AC%94%E8%AE%B004-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h1><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p><strong>栈(stack)是限定仅在表尾进行插入和删除操作的线性表。</strong><br>允许插入和删除的一端称为栈顶(top)，另一端称为栈底(bottom)，不含任何数据元素的栈称为空栈。栈又称为后进先出(Last In First Out)的线性表，简称LIFO结构。<br>栈的插入操作，叫做进栈，也称压栈、入栈。<br>栈的删除操作，叫作出栈，弹栈。</p><a id="more"></a><h3 id="栈的顺序存储结构"><a href="#栈的顺序存储结构" class="headerlink" title="栈的顺序存储结构"></a>栈的顺序存储结构</h3><pre><code class="c">typedef int SElemType; /* SElemType类型根据实际情况而定，这里假设为int */typedef struct {    SelemType data[MAXSIZE];    int top; /* 用于栈顶指针 */}SQStact；</code></pre><h4 id="进栈操作push："><a href="#进栈操作push：" class="headerlink" title="进栈操作push："></a>进栈操作push：</h4><pre><code class="c">/* 插入元素e为新的栈顶元素 */Status Push(SqStack *S, SElemType e) {    if (S-&gt;top == MAXSIZE - 1) { /* 栈满 */        return ERROR;    }    S-&gt;top++;                    /* 栈顶指针增加一 */    S-&gt;data[S-&gt;top] = e;         /* 将新插入元素赋值给栈顶空间 */    return OK;}</code></pre><h4 id="出栈操作pop："><a href="#出栈操作pop：" class="headerlink" title="出栈操作pop："></a>出栈操作pop：</h4><pre><code class="c">/* 若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR */Status Pop(SqStack *s, SElemType *e) {    if (s-&gt;top == -1)        return ERROR;    *e = S-&gt;data[S-&gt;top];      /* 将要删除的栈顶元素赋值给e */    S-&gt;top--;                  /* 栈顶指针减一 */    return OK;}</code></pre><p>时间复杂度均是$O(1)$。</p><h3 id="两栈共享空间"><a href="#两栈共享空间" class="headerlink" title="两栈共享空间"></a>两栈共享空间</h3><pre><code class="c">/* 两栈共享空间结构 */typedef struct {    SElemType data[MAXSIZE];    int top1;   /* 栈1 栈顶指针 */    int top2;   /* 栈2 栈顶指针 */}SqDoubleStack;</code></pre><p>数组有两个端点，两个栈有两个栈底，一个栈的栈底为数组的始端，即下标为0处，另一个栈为栈的末端，即下标为数组长度n-1处。<br>栈1 为空时，top1等于-1；栈2 为空时，top2等于n。<br>当<code>top1 + 1 == top2</code> 时为栈满。</p><h4 id="push"><a href="#push" class="headerlink" title="push"></a>push</h4><pre><code class="c">/* 插入元素e为新的栈顶元素 */Status Push(SqDoubleStack *S, SElemType e, int stackNumber) {    if (S-&gt;top1 + 1 == S-&gt;top2)   /* 栈已满，不能再push新元素了 */        return ERROR;    if (stackNumber == 1)         /* 栈1有元素进栈 */        S-&gt;data[++S-&gt;top1] = e;   /* 若栈1 则先top1+1后给数组元素赋值 */    else if (stackNumber == 2)    /* 栈2有元素进栈 */        S-&gt;data[--S-&gt;top2] = e;   /* 若栈2 则先top2-1后给数组元素赋值 */    return OK;}</code></pre><h4 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h4><pre><code class="c">/* 若栈不为空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR */Status Pop(SqDoubleStack *S, SElemType *e, int stackNumber) {    if (stackNumber == 1) {        if (S-&gt;top1 == -1)            return ERROR;          /* 说明栈1已经是空栈，溢出 */        *e = S-&gt;data[S-&gt;top1--];   /* 将栈1的栈顶元素出栈 */    } else if (stackNumber == 2) {        if (S-&gt;top2 == MAXSIZE)    /* 说明栈2已经是空栈，溢出 */            return ERROR;        *e = S-&gt;data[S-&gt;top2++];   /* 将栈1的栈顶元素出栈 */    }    return OK;}</code></pre><p>两栈共享空间适用于相同数据类型，如果是不相同数据类型的栈，这种办法不但不能更好地处理问题，反而会使问题变得更复杂。</p><h3 id="栈的链式存储结构"><a href="#栈的链式存储结构" class="headerlink" title="栈的链式存储结构"></a>栈的链式存储结构</h3><p>栈的链式存储结构，简称为链栈。<br>通常对于链栈来说，是不需要头结点的。<br>空栈，链表原定义是头指针指向空，链栈就是top=NULL。</p><pre><code class="c">typedef struct StackNode {    SElemType data;    struct StackNode *next;}StackNode, *LinkStackPtr;typedef struct LinkStack {    LinkStackPtr top;    int count;}LinkStack;</code></pre><h4 id="push入栈"><a href="#push入栈" class="headerlink" title="push入栈"></a>push入栈</h4><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/336228375.png" alt="链栈push"></p><pre><code class="c">/* 插入元素e为新的栈顶元素 */Status Push(LinkStack *S, SElemType e) {    LinkStackPtr s = (LinkStackPtr)malloc(sizeof(StackNode));    s-&gt;data = e;    s-&gt;next = S-&gt;top;   /* 把当前的栈顶元素赋值给新结点的直接后继 */    S-&gt;top = s;         /* 将新的结点s赋值给栈顶指针 */    S-&gt;count++;    return OK;}</code></pre><h4 id="pop出栈"><a href="#pop出栈" class="headerlink" title="pop出栈"></a>pop出栈</h4><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/5ab630dc-67cf-4671-816d-09ee4466a78f.png" alt="链栈pop出栈"></p><pre><code class="c">/* 若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR */Status Pop(LinkStack *S, SElemType *e){    LinkStackPtr p;    if (StackEmpty(*S))        return ERROR;    *e = S-&gt;top-&gt;data;    p = S-&gt;top;            /* 将栈顶结点赋值给p，如图③ */    S-&gt;top = S-&gt;top-&gt;next; /* 使得栈顶指针下移一位，指向后一结点，如图④ */    free(p);    S-&gt;count--;    return OK;}</code></pre><h3 id="对比顺序栈和链栈"><a href="#对比顺序栈和链栈" class="headerlink" title="对比顺序栈和链栈"></a>对比顺序栈和链栈</h3><ol><li>push和pop时间复杂度上均为$O(1)$。</li><li>顺序栈需要确定一个长度，可能存在内存空间的浪费。</li><li>链栈要求每个元素都有指针域，增加了内存开销，但对于长度无限制。</li></ol><p>所以它们的区别和线性表中讨论的一样，<strong>如果栈的使用过程中元素变化不可预料，那么最好使用链栈，反之，如果它的变化在可控范围内，使用顺序栈会更好一些。</strong></p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><h3 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><p>1，1，2，3，5，8，13，21，34，55，89，144</p><pre><code class="c">int Fbi(int i)  /* 斐波那契的递归函数 */{    if( i &lt; 2 )        return i == 0 ? 0 : 1;    return Fbi(i - 1) + Fbi(i - 2);}int main(){    for(i = 0;i &lt; 40;i++)        printf(&quot;%d &quot;, Fbi(i));    return 0;}</code></pre><h3 id="递归定义"><a href="#递归定义" class="headerlink" title="递归定义"></a>递归定义</h3><p><strong>把一个直接调用自己或通过一系列的调用语句间接地调用自己的函数，称作为递归。</strong></p><h2 id="栈的应用——四则运算表达式求值"><a href="#栈的应用——四则运算表达式求值" class="headerlink" title="栈的应用——四则运算表达式求值"></a>栈的应用——四则运算表达式求值</h2><h3 id="后缀表达法（逆波兰）"><a href="#后缀表达法（逆波兰）" class="headerlink" title="后缀表达法（逆波兰）"></a>后缀表达法（逆波兰）</h3><p><code>&quot;9 + (3-1) * 3 + 10/2&quot;</code> ————&gt; <code>&quot;9 3 1 - 3 * + 10 2 / +&quot;</code><br>规则：从左到右遍历表达式的每个数字和符号，遇到是数字就进栈，遇到是符号，就将处于栈顶两个数字出栈，进行运算，运算结果进栈，一直到最终获得结果。</p><h3 id="中缀表达式转后缀表达式"><a href="#中缀表达式转后缀表达式" class="headerlink" title="中缀表达式转后缀表达式"></a>中缀表达式转后缀表达式</h3><p>平时用的标准四则运算表达式，叫做中缀表达式。<br>规则：从左到右遍历中缀表达式的每个数字和符号，若是数字就输出，即成为后缀表达式的一部分；若是符号，则判断其与栈顶符号的优先级，是右括号或优先级低于栈顶符号，则栈顶元素依次出栈并输出，并将当前符号进栈，一直到最终输出后缀表达式。</p><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p><strong>队列（queue）是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。先进先出（First In First Out），FIFO。</strong><br>运行插入的一端为队尾，允许删除的一端称为队头。</p><h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><p>解决假溢出的办法是后边满了，就再从头开始，也就是头尾相接的循环，<strong>把队列的这种头尾相接的<em>顺序存储结构</em>称为循环队列</strong>。</p><p>如果队列为空时，front（指向队头元素）等于rear（指向队尾元素的下一个位置）。<br>如果队列满时，保留一个元素空间，如下图：<br><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/5b62d486-6859-4524-88ab-02cb97055ee0.jpg" alt="循环队列满"><br>如果队列的最大尺寸为QueueSize，那么队列满的条件是$(rear+1) % QueueSize == front$。<br>如上边的例子，QueueSize=5，左图front=0，rear=4，(4+1)%5 = 0，所以此时队列满。右图，front=2，rear=1，(1+1)%5=2，所以此时队列满。</p><p>当rear&gt;front时，队列长度为rear-front。当rear&lt;front时，队列长度一段为QueueSize-front，另一段0+rear，加一起为rear-front+QueueSize。<br>因此计算队列长度的公式为：$$(rear-front+QueueSize) % QueueSize$$</p><h4 id="循环队列的顺序存储结构"><a href="#循环队列的顺序存储结构" class="headerlink" title="循环队列的顺序存储结构"></a>循环队列的顺序存储结构</h4><pre><code class="c">typedef int QElemType;typedef struct {    QElemType data[MAXSIZE];    int front; /* 头指针 */    int rear;  /* 尾指针，如果队列不为空，指向队列尾元素的下一个位置 */}</code></pre><p>循环队列初始化代码</p><pre><code class="c">/* 初始化一个空队列 */Status InitQueue(SqQueue *Q){    Q-&gt;front = 0;    Q-&gt;rear = 0;    return OK;}</code></pre><h3 id="队列的链式存储结构"><a href="#队列的链式存储结构" class="headerlink" title="队列的链式存储结构"></a>队列的链式存储结构</h3><p>队头指针指向链队列的头结点，队尾指针指向终端结点。<br><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/1ecef1e3-4255-417f-a3c0-b9c776174f24.jpg" alt="队列的链式存储结构"><br>空队列时，front和rear都指向头结点。</p><p>入队：在链表尾部插入结点<br><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/9061524c-cc29-4766-b866-34b2fbeb5255.jpg" alt="入队"></p><p>出队：①头结点的后继结点出队，②将头结点的后继改为它后面的结点，③若链表除头结点外只剩下一个元素，则需将rear指向头结点。<br><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/64b667c9-2d8a-4161-9b70-179394730fa1.jpg" alt="出队"></p><br>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 大话数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《大话数据结构》笔记03-线性表</title>
      <link href="/2017/09/04/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B%E7%AC%94%E8%AE%B003-%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
      <url>/2017/09/04/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B%E7%AC%94%E8%AE%B003-%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><p>线性表：零个或多个数据元素的<strong>有限</strong>序列。</p><a id="more"></a><p>线性表的抽象数据类型定义如下：</p><pre><code class="c">ADT 线性表(List)Data    线性表的数据对象集合为{a1, a2, ... , an}，每个元素的类型均为DataType。其中，除第一个元素a1外，每个元素有且仅有一个直接前驱元素，除了最后一个元素an 外，每一个元素有却仅有一个直接后继元素。数据元素之间的关系是一对一的关系。Operation    InitList(*L): 初始化操作，建立一个空的线性表L。    ListEmpty(L): 若线性表为空，返回true，否则返回false。    ClearList(*L): 将线性表清空。    GetElem(L, i, *e): 将线性表L中的第i个位置元素值返回给e。    LocateElem(L, e): 在线性表L中查找于给定值e相等的元素，如果查找成功，返回该元素在表中的序号表示成功；否则，返回0(-1)表示失败。    ListInsert(*L, i, e): 在线性表L中的第i个位置插入新元素e。    ListDelete(*L, i, e): 删除线性表L中第i个位置元素，并用e返回其值。    ListLength(L)： 返回线性表L的元素个数。endADT</code></pre><p>Java中 <code>List&lt;E&gt;</code> 接口中部分方法：</p><pre><code class="java">public interface List&lt;E&gt; extends Collection&lt;E&gt; {    //返回列表中的元素数。    int size();    //如果列表不包含元素，则返回 true。    boolean isEmpty();    //从列表中移除所有元素    void clear();    //如果列表包含指定的元素，则返回 true。    boolean contains(Object o);    //向列表添加指定的元素    boolean add(E e);    void add(int index, E element);    E remove(int index);//删除    boolean remove(Object o);//从此列表中移除第一次出现的指定元素（如果存在）    E get(int index);    E set(int index, E element);    int indexOf(Object o);    int lastIndexOf(Object o);}</code></pre><h3 id="线性表的顺序存储结构"><a href="#线性表的顺序存储结构" class="headerlink" title="线性表的顺序存储结构"></a>线性表的顺序存储结构</h3><p><strong>线性表的顺序存储结构</strong>，指的是用一段地址连续的存储单元依次存储线性表的数据元素。</p><p>线性表的顺序存储的结构代码：</p><pre><code class="c">#define MAXSIZE 20  /* 存储空间初始分配量 */typedef int ElemType; /* ElemType 类型根据实际情况而定，这里假设为int */typedef struct｛    ElemType data[MAXSIZE]; /* 数组存储数据元素，最大值为MAXSIZE */    int length; /* 线性表当前长度 */｝SqList;</code></pre><p>顺序存储结构需要三个属性：</p><ul><li>存储空间的起始位置：数组 data，它的存储位置就是存储空间的存储位置。</li><li>线性表的最大存储容量：数组长度 MAXSIZE。</li><li>线性表的当前长度：length。</li></ul><p>对每个线性表位置的存入或者取出数据，时间复杂度为$O(1)$，我们通常把具有这一特点的存储结构称为随机存取结构。</p><h4 id="顺序存储结构的插入操作"><a href="#顺序存储结构的插入操作" class="headerlink" title="顺序存储结构的插入操作"></a>顺序存储结构的插入操作</h4><p>思路：</p><ul><li>如果插入位置不合理，抛出异常；</li><li>如果线性表长度大于数组长度，则抛出异常或动态增加容量；</li><li>从最后一个元素向前遍历到第i个位置，分别将它们都向后移动一个位置；</li><li>将要插入的元素填入位置i处；</li><li>表长加1.</li></ul><pre><code class="c">#define OK 1#define ERROR 0#define TRUE 1#define FALSE 0/* Status是函数的类型，其值是函数结果状态代码，如OK等 */typedef int Status;/* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) *//* 操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加1 */Status ListInsert(SqList *L, int i, ElemType e){    int k;    if (L-&gt;length == MAXSIZE) /* 顺序线性表已经满 */        return ERROR;    if (i &lt; 1 || i &gt; L-&gt;length + 1) /* 当i不在范围内时 */        return ERROR;    if (i &lt;= L-&gt;length) { /* 若插入的数据的位置不在表尾 */        for (k = L-&gt;length - 1; k &gt;= i - 1; k--) { /* 将要插入位置后数据元素向后移动一位 */            L-&gt;data[k+1] = L-&gt;data[k];        }    }    L-&gt;data[i-1] = e; /* 将新元素插入 */    L-&gt;length++;    return OK;}</code></pre><h4 id="顺序存储结构的删除操作"><a href="#顺序存储结构的删除操作" class="headerlink" title="顺序存储结构的删除操作"></a>顺序存储结构的删除操作</h4><p>思路：</p><ul><li>如果删除的位置不合理，抛出异常；</li><li>取出删除的元素；</li><li>从删除元素的位置开始遍历到最后一个元素的位置，分别将它们都向前移动一个位置；</li><li>表长减1。</li></ul><p>插入和删除操作的<strong>时间复杂度</strong>为$O(n)$</p><h4 id="线性表顺序存储结构的优缺点"><a href="#线性表顺序存储结构的优缺点" class="headerlink" title="线性表顺序存储结构的优缺点"></a>线性表顺序存储结构的优缺点</h4><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/863180593.png" alt="线性表顺序存储结构的优缺点"></p><h3 id="线性表的链式存储结构"><a href="#线性表的链式存储结构" class="headerlink" title="线性表的链式存储结构"></a>线性表的链式存储结构</h3><p>为了表示每个数据元素$a_i$与其直接后继数据元素$a_{i+1}$之间的逻辑关系，对数据元素$a_i$来说，除了存储其本身的信息之外，还需存储一个指示其直接后继的信息(即直接后继的存储位置)。我们把存储数据元素谢谢的域称为<strong>数据域</strong>，把存储直接后继位置的域称为<strong>指针域</strong>。指针域中存储的信息称做<strong>指针或链</strong>。这两部分信息组成数据元素$a_i$的存储映像，称为<strong>结点</strong>（Node）。</p><p>n个结点($a_i$的存储映像)链结成一个链表，即为线性表（$a_1, a_2, ..., a_n$）的链式存储结构，因为此链表的每一个结点中只包含一个指针域，所以叫做<strong>单链表</strong>。<br><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/865202531.png" alt="单链表"></p><p>链表中第一个结点的存储位置叫做头指针，最后一个结点指针为NULL(或用&quot;^&quot;符号表示)<br><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/865429937.png" alt="带头结点的单链表(a)非空表；(b)空表"></p><h4 id="头指针与头结点的异同"><a href="#头指针与头结点的异同" class="headerlink" title="头指针与头结点的异同"></a>头指针与头结点的异同</h4><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/865924062.png" alt="头指针与头结点的异同"></p><h4 id="线性表的单链表存储结构代码描述"><a href="#线性表的单链表存储结构代码描述" class="headerlink" title="线性表的单链表存储结构代码描述"></a>线性表的单链表存储结构代码描述</h4><pre><code class="c">typedef struct Node{    ElemType data;    struct Node *next;} Node;typedef struct Node *LinkList; /* 定义LinkList */</code></pre><h4 id="单链表的读取"><a href="#单链表的读取" class="headerlink" title="单链表的读取"></a>单链表的读取</h4><p>思路：</p><ol><li>声明一个结点$p$指向链表第一个结点，初始化$j$从1开始；</li><li>当$j&lt;i$时，就遍历链表，让$p$的指针向后移动，不断指向下一个结点，$j$累加1；</li><li>若到链表末尾$p$为空，则说明第$i$个元素不存在；</li><li>否则查找成功，返回结点$p$的数据。</li></ol><p>时间复杂度是$O(n)$。</p><h4 id="单链表的插入与删除"><a href="#单链表的插入与删除" class="headerlink" title="单链表的插入与删除"></a>单链表的插入与删除</h4><p>单链表插入和删除算法，我们发现，它们其实都是由两部分组成：第一部分就是遍历查找第$i$个结点；第二部分就是插入和删除结点。我们很容易推导出：它们的时间复杂度都是$O(n)$。如果在我们不知道第i个结点的指针位置，单链表数据结构在插入和删除操作上，与线性表的顺序存储结构是没有太大优势的。我们只需要在第一次时，找到第$i$个位置的指针，此时为$O(n)$，接下来只是简单地通过赋值移动指针而已，时间复杂度都是$O(1)$。显然，<strong>对于插入或删除数据越频繁的操作，单链表的效率优势就越是明显</strong>。</p><h4 id="单链表结构与顺序存储结构优缺点"><a href="#单链表结构与顺序存储结构优缺点" class="headerlink" title="单链表结构与顺序存储结构优缺点"></a>单链表结构与顺序存储结构优缺点</h4><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/871321046.png" alt=""></p><h3 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h3><p>静态链表其实是为了给没有指针的高级语言设计的一种实现单链表能力的方法。<br><strong>用数组描述的链表叫做静态链表。</strong></p><p>为了我们方便插入数据，通常会把数组建立得大一些，以便有一些空闲空间可以便于插入时不至于溢出。</p><pre><code class="c">/* 线性表的静态链表存储结构 */#define MAXSIZE 1000typedef struct{    ElemType data;    int cur; /* 游标，为0时表示无指向 */} Component, StaticLinkList[MAXSIZE];</code></pre><p>另外我们对数组第一个和最后一个元素作为特殊元素处理，不存数据。我们通常把未被使用的数组元素称为<strong>备用链表</strong>。而数组第一个元素，即下标为0的元素的cur就存放备用链表的第一个结点的下标；而数组的最后一个元素的cur则存放第一个有数值的元素的下标，相当于单链表中的头结点作用，当整个链表为空时，则为0。<br><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/872328718.png" alt=""></p><h4 id="静态链表优缺点"><a href="#静态链表优缺点" class="headerlink" title="静态链表优缺点"></a>静态链表优缺点</h4><p>优点：在插入和删除操作时，只需要修改游标，不需要移动元素，从而改进了在顺序存储结构中的插入和删除操作需要移动大量元素的缺点。<br>缺点：①没有解决连续存储分配带来的表长难以确定的问题；②失去了顺序存储结构随机存取的特性。</p><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p><strong>将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表。</strong><br><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/874903046.png" alt="循环链表"></p><p>其实循环链表和单链表的主要差异就在与循环的判断条件上，原来是判断p-&gt;next是否为空，现在则是<strong>p-&gt;next不等于头结点</strong>，则循环未结束。</p><h4 id="尾指针"><a href="#尾指针" class="headerlink" title="尾指针"></a>尾指针</h4><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/875156593.png" alt="尾指针"><br>终端结点用尾指针rear指示，则查找终端结点是$O(1)$，而开始结点，其实就是rear-&gt;next-&gt;next，时间复杂度也是$O(1)$。</p><p>要将两个循环链表合并成一个表时，有了尾指针就非常简单了<br><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/875483875.png" alt=""><br><strong>注意：只保留一个头结点</strong></p><pre><code class="c">p=rearA-&gt;next;rearA-&gt;next = rearB-&gt;next-&gt;next;q = rearB-&gt;next;rearB-&gt;next = p;free(q);</code></pre><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p><strong>双向链表是在单链表的每一个结点中，在设置一个指向其前驱结点的指针域。</strong></p><pre><code class="c">/* 线性表的双向链表存储结构 */typedef struct DulNode{    ElemType data;    struct DulNode *prior; /* 直接前驱指针 */    struct DulNode *next;  /* 直接后继指针 */} DulNode, *DuLinkList;</code></pre><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/935875296.png" alt="双向链表"><br><strong>在插入和删除时，需要改变两个指针变量。</strong></p><p>插入：<br><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/936140718.png" alt="双向链表插入"></p><pre><code class="c">s-&gt;prior = p;s-&gt;next = p-&gt;next;p-&gt;next-&gt;proir = s;p-&gt;next = s;</code></pre><p>删除：<br><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/936310656.png" alt="双向链表删除"></p><pre><code class="c">p-&gt;proir-&gt;next = p-&gt;next;p-&gt;next-&gt;prior = p-&gt;prior;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 大话数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《大话数据结构》笔记02-算法</title>
      <link href="/2017/09/04/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B%E7%AC%94%E8%AE%B002-%E7%AE%97%E6%B3%95/"/>
      <url>/2017/09/04/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B%E7%AC%94%E8%AE%B002-%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>算法(Algorithm)：是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。</p><h3 id="算法的特性"><a href="#算法的特性" class="headerlink" title="算法的特性"></a>算法的特性</h3><ol><li>输入输出<br>算法可以有零个或多个输入，但至少有一个或多个输出。</li><li>有穷性<br>指算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成。</li><li>确定性<br>算法的每一步骤都具有确定的含义，不会出现二义性。</li><li>可行性<br>算法的每一步都必须是可行的，也就是说，每一步都能通过执行有限次数完成。</li></ol><a id="more"></a><h3 id="算法设计的要求"><a href="#算法设计的要求" class="headerlink" title="算法设计的要求"></a>算法设计的要求</h3><ol><li>正确性<br>算法的正确性是指算法至少应该具有输入、输出和加工处理无歧义性、能正确反映问题的需求、能够得到问题的正确答案。</li><li>可读性<br>算法设计的另一目的是为了便于阅读、理解和交流。</li><li>健壮性<br>当输入数据不合法时，算法也能做出相关处理，而不是产生异常或者莫名其妙的结果。</li><li>时间效率高和存储低</li></ol><h2 id="算法效率的度量方法"><a href="#算法效率的度量方法" class="headerlink" title="算法效率的度量方法"></a>算法效率的度量方法</h2><p>事前分析估算方法：在计算机程序编制前，依据统计方法对算法进行估算。<br>一个程序的运行时间，主要依赖于算法的好坏和问题的输入规模(输入量的多少)。</p><p>求和算法1：</p><pre><code class="c">int i, sum = 0, n = 100;      /* 执行1次 */for (i = 1; i &lt;= n; i++){     /* 执行n+1次 */    sum = sum + i;            /* 执行n次 */}prinf(&quot;%d&quot;, sum);             /* 执行1次 */</code></pre><p>求和算法2：</p><pre><code class="c">int sum = 0, n = 100;      /* 执行1次 */sum = (1 + n) * n/2;       /* 执行1次 */prinf(&quot;%d&quot;, sum);          /* 执行1次 */</code></pre><p>这个算法其实就是$n$次于1次的差距，算法的好坏显而易见。</p><h2 id="算法时间复杂度"><a href="#算法时间复杂度" class="headerlink" title="算法时间复杂度"></a>算法时间复杂度</h2><p><strong>在进行算法分析时，语句总的执行次数 $T(n)$是关于问题规模 $n$的函数，进而分析 $T(n)$随 $n$ 的变化情况并确定 $T(n)$ 的数量级。算法的时间复杂度，也就是算法的时间度量，记作：$T(n) = O(f(n))$。它表示随问题规模 $n$ 的增大，算法执行时间的增长率和 $f(n)$ 的增长率相同，称作算法的渐进时间复杂度，简称为时间复杂度。其中 $f(n)$ 是问题规模 $n$ 的某个函数。</strong><br>这样用大写 $O()$ 来体现算法时间复杂度的记法，称之为<strong>大O记法</strong>。</p><h3 id="推导大O阶方法"><a href="#推导大O阶方法" class="headerlink" title="推导大O阶方法"></a>推导大O阶方法</h3><ol><li>用常数1取代运行时间中的所有加法常数。</li><li>在修改后的运行次数函数中，只保留最高阶项。</li><li>如果最高阶项存在且不是1，则去除于这个项相乘的常数。</li></ol><p><strong>得到的结果就是大O阶</strong>。</p><h3 id="常数项"><a href="#常数项" class="headerlink" title="常数项"></a>常数项</h3><p>在求和算法2中，算法的运行次数函数$f(n) = 3$，根据推导大O阶方法，所以这个算法的时间复杂度为 $O(1)$。</p><h3 id="线性阶"><a href="#线性阶" class="headerlink" title="线性阶"></a>线性阶</h3><p>在求和算法1中，算法的时间复杂度为 $O(n)$。</p><h3 id="对数阶"><a href="#对数阶" class="headerlink" title="对数阶"></a>对数阶</h3><pre><code class="c">int count = 1;while (count &lt; n){    count = count * 2;}</code></pre><p>有$<br>2^x = n<br>$ 得到 $<br>x=log_{2}n<br>$ 所以这个循环的时间复杂度为 $O(logn)$。</p><h3 id="平方阶"><a href="#平方阶" class="headerlink" title="平方阶"></a>平方阶</h3><pre><code class="c">int i, j;for (i = o; i &lt; n; i++){    for (j = o; j &lt; n; j++){        /* ... */    }}</code></pre><p>循环嵌套 时间复杂度为$O(n^2)$</p><p>如果外循环次数变为了 m，时间复杂度就变成了$O(m*n)$</p><pre><code class="c">int i, j;for (i = o; i &lt; n; i++){    for (j = i; j &lt; n; j++){    /* 注意j = i */        /* ... */    }}</code></pre><p>这个循环嵌套，总执行次数为：$$n + (n -1) + (n - 2) + ... + 1 = \frac{n(n+1)}{2} = \frac{n^2}{2} + \frac{n}{2}$$</p><p>使用推导大O阶的方法，①没有加法常数不予考虑；②只保留最高项，保留$n^2/2$；③去除这个项相乘的常数，去除$1/2$。所以时间复杂度为 $O(n^2)$。</p><h3 id="常见的时间复杂度"><a href="#常见的时间复杂度" class="headerlink" title="常见的时间复杂度"></a>常见的时间复杂度</h3><table><thead><tr><th align="center">执行次数函数</th><th align="center">阶</th><th align="center">非正式术语</th></tr></thead><tbody><tr><td align="center">$12$</td><td align="center">$O(1)$</td><td align="center">常数阶</td></tr><tr><td align="center">$2n+3$</td><td align="center">$O(n)$</td><td align="center">线性阶</td></tr><tr><td align="center">$3n^2+2n+1$</td><td align="center">$O(n^2)$</td><td align="center">平方阶</td></tr><tr><td align="center">$5log_{2}n+20$</td><td align="center">$O(logn)$</td><td align="center">对数阶</td></tr><tr><td align="center">$2n+3nlog_{2}n+19$</td><td align="center">$O(nlogn)$</td><td align="center">nlogn阶</td></tr><tr><td align="center">$6n^3+2n^2+3n+4$</td><td align="center">$O(n^3)$</td><td align="center">立方阶</td></tr><tr><td align="center">$2^n$</td><td align="center">$O(2^n)$</td><td align="center">指数阶</td></tr></tbody></table><p>常用的时间复杂度所耗费的时间从小到大依次是：<br>$$<br>O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n^2)&lt;O(n^3)&lt;O(2^n)&lt;O(n!)&lt;O(n^n)<br>$$<br>从$O(n^3)$往后，过大n都会时结果变得不现实。</p><h3 id="最坏情况"><a href="#最坏情况" class="headerlink" title="最坏情况"></a>最坏情况</h3><p>最坏情况运行时间是一种保证，那就是运行时间将不会再坏了。在应用中，这是一种最重要的需求，通常，除非特别指定，我们提到的运行时间都是最坏情况的运行时间。</p><br>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 大话数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《大话数据结构》笔记01-绪论</title>
      <link href="/2017/09/04/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B%E7%AC%94%E8%AE%B001-%E7%BB%AA%E8%AE%BA/"/>
      <url>/2017/09/04/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B%E7%AC%94%E8%AE%B001-%E7%BB%AA%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>数据结构</strong>是一门研究非数值计算的程序设计问题中的操作对象，以及它们之间的关系和操作等相关问题的<strong>学科</strong>。</p><p><strong>数据结构</strong>：是相互之间存在一种或多种特定关系的数据元素的集合。</p><p><strong>数据</strong>：是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。数据不仅仅包括整型、实型等数值类型，还包括字符及声音、图像、视频等非数值类型。（可以输入到计算机中，能被计算机程序处理）</p><p><strong>数据元素</strong>：是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录。（人类--人）</p><p><strong>数据项</strong>：一个数据元素可以由若干数据项组成，数据项是数据不可分割的最小单位。<br><strong>数据元素才是数据结构中建立数据模型的着眼点。</strong></p><p><strong>数据对象</strong>：是性质相同的数据元素的集合，是数据的子集。</p><a id="more"></a><p>不同数据元素之间不是独立的，而是存在特定的关系，我们将这些关系称为<strong>结构</strong></p><h2 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h2><p><strong>逻辑结构：是指数据对象中数据元素之间的相互关系。</strong></p><ol><li>集合结构</li></ol><p><strong>集合结构</strong>：集合结构中的数据元素除了同属于一个集合外，它们之间没有其他关系。<br><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/4c4e9ba9-a052-4f49-86d7-110abeff4f86.jpg" alt="集合结构"><br>2. 线性结构<br><strong>线性结构</strong>：线性结构中数据元素之间是一对一的关系。<br><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/5a692941-3b94-43b7-b2c3-4521ca9b11fd.jpg" alt="线性结构"><br>3. 树形结构<br><strong>树形结构</strong>：树形结构中的元素之间存在一种一对多的层次关系。<br><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/f7c182de-f883-4d72-b298-0b93ddff3ef5.jpg" alt="树形结构"><br>4. 图形结构<br><strong>图形结构</strong>：图形结构的数据元素是多对多的关系。<br><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/a3350f08-da9e-4efe-bf9d-6c73bae52183.jpg" alt="图形结构"></p><p><strong>逻辑结构</strong>是针对<strong>具体问题</strong>的，是为了解决某个问题，在对问题理解的基础上，选择一个合适的数据结构表示数据元素之间的逻辑关系。</p><p><strong>物理结构</strong>是面向<strong>计算机</strong>的，其基本的目标就是将数据及其逻辑关系存储到计算机的内存中，</p><h2 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h2><p>物理结构：是指数据的逻辑结构在计算机中的存储形式。（内存）</p><ol><li>顺序存储结构</li></ol><p><strong>顺序存储结构</strong>：是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的。（数组）<br><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/0f8b1d8a-3155-4cca-86b4-d57bc467ba8e.jpg" alt="顺序存储结构"><br>2. 链式存储结构<br><strong>链式存储结构</strong>：是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。<br><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/0dccd612-891f-4d1d-a68b-34dc06587f0d.jpg" alt="链式存储结构"></p><h2 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h2><p><strong>数据类型</strong>：是指一组性质相同的值的集合及定义在此集合上的一些操作的总称。</p><p><strong>抽象数据类型</strong>（Abstract Data Type, ADT）：是指一个数学模型及定义在该模型上的一组操作。(Java--类)</p><p>抽象数据类型的标准格式：</p><pre><code>ADT 抽象数据类型名Data    数据元素之间逻辑关系的定义Operation    操作 1        初始条件        操作结果描述    操作 2        ...    操作 n        ...endADT</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/2427c4dc-5f2e-4105-8119-822e9082bc25.jpg" alt="概念"><br><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/4e05ddf4-93ed-41e6-8e10-54232134c9d0.jpg" alt="结构"></p><br>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 大话数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC MongoDB整合中遇到的问题</title>
      <link href="/2017/08/05/SpringMVC-MongoDB%E6%95%B4%E5%90%88%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2017/08/05/SpringMVC-MongoDB%E6%95%B4%E5%90%88%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>集成环境：<code>Spring4</code>+<code>SpringMVC</code>+<code>MongoDB</code>+<code>MySQL</code>+<code>MyBatis</code>+<code>Druid</code>+<code>FreeMarker</code><br>MongoDB包含用户认证部分，<a href="https://github.com/CoolView/MongodbSpringMySQLDemo" target="_blank" rel="noopener">源码地址</a></p><h3 id="Spring3-升级至-Spring4"><a href="#Spring3-升级至-Spring4" class="headerlink" title="Spring3 升级至 Spring4"></a>Spring3 升级至 Spring4</h3><p>出现错误如下：</p><pre><code class="java">严重: Servlet [SpringMVC] in web application [/storm] threw load() exceptionjava.lang.ClassNotFoundException: com.fasterxml.jackson.core.JsonProcessingException    at org.apache.catalina.loader.WebappClassLoaderBase.loadClass(WebappClassLoaderBase.java:1305)    at org.apache.catalina.loader.WebappClassLoaderBase.loadClass(WebappClassLoaderBase.java:1157)    at java.lang.Class.getDeclaredMethods0(Native Method)    at java.lang.Class.privateGetDeclaredMethods(Class.java:2531)    at java.lang.Class.getDeclaredMethods(Class.java:1855)...</code></pre><a id="more"></a><ol><li>使用<code>Spring4</code>时需要使用<code>jackson2.X</code>的，在<code>maven</code>中的依赖为<pre><code class="xml">&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.5.1&lt;/version&gt; &lt;type&gt;bundle&lt;/type&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.5.0&lt;/version&gt; &lt;type&gt;bundle&lt;/type&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.4.0&lt;/version&gt; &lt;type&gt;bundle&lt;/type&gt;&lt;/dependency&gt;</code></pre></li><li><code>spring mvc</code>的配置如下<pre><code class="xml">&lt;bean id=&quot;mappingJacksonHttpMessageConverter&quot; class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt; &lt;property name=&quot;supportedMediaTypes&quot;&gt;     &lt;list&gt;         &lt;value&gt;text/html;charset=UTF-8&lt;/value&gt;     &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt;&lt;bean class=&quot;org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter&quot;&gt; &lt;property name=&quot;messageConverters&quot;&gt;     &lt;list&gt;         &lt;bean class=&quot;org.springframework.http.converter.ByteArrayHttpMessageConverter&quot;/&gt;         &lt;!-- json转换器 --&gt;         &lt;ref bean=&quot;mappingJacksonHttpMessageConverter&quot; /&gt;     &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt;</code></pre>要使用 <code>Jackson2HttpMessageConverter</code><br>感谢<a href="http://blog.csdn.net/u013667086/article/details/44807247" target="_blank" rel="noopener">java.lang.ClassNotFoundException: com.fasterxml.jackson.core.JsonProcessingException</a></li></ol><h3 id="引入FreeMarker"><a href="#引入FreeMarker" class="headerlink" title="引入FreeMarker"></a>引入FreeMarker</h3><p>需要引入<code>spring-context-support-3.2.0.RC2.jar</code></p><h3 id="MongoDB数据库中加入认证"><a href="#MongoDB数据库中加入认证" class="headerlink" title="MongoDB数据库中加入认证"></a>MongoDB数据库中加入认证</h3><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p><a href="http://blog.csdn.net/boybruce/article/details/45821829" target="_blank" rel="noopener">SpringMVC Mongodb 配置中加入用户认证信息</a>，该方法适用于认证库和连接库相同的情况，并不适用于不同的情况。<br>首先声明一个用户信息bean</p><pre><code class="xml">&lt;bean id=&quot;userCredentials&quot; class=&quot;org.springframework.data.authentication.UserCredentials&quot;&gt;    &lt;constructor-arg name=&quot;username&quot; value=&quot;${mongo.uname}&quot; /&gt;    &lt;constructor-arg name=&quot;password&quot; value=&quot;${mongo.upass}&quot; /&gt;&lt;/bean&gt;</code></pre><p> 修改mongoTemplate的配置，多加入一个构造函数参数</p><pre><code class="xml">&lt;bean id=&quot;mongoTemplate&quot; class=&quot;org.springframework.data.mongodb.core.MongoTemplate&quot;&gt;    &lt;constructor-arg ref=&quot;mongo&quot; /&gt;    &lt;constructor-arg name=&quot;databaseName&quot; value=&quot;${mongo.dbName}&quot; /&gt;    &lt;constructor-arg ref=&quot;userCredentials&quot; /&gt;&lt;/bean&gt;</code></pre><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p>MongoDB数据库中加入认证，并且认证的库和需要连接的库不是同一个。<br>使用较高版本的<code>spring-data-mongodb</code>，否则容易出现找不到<code>authentication-dbname</code>属性的错误，这个属性就是进行认证的库，区别于需连接使用的库<code>dbname</code>,这里使用的版本是<code>1.10.6.RELEASE</code>：</p><pre><code class="xml">&lt;mongo:db-factory id=&quot;mongoDbFactory&quot; dbname=&quot;${mongo.dbname}&quot; mongo-ref=&quot;mongo&quot; username=&quot;${mongo.uname}&quot;    password=&quot;${mongo.upass}&quot; authentication-dbname=&quot;${mongo.authdbname}&quot;/&gt;&lt;bean id=&quot;mongoTemplate&quot; class=&quot;org.springframework.data.mongodb.core.MongoTemplate&quot;&gt;    &lt;constructor-arg name=&quot;mongoDbFactory&quot; ref=&quot;mongoDbFactory&quot;/&gt;&lt;/bean&gt;</code></pre><h3 id="配置druid监控spring-jdbc"><a href="#配置druid监控spring-jdbc" class="headerlink" title="配置druid监控spring jdbc"></a>配置druid监控spring jdbc</h3><p>下方配置包名时，切记不能配置为<code>com.*</code>，具体原因未知。</p><pre><code class="xml">&lt;bean id=&quot;druid-stat-interceptor&quot; class=&quot;com.alibaba.druid.support.spring.stat.DruidStatInterceptor&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;druid-stat-pointcut&quot; class=&quot;org.springframework.aop.support.JdkRegexpMethodPointcut&quot; scope=&quot;prototype&quot;&gt;    &lt;property name=&quot;patterns&quot;&gt;        &lt;list&gt;            &lt;value&gt;com.mongospringmysql.*&lt;/value&gt;        &lt;/list&gt;    &lt;/property&gt;&lt;/bean&gt;&lt;aop:config&gt;    &lt;aop:advisor advice-ref=&quot;druid-stat-interceptor&quot; pointcut-ref=&quot;druid-stat-pointcut&quot; /&gt;&lt;/aop:config&gt;</code></pre><br>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> MongoDB </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB学习笔记13-MongoDB备份</title>
      <link href="/2017/07/17/MongoDB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B013-MongoDB%E5%A4%87%E4%BB%BD/"/>
      <url>/2017/07/17/MongoDB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B013-MongoDB%E5%A4%87%E4%BB%BD/</url>
      
        <content type="html"><![CDATA[<h2 id="mongoexport命令"><a href="#mongoexport命令" class="headerlink" title="mongoexport命令"></a>mongoexport命令</h2><p>导出可以使用<code>mongoexport</code>命令，导出会中断其它操作。常用参数：</p><ul><li><code>-d</code>：指明要导出的数据库</li><li><code>-c</code>：指明要导出的集合</li><li><code>-o</code>：指明要导出的文件名</li><li><code>--host</code>：指明数据库主机地址（不写默认就是本机）</li><li><code>--port</code>：指明数据库端口（不写默认就是<code>27017</code>）</li></ul><a id="more"></a><p>如下：导出<code>test</code>数据库中的<code>person</code>集合</p><pre><code>C:\Users\bin&gt;mongoexport -d test -c person -o C:\data\person.json2015-06-02T14:43:02.493+0800    connected to: localhost2015-06-02T14:43:02.495+0800    exported 6 records</code></pre><h2 id="mongoimport命令"><a href="#mongoimport命令" class="headerlink" title="mongoimport命令"></a>mongoimport命令</h2><p>导入可以使用<code>mongoimport</code>命令，导入也会中断其它操作。常用参数：</p><ul><li><code>--db</code>：指明要导入到的数据库（如果数据库不存在会自动创建）</li><li><code>--collection</code>：指明要导入到的集合（如果集合不存在会自动创建）</li><li><code>--file</code>：数据文件地址</li><li><code>--host</code>：指明数据库主机地址（不写默认就是本机）</li><li><code>--port</code>：指明数据库端口（不写默认就是<code>27017</code>）</li></ul><p>如下：导入数据到<code>test</code>数据库中的<code>person</code>集合</p><pre><code>C:\Users\bin&gt;mongoimport --db test --collection person2 --file C:\data\person.json2015-06-02T14:46:27.687+0800    connected to: localhost2015-06-02T14:46:27.691+0800    imported 6 documents</code></pre><h2 id="mongodump命令"><a href="#mongodump命令" class="headerlink" title="mongodump命令"></a>mongodump命令</h2><p>运行时备份可以使用<code>mongodump</code>命令，它不会中断其它操作，但可能会遗漏数据，因为可能内存中的数据尚未写回数据库中。</p><ul><li><code>-h</code>：<code>MongoDB</code>所在服务器地址，例如：<code>127.0.0.1</code>，当然也可以指定端口号：<code>127.0.0.1:27017</code></li><li><code>-d</code>：需要备份的数据库实例，例如：<code>test</code></li><li><code>-o</code>：备份的数据存放位置，例如：<code>c:\data\dump</code>，当然该目录需要提前建立，在备份完成后，系统自动在<code>dump</code>目录下建立一个<code>test</code>目录，这个目录里面存放该数据库实例的备份数据。</li></ul><p>如下：备份<code>test</code>数据库。</p><pre><code>C:\Users\bin&gt;mongodump --host 127.0.0.1:27017 -d test -o C:\data\test</code></pre><h2 id="mongorestore命令"><a href="#mongorestore命令" class="headerlink" title="mongorestore命令"></a>mongorestore命令</h2><p>运行时恢复可以使用<code>mongorestore</code>命令。</p><ul><li><code>--host &lt;:port&gt;, -h &lt;:port&gt;</code>：<code>MongoDB</code>所在服务器地址，默认为： <code>localhost:27017</code>。</li><li><code>--db , -d</code>：需要恢复的数据库实例，例如：<code>test</code>。</li><li><code>--drop</code>：恢复的时候，先删除当前数据，然后恢复备份的数据。就是说，恢复后，备份后添加修改的数据都会被删除，慎用！</li><li><code>&lt;path&gt;</code>：<code>mongorestore</code> 设置备份数据所在位置，例如：<code>c:\data\dump\test</code>。</li><li><code>--dir</code>：指定备份的目录。<br>你不能同时指定 <code>&lt;path&gt;</code> 和 <code>--dir</code> 选项。</li></ul><p>如下：恢复<code>test</code>数据库</p><pre><code>C:\Users\bin&gt;mongorestore --host 127.0.0.1:27017 -d test -directoryperdb C:\data\test\test</code></pre><h2 id="数据修复"><a href="#数据修复" class="headerlink" title="数据修复"></a>数据修复</h2><p>当停电等不可逆转情况发生，由于<code>MongoDB</code>的存储结构导致会产生垃圾数据，这时候就可以使用数据库的自我修复，命令为<code>db.repairDatabase()</code>。</p><br>]]></content>
      
      
      <categories>
          
          <category> MongoDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB学习笔记12-MongoDB聚合</title>
      <link href="/2017/07/17/MongoDB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B012-MongoDB%E8%81%9A%E5%90%88/"/>
      <url>/2017/07/17/MongoDB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B012-MongoDB%E8%81%9A%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h2 id="count函数"><a href="#count函数" class="headerlink" title="count函数"></a>count函数</h2><p>查询文档数</p><pre><code class="shell">&gt; db.person.find().count()6</code></pre><a id="more"></a><h2 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h2><blockquote><p><a href="https://docs.mongodb.com/manual/reference/command/distinct/index.html" target="_blank" rel="noopener">https://docs.mongodb.com/manual/reference/command/distinct/index.html</a></p></blockquote><p>去重，用法：<code>db.runCommand({distinct:&quot;集合名&quot;, key:&quot;查询的键&quot;, query: { &quot;查询条件&quot;: &quot;A&quot;}})</code></p><pre><code class="shell">&gt; db.runCommand({distinct:&quot;person&quot;, key:&quot;age&quot;, query: { name: &quot;A&quot;}})</code></pre><p>指定排序规则，New in version 3.4.</p><p>倒序中文，仅执行基本字符的比较，忽略其他差异，如变音符号和大小写，添加参数 collation: { locale: &quot;zh&quot;, strength: 1, backwards: true }，参数说明详见：<a href="https://docs.mongodb.com/manual/reference/collation/#collation-document-fields" target="_blank" rel="noopener">https://docs.mongodb.com/manual/reference/collation/#collation-document-fields</a></p><p>另一种方式，<a href="https://docs.mongodb.com/manual/reference/method/db.collection.distinct/index.html" target="_blank" rel="noopener">db.collection.distinct()</a>，使用方式与 distinct 类似。</p><h2 id="group"><a href="#group" class="headerlink" title="group"></a>group</h2><p>文档：<a href="https://docs.mongodb.com/manual/reference/operator/aggregation/group/" target="_blank" rel="noopener">https://docs.mongodb.com/manual/reference/operator/aggregation/group/</a></p><p>参数包含一个 <code>_id</code> 字段，该字段按键包含不同的组。相当于 MySQL 中 group by 后的字段，不同的是 <code>_id</code> 后面可以跟 null。</p><p>参数还可以包含计算字段，这些字段包含按 <code>$group</code> 的 <code>_id</code> 字段分组的某些累加器表达式的值。</p><p><code>$group</code> 不会对其输出文档进行排序。</p><p>集合数据如下：</p><pre><code class="json">{ &quot;_id&quot; : 1, &quot;item&quot; : &quot;abc&quot;, &quot;price&quot; : 10, &quot;quantity&quot; : 2, &quot;date&quot; : ISODate(&quot;2014-03-01T08:00:00Z&quot;) }{ &quot;_id&quot; : 2, &quot;item&quot; : &quot;jkl&quot;, &quot;price&quot; : 20, &quot;quantity&quot; : 1, &quot;date&quot; : ISODate(&quot;2014-03-01T09:00:00Z&quot;) }{ &quot;_id&quot; : 3, &quot;item&quot; : &quot;xyz&quot;, &quot;price&quot; : 5, &quot;quantity&quot; : 10, &quot;date&quot; : ISODate(&quot;2014-03-15T09:00:00Z&quot;) }{ &quot;_id&quot; : 4, &quot;item&quot; : &quot;xyz&quot;, &quot;price&quot; : 5, &quot;quantity&quot; : 20, &quot;date&quot; : ISODate(&quot;2014-04-04T11:21:39.736Z&quot;) }{ &quot;_id&quot; : 5, &quot;item&quot; : &quot;abc&quot;, &quot;price&quot; : 10, &quot;quantity&quot; : 10, &quot;date&quot; : ISODate(&quot;2014-04-04T21:23:13.331Z&quot;) }</code></pre><h3 id="按年，月，日分组"><a href="#按年，月，日分组" class="headerlink" title="按年，月，日分组"></a>按年，月，日分组</h3><p>并计算每组的总价格和平均数量</p><pre><code class="json">db.sales.aggregate(   [      {        $group : {           _id : { month: { $month: &quot;$date&quot; }, day: { $dayOfMonth: &quot;$date&quot; }, year: { $year: &quot;$date&quot; } },           totalPrice: { $sum: { $multiply: [ &quot;$price&quot;, &quot;$quantity&quot; ] } },           averageQuantity: { $avg: &quot;$quantity&quot; },           count: { $sum: 1 }        }      }   ])</code></pre><p>结果</p><pre><code class="json">{ &quot;_id&quot; : { &quot;month&quot; : 3, &quot;day&quot; : 15, &quot;year&quot; : 2014 }, &quot;totalPrice&quot; : 50, &quot;averageQuantity&quot; : 10, &quot;count&quot; : 1 }{ &quot;_id&quot; : { &quot;month&quot; : 4, &quot;day&quot; : 4, &quot;year&quot; : 2014 }, &quot;totalPrice&quot; : 200, &quot;averageQuantity&quot; : 15, &quot;count&quot; : 2 }{ &quot;_id&quot; : { &quot;month&quot; : 3, &quot;day&quot; : 1, &quot;year&quot; : 2014 }, &quot;totalPrice&quot; : 40, &quot;averageQuantity&quot; : 1.5, &quot;count&quot; : 2 }</code></pre><h3 id="Group-by-null"><a href="#Group-by-null" class="headerlink" title="Group by null"></a>Group by null</h3><p><code>_id</code> 为null，计算总价格，平均数量，集合中文档的总数</p><pre><code class="json">db.sales.aggregate(   [      {        $group : {           _id : null,           totalPrice: { $sum: { $multiply: [ &quot;$price&quot;, &quot;$quantity&quot; ] } },           averageQuantity: { $avg: &quot;$quantity&quot; },           count: { $sum: 1 }        }      }   ])</code></pre><p>结果</p><pre><code class="json">{ &quot;_id&quot; : null, &quot;totalPrice&quot; : 290, &quot;averageQuantity&quot; : 8.6, &quot;count&quot; : 5 }</code></pre><h3 id="检索不同的值"><a href="#检索不同的值" class="headerlink" title="检索不同的值"></a>检索不同的值</h3><pre><code class="json">db.sales.aggregate( [ { $group : { _id : &quot;$item&quot; } } ] )</code></pre><p>结果</p><pre><code class="json">{ &quot;_id&quot; : &quot;xyz&quot; }{ &quot;_id&quot; : &quot;jkl&quot; }{ &quot;_id&quot; : &quot;abc&quot; }</code></pre><h3 id="将书籍集合按作者分组"><a href="#将书籍集合按作者分组" class="headerlink" title="将书籍集合按作者分组"></a>将书籍集合按作者分组</h3><p>原始集合：</p><pre><code class="json">{ &quot;_id&quot; : 8751, &quot;title&quot; : &quot;The Banquet&quot;, &quot;author&quot; : &quot;Dante&quot;, &quot;copies&quot; : 2 }{ &quot;_id&quot; : 8752, &quot;title&quot; : &quot;Divine Comedy&quot;, &quot;author&quot; : &quot;Dante&quot;, &quot;copies&quot; : 1 }{ &quot;_id&quot; : 8645, &quot;title&quot; : &quot;Eclogues&quot;, &quot;author&quot; : &quot;Dante&quot;, &quot;copies&quot; : 2 }{ &quot;_id&quot; : 7000, &quot;title&quot; : &quot;The Odyssey&quot;, &quot;author&quot; : &quot;Homer&quot;, &quot;copies&quot; : 10 }{ &quot;_id&quot; : 7020, &quot;title&quot; : &quot;Iliad&quot;, &quot;author&quot; : &quot;Homer&quot;, &quot;copies&quot; : 10 }</code></pre><p>操作</p><pre><code class="json">db.books.aggregate(   [     { $group : { _id : &quot;$author&quot;, books: { $push: &quot;$title&quot; } } }   ])</code></pre><p>结果</p><pre><code class="json">{ &quot;_id&quot; : &quot;Homer&quot;, &quot;books&quot; : [ &quot;The Odyssey&quot;, &quot;Iliad&quot; ] }{ &quot;_id&quot; : &quot;Dante&quot;, &quot;books&quot; : [ &quot;The Banquet&quot;, &quot;Divine Comedy&quot;, &quot;Eclogues&quot; ] }</code></pre><p>按作者分组集合，<code>$$ROOT</code></p><pre><code class="json">db.books.aggregate(   [     { $group : { _id : &quot;$author&quot;, books: { $push: &quot;$$ROOT&quot; } } }   ])</code></pre><p>结果</p><pre><code class="json">{  &quot;_id&quot; : &quot;Homer&quot;,  &quot;books&quot; :     [       { &quot;_id&quot; : 7000, &quot;title&quot; : &quot;The Odyssey&quot;, &quot;author&quot; : &quot;Homer&quot;, &quot;copies&quot; : 10 },       { &quot;_id&quot; : 7020, &quot;title&quot; : &quot;Iliad&quot;, &quot;author&quot; : &quot;Homer&quot;, &quot;copies&quot; : 10 }     ]}{  &quot;_id&quot; : &quot;Dante&quot;,  &quot;books&quot; :     [       { &quot;_id&quot; : 8751, &quot;title&quot; : &quot;The Banquet&quot;, &quot;author&quot; : &quot;Dante&quot;, &quot;copies&quot; : 2 },       { &quot;_id&quot; : 8752, &quot;title&quot; : &quot;Divine Comedy&quot;, &quot;author&quot; : &quot;Dante&quot;, &quot;copies&quot; : 1 },       { &quot;_id&quot; : 8645, &quot;title&quot; : &quot;Eclogues&quot;, &quot;author&quot; : &quot;Dante&quot;, &quot;copies&quot; : 2 }     ]}</code></pre><h2 id="aggregate"><a href="#aggregate" class="headerlink" title="aggregate"></a>aggregate</h2><blockquote><p><a href="https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/" target="_blank" rel="noopener">https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/</a><br><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/" target="_blank" rel="noopener">https://docs.mongodb.com/manual/reference/operator/aggregation/</a></p></blockquote><p>集合中的数据如下：</p><pre><code class="js">{   _id: ObjectId(7df78ad8902c)   title: &#39;MongoDB Overview&#39;,   description: &#39;MongoDB is no sql database&#39;,   by_user: &#39;w3cschool.cc&#39;,   url: &#39;http://www.w3cschool.cc&#39;,   tags: [&#39;mongodb&#39;, &#39;database&#39;, &#39;NoSQL&#39;],   likes: 100},{   _id: ObjectId(7df78ad8902d)   title: &#39;NoSQL Overview&#39;,   description: &#39;No sql database is very fast&#39;,   by_user: &#39;w3cschool.cc&#39;,   url: &#39;http://www.w3cschool.cc&#39;,   tags: [&#39;mongodb&#39;, &#39;database&#39;, &#39;NoSQL&#39;],   likes: 10},{   _id: ObjectId(7df78ad8902e)   title: &#39;Neo4j Overview&#39;,   description: &#39;Neo4j is no sql database&#39;,   by_user: &#39;Neo4j&#39;,   url: &#39;http://www.neo4j.com&#39;,   tags: [&#39;neo4j&#39;, &#39;database&#39;, &#39;NoSQL&#39;],   likes: 750},</code></pre><p>现在我们通过以上集合计算每个作者所写的文章数，使用 <code>aggregate()</code> 计算结果如下：</p><pre><code class="json">&gt; db.mycol.aggregate([{$group : {_id : &quot;$by_user&quot;, num_tutorial : {$sum : 1}}}]){   &quot;result&quot; : [      {         &quot;_id&quot; : &quot;w3cschool.cc&quot;,         &quot;num_tutorial&quot; : 2      },      {         &quot;_id&quot; : &quot;Neo4j&quot;,         &quot;num_tutorial&quot; : 1      }   ],   &quot;ok&quot; : 1}&gt;</code></pre><p>以上实例类似 <code>sql</code> 语句：</p><pre><code class="sql">select by_user as _id, count(*) as num_tutorial from mycol group by by_user</code></pre><p>在上面的例子中，我们通过字段 <code>by_user</code> 字段对数据进行分组，并计算 <code>by_user</code> 字段相同值的总和。</p><h3 id="sum"><a href="#sum" class="headerlink" title="$sum"></a>$sum</h3><p>计算总和。</p><pre><code class="shell">db.mycol.aggregate([{    $group: {        _id: &quot;$by_user&quot;,        num_tutorial: {            $sum: &quot;$likes&quot;        }    }}])</code></pre><h3 id="avg"><a href="#avg" class="headerlink" title="$avg"></a>$avg</h3><p>计算平均值</p><pre><code class="shell">db.mycol.aggregate([{    $group: {        _id: &quot;$by_user&quot;,        num_tutorial: {            $avg: &quot;$likes&quot;        }    }}])</code></pre><h3 id="min"><a href="#min" class="headerlink" title="$min"></a>$min</h3><p>获取集合中所有文档对应值得最小值。</p><pre><code class="shell">db.mycol.aggregate([{$group : {_id : &quot;$by_user&quot;, num_tutorial : {$min : &quot;$likes&quot;}}}])</code></pre><h3 id="max"><a href="#max" class="headerlink" title="$max"></a>$max</h3><p>获取集合中所有文档对应值得最大值。</p><pre><code class="shell">db.mycol.aggregate([{$group : {_id : &quot;$by_user&quot;, num_tutorial : {$max : &quot;$likes&quot;}}}])</code></pre><h3 id="push"><a href="#push" class="headerlink" title="$push"></a>$push</h3><p>在结果文档中插入值到一个数组中。</p><pre><code class="shell">db.mycol.aggregate([{$group : {_id : &quot;$by_user&quot;, url : {$push: &quot;$url&quot;}}}])</code></pre><h3 id="addToSet"><a href="#addToSet" class="headerlink" title="$addToSet"></a>$addToSet</h3><p>在结果文档中插入值到一个数组中，但不创建副本。</p><pre><code class="shell">db.mycol.aggregate([{$group : {_id : &quot;$by_user&quot;, url : {$addToSet : &quot;$url&quot;}}}])</code></pre><h3 id="first"><a href="#first" class="headerlink" title="$first"></a>$first</h3><p>根据资源文档的排序获取第一个文档数据。</p><pre><code class="shell">db.mycol.aggregate([{$group : {_id : &quot;$by_user&quot;, first_url : {$first : &quot;$url&quot;}}}])</code></pre><h3 id="last"><a href="#last" class="headerlink" title="$last"></a>$last</h3><p>根据资源文档的排序获取最后一个文档数据</p><pre><code class="shell">db.mycol.aggregate([{$group : {_id : &quot;$by_user&quot;, last_url : {$last : &quot;$url&quot;}}}])</code></pre><h3 id="substr-截取字符串"><a href="#substr-截取字符串" class="headerlink" title="substr 截取字符串"></a>substr 截取字符串</h3><p>从版本3.4开始不推荐使用：<code>$substr</code> 是 <a href="https://docs.mongodb.com/manual/reference/operator/aggregation/substrBytes/" target="_blank" rel="noopener">$substrBytes</a> 的别名。</p><pre><code class="json">{ $substrBytes: [ &lt;string expression&gt;, &lt;byte index&gt;, &lt;byte count&gt; ] }</code></pre><p>注意是 <strong>字节数</strong>，如果是中文，可能会报错，索引不能是 UTF-8 字符中间索引。</p><pre><code class="json">{ $substrBytes: [ &quot;abcde&quot;, 1, 2 ] }&quot;bc&quot;{ $substrBytes: [ &quot;Hello World!&quot;, 6, 5 ] }&quot;World&quot;{ $substrBytes: [ &quot;cafétéria&quot;, 7, 3 ] }&quot;Error: Invalid range, starting index is a UTF-8 continuation byte.&quot;</code></pre><p>计算出 cardnumber 字段，从第 6 位取 4 个字符，并大于 1960 的数量。</p><pre><code class="json">db.mycol.aggregate(    [        {            &quot;$project&quot;: {                &quot;_id&quot;: 0,                &quot;cardnumber&quot;: 1,                &quot;yearSubstring&quot;: {                    &quot;$substr&quot;: [&quot;$cardnumber&quot;, 6, 4]                }            }        },        {            &quot;$match&quot;: {                &quot;cardnumber&quot;: {                    &quot;$exists&quot;: &quot;true&quot;                },                &quot;yearSubstring&quot;: {                    &quot;$gt&quot;: &quot;1960&quot;                }            }        },        {            $count: &quot;count&quot;        }    ])</code></pre><h3 id="count"><a href="#count" class="headerlink" title="count"></a>count</h3><blockquote><p><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/count/" target="_blank" rel="noopener">https://docs.mongodb.com/manual/reference/operator/aggregation/count/</a></p></blockquote><p>两种方法，根据过滤条件查询总数</p><pre><code class="json">// 不使用 countdb.mycol.aggregate( [    {&quot;$project&quot;: {&quot;_id&quot;: 0, &quot;cardnumber&quot;: 1, &quot;yearSubstring&quot;: {&quot;$substr&quot;: [&quot;$cardnumber&quot;, 6, 4]}}},    {&quot;$match&quot;: {&quot;cardnumber&quot;: {&quot;$exists&quot;: &quot;true&quot;}, &quot;yearSubstring&quot;: {&quot;$gt&quot;: &quot;1960&quot;}}},    {$group : {_id: null, myCount: {$sum : 1}}},    {&quot;$project&quot;: {&quot;_id&quot;: 0, &quot;myCount&quot;: 1}}])</code></pre><pre><code class="json">db.mycol.aggregate( [    {&quot;$project&quot;: {&quot;_id&quot;: 0, &quot;cardnumber&quot;: 1, &quot;yearSubstring&quot;: {&quot;$substr&quot;: [&quot;$cardnumber&quot;, 6, 4]}}},    {&quot;$match&quot;: {&quot;cardnumber&quot;: {&quot;$exists&quot;: &quot;true&quot;}, &quot;yearSubstring&quot;: {&quot;$gt&quot;: &quot;1960&quot;}}},    {$count: &quot;count&quot;}])</code></pre><h2 id="管道的概念"><a href="#管道的概念" class="headerlink" title="管道的概念"></a>管道的概念</h2><p>管道在 <code>Unix</code> 和 <code>Linux</code> 中一般用于将当前命令的输出结果作为下一个命令的参数。</p><p><code>MongoDB</code> 的聚合管道将 <code>MongoDB</code> 文档在一个管道处理完毕后将结果传递给下一个管道处理。管道操作是可以重复的。</p><p>表达式：处理输入文档并输出。表达式是无状态的，只能用于计算当前聚合管道的文档，不能处理其它的文档。</p><p>这里我们介绍一下聚合框架中常用的几个操作：</p><ul><li><strong><code>$project</code></strong>：修改输入文档的结构。可以用来重命名、增加或删除域，也可以用于创建计算结果以及嵌套文档。</li><li><strong><code>$match</code></strong>：用于过滤数据，只输出符合条件的文档。<code>$match</code> 使用 <code>MongoDB</code> 的标准查询操作。</li><li><strong><code>$limit</code></strong>：用来限制 <code>MongoDB</code> 聚合管道返回的文档数。</li><li><strong><code>$skip</code></strong>：在聚合管道中跳过指定数量的文档，并返回余下的文档。</li><li><strong><code>$unwind</code></strong>：将文档中的某一个数组类型字段拆分成多条，每条包含数组中的一个值。</li><li><strong><code>$group</code></strong>：将集合中的文档分组，可用于统计结果。</li><li><strong><code>$sort</code></strong>：将输入文档排序后输出。</li><li><strong><code>$geoNear</code></strong>：输出接近某一地理位置的有序文档。</li></ul><p>管道操作符实例</p><h3 id="project实例"><a href="#project实例" class="headerlink" title="$project实例"></a>$project实例</h3><pre><code class="shell">db.article.aggregate({    $project : {        title : 1 ,        author : 1 ,    }});</code></pre><p>这样的话结果中就只还有 <code>_id</code> , <code>tilte</code> 和 <code>author</code> 三个字段了，默认情况下 <code>_id</code> 字段是被包含的，如果要想不包含 <code>_id</code> 话可以这样:</p><pre><code class="shell">db.article.aggregate(    { $project : {        _id : 0 ,        title : 1 ,        author : 1    }});</code></pre><h3 id="match实例"><a href="#match实例" class="headerlink" title="$match实例"></a>$match实例</h3><pre><code class="shell">db.articles.aggregate( [    { $match : { score : { $gt : 70, $lte : 90 } } },    { $group: { _id: null, count: { $sum: 1 } } }] );</code></pre><p><code>$match</code> 用于获取分数大于 70 小于或等于 90 记录，然后将符合条件的记录送到下一阶段 <code>$group</code> 管道操作符进行处理。</p><h3 id="skip实例"><a href="#skip实例" class="headerlink" title="$skip实例"></a>$skip实例</h3><pre><code class="shell">db.article.aggregate({ $skip : 5 });</code></pre><p>经过 <code>$skip</code> 管道操作符处理后，前五个文档被&quot;过滤&quot;掉。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h3><pre><code class="json">db.article.aggregate([    { &quot;$match&quot; : { &quot;identifytime&quot; : { &quot;$gte&quot; : 1495555200 , &quot;$lte&quot; : 1503372850}}} ,    { &quot;$project&quot; : { &quot;aptype&quot; : 1}} ,    { &quot;$group&quot; : { &quot;_id&quot; :  &quot;$aptype&quot;  , &quot;totalNum&quot; : { &quot;$sum&quot; : 1}}} ,    { &quot;$sort&quot; : { &quot;totalNum&quot; : -1}} ,    { &quot;$skip&quot; : 0} ,    { &quot;$limit&quot; : 15}]){&quot;_id&quot; : 1, &quot;totalNum&quot; : 5.0}{&quot;_id&quot; : 2, &quot;totalNum&quot; : 2.0}{&quot;_id&quot; : 3, &quot;totalNum&quot; : 1.0}{&quot;_id&quot; : 0, &quot;totalNum&quot; : 1.0}</code></pre><p><strong>Spring Date MongoDB</strong></p><pre><code class="java">TypedAggregation&lt;T&gt; agg = Aggregation.newAggregation(        entityClass,        Aggregation.match(criteria),        Aggregation.project(&quot;aptype&quot;),        Aggregation.group(&quot;aptype&quot;).count().as(&quot;totalNum&quot;),        Aggregation.sort(Sort.Direction.DESC, &quot;totalNum&quot;),        Aggregation.skip((long) ((thispage - 1) * 15)),//分页        Aggregation.limit(15)    );AggregationResults&lt;T&gt; result = mongoTemplate.aggregate(agg,collectionName, entityClass);List&lt;T&gt; resultList = result.getMappedResults();</code></pre><h3 id="方式二：为分组的字段-id建立别名"><a href="#方式二：为分组的字段-id建立别名" class="headerlink" title="方式二：为分组的字段_id建立别名"></a>方式二：为分组的字段<code>_id</code>建立别名</h3><pre><code class="json">db.article.aggregate([    { &quot;$match&quot; : { &quot;identifytime&quot; : { &quot;$gte&quot; : 1495555200 , &quot;$lte&quot; : 1503372850}}} ,    { &quot;$group&quot; : { &quot;_id&quot; :  &quot;$aptype&quot; , &quot;totalNum&quot; : { &quot;$sum&quot; : 1}}} ,    { &quot;$project&quot; : {&quot;totalNum&quot; : 1 , &quot;_id&quot; : 0, &quot;aptype&quot; : &quot;$_id&quot; }} ,    { &quot;$sort&quot; : { &quot;totalNum&quot; : -1}} ,    { &quot;$skip&quot; : 0} ,    { &quot;$limit&quot; : 15}]){&quot;totalNum&quot; : 5.0, &quot;aptype&quot; : 1}{&quot;totalNum&quot; : 2.0, &quot;aptype&quot; : 2}{&quot;totalNum&quot; : 1.0, &quot;aptype&quot; : 3}{&quot;totalNum&quot; : 1.0, &quot;aptype&quot; : 0}</code></pre><p><strong>Spring Date MongoDB</strong></p><p>如果需要分组的字段大于一个，按照上面的写法也行</p><pre><code class="java">TypedAggregation&lt;T&gt; agg = Aggregation.newAggregation(    entityClass,    Aggregation.match(criteria),    Aggregation.group(&quot;aptype&quot;).count().as(&quot;totalNum&quot;), // 需要在 project 之上    Aggregation.project(&quot;totalNum&quot;, &quot;aptype&quot;).and(&quot;aptype&quot;).previousOperation(), // 需要分组的字段，&quot;totalNum&quot;必须要有    Aggregation.sort(Sort.Direction.DESC, &quot;totalNum&quot;),    Aggregation.skip((long) ((thispage - 1) * 15)),//分页    Aggregation.limit(15));AggregationResults&lt;T&gt; result = mongoTemplate.aggregate(agg, collectionName, entityClass);List&lt;T&gt; resultList = result.getMappedResults();return resultList;</code></pre>]]></content>
      
      
      <categories>
          
          <category> MongoDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB学习笔记11-MongoDB索引</title>
      <link href="/2017/07/17/MongoDB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B011-MongoDB%E7%B4%A2%E5%BC%95/"/>
      <url>/2017/07/17/MongoDB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B011-MongoDB%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<h2 id="索引的基本使用"><a href="#索引的基本使用" class="headerlink" title="索引的基本使用"></a>索引的基本使用</h2><h3 id="建立索引"><a href="#建立索引" class="headerlink" title="建立索引"></a>建立索引</h3><p>数据库会按照索引对数据进行一个排序，存储在一个地方，查询时先到这个地方进行定位，然后再去取真实数据。而<code>MongoDB</code>对不会采用任何索引的查询都会进行<code>全表扫描</code>，即查询整个集合。<br>在<code>shell</code>中为某个<code>key</code>建立索引的方法为调用集合的<code>ensureIndex</code>函数来构建索引，即索引是建立在集合之上的：<code>db.集合名.ensureIndex({key:1})</code>，其中的<code>key</code>表示为哪个<code>key</code>建立索引，<code>1（大于0）</code>表示<strong><code>升序</code></strong>建立索引数据，而<code>-1（小于0）</code>表示<strong><code>降序</code></strong>建立索引数据，如下图：为<code>age</code>这个键升序建立索引。</p><pre><code>&gt; db.person.ensureIndex({age:1})</code></pre><p>还可以通过点符号为内嵌文档建立索引，</p><pre><code>&gt; db.person.ensureIndex({&quot;score.math&quot;:1})</code></pre><a id="more"></a><style>table th:first-of-type {    width: 150px;}table th:nth-of-type(2) {    width: 150px;}</style><h3 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h3><table><thead><tr><th align="center">Parameter</th><th align="center">Type</th><th align="center">Description</th></tr></thead><tbody><tr><td align="center">background</td><td align="center">Boolean</td><td align="center">建索引过程会阻塞其它数据库操作，<code>background</code>可指定以后台方式创建索引，即增加 <code>&quot;background&quot;</code> 可选参数。 <code>&quot;background&quot;</code> 默认值为<code>false</code>。</td></tr><tr><td align="center">unique</td><td align="center">Boolean</td><td align="center">建立的索引是否唯一。指定为<code>true</code>创建唯一索引。默认值为<code>false</code>。</td></tr><tr><td align="center">name</td><td align="center">string</td><td align="center">索引的名称。如果未指定，<code>MongoDB</code>的通过连接索引的字段名和排序顺序生成一个索引名称。</td></tr><tr><td align="center">dropDups</td><td align="center">Boolean</td><td align="center">在建立唯一索引时是否删除重复记录,指定 <code>true</code> 创建唯一索引。默认值为 <code>false</code>。</td></tr><tr><td align="center">sparse</td><td align="center">Boolean</td><td align="center">对文档中不存在的字段数据不启用索引；这个参数需要特别注意，如果设置为<code>true</code>的话，在索引字段中不会查询出不包含对应字段的文档。默认值为 <code>false</code>。</td></tr><tr><td align="center">expireAfterSeconds</td><td align="center">integer</td><td align="center">指定一个以秒为单位的数值，完成 <code>TTL</code>设定，设定集合的生存时间。</td></tr><tr><td align="center">v</td><td align="center">index version</td><td align="center">索引的版本号。默认的索引版本取决于mongod创建索引时运行的版本。</td></tr><tr><td align="center">weights</td><td align="center">document</td><td align="center">索引权重值，数值在 1 到 99,999 之间，表示该索引相对于其他索引字段的得分权重。</td></tr><tr><td align="center">default_language</td><td align="center">string</td><td align="center">对于文本索引，该参数决定了停用词及词干和词器的规则的列表。 默认为英语。</td></tr><tr><td align="center">language_override</td><td align="center">string</td><td align="center">对于文本索引，该参数指定了包含在文档中的字段名，语言覆盖默认的<code>language</code>，默认值为 <code>language</code>。</td></tr></tbody></table><h3 id="在shell中查看数据库已建立的索引"><a href="#在shell中查看数据库已建立的索引" class="headerlink" title="在shell中查看数据库已建立的索引"></a>在shell中查看数据库已建立的索引</h3><p>索引的描述信息存储在集合<code>system.indexes</code>中，这是系统提供的保留集合（创建数据库时），不能对其进行插入或删除操作。操作这个集合只能通过<code>ensureIndex</code>插入索引，<code>dropIndex</code>删除索引两个函数。<br>在<code>system.indexes</code>和<code>system.namespaces</code>集合中都能看到数据库已建立的索引，系统还会默认为<code>_id</code>键建立唯一索引。其中键<code>ns</code>是“数据库名.集合名”</p><pre><code>&gt; db.system.indexes.find(){ &quot;v&quot; : 1, &quot;key&quot; : { &quot;_id&quot; : 1 }, &quot;name&quot; : &quot;_id_&quot;, &quot;ns&quot; : &quot;test.system.users&quot; }{ &quot;v&quot; : 1, &quot;key&quot; : { &quot;_id&quot; : 1 }, &quot;name&quot; : &quot;_id_&quot;, &quot;ns&quot; : &quot;test.person&quot; }{ &quot;v&quot; : 1, &quot;key&quot; : { &quot;age&quot; : 1 }, &quot;name&quot; : &quot;age_1&quot;, &quot;ns&quot; : &quot;test.person&quot; }&gt;&gt; db.system.namespaces.find(){ &quot;name&quot; : &quot;test.system.indexes&quot; }{ &quot;name&quot; : &quot;test.system.users&quot; }{ &quot;name&quot; : &quot;test.system.users.$_id_&quot; }{ &quot;name&quot; : &quot;test.person&quot; }{ &quot;name&quot; : &quot;test.person.$_id_&quot; }{ &quot;name&quot; : &quot;test.person.$age_1&quot; }</code></pre><h3 id="索引名称"><a href="#索引名称" class="headerlink" title="索引名称"></a>索引名称</h3><p>集合中每个索引都会有一个字符串名字，来唯一标识这个索引，且MongoDB通过这个名称来操作索引。默认索引的名称规则为：<code>keyname1_dir1_keyname2_dir2.....</code>，<code>keyname</code>是构建索引的键名称，<code>dir</code>是代表其方向的数字。如创建索引<code>{&quot;a&quot;:1,&quot;b&quot;:1}</code>，其的默认名称是<code>&quot;a_1_b_1&quot;</code>。也可以在建立索引时指定索引的名称，使用方式是使用<code>ensureIndex</code>函数的另一个参数指定<code>name</code>键，如下图：为<code>age</code>键建立倒序索引，并指定名称为<code>$index_age_-1</code>。</p><pre><code>&gt; db.person.ensureIndex({age:-1},{name:&quot;$index_age_-1&quot;}){ &quot;v&quot; : 1, &quot;key&quot; : { &quot;_id&quot; : 1 }, &quot;name&quot; : &quot;_id_&quot;, &quot;ns&quot; : &quot;test.system.users&quot; }{ &quot;v&quot; : 1, &quot;key&quot; : { &quot;_id&quot; : 1 }, &quot;name&quot; : &quot;_id_&quot;, &quot;ns&quot; : &quot;test.person&quot; }{ &quot;v&quot; : 1, &quot;key&quot; : { &quot;age&quot; : 1 }, &quot;name&quot; : &quot;age_1&quot;, &quot;ns&quot; : &quot;test.person&quot; }{ &quot;v&quot; : 1, &quot;key&quot; : { &quot;age&quot; : -1 }, &quot;name&quot; : &quot;$index_age_-1&quot;, &quot;ns&quot; : &quot;test.person&quot; }&gt;</code></pre><h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><p>建立唯一索引是使用<code>ensureIndex</code>函数的另一个参数，指定<code>unique</code>键为<code>true</code>，如下：为<code>name</code>键建立升序的唯一索引，并指定索引名字。</p><pre><code>&gt; db.person.ensureIndex({name:1},{name:&quot;$index_name_1&quot;,unique:true})&gt; db.person.insert({name:&quot;lisi&quot;})WriteResult({        &quot;nInserted&quot; : 0,        &quot;writeError&quot; : {                &quot;code&quot; : 11000,                &quot;errmsg&quot; : &quot;E11000 duplicate key error index: test.person.$$index_age_1 dup key: { : \&quot;lisi\&quot; }&quot;        }})&gt;</code></pre><p>这样建立唯一索引后，当再次插入一条文档，而该文档的<code>name</code>键的值已存在了就不能插入该文档了。<br>但是如果在为某个<code>key</code>建立唯一索引之前，该集合的所有文档中这个<code>key</code>的值<strong>已经存在重复</strong>的情况了，如果是在这种情况下为该key建立唯一索引，则要使用<code>ensureIndex</code>函数的另一个参数，指定<code>dropDups</code>键为<code>true</code>，如下图：指定<code>了dropDups</code>键为<code>true</code>后，它会删除在这个要建立索引的<code>key</code>上重复的数据，保留这个键第一次出现某个值的文档，<strong>再次出现这个值的文档会直接被删掉</strong></p><pre><code>&gt; db.person.ensureIndex({name:-1},{unique:true,dropDups:true})</code></pre><h3 id="hint：在查询时强制使用指定的索引"><a href="#hint：在查询时强制使用指定的索引" class="headerlink" title="hint：在查询时强制使用指定的索引"></a>hint：在查询时强制使用指定的索引</h3><p>（前提是指定使用的索引必须是已经成功创建了的）<br><code>hint</code>函数可以作为操作游标的函数调用，它会继续返回一个游标，一般情况下没有必要通过<code>hint</code>去强制使用某个索引，<code>MongoDB</code>的查询优化器能帮助使用最佳的索引去进行查询。如下：</p><pre><code>&gt; db.person.find(){ &quot;_id&quot; : 1001, &quot;name&quot; : &quot;lisi&quot;, &quot;age&quot; : 20 }{ &quot;_id&quot; : 1002, &quot;name&quot; : &quot;zhangsan&quot;, &quot;age&quot; : 21 }{ &quot;_id&quot; : 1004, &quot;name&quot; : &quot;zhaoliu&quot;, &quot;age&quot; : 17 }{ &quot;_id&quot; : 1003, &quot;age&quot; : 19, &quot;name&quot; : &quot;wangwu&quot; }&gt;&gt; db.person.find().hint({age:1}){ &quot;_id&quot; : 1004, &quot;name&quot; : &quot;zhaoliu&quot;, &quot;age&quot; : 17 }{ &quot;_id&quot; : 1003, &quot;age&quot; : 19, &quot;name&quot; : &quot;wangwu&quot; }{ &quot;_id&quot; : 1001, &quot;name&quot; : &quot;lisi&quot;, &quot;age&quot; : 20 }{ &quot;_id&quot; : 1002, &quot;name&quot; : &quot;zhangsan&quot;, &quot;age&quot; : 21 }&gt;</code></pre><h2 id="索引管理"><a href="#索引管理" class="headerlink" title="索引管理"></a>索引管理</h2><h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h3><p>在删除索引时可以指定要删除的索引的名字而执行精确删除，还可以使用*号来进行批量删除，<code>shell</code>命令为：<code>db.runCommand({dropIndexes:&quot;集合名&quot;, index:&quot;索引名或*号&quot;})</code>，如下图：不能删除默认给<code>_id</code>键生成的索引。</p><pre><code>&gt; db.runCommand({dropIndexes:&quot;person&quot;,index:&quot;age_1&quot;}){ &quot;nIndexesWas&quot; : 4, &quot;ok&quot; : 1 }&gt;</code></pre><p>除了这种使用命令的方式外，还可以直接使用在集合上：<code>db.集合名.dropIndexes()</code>，它会直接将该集合所有的索引全部删掉。</p><p>还可以使用集合函数：<code>db.集合名.dropIndex(&quot;索引名&quot;)</code>，它会删除该集合上指定名字的索引，注意使用这个函数的正确步骤应该是<strong>先通过查询<code>system.indexes</code>确认索引的名称，然后再删除</strong>，因为不是所有语言的数据库驱动都是按照前面介绍的方式去生成索引名称。</p><p>除此之外，还有一种删除索引的方式是将集合删掉，这样所有索引（包括键<code>_id</code>的唯一索引）、文档都会被删除。而上面介绍的的删除所有索引的方式都不会删除系统为键<code>_id</code>创建的唯一索引，且调用集合的<code>remove</code>函数，即使删除所有文档，也不会删除索引，当往集合中添加数据时，该索引还会起作用。</p><h3 id="索引的构建"><a href="#索引的构建" class="headerlink" title="索引的构建"></a>索引的构建</h3><p>是一个耗时耗资源的过程，并且在构建过程中会暂时锁表，数据库会阻塞所有的访问请求。为了不影响查询可以让索引的创建过程在后台执行，即指定<code>ensureIndex</code>函数的第二个参数的<code>background</code>键为<code>true</code>即可，表明在数据库服务空闲时来构建索引，如下：对于一个大数量的集合添加索引时应该启用这个参数，且即时启用了这个参数，构建索引仍会影响正常服务，但不会彻底阻塞数据库服务。</p><br>]]></content>
      
      
      <categories>
          
          <category> MongoDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB学习笔记10-MongoDB分页、排序与游标</title>
      <link href="/2017/07/17/MongoDB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B010-MongoDB%E5%88%86%E9%A1%B5%E3%80%81%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%B8%B8%E6%A0%87/"/>
      <url>/2017/07/17/MongoDB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B010-MongoDB%E5%88%86%E9%A1%B5%E3%80%81%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%B8%B8%E6%A0%87/</url>
      
        <content type="html"><![CDATA[<h2 id="分页limit与skip"><a href="#分页limit与skip" class="headerlink" title="分页limit与skip"></a>分页limit与skip</h2><h3 id="limit返回指定条数的数据"><a href="#limit返回指定条数的数据" class="headerlink" title="limit返回指定条数的数据"></a>limit返回指定条数的数据</h3><pre><code>&gt; db.person.find(){ &quot;_id&quot; : 1001, &quot;name&quot; : &quot;lisi&quot;, &quot;age&quot; : 20 }{ &quot;_id&quot; : 1002, &quot;name&quot; : &quot;zhangsan&quot;, &quot;age&quot; : 21 }{ &quot;_id&quot; : 1003, &quot;name&quot; : &quot;wangwu&quot;, &quot;age&quot; : 18 }{ &quot;_id&quot; : 1004, &quot;name&quot; : &quot;zhaoliu&quot;, &quot;age&quot; : 17 }{ &quot;_id&quot; : 1005, &quot;name&quot; : &quot;sunqi&quot;, &quot;age&quot; : 24 }{ &quot;_id&quot; : 1006, &quot;name&quot; : &quot;zhouba&quot;, &quot;age&quot; : 23 }&gt;&gt; db.person.find().limit(3){ &quot;_id&quot; : 1001, &quot;name&quot; : &quot;lisi&quot;, &quot;age&quot; : 20 }{ &quot;_id&quot; : 1002, &quot;name&quot; : &quot;zhangsan&quot;, &quot;age&quot; : 21 }{ &quot;_id&quot; : 1003, &quot;name&quot; : &quot;wangwu&quot;, &quot;age&quot; : 18 }&gt;</code></pre><a id="more"></a><h3 id="skip指定跨度"><a href="#skip指定跨度" class="headerlink" title="skip指定跨度"></a>skip指定跨度</h3><pre><code>&gt; db.person.find().skip(3){ &quot;_id&quot; : 1004, &quot;name&quot; : &quot;zhaoliu&quot;, &quot;age&quot; : 17 }{ &quot;_id&quot; : 1005, &quot;name&quot; : &quot;sunqi&quot;, &quot;age&quot; : 24 }{ &quot;_id&quot; : 1006, &quot;name&quot; : &quot;zhouba&quot;, &quot;age&quot; : 23 }&gt;</code></pre><h3 id="limit与skip结合，进行分页"><a href="#limit与skip结合，进行分页" class="headerlink" title="limit与skip结合，进行分页"></a>limit与skip结合，进行分页</h3><pre><code>&gt; db.person.find().skip(0).limit(2){ &quot;_id&quot; : 1001, &quot;name&quot; : &quot;lisi&quot;, &quot;age&quot; : 20 }{ &quot;_id&quot; : 1002, &quot;name&quot; : &quot;zhangsan&quot;, &quot;age&quot; : 21 }&gt;&gt; db.person.find().skip(2).limit(2){ &quot;_id&quot; : 1003, &quot;name&quot; : &quot;wangwu&quot;, &quot;age&quot; : 18 }{ &quot;_id&quot; : 1004, &quot;name&quot; : &quot;zhaoliu&quot;, &quot;age&quot; : 17 }&gt;&gt; db.person.find().skip(4).limit(2){ &quot;_id&quot; : 1005, &quot;name&quot; : &quot;sunqi&quot;, &quot;age&quot; : 24 }{ &quot;_id&quot; : 1006, &quot;name&quot; : &quot;zhouba&quot;, &quot;age&quot; : 23 }&gt;</code></pre><h2 id="排序sort"><a href="#排序sort" class="headerlink" title="排序sort"></a>排序sort</h2><h3 id="sort排序"><a href="#sort排序" class="headerlink" title="sort排序"></a>sort排序</h3><p>指定排序的<code>key</code>，大于<code>0</code>为升序，小于<code>0</code>为降序。如果指定了多个排序键，比如<code>{age:1,name:-1}</code>，则是先按<code>age</code>升序排列，对于<code>age</code>键相等的文档，则按<code>name</code>降序排列。</p><pre><code>&gt; db.person.find().sort({age:1}){ &quot;_id&quot; : 1004, &quot;name&quot; : &quot;zhaoliu&quot;, &quot;age&quot; : 17 }{ &quot;_id&quot; : 1003, &quot;name&quot; : &quot;wangwu&quot;, &quot;age&quot; : 18 }{ &quot;_id&quot; : 1001, &quot;name&quot; : &quot;lisi&quot;, &quot;age&quot; : 20 }{ &quot;_id&quot; : 1002, &quot;name&quot; : &quot;zhangsan&quot;, &quot;age&quot; : 21 }{ &quot;_id&quot; : 1006, &quot;name&quot; : &quot;zhouba&quot;, &quot;age&quot; : 23 }{ &quot;_id&quot; : 1005, &quot;name&quot; : &quot;sunqi&quot;, &quot;age&quot; : 24 }&gt;&gt; db.person.find().sort({age:-1}){ &quot;_id&quot; : 1005, &quot;name&quot; : &quot;sunqi&quot;, &quot;age&quot; : 24 }{ &quot;_id&quot; : 1006, &quot;name&quot; : &quot;zhouba&quot;, &quot;age&quot; : 23 }{ &quot;_id&quot; : 1002, &quot;name&quot; : &quot;zhangsan&quot;, &quot;age&quot; : 21 }{ &quot;_id&quot; : 1001, &quot;name&quot; : &quot;lisi&quot;, &quot;age&quot; : 20 }{ &quot;_id&quot; : 1003, &quot;name&quot; : &quot;wangwu&quot;, &quot;age&quot; : 18 }{ &quot;_id&quot; : 1004, &quot;name&quot; : &quot;zhaoliu&quot;, &quot;age&quot; : 17 }&gt;</code></pre><h3 id="排序的先后"><a href="#排序的先后" class="headerlink" title="排序的先后"></a>排序的先后</h3><p>如下代码所示，使用<code>sort</code>，始终是先对满足查询条件而查询到的结果集进行排序，然后再进行选取指定的条数或者是跳过指定的条数。它们的关系就是：<strong>在数据库服务器端，先执行<code>sort</code>，然后在排好序的文档上执行<code>skip</code>，最后按照<code>limit</code>设定的最大数量返回文档子集</strong>。</p><pre><code>&gt; db.person.find().limit(2).sort({age:1}){ &quot;_id&quot; : 1004, &quot;name&quot; : &quot;zhaoliu&quot;, &quot;age&quot; : 17 }{ &quot;_id&quot; : 1003, &quot;name&quot; : &quot;wangwu&quot;, &quot;age&quot; : 18 }&gt;&gt; db.person.find().sort({age:1}).limit(2){ &quot;_id&quot; : 1004, &quot;name&quot; : &quot;zhaoliu&quot;, &quot;age&quot; : 17 }{ &quot;_id&quot; : 1003, &quot;name&quot; : &quot;wangwu&quot;, &quot;age&quot; : 18 }&gt;&gt; db.person.find().skip(2).sort({age:1}){ &quot;_id&quot; : 1001, &quot;name&quot; : &quot;lisi&quot;, &quot;age&quot; : 20 }{ &quot;_id&quot; : 1002, &quot;name&quot; : &quot;zhangsan&quot;, &quot;age&quot; : 21 }{ &quot;_id&quot; : 1006, &quot;name&quot; : &quot;zhouba&quot;, &quot;age&quot; : 23 }{ &quot;_id&quot; : 1005, &quot;name&quot; : &quot;sunqi&quot;, &quot;age&quot; : 24 }&gt;&gt; db.person.find().sort({age:1}).skip(2){ &quot;_id&quot; : 1001, &quot;name&quot; : &quot;lisi&quot;, &quot;age&quot; : 20 }{ &quot;_id&quot; : 1002, &quot;name&quot; : &quot;zhangsan&quot;, &quot;age&quot; : 21 }{ &quot;_id&quot; : 1006, &quot;name&quot; : &quot;zhouba&quot;, &quot;age&quot; : 23 }{ &quot;_id&quot; : 1005, &quot;name&quot; : &quot;sunqi&quot;, &quot;age&quot; : 24 }&gt;</code></pre><h3 id="排序的优先级"><a href="#排序的优先级" class="headerlink" title="排序的优先级"></a>排序的优先级</h3><p>由于<code>MongoDB</code>的<code>key</code>可以存储不同类型的数据，所以排序是有优先级的，如下：</p><pre><code>&gt; db.person.find(){ &quot;_id&quot; : 1001, &quot;name&quot; : &quot;lisi&quot;, &quot;age&quot; : 20 }{ &quot;_id&quot; : 1002, &quot;name&quot; : &quot;zhangsan&quot;, &quot;age&quot; : 21 }{ &quot;_id&quot; : 1004, &quot;name&quot; : &quot;zhaoliu&quot;, &quot;age&quot; : 17 }{ &quot;_id&quot; : 1005, &quot;name&quot; : &quot;sunqi&quot;, &quot;age&quot; : 24 }{ &quot;_id&quot; : 1006, &quot;name&quot; : &quot;zhouba&quot;, &quot;age&quot; : 23 }{ &quot;_id&quot; : 1003, &quot;age&quot; : &quot;十八岁&quot;, &quot;name&quot; : &quot;wangwu&quot; }&gt;&gt; db.person.find().sort({age:1}){ &quot;_id&quot; : 1004, &quot;name&quot; : &quot;zhaoliu&quot;, &quot;age&quot; : 17 }{ &quot;_id&quot; : 1001, &quot;name&quot; : &quot;lisi&quot;, &quot;age&quot; : 20 }{ &quot;_id&quot; : 1002, &quot;name&quot; : &quot;zhangsan&quot;, &quot;age&quot; : 21 }{ &quot;_id&quot; : 1006, &quot;name&quot; : &quot;zhouba&quot;, &quot;age&quot; : 23 }{ &quot;_id&quot; : 1005, &quot;name&quot; : &quot;sunqi&quot;, &quot;age&quot; : 24 }{ &quot;_id&quot; : 1003, &quot;age&quot; : &quot;十八岁&quot;, &quot;name&quot; : &quot;wangwu&quot; }&gt;</code></pre><p><strong>优先级从高到低依次为</strong>：最小值、null、数字、字符串、对象/文档、数组、二进制、对象ID、布尔、日期、时间戳、正则、最大值。</p><h2 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h2><ol><li>如下代码所示，查询出某个文档中某个<code>key</code>（假设类型是数组）的元素个数，使用<code>find</code>函数的返回值是一个游标，所以需要用到游标遍历的方式来遍历查询出来的每个文档，而<code>findOne</code>就可以直接输出。<pre><code>&gt; db.person1.find(){ &quot;_id&quot; : 1002, &quot;name&quot; : &quot;bbb&quot;, &quot;books&quot; : [ &quot;JS&quot; ] }{ &quot;_id&quot; : 1001, &quot;name&quot; : &quot;aaa&quot;, &quot;books&quot; : [ &quot;JSP&quot;, &quot;JAVA&quot; ] }&gt;&gt; var iter = db.person1.find({name:&quot;aaa&quot;})&gt; while(iter.hasNext()) {... var obj = iter.next();... print(obj.books.length);... }2&gt;&gt; var iter = db.person1.findOne({name:&quot;aaa&quot;})&gt; iter.books.length2&gt;</code></pre></li><li><code>find()</code>函数返回一个游标。如果在调用<code>find</code>函数时，不保存返回值，其会自动递归<code>find</code>返回的游标，将前 20 条数据展示在<code>shell</code>中（输入<code>it</code>会继续显示下20条），<pre><code>&gt; var iter = db.pers.find()&gt; iter... # 省略17条{ &quot;_id&quot; : 17, &quot;age&quot; : 17 }{ &quot;_id&quot; : 18, &quot;age&quot; : 18 }{ &quot;_id&quot; : 19, &quot;age&quot; : 19 }Type &quot;it&quot; for more&gt; it{ &quot;_id&quot; : 20, &quot;age&quot; : 20 }{ &quot;_id&quot; : 21, &quot;age&quot; : 21 }{ &quot;_id&quot; : 22, &quot;age&quot; : 22 }</code></pre></li><li>游标到底部就会释放资源，不能再次读取，只能读一遍。</li><li>游标的销毁条件：<ul><li>客户端发来销毁信息。</li><li>游标迭代完毕。</li><li>默认情况下，游标超过10分钟没用也会被清除。</li></ul></li><li>当获得游标后，客户端可以通过对游标进行一些设置就能对查询结果进行有效地控制，如可以限制查询得到的结果数量、跳过部分结果、或对结果集按任意键进行排序等，也就是先对游标进行处理后，再让访问数据库的动作按照指定的意愿发生。比如上面分页和排序中使用的<code>limit()</code>、<code>skip()</code>、<code>sort()</code>等函数，为什么这些函数可以进行链式调用呢？就是因为操作游标的函数返回的都是游标。</li></ol><br>]]></content>
      
      
      <categories>
          
          <category> MongoDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB学习笔记09-MongoDB在Shell中执行查询</title>
      <link href="/2017/07/17/MongoDB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B009-MongoDB%E5%9C%A8Shell%E4%B8%AD%E6%89%A7%E8%A1%8C%E6%9F%A5%E8%AF%A2/"/>
      <url>/2017/07/17/MongoDB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B009-MongoDB%E5%9C%A8Shell%E4%B8%AD%E6%89%A7%E8%A1%8C%E6%9F%A5%E8%AF%A2/</url>
      
        <content type="html"><![CDATA[<h3 id="查询集合中所有文档"><a href="#查询集合中所有文档" class="headerlink" title="查询集合中所有文档"></a>查询集合中所有文档</h3><p><code>db.集合名.find()</code></p><h3 id="查询集合中第一个文档"><a href="#查询集合中第一个文档" class="headerlink" title="查询集合中第一个文档"></a>查询集合中第一个文档</h3><p><code>db.集合名.findOne()</code></p><a id="more"></a><h3 id="查询全部文档"><a href="#查询全部文档" class="headerlink" title="查询全部文档"></a>查询全部文档</h3><p><code>db.集合名.find({})</code>，如果查询文档{}中包含了多个键值对，则是<code>AND</code>的关系。</p><pre><code>&gt; db.pers.find() # db.pers.find({}){ &quot;_id&quot; : 1001, &quot;name&quot; : &quot;aaa&quot;, &quot;age&quot; : 9 }{ &quot;_id&quot; : 1002, &quot;name&quot; : &quot;bbb&quot;, &quot;age&quot; : 12 }{ &quot;_id&quot; : 1003, &quot;name&quot; : &quot;ccc&quot;, &quot;age&quot; : 13 }{ &quot;_id&quot; : 1004, &quot;name&quot; : &quot;ddd&quot;, &quot;age&quot; : 15 }{ &quot;_id&quot; : 1005, &quot;name&quot; : &quot;eee&quot;, &quot;age&quot; : 22 }&gt; db.pers.find({name:&quot;aaa&quot;,age:9}){ &quot;_id&quot; : 1001, &quot;name&quot; : &quot;aaa&quot;, &quot;age&quot; : 9 }</code></pre><h3 id="五种基本的查询条件"><a href="#五种基本的查询条件" class="headerlink" title="五种基本的查询条件"></a>五种基本的查询条件</h3><p><code>$lt(&lt;)</code>、<code>$lte(&lt;=)</code>、<code>$gt(&gt;)</code>、<code>$gte(&gt;=)</code>、<code>$ne(!=)</code>，当对某个<code>key</code>，分开指定了多次查询条件，则对该<code>key</code>的查询条件是以最后一个查询条件为准。</p><pre><code>&gt; db.pers.find({age:{$gt:13,$lt:22}}) # amd{ &quot;_id&quot; : 1004, &quot;name&quot; : &quot;ddd&quot;, &quot;age&quot; : 15 }&gt;&gt; db.pers.find({age:{$gt:13},age:{$lt:10}}) # 相同key 最后一个为准{ &quot;_id&quot; : 1001, &quot;name&quot; : &quot;aaa&quot;, &quot;age&quot; : 9 }&gt;</code></pre><h3 id="包含与不包含：-in、-nin"><a href="#包含与不包含：-in、-nin" class="headerlink" title="包含与不包含：$in、$nin"></a>包含与不包含：$in、$nin</h3><p>都只能作用于数组，而不能作用于其他类型</p><pre><code>&gt; db.pers.find({age:{$in:[9,12]}}){ &quot;_id&quot; : 1001, &quot;name&quot; : &quot;aaa&quot;, &quot;age&quot; : 9 }{ &quot;_id&quot; : 1002, &quot;name&quot; : &quot;bbb&quot;, &quot;age&quot; : 12 }&gt;&gt; db.pers.find({age:{$nin:[9,12]}}){ &quot;_id&quot; : 1003, &quot;name&quot; : &quot;ccc&quot;, &quot;age&quot; : 13 }{ &quot;_id&quot; : 1004, &quot;name&quot; : &quot;ddd&quot;, &quot;age&quot; : 15 }{ &quot;_id&quot; : 1005, &quot;name&quot; : &quot;eee&quot;, &quot;age&quot; : 22 }&gt;</code></pre><h3 id="or查询：-or"><a href="#or查询：-or" class="headerlink" title="or查询：$or"></a>or查询：$or</h3><p>注意最外面是<code>or</code>查询器，<code>or</code>查询器的<code>value</code>是一个数组，里面是很多的查询条件，数组中每个查询条件就是<code>or</code>的关系。使用这个条件操作符有一个最佳实践是：将最宽松的条件放在前面，这样可以加快文档匹配速度</p><pre><code>&gt; db.pers.find({$or:[{name:{$in:[&quot;aaa&quot;,&quot;bbb&quot;]}},{age:{$gt:15}}]}){ &quot;_id&quot; : 1001, &quot;name&quot; : &quot;aaa&quot;, &quot;age&quot; : 9 }{ &quot;_id&quot; : 1002, &quot;name&quot; : &quot;bbb&quot;, &quot;age&quot; : 12 }{ &quot;_id&quot; : 1005, &quot;name&quot; : &quot;eee&quot;, &quot;age&quot; : 22 }&gt;</code></pre><h3 id="null查询"><a href="#null查询" class="headerlink" title="null查询"></a>null查询</h3><p>会查询出没有这个<code>key</code>的记录，如果需要过滤掉这种文档，需要另外一个条件操作符<code>$exists</code>，指明这个键必须存在，如下如：此时<code>=null</code>的判断只能通过<code>{&quot;$in&quot;：[null]}</code>来实现了</p><pre><code>&gt; db.pers.find(){ &quot;_id&quot; : 1001, &quot;name&quot; : &quot;aaa&quot;, &quot;age&quot; : 9 }{ &quot;_id&quot; : 1003, &quot;name&quot; : &quot;ccc&quot;, &quot;age&quot; : 13 }{ &quot;_id&quot; : 1002, &quot;age&quot; : 12, &quot;name&quot; : &quot;bbb&quot;, &quot;sex&quot; : null }{ &quot;_id&quot; : 1004, &quot;age&quot; : 12, &quot;name&quot; : &quot;bbb&quot;, &quot;sex&quot; : &quot;M&quot; }{ &quot;_id&quot; : 1005, &quot;age&quot; : 12, &quot;name&quot; : &quot;bbb&quot;, &quot;sex&quot; : &quot;M&quot; }&gt;&gt; db.pers.find({sex: {$in: [null]}}){ &quot;_id&quot; : 1001, &quot;name&quot; : &quot;aaa&quot;, &quot;age&quot; : 9 }{ &quot;_id&quot; : 1003, &quot;name&quot; : &quot;ccc&quot;, &quot;age&quot; : 13 }{ &quot;_id&quot; : 1002, &quot;age&quot; : 12, &quot;name&quot; : &quot;bbb&quot;, &quot;sex&quot; : null }&gt;&gt; db.pers.find({sex:null}){ &quot;_id&quot; : 1001, &quot;name&quot; : &quot;aaa&quot;, &quot;age&quot; : 9 }{ &quot;_id&quot; : 1003, &quot;name&quot; : &quot;ccc&quot;, &quot;age&quot; : 13 }{ &quot;_id&quot; : 1002, &quot;age&quot; : 12, &quot;name&quot; : &quot;bbb&quot;, &quot;sex&quot; : null }&gt;&gt; db.pers.find({sex: {$in: [null], $exists: true}}){ &quot;_id&quot; : 1002, &quot;age&quot; : 12, &quot;name&quot; : &quot;bbb&quot;, &quot;sex&quot; : null }&gt;</code></pre><h3 id="正则查询"><a href="#正则查询" class="headerlink" title="正则查询"></a>正则查询</h3><p><code>Shell</code>中写正则表达式的方式和<code>JavaScript</code>的一致，写在一对<code>//</code>之间的就是正则表达式。查询<code>name</code>这个<code>key</code>对应的<code>value</code>中包含有字母<code>a</code>的文档，如下图</p><pre><code>&gt; db.pers.find({name: /a/i}){ &quot;_id&quot; : 1001, &quot;name&quot; : &quot;aaa&quot;, &quot;age&quot; : 9 }&gt;</code></pre><p><strong><code>MongoDB</code>支持正则表达式这种数据类型</strong>，对于这种键值对，正则表达式也可以匹配成功，如下图：还可以发现正则匹配不区分大小写。但注意正则表达式的匹配必须是完全匹配，即正则表达式的写法完全相同才可以匹配成功。<code>MongoDB</code>可以为前缀型的正则表达式<code>（/^abc/i）</code>查询使用索引，所以这种前缀型的正则表式查询速度会很快。</p><pre><code>&gt; db.preso.find(){ &quot;_id&quot; : 1001, &quot;age&quot; : 9, &quot;name&quot; : &quot;abc&quot; }{ &quot;_id&quot; : 1002, &quot;age&quot; : 10, &quot;name&quot; : &quot;aBc&quot; }{ &quot;_id&quot; : 1003, &quot;age&quot; : 10, &quot;name&quot; : /abc/i }&gt;&gt; db.preso.find({name:/abc/i}){ &quot;_id&quot; : 1001, &quot;age&quot; : 9, &quot;name&quot; : &quot;abc&quot; }{ &quot;_id&quot; : 1002, &quot;age&quot; : 10, &quot;name&quot; : &quot;aBc&quot; }{ &quot;_id&quot; : 1003, &quot;age&quot; : 10, &quot;name&quot; : /abc/i }&gt;</code></pre><h3 id="not：可以用到任何地方进行取反的操作"><a href="#not：可以用到任何地方进行取反的操作" class="headerlink" title="$not：可以用到任何地方进行取反的操作"></a>$not：可以用到任何地方进行取反的操作</h3><p>与<code>$nin</code>的区别就在于<code>$nin</code>只能用在数组上，如下图：</p><pre><code>&gt; db.pers.find({name:{$not: /a/i}}){ &quot;_id&quot; : 1003, &quot;name&quot; : &quot;ccc&quot;, &quot;age&quot; : 13 }{ &quot;_id&quot; : 1002, &quot;age&quot; : 12, &quot;name&quot; : &quot;bbb&quot;, &quot;sex&quot; : null }{ &quot;_id&quot; : 1004, &quot;age&quot; : 12, &quot;name&quot; : &quot;bbb&quot;, &quot;sex&quot; : &quot;M&quot; }{ &quot;_id&quot; : 1005, &quot;age&quot; : 12, &quot;name&quot; : &quot;bbb&quot;, &quot;sex&quot; : &quot;M&quot; }&gt;</code></pre><h3 id="mod"><a href="#mod" class="headerlink" title="$mod"></a>$mod</h3><p>使用格式为 <code>{&quot;键&quot;：{&quot;$mod&quot;：[num1, num2]}}</code>，查询<code>键</code>的值对<code>num1</code>取余，如果余等于<code>num2</code>，则整条文档符合条件，如下：</p><pre><code>&gt; db.preso.find(){ &quot;_id&quot; : 1001, &quot;age&quot; : 9, &quot;name&quot; : &quot;abc&quot; }{ &quot;_id&quot; : 1002, &quot;age&quot; : 10, &quot;name&quot; : &quot;aBc&quot; }{ &quot;_id&quot; : 1003, &quot;age&quot; : 10, &quot;name&quot; : /abc/i }&gt;&gt; db.preso.find({age:{$mod:[2,0]}}){ &quot;_id&quot; : 1002, &quot;age&quot; : 10, &quot;name&quot; : &quot;aBc&quot; }{ &quot;_id&quot; : 1003, &quot;age&quot; : 10, &quot;name&quot; : /abc/i }&gt;</code></pre><h3 id="查询指定key：第二个参数就是指定要查询的key"><a href="#查询指定key：第二个参数就是指定要查询的key" class="headerlink" title="查询指定key：第二个参数就是指定要查询的key"></a>查询指定key：第二个参数就是指定要查询的key</h3><p>想要查询出哪个<code>key</code>，就将其对应的<code>value</code>置为非<code>0</code>，默认情况下会将<code>_id</code>也查询出来，可以将其对应的<code>value</code>置为<code>0</code>，就不会查询出来了</p><pre><code>&gt; db.preso.find({},{age:1,age:0}){ &quot;_id&quot; : 1001, &quot;name&quot; : &quot;abc&quot; }{ &quot;_id&quot; : 1002, &quot;name&quot; : &quot;aBc&quot; }{ &quot;_id&quot; : 1003, &quot;name&quot; : /abc/i }&gt;&gt; db.preso.find({},{age:1,_id:0}){ &quot;age&quot; : 9 }{ &quot;age&quot; : 10 }{ &quot;age&quot; : 10 }</code></pre><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>考虑集合 <code>inventory</code> 包含如下文档：</p><pre><code>{ _id: 5, type: &quot;food&quot;, item: &quot;aaa&quot;, ratings: [ 5, 8, 9 ] }{ _id: 6, type: &quot;food&quot;, item: &quot;bbb&quot;, ratings: [ 5, 9 ] }{ _id: 7, type: &quot;food&quot;, item: &quot;ccc&quot;, ratings: [ 9, 5, 8 ] }</code></pre><h4 id="数组精确匹配"><a href="#数组精确匹配" class="headerlink" title="数组精确匹配"></a>数组精确匹配</h4><p>要指定数组相等匹配，使用查询文档 <code>{ &lt;field&gt;: &lt;value&gt; }</code> 其中 <code>&lt;value&gt;</code> 是匹配的数组。数组的相等匹配要求数组字段与指定的匹配数组 <code>&lt;value&gt;</code> 完全 相符，包括数组元素的顺序。</p><p>下面示例将筛选出 <code>ratings</code> 字段为数组，包含 <code>5， 8， 9</code> 三个元素并且元素顺序符合该<strong>顺序</strong>的所有文档：</p><pre><code>&gt; db.inventory.find( { ratings: [ 5, 8, 9 ] } ){ &quot;_id&quot; : 5, &quot;type&quot; : &quot;food&quot;, &quot;item&quot; : &quot;aaa&quot;, &quot;ratings&quot; : [ 5, 8, 9 ] }</code></pre><h4 id="匹配数组元素"><a href="#匹配数组元素" class="headerlink" title="匹配数组元素"></a>匹配数组元素</h4><p>相等匹配可以指定数组中单一元素进行匹配。这些相等匹配将匹配包含至少一个元素等于指定值的数组。</p><p>下面示例查询数组字段 <code>ratings</code> 中元素之一为 <code>5</code> 的所有文档。</p><pre><code>&gt; db.inventory.find( { ratings: 5 } ){ &quot;_id&quot; : 5, &quot;type&quot; : &quot;food&quot;, &quot;item&quot; : &quot;aaa&quot;, &quot;ratings&quot; : [ 5, 8, 9 ] }{ &quot;_id&quot; : 6, &quot;type&quot; : &quot;food&quot;, &quot;item&quot; : &quot;bbb&quot;, &quot;ratings&quot; : [ 5, 9 ] }{ &quot;_id&quot; : 7, &quot;type&quot; : &quot;food&quot;, &quot;item&quot; : &quot;ccc&quot;, &quot;ratings&quot; : [ 9, 5, 8 ] }</code></pre><h4 id="匹配数组中特定元素"><a href="#匹配数组中特定元素" class="headerlink" title="匹配数组中特定元素"></a>匹配数组中特定元素</h4><p>使用 <code>dot notation</code>（点符号） 可以在数组特定的索引或位置指定相等匹配的元素。</p><p>在下面示例中，查询使用 <code>dot notation</code> 匹配数组字段 ratings 的第一个元素为 5 的所有文档：</p><pre><code>&gt; db.inventory.find( { &#39;ratings.0&#39;: 5 } ){ &quot;_id&quot; : 5, &quot;type&quot; : &quot;food&quot;, &quot;item&quot; : &quot;aaa&quot;, &quot;ratings&quot; : [ 5, 8, 9 ] }{ &quot;_id&quot; : 6, &quot;type&quot; : &quot;food&quot;, &quot;item&quot; : &quot;bbb&quot;, &quot;ratings&quot; : [ 5, 9 ] }</code></pre><h4 id="为数组元素指定复合条件"><a href="#为数组元素指定复合条件" class="headerlink" title="为数组元素指定复合条件"></a>为数组元素指定复合条件</h4><h5 id="单元素满足条件"><a href="#单元素满足条件" class="headerlink" title="单元素满足条件"></a>单元素满足条件</h5><p>使用 <code>$elemMatch</code>操作符为数组元素指定<strong>复合条件</strong>，以查询数组中至少一个元素满足所有指定条件的文档。</p><p>下面示例查询 <code>ratings</code> 数组中至少一个元素大于 <code>($gt) 5</code> 且小于 <code>($lt) 9</code> 的文档：</p><pre><code>&gt; db.inventory.find( { ratings: { $elemMatch: { $gt: 5, $lt: 9 } } } ){ &quot;_id&quot; : 5, &quot;type&quot; : &quot;food&quot;, &quot;item&quot; : &quot;aaa&quot;, &quot;ratings&quot; : [ 5, 8, 9 ] }{ &quot;_id&quot; : 7, &quot;type&quot; : &quot;food&quot;, &quot;item&quot; : &quot;ccc&quot;, &quot;ratings&quot; : [ 9, 5, 8 ] }</code></pre><h5 id="满足条件的元素组合"><a href="#满足条件的元素组合" class="headerlink" title="满足条件的元素组合"></a>满足条件的元素组合</h5><p>下面示例将查询 <code>ratings</code> 中包含某些元素组合满足查询条件的文档；比如，一个元素满足大于 <code>5</code> 的条件，另外元素满足小于 <code>9</code> 的条件，或一个元素同时满足两个条件；</p><pre><code>&gt; db.inventory.find( { ratings: { $gt: 5, $lt: 9 } } ){ &quot;_id&quot; : 5, &quot;type&quot; : &quot;food&quot;, &quot;item&quot; : &quot;aaa&quot;, &quot;ratings&quot; : [ 5, 8, 9 ] }{ &quot;_id&quot; : 6, &quot;type&quot; : &quot;food&quot;, &quot;item&quot; : &quot;bbb&quot;, &quot;ratings&quot; : [ 5, 9 ] }{ &quot;_id&quot; : 7, &quot;type&quot; : &quot;food&quot;, &quot;item&quot; : &quot;ccc&quot;, &quot;ratings&quot; : [ 9, 5, 8 ] }</code></pre><h4 id="给文档数组指定复合条件"><a href="#给文档数组指定复合条件" class="headerlink" title="给文档数组指定复合条件"></a>给文档数组指定复合条件</h4><h5 id="单元素满足条件-1"><a href="#单元素满足条件-1" class="headerlink" title="单元素满足条件"></a>单元素满足条件</h5><p>使用 <code>$elemMatch</code>操作符为内嵌文档数组指定复合条件，以查询数组中只是一个内嵌文档满足所有指定添加的文档。</p><p>下面示例查询 <code>memos</code> 数组中至少有一个内嵌文档同时包含 <code>memo</code> 和 <code>by</code> 字段并且值分别为 <code>&#39;on time&#39;</code> 与 <code>&#39;shipping&#39;</code> 的所有文档：</p><pre><code>&gt; db.inventory.find( { memos : { $elemMatch : { memo: &#39;on time&#39;, by: &#39;shipping&#39;} } } ){   _id: 100,   type: &quot;food&quot;,   item: &quot;xyz&quot;,   qty: 25,   price: 2.5,   ratings: [ 5, 8, 9 ],   memos: [ { memo: &quot;on time&quot;, by: &quot;shipping&quot; }, { memo: &quot;approved&quot;, by: &quot;billing&quot; } ]}</code></pre><h5 id="满足条件的元素组合-1"><a href="#满足条件的元素组合-1" class="headerlink" title="满足条件的元素组合"></a>满足条件的元素组合</h5><p>下面示例查询 <code>memos</code> 数组中包含某些元素组合满足查询条件的文档：例如，其中一个元素满足字段 <code>memo</code> 值等于 <code>&#39;on time&#39;</code> 条件，另外一个元素满足字段 <code>by</code> 值等于 <code>&#39;shipping&#39;</code> ，或一个元素同时满足两个条件：</p><pre><code>&gt; db.inventory.find( { &#39;memos.memo&#39;: &#39;on time&#39;, &#39;memos.by&#39;: &#39;shipping&#39; } ){  _id: 100,  type: &quot;food&quot;,  item: &quot;xyz&quot;,  qty: 25,  price: 2.5,  ratings: [ 5, 8, 9 ],  memos: [ { memo: &quot;on time&quot;, by: &quot;shipping&quot; }, { memo: &quot;approved&quot;, by: &quot;billing&quot; } ]}{  _id: 101,  type: &quot;fruit&quot;,  item: &quot;jkl&quot;,  qty: 10,  price: 4.25,  ratings: [ 5, 9 ],  memos: [ { memo: &quot;on time&quot;, by: &quot;payment&quot; }, { memo: &quot;delayed&quot;, by: &quot;shipping&quot; } ]}</code></pre><br><div class="bdsharebuttonbox" style="float:right"><a href="#" class="bds_more" data-cmd="more"></a><a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a><a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a><a href="#" class="bds_tqq" data-cmd="tqq" title="分享到腾讯微博"></a><a href="#" class="bds_renren" data-cmd="renren" title="分享到人人网"></a><a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a></div><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>]]></content>
      
      
      <categories>
          
          <category> MongoDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB学习笔记08-MongoDB在Shell中执行删除</title>
      <link href="/2017/07/17/MongoDB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B008-MongoDB%E5%9C%A8Shell%E4%B8%AD%E6%89%A7%E8%A1%8C%E5%88%A0%E9%99%A4/"/>
      <url>/2017/07/17/MongoDB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B008-MongoDB%E5%9C%A8Shell%E4%B8%AD%E6%89%A7%E8%A1%8C%E5%88%A0%E9%99%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h2><p>参数说明：</p><ul><li><strong>query</strong> :（可选）删除的文档的条件。</li><li><strong>justOne</strong> : （可选）如果设为 true 或 1，则只删除一个文档。</li><li><strong>writeConcern</strong> :（可选）抛出异常的级别。<a id="more"></a></li></ul><ol><li>删除集合中所有文档：<code>db.集合名.remove({})</code>，集合本身和索引不会被删除。</li><li>根据条件删除：db.集合名.remove({...})。<pre><code>&gt; db.person.find(){ &quot;_id&quot; : 1002, &quot;name&quot; : &quot;wang&quot;, &quot;age&quot; : 30 }{ &quot;_id&quot; : 1001, &quot;name&quot; : &quot;zhang&quot;, &quot;age&quot; : 20 }{ &quot;_id&quot; : 1003, &quot;name&quot; : &quot;zhang&quot;, &quot;age&quot; : 20 }&gt;&gt; db.person.remove({&quot;age&quot;:20})WriteResult({ &quot;nRemoved&quot; : 2 })&gt; db.person.find(){ &quot;_id&quot; : 1002, &quot;name&quot; : &quot;wang&quot;, &quot;age&quot; : 30 }&gt;</code></pre></li><li><code>justOne</code> : （可选）如果设为 <code>true</code> 或 <code>1</code>，则只删除一个文档。<pre><code>&gt; db.person.find(){ &quot;_id&quot; : 1002, &quot;name&quot; : &quot;wang&quot;, &quot;age&quot; : 30 }{ &quot;_id&quot; : 1001, &quot;name&quot; : &quot;zhang&quot;, &quot;age&quot; : 20 }{ &quot;_id&quot; : 1003, &quot;name&quot; : &quot;zhang&quot;, &quot;age&quot; : 20 }&gt;&gt; db.person.remove({&quot;age&quot;:20},1)WriteResult({ &quot;nRemoved&quot; : 1 })&gt; db.person.find(){ &quot;_id&quot; : 1002, &quot;name&quot; : &quot;wang&quot;, &quot;age&quot; : 30 }{ &quot;_id&quot; : 1003, &quot;name&quot; : &quot;zhang&quot;, &quot;age&quot; : 20 }&gt;</code></pre></li></ol><h2 id="删除集合"><a href="#删除集合" class="headerlink" title="删除集合"></a>删除集合</h2><p>使用<code>drop()</code>删除集合<br>如果你想删除整个<code>userdetails</code>集合，包含所有文档数据，可以执行以下数据：</p><pre><code>&gt;db.userdetails.drop()</code></pre><h2 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h2><p>使用<code>dropDatabase()</code>函数删除数据库<br>如果你想删除整个数据库的数据，你可以执行以下命令：</p><pre><code>&gt;db.dropDatabase()</code></pre><p>执行命令前查看当前使用的数据库是一个良好的习惯，这样可以确保你要删除数据库是正确的，以免造成误操作而产生数据丢失的后果：</p><pre><code>&gt;dbtest&gt;</code></pre><br>]]></content>
      
      
      <categories>
          
          <category> MongoDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB学习笔记07-MongoDB在Shell中执行更新</title>
      <link href="/2017/07/17/MongoDB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B007-MongoDB%E5%9C%A8Shell%E4%B8%AD%E6%89%A7%E8%A1%8C%E6%9B%B4%E6%96%B0/"/>
      <url>/2017/07/17/MongoDB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B007-MongoDB%E5%9C%A8Shell%E4%B8%AD%E6%89%A7%E8%A1%8C%E6%9B%B4%E6%96%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="update-参数"><a href="#update-参数" class="headerlink" title="update()参数"></a>update()参数</h3><p><strong><code>update()</code></strong>函数接受以下四个参数：</p><ul><li><strong>criteria</strong> : <code>update</code>的查询条件，类似<code>sql update</code>查询内<code>where</code>后面的。</li><li><strong>objNew</strong> : <code>update</code>的对象和一些更新的操作符（如<code>$</code>,<code>$inc</code>...）等，也可以理解为<code>sql update</code>查询内<code>set</code>后面的</li><li><strong>upsert</strong> : 这个参数的意思是，如果不存在<code>update</code>的记录，是否插入<code>objNew</code>,<code>true</code>为插入，默认是<code>false</code>，不插入。</li><li><strong>multi</strong> : <code>mongodb</code>默认是<code>false</code>,只更新找到的第一条记录，如果这个参数为<code>true</code>,就把按条件查出来多条记录全部更新。</li></ul><a id="more"></a><h3 id="强硬的文档替换式更新"><a href="#强硬的文档替换式更新" class="headerlink" title="强硬的文档替换式更新"></a>强硬的文档替换式更新</h3><p>此种更新操作类似于把之前的老文档删除，然后替换为更新的文档，也就是用新文档替换老文档，如下图：原文档中根本不存在<code>age</code>这个<code>key</code>，但是执行替换式更新后，不管老文档存在哪些<code>key</code>，更新最后都仅仅只会存在新的文档中的那些<code>key</code>（原文档的<code>_id</code>还会存在）。</p><pre><code>&gt; db.person.find(){ &quot;_id&quot; : ObjectId(&quot;556c0b48361be67b8f01af2c&quot;), &quot;name&quot; : &quot;zhang&quot; }&gt; db.person.find().pretty()  # 用格式化方式显示结果{    &quot;_id&quot; : ObjectId(&quot;556c0b48361be67b8f01af2c&quot;),    &quot;name&quot; : &quot;zhang&quot;,}&gt; db.person.update({name:&quot;zhang&quot;},{age:4})WriteResult({ &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 })&gt; db.person.find(){ &quot;_id&quot; : ObjectId(&quot;556c0b48361be67b8f01af2c&quot;), &quot;age&quot; : 4 }&gt;</code></pre><p>这个时候如果是真的只需要更新<code>name</code>键的值，可以使用如下的方式：但是这种方式要注意一个问题，就是变量p必须通过<strong><code>findOne()</code></strong>去获得，如果通过<code>find()</code>方法获得，则后面的<code>update</code>方法会报错；而且因为<code>findOne</code>方法仅会返回查询文档匹配的一条集合文档，使用这种方式做<code>update</code>时，此处<code>update</code>满足更新条件的文档可能不止一条，那么更新就会失败，因为会出现集合中<code>_id</code>键值重复的现象。</p><pre><code>&gt; db.person.find(){ &quot;_id&quot; : ObjectId(&quot;556c0b48361be67b8f01af2c&quot;), &quot;age&quot; : 4 }&gt;&gt; var p = db.person.findOne()&gt; p.age = 14;14&gt; db.person.update({&quot;_id&quot; : ObjectId(&quot;556c0b48361be67b8f01af2c&quot;)},p)&gt;&gt; db.person.find(){ &quot;_id&quot; : ObjectId(&quot;556c0b48361be67b8f01af2c&quot;), &quot;age&quot; : 14 }&gt;</code></pre><p><strong>不可以更新<code>_id</code>这个<code>key</code>的值，而不管更新后的<code>_id</code>值是否已经存在</strong></p><h3 id="使用修改器进行局部更新"><a href="#使用修改器进行局部更新" class="headerlink" title="使用修改器进行局部更新"></a>使用修改器进行局部更新</h3><h4 id="set修改器"><a href="#set修改器" class="headerlink" title="$set修改器"></a>$set修改器</h4><p><code>{$set:{key:value}}</code>，如果满足更新条件的文档中存在<code>$set</code>修改器中的<code>key</code>时，则进行更新，否则进行添加</p><pre><code>&gt; db.person.find(){ &quot;_id&quot; : 1001, &quot;name&quot; : &quot;eee&quot; }{ &quot;_id&quot; : 1002, &quot;name&quot; : &quot;eee&quot; }&gt;&gt; db.person.update({name:&quot;eee&quot;},{$set:{name:&quot;aaa&quot;,age:23}})&gt; db.person.find(){ &quot;_id&quot; : 1001, &quot;name&quot; : &quot;aaa&quot;, &quot;age&quot; : 23 }{ &quot;_id&quot; : 1002, &quot;name&quot; : &quot;eee&quot; }  # 要修改多条相同的文档，则需要设置 multi 参数为 true&gt; db.person.update({name:&quot;aaa&quot;},{$set:{name:&quot;aaa1&quot;,age:23}},{multi:true})</code></pre><h4 id="inc修改器"><a href="#inc修改器" class="headerlink" title="$inc修改器"></a>$inc修改器</h4><p><code>{$inc:{key:value}}</code>，仅适用于数字类型，可以为指定的<code>key</code>对应的数字类型的值进行加减操作，如下：</p><pre><code>&gt; db.person.find(){ &quot;_id&quot; : 1001, &quot;name&quot; : &quot;aaa&quot;, &quot;age&quot; : 23 }{ &quot;_id&quot; : 1002, &quot;name&quot; : &quot;eee&quot; }&gt;&gt; db.person.update({name:&quot;aaa&quot;},{$inc:{age:2}})WriteResult({ &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 })&gt; db.person.find(){ &quot;_id&quot; : 1001, &quot;name&quot; : &quot;aaa&quot;, &quot;age&quot; : 25 }{ &quot;_id&quot; : 1002, &quot;name&quot; : &quot;eee&quot; }&gt;&gt; db.person.update({name:&quot;aaa&quot;},{$inc:{age:-2}})WriteResult({ &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 })&gt; db.person.find(){ &quot;_id&quot; : 1001, &quot;name&quot; : &quot;aaa&quot;, &quot;age&quot; : 23 }{ &quot;_id&quot; : 1002, &quot;name&quot; : &quot;eee&quot; }&gt;</code></pre><h4 id="unset修改器"><a href="#unset修改器" class="headerlink" title="$unset修改器"></a>$unset修改器</h4><p><code>{$unset:{key:value}}</code>，删除指定的<code>key</code>，如下：</p><pre><code>&gt; db.person.find(){ &quot;_id&quot; : 1001, &quot;name&quot; : &quot;aaa&quot;, &quot;age&quot; : 23 }{ &quot;_id&quot; : 1002, &quot;name&quot; : &quot;eee&quot; }&gt;&gt; db.person.update({name:&quot;aaa&quot;},{$unset:{age:23}})&gt; db.person.find(){ &quot;_id&quot; : 1001, &quot;name&quot; : &quot;aaa&quot; }{ &quot;_id&quot; : 1002, &quot;name&quot; : &quot;eee&quot; }&gt;</code></pre><h4 id="push修改器"><a href="#push修改器" class="headerlink" title="$push修改器"></a>$push修改器</h4><p><code>{$push:{key:value}}</code>，如果指定的<strong><code>key</code>是数组</strong>，则往该数组中追加新的元素；如果指定的<code>key</code>不是数组，则中断操作；如果不存在指定的<code>key</code>，则创建，且类型为数组类型，并加入新的元素（可重复）；如下：</p><pre><code>&gt; db.person.find(){ &quot;_id&quot; : 1001, &quot;name&quot; : &quot;aaa&quot; }{ &quot;_id&quot; : 1002, &quot;name&quot; : &quot;eee&quot; }&gt;&gt; db.person.update({name:&quot;aaa&quot;},{$push:{name:&quot;java&quot;}})WriteResult({        &quot;nMatched&quot; : 0,        &quot;nUpserted&quot; : 0,        &quot;nModified&quot; : 0,        &quot;writeError&quot; : {                &quot;code&quot; : 16837,                &quot;errmsg&quot; : &quot;The field &#39;name&#39; must be an array but is of type String in document {_id: 1001.0}&quot;        }})&gt; db.person.update({name:&quot;aaa&quot;},{$push:{books:&quot;java&quot;}})WriteResult({ &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 })&gt; db.person.find(){ &quot;_id&quot; : 1002, &quot;name&quot; : &quot;eee&quot; }{ &quot;_id&quot; : 1001, &quot;name&quot; : &quot;aaa&quot;, &quot;books&quot; : [ &quot;java&quot; ] }&gt; db.person.update({name:&quot;aaa&quot;},{$push:{books:&quot;MongoDB&quot;}})WriteResult({ &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 })&gt; db.person.find(){ &quot;_id&quot; : 1002, &quot;name&quot; : &quot;eee&quot; }{ &quot;_id&quot; : 1001, &quot;name&quot; : &quot;aaa&quot;, &quot;books&quot; : [ &quot;java&quot;, &quot;MongoDB&quot; ] }&gt;</code></pre><h4 id="pushAll修改器"><a href="#pushAll修改器" class="headerlink" title="$pushAll修改器"></a>$pushAll修改器</h4><p><code>{$pushAll:{key:value}}</code>，与<code>$push</code>一样，只是它可以一次性批量加入一个数组中的所有元素，如下图：</p><pre><code>&gt; db.person.find(){ &quot;_id&quot; : 1002, &quot;name&quot; : &quot;eee&quot; }{ &quot;_id&quot; : 1001, &quot;name&quot; : &quot;aaa&quot;, &quot;books&quot; : [ &quot;java&quot;, &quot;MongoDB&quot; ] }&gt;&gt; db.person.update({name:&quot;aaa&quot;},{$pushAll:{books:[&quot;JavaEE&quot;,&quot;JSP&quot;]}})&gt; db.person.find(){ &quot;_id&quot; : 1002, &quot;name&quot; : &quot;eee&quot; }{ &quot;_id&quot; : 1001, &quot;name&quot; : &quot;aaa&quot;, &quot;books&quot; : [ &quot;java&quot;, &quot;MongoDB&quot;, &quot;JavaEE&quot;, &quot;JSP&quot; ] }&gt;</code></pre><h4 id="addToSet修改器"><a href="#addToSet修改器" class="headerlink" title="$addToSet修改器"></a>$addToSet修改器</h4><p><code>{$addToSet:{key:value}}</code>，与<code>$push</code>一样，只是当目标数组不存在该元素时才加入，如下图：</p><pre><code>&gt; db.person.find(){ &quot;_id&quot; : 1002, &quot;name&quot; : &quot;eee&quot; }&gt; db.person.update({name:&quot;eee&quot;},{$addToSet:{name:&quot;java&quot;}})WriteResult({        &quot;nMatched&quot; : 0,        &quot;nUpserted&quot; : 0,        &quot;nModified&quot; : 0,        &quot;writeError&quot; : {                &quot;code&quot; : 16837,                &quot;errmsg&quot; : &quot;Cannot apply $addToSet to a non-array field. Field named &#39;name&#39; has a non-array type String in the document _id: 1002.0&quot;        }})&gt;  db.person.update({name:&quot;eee&quot;},{$addToSet:{books:&quot;Java&quot;}})WriteResult({ &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 })&gt; db.person.find(){ &quot;_id&quot; : 1002, &quot;name&quot; : &quot;eee&quot;, &quot;books&quot; : [ &quot;Java&quot; ] }&gt;&gt; db.person.update({name:&quot;eee&quot;},{$addToSet:{books:&quot;Java&quot;}})WriteResult({ &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 0 })&gt; db.person.find(){ &quot;_id&quot; : 1002, &quot;name&quot; : &quot;eee&quot;, &quot;books&quot; : [ &quot;Java&quot; ] }&gt;</code></pre><h4 id="pop修改器"><a href="#pop修改器" class="headerlink" title="$pop修改器"></a>$pop修改器</h4><p><code>{$pop:{key:value}}</code>，从指定数组的头或尾<strong>删除</strong>一个元素，从头删除一个元素用小于 0 的值，从尾删除一个元素用大于 0 的值，如下图：</p><pre><code>&gt; db.person.find(){ &quot;_id&quot; : 1001, &quot;name&quot; : &quot;aaa&quot;, &quot;books&quot; : [ &quot;java&quot;, &quot;MongoDB&quot;, &quot;JavaEE&quot;, &quot;JSP&quot;,&quot;Spring&quot; ] }&gt;&gt; db.person.update({_id:1001},{$pop:{books:-1}})&gt; db.person.find(){ &quot;_id&quot; : 1001, &quot;name&quot; : &quot;aaa&quot;, &quot;books&quot; : [ &quot;MongoDB&quot;, &quot;JavaEE&quot;, &quot;JSP&quot;, &quot;Spring] }&gt;&gt; db.person.update({_id:1001},{$pop:{books:-2}})&gt; db.person.find(){ &quot;_id&quot; : 1001, &quot;name&quot; : &quot;aaa&quot;, &quot;books&quot; : [ &quot;JavaEE&quot;, &quot;JSP&quot;, &quot;Spring&quot; ] }&gt;&gt; db.person.update({_id:1001},{$pop:{books:1}})&gt; db.person.find(){ &quot;_id&quot; : 1001, &quot;name&quot; : &quot;aaa&quot;, &quot;books&quot; : [ &quot;JavaEE&quot;, &quot;JSP&quot; ] }&gt;&gt; db.person.update({_id:1001},{$pop:{books:2}})&gt; db.person.find(){ &quot;_id&quot; : 1001, &quot;name&quot; : &quot;aaa&quot;, &quot;books&quot; : [ &quot;JavaEE&quot; ] }&gt;</code></pre><h4 id="pull修改器"><a href="#pull修改器" class="headerlink" title="$pull修改器"></a>$pull修改器</h4><p><code>{$pull:{key:value}}</code>，从指定数组中删除一个被指定的值，如下：</p><pre><code>&gt; db.person.find(){ &quot;_id&quot; : 1001, &quot;name&quot; : &quot;aaa&quot;, &quot;books&quot; : [ &quot;JavaEE&quot; ] }&gt; db.person.update({_id:1001},{$pull:{books:&quot;JavaEE&quot;}})&gt; db.person.find(){ &quot;_id&quot; : 1001, &quot;name&quot; : &quot;aaa&quot;, &quot;books&quot; : [ ] }&gt;</code></pre><h4 id="pullAll修改器"><a href="#pullAll修改器" class="headerlink" title="$pullAll修改器"></a>$pullAll修改器</h4><p><code>{$pullAll:{key:value}}</code>，从指定数组中一次性删除多个被指定的值，如下：</p><pre><code>&gt; db.person.find(){ &quot;_id&quot; : 1002, &quot;name&quot; : &quot;eee&quot;, &quot;books&quot; : [ &quot;Java&quot;, &quot;JavaEE&quot; ] }&gt;&gt; db.person.update({_id:1002},{$pullAll:{books:[&quot;JavaEE&quot;,&quot;Java&quot;]}})&gt; db.person.find(){ &quot;_id&quot; : 1002, &quot;name&quot; : &quot;eee&quot;, &quot;books&quot; : [ ] }&gt;</code></pre><h4 id="数组定位器"><a href="#数组定位器" class="headerlink" title="数组定位器$"></a>数组定位器<code>$</code></h4><p>如果数组中有多个元素，需要对其中一部分进行更新，则可以使用定位器<code>$</code>。注意：当使用了<code>books.price</code>这种方式时，一定要加上引号，不然会报错。</p><pre><code>&gt; db.person.find(){ &quot;_id&quot; : 1002, &quot;books&quot; : [ { &quot;name&quot; : &quot;JSP&quot;, &quot;price&quot; : 23.5 },            { &quot;name&quot; : &quot;JAVA&quot;, &quot;price&quot; : 45.5 },            { &quot;name&quot; : &quot;Spring&quot;, &quot;price&quot; : 45.5 } ] }&gt;&gt; db.person.update({&quot;books.price&quot;:45.5},{$set:{&quot;books.$.author&quot;:&quot;abc&quot;}})&gt; db.person.find(){ &quot;_id&quot; : 1002, &quot;books&quot; : [ { &quot;name&quot; : &quot;JSP&quot;, &quot;price&quot; : 23.5 },            { &quot;name&quot; : &quot;JAVA&quot;, &quot;price&quot; : 45.5, &quot;author&quot; : &quot;abc&quot; },            { &quot;name&quot; : &quot;Spring&quot;, &quot;price&quot; : 45.5 } ] }&gt;</code></pre><p>如果是知道数组元素索引，还可以通过索引的方式，比如把上面的<code>books.$.author</code>改为：<code>books.0.author</code>。这样更新的指定数组角标位置下的元素，即：</p><pre><code>&gt; db.person.update({&quot;books.price&quot;:45.5},{$set:{&quot;books.0.author&quot;:&quot;abc&quot;}})&gt; db.person.find(){ &quot;_id&quot; : 1002, &quot;books&quot; : [ { &quot;name&quot; : &quot;JSP&quot;, &quot;price&quot; : 23.5, &quot;author&quot; : &quot;abc&quot; },            { &quot;name&quot; : &quot;JAVA&quot;, &quot;price&quot; : 45.5 },            { &quot;name&quot; : &quot;Spring&quot;, &quot;price&quot; : 45.5 } ] }</code></pre><h4 id="addToSet与-each结合完成批量数组更新"><a href="#addToSet与-each结合完成批量数组更新" class="headerlink" title="$addToSet与$each结合完成批量数组更新"></a><code>$addToSet</code>与<code>$each</code>结合完成批量数组更新</h4><p>如下：<code>$each</code>会循环后面的数组，把每个元素值进行<code>$addToSet</code>操作。</p><pre><code>&gt; db.person.find(){ &quot;_id&quot; : 1001, &quot;name&quot; : &quot;aaa&quot;, &quot;books&quot; : [ &quot;Java&quot; ] }&gt;&gt; db.person.update({_id:1001},{$addToSet:{books:{$each:[&quot;Java&quot;,&quot;JSP&quot;]}}})&gt; db.person.find(){ &quot;_id&quot; : 1001, &quot;name&quot; : &quot;aaa&quot;, &quot;books&quot; : [ &quot;Java&quot;, &quot;JSP&quot; ] }&gt;</code></pre><h4 id="push与-inc结合使用"><a href="#push与-inc结合使用" class="headerlink" title="$push与$inc结合使用"></a><code>$push</code>与<code>$inc</code>结合使用</h4><p>比如要往文档的books这个key（数组）中加入一个元素，同时该文档的books_size这个key的大小加1，如下图：这个方式和修改器<code>$addToSet</code>没法配合使用，因为无法判断这个元素是否添加到了数组中</p><pre><code>&gt; db.person.find(){ &quot;_id&quot; : 1002, &quot;books&quot; : [ &quot;Java&quot;, &quot;MongoDB&quot; ], &quot;books_size&quot; : 2, &quot;name&quot; : &quot;aaa&quot; }&gt;&gt; db.person.update({_id:1002},{$push:{books: &quot;JSP&quot;}, $inc:{books_size:1}})&gt; db.person.find(){ &quot;_id&quot; : 1002, &quot;books&quot; : [ &quot;Java&quot;, &quot;MongoDB&quot;, &quot;JSP&quot; ], &quot;books_size&quot; : 3, &quot;name&quot;: &quot;aaa&quot; }&gt;</code></pre><h3 id="3-2版本新增方法"><a href="#3-2版本新增方法" class="headerlink" title="3.2版本新增方法"></a>3.2版本新增方法</h3><p>详情见<a href="https://docs.mongodb.com/manual/reference/update-methods/" target="_blank" rel="noopener">官方文档</a><br><a href="https://docs.mongodb.com/manual/reference/method/db.collection.updateOne/#db.collection.updateOne" target="_blank" rel="noopener">db.collection.updateOne()</a><br><a href="https://docs.mongodb.com/manual/reference/method/db.collection.updateMany/#db.collection.updateMany" target="_blank" rel="noopener">db.collection.updateMany()</a><br><a href="https://docs.mongodb.com/manual/reference/method/db.collection.replaceOne/#db.collection.replaceOne" target="_blank" rel="noopener">db.collection.replaceOne()</a></p><h3 id="save-方法"><a href="#save-方法" class="headerlink" title="save() 方法"></a>save() 方法</h3><p><code>save()</code> 方法通过传入的文档来替换已有文档。如果未传入<code>_id</code>值或<code>_id</code>值未找到则新增文档。</p><pre><code>&gt; db.person.save({&quot;_id&quot;: 1002,name:&quot;aaaaaa&quot;,age:24})WriteResult({ &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 })&gt; db.person.find().pretty(){ &quot;_id&quot; : 1002, &quot;name&quot; : &quot;aaaaaa&quot;, &quot;age&quot; : 24 }</code></pre><br>]]></content>
      
      
      <categories>
          
          <category> MongoDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB学习笔记06-MongoDB在Shell中执行增</title>
      <link href="/2017/07/17/MongoDB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B006-MongoDB%E5%9C%A8Shell%E4%B8%AD%E6%89%A7%E8%A1%8C%E5%A2%9E/"/>
      <url>/2017/07/17/MongoDB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B006-MongoDB%E5%9C%A8Shell%E4%B8%AD%E6%89%A7%E8%A1%8C%E5%A2%9E/</url>
      
        <content type="html"><![CDATA[<h3 id="添加集合并插入一个文档"><a href="#添加集合并插入一个文档" class="headerlink" title="添加集合并插入一个文档"></a>添加集合并插入一个文档</h3><p><code>db.集合名.insert({...})</code></p><pre><code>&gt; db.person.insert({&quot;name&quot;:&quot;zhang&quot;,&quot;age&quot;:15})WriteResult({ &quot;nInserted&quot; : 1 })&gt;</code></pre><a id="more"></a><p>注意：<code>MongoDB</code>会自动为该文档加入一个<code>_id</code>的key，但是如果要插入的文档中已经包含了<code>_id</code>的<code>key</code>，则不会再自动添加了</p><p>以上执行<code>insert</code>时候传入的是一个对象，那么传入的是一个<code>对象数组</code>呢？如下图：如果插入时传入的是一个对象数组，那么会为该对象数组中的每一个对象插入一个文档。</p><pre><code>&gt; db.person.insert([{&quot;name&quot;:&quot;zhang&quot;,&quot;age&quot;:15},{&quot;name&quot;:&quot;wang&quot;,&quot;age&quot;:22}])BulkWriteResult({        &quot;writeErrors&quot; : [ ],        &quot;writeConcernErrors&quot; : [ ],        &quot;nInserted&quot; : 2,        &quot;nUpserted&quot; : 0,        &quot;nMatched&quot; : 0,        &quot;nModified&quot; : 0,        &quot;nRemoved&quot; : 0,        &quot;upserted&quot; : [ ]})&gt; db.person.find(){ &quot;_id&quot; : ObjectId(&quot;556bf3da361be67b8f01af25&quot;), &quot;name&quot; : &quot;zhang&quot;, &quot;age&quot; : 15 }{ &quot;_id&quot; : ObjectId(&quot;556bf3da361be67b8f01af26&quot;), &quot;name&quot; : &quot;wang&quot;, &quot;age&quot; : 22 }&gt;</code></pre><p>如果采用<code>save</code>方法遇到已经存在的<code>_id</code>，则不会报错，它其实是把已经存在的<code>_id</code>的那个文档进行更新；当然，如果要插入的文档的<code>_id</code>值还不存在，则插入新文档</p><pre><code>&gt; db.person.find(){ &quot;_id&quot; : 1002, &quot;name&quot; : &quot;zhang&quot;, &quot;age&quot; : 15 }&gt; db.person.save({&quot;_id&quot;:1002,&quot;name&quot;:&quot;wang&quot;,&quot;age&quot;:30})WriteResult({ &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 })&gt; db.person.find(){ &quot;_id&quot; : 1002, &quot;name&quot; : &quot;wang&quot;, &quot;age&quot; : 30 }&gt;</code></pre><h3 id="插入文档数组"><a href="#插入文档数组" class="headerlink" title="插入文档数组"></a>插入文档数组</h3><p>定义变量 <code>mydocuments</code> 用于保存待插入的文档数组。</p><pre><code>&gt; var mydocuments =     [       {         item: &quot;ABC2&quot;,         details: { model: &quot;14Q3&quot;, manufacturer: &quot;M1 Corporation&quot;},         stock: [ { size: &quot;M&quot;, qty: 50 } ],         category: &quot;clothing&quot;       },       {         item: &quot;MNO2&quot;,         details: { model: &quot;14Q3&quot;, manufacturer: &quot;ABC Company&quot; },         stock: [ { size: &quot;S&quot;, qty: 5 }, { size: &quot;M&quot;, qty: 5 }, { size: &quot;L&quot;,qty: 1 } ],         category: &quot;clothing&quot;       },       {         item: &quot;IJK2&quot;,         details: { model: &quot;14Q2&quot;, manufacturer: &quot;M5 Corporation&quot;},         stock: [ { size: &quot;S&quot;, qty: 5 }, { size: &quot;L&quot;, qty: 1 } ],         category: &quot;houseware&quot;       }     ];</code></pre><p>传递数组 <code>mydocuments</code> 到方法 <code>db.collection.insert()</code> 执行批量插入。</p><pre><code>db.inventory.insert( mydocuments );</code></pre><p>该方法返回包含操作状态的 <code>BulkWriteResult</code> 对象。若插入成功将返回如下对象：</p><pre><code>BulkWriteResult({   &quot;writeErrors&quot; : [ ],   &quot;writeConcernErrors&quot; : [ ],   &quot;nInserted&quot; : 3,   &quot;nUpserted&quot; : 0,   &quot;nMatched&quot; : 0,   &quot;nModified&quot; : 0,   &quot;nRemoved&quot; : 0,   &quot;upserted&quot; : [ ]})</code></pre><h3 id="用-Bulk-插入多个文档"><a href="#用-Bulk-插入多个文档" class="headerlink" title="用 Bulk 插入多个文档"></a>用 Bulk 插入多个文档</h3><p>3.2 版本提供了<a href="https://docs.mongodb.com/manual/reference/method/db.collection.bulkWrite/#db.collection.bulkWrite" target="_blank" rel="noopener">db.collection.bulkWrite</a> 进行批量操作<br><strong>2.6 新版功能</strong><br>MongoDB提供一个用于执行批量写入的 <code>Bulk()</code> API。以下操作步骤描述了如何使用 <code>Bulk()</code> API向<code>MongoDB</code>集合中插入一组文档。</p><h4 id="初始化一个操作构建器-Bulk"><a href="#初始化一个操作构建器-Bulk" class="headerlink" title="初始化一个操作构建器 Bulk"></a>初始化一个操作构建器 Bulk</h4><p>给集合 <code>inventory</code> 初始化一个操作构建器 <code>Bulk</code>。</p><pre><code>var bulk = db.inventory.initializeUnorderedBulkOp();</code></pre><p>该操作返回一个无序的操作构建器，维护了所有待执行的操作列表。无序操作意味着<code>MongoDB</code>能够以平行方式执行，也可以用非确定性顺序的方式执行列表中的操作。如果当执行其中一个写操作时出现错误，<code>MongoDB</code>将继续执行列表中其他剩余的写操作。<br>你也可初始化一个有序的操作构建器；详见 <a href="https://docs.mongodb.com/manual/reference/method/db.collection.initializeOrderedBulkOp/" target="_blank" rel="noopener">db.collection.initializeOrderedBulkOp()</a>。</p><h4 id="向-bulk-对象中添加插入操作"><a href="#向-bulk-对象中添加插入操作" class="headerlink" title="向 bulk 对象中添加插入操作"></a>向 bulk 对象中添加插入操作</h4><p>使用 <code>Bulk.insert()</code> 方法向 <code>bulk</code> 对象中添加两个插入操作。</p><pre><code>bulk.insert(   {     item: &quot;BE10&quot;,     details: { model: &quot;14Q2&quot;, manufacturer: &quot;XYZ Company&quot; },     stock: [ { size: &quot;L&quot;, qty: 5 } ],     category: &quot;clothing&quot;   });bulk.insert(   {     item: &quot;ZYT1&quot;,     details: { model: &quot;14Q1&quot;, manufacturer: &quot;ABC Company&quot;  },     stock: [ { size: &quot;S&quot;, qty: 5 }, { size: &quot;M&quot;, qty: 5 } ],     category: &quot;houseware&quot;   });</code></pre><h4 id="向-bulk-对象中添加查询修改删除操作"><a href="#向-bulk-对象中添加查询修改删除操作" class="headerlink" title="向 bulk 对象中添加查询修改删除操作"></a>向 bulk 对象中添加查询修改删除操作</h4><pre><code>bulk.find( { status: &quot;D&quot; } ).remove(); # 还有 removeOne() 操作bulk.find( { status: &quot;P&quot; } ).update( { $set: { comment: &quot;Pending&quot; } } );bulk.find( { item: &quot;abc123&quot; } ).replaceOne( { item: &quot;abc123&quot;, status: &quot;P&quot;, points: 100 } ); # _id还在不变bulk.find( { item: &quot;abc123&quot; } ).upsert().replaceOne( { item: &quot;abc123&quot;, status: &quot;P&quot;, points: 100 } ); # 如果没找到那么进行插入操作，# 后面可以跟的操作 Bulk.find.replaceOne()，Bulk.find.updateOne()，Bulk.find.update()</code></pre><h4 id="Bulk-getOperations"><a href="#Bulk-getOperations" class="headerlink" title="Bulk.getOperations()"></a>Bulk.getOperations()</h4><p>循环插入1500条数据，同样可以进行<code>Update</code>，<code>Remove</code>操作</p><pre><code>var bulk = db.items.initializeUnorderedBulkOp();for (var i = 1; i &lt;= 1500; i++) {    bulk.insert( { x: i } );}bulk.execute();bulk.getOperations();</code></pre><h4 id="执行批量操作"><a href="#执行批量操作" class="headerlink" title="执行批量操作"></a>执行批量操作</h4><p>调用 <code>bulk</code> 对象的 <code>execute()</code> 方法以执行 <code>bulk</code> 对象列表中的所有操作。</p><pre><code>bulk.execute();</code></pre><p>该方法返回包含操作状态的 BulkWriteResult 对象。若插入成功将返回如下对象：</p><pre><code>BulkWriteResult({   &quot;writeErrors&quot; : [ ],   &quot;writeConcernErrors&quot; : [ ],   &quot;nInserted&quot; : 2,   &quot;nUpserted&quot; : 0,   &quot;nMatched&quot; : 0,   &quot;nModified&quot; : 0,   &quot;nRemoved&quot; : 0,   &quot;upserted&quot; : [ ]})</code></pre><h3 id="3-2-版本后还有以下几种语法可用于插入文档"><a href="#3-2-版本后还有以下几种语法可用于插入文档" class="headerlink" title="3.2 版本后还有以下几种语法可用于插入文档"></a>3.2 版本后还有以下几种语法可用于插入文档</h3><p><code>db.collection.insertOne()</code>:向指定集合中插入<strong>一条</strong>文档数据<br><code>db.collection.insertMany()</code>:向指定集合中插入<strong>多条</strong>文档数据</p><pre><code>#  插入单条数据&gt; var document = db.collection.insertOne({&quot;a&quot;: 3})&gt; document{    &quot;acknowledged&quot; : true,    &quot;insertedId&quot; : ObjectId(&quot;571a218011a82a1d94c02333&quot;)}#  插入多条数据&gt; var res = db.collection.insertMany([{&quot;b&quot;: 3}, {&#39;c&#39;: 4}])&gt; res{    &quot;acknowledged&quot; : true,    &quot;insertedIds&quot; : [            ObjectId(&quot;571a22a911a82a1d94c02337&quot;),            ObjectId(&quot;571a22a911a82a1d94c02338&quot;)    ]}</code></pre><br>]]></content>
      
      
      <categories>
          
          <category> MongoDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB学习笔记05-Shell常用命令</title>
      <link href="/2017/07/17/MongoDB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B005-Shell%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2017/07/17/MongoDB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B005-Shell%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="连接到一个-MongoDB"><a href="#连接到一个-MongoDB" class="headerlink" title="连接到一个 MongoDB"></a>连接到一个 MongoDB</h2><p>在命令行提示符下，输入 mongo 命令来启动 mongo 程序</p><pre><code>C:\Users\bin&gt;mongoMongoDB shell version: 3.0.2connecting to: test</code></pre><a id="more"></a><h2 id="shell命令基本使用"><a href="#shell命令基本使用" class="headerlink" title="shell命令基本使用"></a>shell命令基本使用</h2><p>更多详见<a href="https://docs.mongodb.com/manual/reference/" target="_blank" rel="noopener">官方文档</a><br>mongo 程序启动时会默认选定 test 数据库。</p><h3 id="操作数据库"><a href="#操作数据库" class="headerlink" title="操作数据库"></a>操作数据库</h3><pre><code>&gt; db  # 打印出当前的数据库名&gt; show dbs  # 列出所有数据库&gt; use db  # 切换到一个新的数据库 db&gt; db.dropDatabase()  # 删除当前数据库&gt; db.cloneDatabase(&quot;127.0.0.1&quot;)   # 将指定机器上的和当前数据库名相同的数据库的数据克隆到当前数据库，&gt; db.copyDatabase(&quot;mydb&quot;, &quot;temp&quot;, &quot;127.0.0.1&quot;)  # 将本机的mydb的数据复制到temp数据库中&gt; db.repairDatabase()  # 修复当前数据库&gt; db.getName()  # 查看当前使用的数据库，也可以直接用db&gt; db.stats()  # 显示当前db状态&gt; db.version()  # 当前db版本&gt; db.getMongo()  ＃ 查看当前db的链接机器地址&gt; db.serverStatus()  # 查看数据库服务器的状态</code></pre><h3 id="操作集合"><a href="#操作集合" class="headerlink" title="操作集合"></a>操作集合</h3><pre><code>&gt; show collections  # 查看某个数据库中所有的集合&gt; db.集合名.drop()  # 删除数据库中指定的集合&gt; db.集合名.help()</code></pre><style>table th:first-of-type {width: 140px;}table th:nth-of-type(2) {width: 200px;}</style><h3 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a>创建集合</h3><p><code>createCollection()</code> 方法的基本格式：<code>db.createCollection(name, options)</code></p><p>在该命令中，<code>name</code> 是所要创建的集合名称。<code>options</code> 是一个用来指定集合配置的文档。</p><table><thead><tr><th align="center">参数</th><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">name</td><td align="center">字符串</td><td align="center">所要创建的集合名称</td></tr><tr><td align="center">options</td><td align="center">文档</td><td align="center">可选。指定有关内存大小及索引的选项</td></tr></tbody></table><p>参数 <code>options</code> 是可选的，所以你必须指定的只有集合名称。下表列出了所有可用选项：</p><table><thead><tr><th align="center">字段</th><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">capped</td><td align="center">布尔</td><td align="center">（可选）如果为 true，则创建<a href="/2017/07/17/MongoDB学习笔记03-MongoDB%20数据库，对象，集合/#capped-collections">固定集合</a>。固定集合是指有着固定大小的集合，当达到最大值时，它会自动覆盖最早的文档。 <br/>当该值为 true 时，必须指定 size 参数。</td></tr><tr><td align="center">autoIndexID</td><td align="center">布尔</td><td align="center">（可选）如为 true，自动在 _id 字段创建索引。默认为 false。</td></tr><tr><td align="center">size</td><td align="center">数值</td><td align="center">（可选）为固定集合指定一个最大值（以字节计）。<br/>如果 capped 为 true，也需要指定该字段。</td></tr><tr><td align="center">max</td><td align="center">数值</td><td align="center">（可选）指定固定集合中包含文档的最大数量。</td></tr></tbody></table><h3 id="MongoDB自带一个JavaScript-Shell"><a href="#MongoDB自带一个JavaScript-Shell" class="headerlink" title="MongoDB自带一个JavaScript Shell"></a>MongoDB自带一个JavaScript Shell</h3><p>&emsp;&emsp;它是一个JavaScript解释器，还是一个MongoDB的客户端，可以通过JavaScript与启动的数据库实例进行交互(Shell中命令区分大小写)。在Shell中，每当写完一句完整的JS代码，Shell就会将其结果返回。</p><h3 id="shell中的help函数："><a href="#shell中的help函数：" class="headerlink" title="shell中的help函数："></a>shell中的help函数：</h3><p>当进入到某个数据库中，要如何知道可以使用哪些操作呢？此时就可以使用<code>help</code>函数，如下图，就能够列出数据库级别有哪些用法了，当然除了数据库级别的<code>help</code>，还有集合级别的<code>help</code>，使用方法为：<code>db.集合名.help()</code>。在函数名称后面不添加<code>（）</code>还可以查看函数的源码。</p><pre><code>&gt; db.help()DB methods:        db.adminCommand(nameOrDocument) - switches to &#39;admin&#39; db, and runs command [ just calls db.runCommand(...) ]        db.auth(username, password)        db.cloneDatabase(fromhost)        db.commandHelp(name) returns the help for the command        db.copyDatabase(fromdb, todb, fromhost)        db.createCollection(name, { size : ..., capped : ..., max : ... } )        db.createUser(userDocument)        db.currentOp() displays currently executing operations in the db        db.dropDatabase()        db.eval(func, args) run code server-side        db.fsyncLock() flush data to disk and lock server for backups        db.fsyncUnlock() unlocks server following a db.fsyncLock()        db.getCollection(cname) same as db[&#39;cname&#39;] or db.cname        db.getCollectionInfos()        db.getCollectionNames()        db.getLastError() - just returns the err msg string        db.getLastErrorObj() - return full status object        db.getLogComponents()        db.getMongo() get the server connection object        db.getMongo().setSlaveOk() allow queries on a replication slave server        db.getName()        db.getPrevError()        db.getProfilingLevel() - deprecated        db.getProfilingStatus() - returns if profiling is on and slow threshold        db.getReplicationInfo()        db.getSiblingDB(name) get the db at the same server as this one        db.getWriteConcern() - returns the write concern used for any operations on this db, inherited from server object if set        db.hostInfo() get details about the server&#39;s host        db.isMaster() check replica primary status        db.killOp(opid) kills the current operation in the db        db.listCommands() lists all the db commands        db.loadServerScripts() loads all the scripts in db.system.js        db.logout()        db.printCollectionStats()        db.printReplicationInfo()        db.printShardingStatus()        db.printSlaveReplicationInfo()        db.dropUser(username)        db.repairDatabase()        db.resetError()        db.runCommand(cmdObj) run a database command.  if cmdObj is a string, turns it into { cmdObj : 1 }        db.serverStatus()        db.setLogLevel(level,&lt;component&gt;)        db.setProfilingLevel(level,&lt;slowms&gt;) 0=off 1=slow 2=all        db.setWriteConcern( &lt;write concern doc&gt; ) - sets the write concern for writes to the db        db.unsetWriteConcern( &lt;write concern doc&gt; ) - unsets the write concern for writes to the db        db.setVerboseShell(flag) display extra information in shell output        db.shutdownServer()        db.stats()        db.version() current version of the server&gt;</code></pre><pre><code>//使用函数&gt; db.getName()test&gt;</code></pre><pre><code>//查看函数源代码&gt; db.getNamefunction (){    return this._name;}&gt;</code></pre><h3 id="Shell内置的JS引擎可以直接执行执行JS代码"><a href="#Shell内置的JS引擎可以直接执行执行JS代码" class="headerlink" title="Shell内置的JS引擎可以直接执行执行JS代码"></a>Shell内置的JS引擎可以直接执行执行JS代码</h3><pre><code>&gt; function invokeEval(){... return db.eval(&quot;return 123&quot;)... }&gt; invokeEval()123&gt;</code></pre><h3 id="connect"><a href="#connect" class="headerlink" title="connect()"></a>connect()</h3><p>虽然Shell中提供的全局变量db指向当前连接的数据库，但还可以用其它的变量来保存其它连接的数据库，利用<code>Shell</code>中提供的<code>connect()</code>命令即可，</p><pre><code>&gt; dbtest&gt; var udb = connect(&quot;127.0.0.1:27017/admin&quot;)connecting to: 127.0.0.1:27017/admin&gt; udbadmin&gt; dbtest&gt;</code></pre><br>]]></content>
      
      
      <categories>
          
          <category> MongoDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB学习笔记04-MySQL MongoDB 常用命令对比</title>
      <link href="/2017/07/17/MongoDB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B004-MySQL%20MongoDB%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%AF%B9%E6%AF%94/"/>
      <url>/2017/07/17/MongoDB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B004-MySQL%20MongoDB%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%AF%B9%E6%AF%94/</url>
      
        <content type="html"><![CDATA[<p>本文源自本人原博<a href="http://blog.csdn.net/u011008734/article/details/47723449" target="_blank" rel="noopener">MySQL MongoDB 常用命令对比 - CSDN博客</a></p><p><img src="http://blog-1252208501.cos.ap-beijing.myqcloud.com/81c3ce79jw1eho4qatgvaj20nd08374r.jpg" alt="MongoDB"></p><a id="more"></a><h2 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h2><table><thead><tr><th align="center">MySQL</th><th align="center">MongoDB</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">mysqldump</td><td align="center">mongodump</td><td align="center">逻辑备份工具</td></tr><tr><td align="center">mysql</td><td align="center">mongorestore</td><td align="center">逻辑恢复工具</td></tr><tr><td align="center">/</td><td align="center">db.repairDatabase()</td><td align="center">修复数据库</td></tr><tr><td align="center">mysqldump</td><td align="center">mongoexport</td><td align="center">数据导出工具</td></tr><tr><td align="center">source</td><td align="center">mongoimport</td><td align="center">数据导入工具</td></tr><tr><td align="center">show databases</td><td align="center">show dbs</td><td align="center">显示库列表</td></tr><tr><td align="center">Show tables</td><td align="center">Show collections</td><td align="center">显示表列表</td></tr><tr><td align="center">Show slave status</td><td align="center">Rs.status</td><td align="center">查询主从状态</td></tr><tr><td align="center">Create table users(a int, b int)</td><td align="center">db.createCollection(&quot;mycoll&quot;, {capped:true, size:100000}) 另：可隐式创建表。</td><td align="center">创建表</td></tr><tr><td align="center">Create INDEX idxname ON users(name)</td><td align="center">db.users.ensureIndex({name:1})</td><td align="center">创建索引</td></tr><tr><td align="center">Create INDEX idxname ON users(name,ts DESC)</td><td align="center">db.users.ensureIndex({name:1,ts:-1})</td><td align="center">创建索引</td></tr><tr><td align="center">&nbsp;</td><td align="center">db.system.users.find()</td><td align="center">查看用户列表</td></tr><tr><td align="center">&nbsp;</td><td align="center">show users</td><td align="center">查看所有用户</td></tr><tr><td align="center">&nbsp;</td><td align="center">db.printCollectionStats()</td><td align="center">查看各collection的状态</td></tr><tr><td align="center">&nbsp;</td><td align="center">db.printReplicationInfo()</td><td align="center">查看主从复制状态</td></tr><tr><td align="center">&nbsp;</td><td align="center">show profile</td><td align="center">查看profiling</td></tr><tr><td align="center">&nbsp;</td><td align="center">db.copyDatabase(&#39;mail_addr&#39;,&#39;mail_addr_tmp&#39;)</td><td align="center">拷贝数据库</td></tr></tbody></table><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><table><thead><tr><th align="center">MySQL</th><th align="center">MongoDB</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Select a, b from users</td><td align="center">db.users.find({},{a:1, b:1})</td><td align="center">查询表</td></tr><tr><td align="center">Select * from users</td><td align="center">db.users.find()</td><td align="center">查询表</td></tr><tr><td align="center">Select * from users where age=33</td><td align="center">db.users.find({age:33})</td><td align="center">条件查询</td></tr><tr><td align="center">Select a, b from users where age=33</td><td align="center">db.users.find({age:33},{a:1, b:1})</td><td align="center">条件查询</td></tr><tr><td align="center">select * from users where age &amp;lt 33</td><td align="center">db.users.find({&#39;age&#39;:{$lt:33}})</td><td align="center">条件查询</td></tr><tr><td align="center">select * from users where age &amp;gt33 and age &amp;lt=40</td><td align="center">db.users.find({&#39;age&#39;:{$gt:33,$lte:40}})</td><td align="center">条件查询</td></tr><tr><td align="center">select * from users where a=1 and b=&#39;q&#39;</td><td align="center">db.users.find({a:1,b:&#39;q&#39;})</td><td align="center">条件查询</td></tr><tr><td align="center">select * from users where a=1 or b=2</td><td align="center">db.users.find( { $or : [ { a : 1 } , { b : 2 } ] } )</td><td align="center">条件查询</td></tr><tr><td align="center">select * from users limit 1</td><td align="center">db.users.findOne()</td><td align="center">条件查询</td></tr><tr><td align="center">select * from users where name like &quot;%Joe%&quot;</td><td align="center">db.users.find({name:/Joe/})</td><td align="center">模糊查询</td></tr><tr><td align="center">select * from users where name like &quot;Joe%&quot;</td><td align="center">db.users.find({name:/^Joe/})</td><td align="center">模糊查询</td></tr><tr><td align="center">select count(1) from users</td><td align="center">Db.users.count()</td><td align="center">获取表记录数</td></tr><tr><td align="center">select count(1) from users where age&gt;30</td><td align="center">db.users.find({age: {&#39;$gt&#39;: 30}}).count()</td><td align="center">获取表记录数</td></tr><tr><td align="center">select DISTINCT last_name from users</td><td align="center">db.users.distinct(&#39;last_name&#39;)</td><td align="center">去掉重复值</td></tr><tr><td align="center">select * from users ORDER BY name</td><td align="center">db.users.find().sort({name:1})</td><td align="center">排序</td></tr><tr><td align="center">select * from users ORDER BY name DESC</td><td align="center">db.users.find().sort({name:-1})</td><td align="center">排序</td></tr><tr><td align="center">EXPLAIN select * from users where z=3</td><td align="center">db.users.find({z:3}).explain()</td><td align="center"></td></tr></tbody></table><h2 id="增删改"><a href="#增删改" class="headerlink" title="增删改"></a>增删改</h2><table><thead><tr><th align="center">MySQL</th><th align="center">MongoDB</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">update users set a=1 where b=&#39;q&#39;</td><td align="center">db.users.update({b:&#39;q&#39;}, {$set:{a:1}}, false, true)</td><td align="center">更新记录</td></tr><tr><td align="center">update users set a=a+2 where b=&#39;q&#39;</td><td align="center">db.users.update({b:&#39;q&#39;}, {$inc:{a:2}}, false, true)</td><td align="center">更新记录</td></tr><tr><td align="center">delete from users where z=&quot;abc&quot;</td><td align="center">db.users.remove({z:&#39;abc&#39;})</td><td align="center">删除记录</td></tr><tr><td align="center">delete * from users</td><td align="center">db.users.remove()</td><td align="center">删除所有的记录</td></tr><tr><td align="center">drop database IF EXISTS test;</td><td align="center">use test<br/>db.dropDatabase()</td><td align="center">删除数据库</td></tr><tr><td align="center">drop table IF EXISTS test;</td><td align="center">db.mytable.drop()</td><td align="center">删除表/collection</td></tr><tr><td align="center">Insert into users values(1, 1)</td><td align="center">db.users.insert({a:1, b:1})</td><td align="center">插入记录</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> MongoDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB学习笔记03-MongoDB 数据库，对象，集合</title>
      <link href="/2017/07/17/MongoDB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B003-MongoDB%20%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8C%E5%AF%B9%E8%B1%A1%EF%BC%8C%E9%9B%86%E5%90%88/"/>
      <url>/2017/07/17/MongoDB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B003-MongoDB%20%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8C%E5%AF%B9%E8%B1%A1%EF%BC%8C%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<p>本文源自本人原博<a href="http://blog.csdn.net/u011008734/article/details/47723279" target="_blank" rel="noopener">MongoDB 数据库，对象，集合 - CSDN博客</a></p><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>一组集合就可以组成一个数据库。一个MongoDB实例可以承载多个数据库。每个数据库都有独立的权限控制。<br><code>&quot;show dbs&quot;</code> 命令可以显示所有数据的列表。</p><a id="more"></a><pre><code>C:\Users\bin&gt;mongoMongoDB shell version: 3.0.2connecting to: test&gt; show dbsadmin  0.078GBdb     0.078GBlocal  0.078GBtest   0.078GB&gt;</code></pre><p>执行 <code>&quot;db&quot;</code> 命令可以显示当前数据库对象或集合。</p><pre><code>&gt; dbtest</code></pre><p>运行<code>&quot;use&quot;</code>命令，可以连接到一个指定的数据库。</p><pre><code>&gt; use localswitched to db local</code></pre><p><font color="red"><strong>注意：</strong></font></p><ol><li>数据库名称可以是任何字符，但是不能包含空字符串，点号（.），或者&quot; &quot;。</li><li>&quot;system&quot; 作为系统保留字符串不能作为数据库名。</li><li>数据库名不能包含 &quot;$&quot;。</li></ol><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p>文档是<code>mongodb</code>中的最核心的概念，是其核心单元，我们可以将文档类比成关系型数据库中的每一<code>行</code>数据。<br><strong><font color="red">多个键及其关联的值有序的放置在一起就是文档</font></strong>。在<code>mongodb</code>中使用一种类<code>json</code>的<code>bson</code>存储数据。<br><code>MongoDB</code>中对文档的区分包括：<strong><code>键值对的顺序</code>，<code>键和值的类型</code>，<code>键和值的大小写</code></strong>。在两个文档中如果这三者有任何一个不一致，这两个文档就不相同。文档中键值对的“值”的数据类型甚至还可以是整个嵌入的文档，<strong><code>“键”则只能是字符串</code></strong>。</p><p>新增文档（集合会自动创建）</p><pre><code>&gt; db.mycoll.insert({&quot;name&quot;:&quot;zhang&quot;})WriteResult({ &quot;nInserted&quot; : 1 })&gt; db.mycoll.remove({&quot;name&quot;:&quot;zhang&quot;})WriteResult({    &quot;nRemoved&quot; : 0,    &quot;writeError&quot; : {        &quot;code&quot; : 20,        &quot;errmsg&quot; : &quot;cannot remove from a capped collection: test.mycoll&quot;    }})&gt;</code></pre><p>插入文档你也可以使用 <code>db.mycoll.save(document)</code> 命令。如果不指定 <code>_id</code> 字段 <code>save()</code> 方法类似于 <code>insert()</code> 方法。如果指定 <code>_id</code> 字段，则会更新该 <code>_id</code> 的数据。</p><p>文档例子如下：</p><pre><code>{ name : &quot;zhang&quot; }</code></pre><ul><li>通常，&quot;<code>object</code>（对象）&quot; 术语是指一个文件。</li><li>文件类似于一个<code>RDBMS</code>的记录(行)。</li><li>我们可以对集合（<code>collection</code>）进行插入，更新和删除操作。</li></ul><p>下表将帮助您更容易理解Mongo中的一些概念：</p><style>table th:first-of-type {    width: 240px;}</style><table><thead><tr><th align="center">RDBMS</th><th align="center">MongoDB</th></tr></thead><tbody><tr><td align="center">Table（表）</td><td align="center">Collection（集合）</td></tr><tr><td align="center">Column（栏）</td><td align="center">Key（键）</td></tr><tr><td align="center">Value（值）</td><td align="center">Value（值）</td></tr><tr><td align="center">Records / Rows（记录/列）</td><td align="center">Document / Object（文档/对象）</td></tr></tbody></table><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>下表为 <code>MongoDB</code> 中常用的几种数据类型。</p><table><thead><tr><th align="center">数据类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">String（字符串）</td><td align="center">存储数据常用的数据类型。在 MongoDB 中，UTF-8 编码的字符串才是合法的。</td></tr><tr><td align="center">Integer（整型）</td><td align="center">用于存储数值。根据你所采用的服务器，可分为 32 位或 64 位。</td></tr><tr><td align="center">Boolean（布尔型）</td><td align="center">逻辑值 True 或者 False。</td></tr><tr><td align="center">Double（双精度浮点值）</td><td align="center">用于存储浮点值。</td></tr><tr><td align="center">Min/Max keys</td><td align="center">将一个值与 BSON（二进制的 JSON）元素的最低值和最高值相对比。</td></tr><tr><td align="center">Null</td><td align="center">用于创建空值。</td></tr><tr><td align="center">Array</td><td align="center">用于将数组或列表或多个值存储为一个键。<code>{&quot;arr&quot;: [&quot;a&quot;,&quot;b&quot;]}</code></td></tr><tr><td align="center">Object</td><td align="center">用于内嵌文档。</td></tr><tr><td align="center">Timestamp</td><td align="center">时间戳。记录文档修改或添加的具体时间。</td></tr><tr><td align="center">Symbol</td><td align="center">符号。该数据类型基本上等同于字符串类型，但不同的是，它一般用于采用特殊符号类型的语言。</td></tr><tr><td align="center">Object IDs</td><td align="center">在mongodb中的文档需要使用唯一的关键字_id来标识他们。几乎每一个mongodb文档都使用_id字段作为第一个属性（在系统集合和定容量集合（capped collection）中有一些例外）。_id值可以是任何类型，最常见的做法是使用ObjectId类型。</td></tr><tr><td align="center">Date</td><td align="center">日期时间。用 UNIX 时间格式来存储当前日期或时间。你可以指定自己的日期时间：创建 Date 对象，传入年月日信息。</td></tr><tr><td align="center">Binary Data</td><td align="center">二进制数据。用于存储二进制数据。shell不支持</td></tr><tr><td align="center">Code</td><td align="center">代码类型。用于在文档中存储 JavaScript 代码。<code>{&quot;x&quot;：function() {}}</code></td></tr><tr><td align="center">Regular expression</td><td align="center">正则表达式类型。用于存储正则表达式。遵循JavaScript的语法</td></tr><tr><td align="center">内嵌文档</td><td align="center">文档可以作为文档中某个key的value <code>{&quot;x&quot;:{&quot;foo&quot;:&quot;bar&quot;}}</code></td></tr><tr><td align="center">Undefined</td><td align="center">未定义 <code>{&quot;x&quot;：undefined}</code></td></tr></tbody></table><p>上面的大部分类型都是显而易见的，但是有必要详细解释一下对象id类型。我们上面说了，对象id类型是一个12字节的唯一id。每个字节2位16进制数，因此整个id类型是一个24位的字符串。其结构如下表所示：<br><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/242845_1323510736LDEF.png" alt=""></p><ul><li>前面四个字节代表从标准纪元开始的时间戳，以秒为单位。</li><li>接下来三个字节表示机器号，一般是机器名的hash值。这可以保证不同机器产生的id不会冲突。</li><li>接下来两个字节表示进程id号，保证统一机器不同建成产生的id不冲突</li><li>最后三个是计数器的计数值，对于任意一秒钟，可以产生2^24个数</li></ul><p>如果不在插入的时候手动的添加_id键，那么系统会自动添加一个。尽管MongoDB的id类型被设计成轻量级的，但是这样还是会不好。毕竟服务器创建这个还是会有开销的。因此，这个工作一般会放到客户端来做。</p><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>集合就是一组文档的组合。如果将文档类比成数据库中的行，那么集合就可以类比成数据库的表。<br>在 <code>mongodb</code> 中的集合是无模式的，也就是说集合中存储的文档的结构可以是不同的，比如下面的两个文档可以同时存入到一个集合中：</p><pre><code>{&quot;name&quot;:&quot;zhang&quot;} {&quot;Name&quot;:&quot;zhang&quot;,&quot;sex&quot;:&quot;nan&quot;}</code></pre><p>当第一个文档插入时，集合就会被创建。</p><h2 id="capped-collections"><a href="#capped-collections" class="headerlink" title="capped collections"></a>capped collections</h2><p><code>Capped collections</code> 就是固定大小的<code>collection</code>。<br>它有很高的性能以及队列过期的特性(过期按照插入的顺序). 有点和 &quot;RRD&quot; 概念类似。</p><p><code>Capped collections</code>是高性能自动的维护对象的插入顺序。它非常适合类似记录日志的功能 和标准的<code>collection</code>不同，你必须要<strong>显式的创建</strong>一个<code>capped collection</code>， 指定一个<code>collection</code>的大小，单位是字节。<code>collection</code>的数据存储空间值提前分配的。</p><p>要注意的是指定的存储大小包含了数据库的头信息。</p><pre><code>&gt; db.createCollection(&quot;myCappedColl&quot;, {capped:true, size:100000}){ &quot;ok&quot; : 1 }&gt;</code></pre><p>还有一个参数 <code>autoIndexID</code>，值可以为 <code>true</code> 和 <code>false</code> 来决定是否需要在 <code>_id</code> 字段上<strong>自动创建索引</strong>，如：</p><pre><code>db.createCollection(&quot;myCappedColl&quot;, {size:10000000, autoIndexId:false})</code></pre><p>还可以指定文档个数，加上 <code>max</code>:1000属性：</p><pre><code>db.createCollection(&quot;myCappedColl&quot;,{capped:true,size:10000,max:1000})</code></pre><p>判断集合是否为固定集合:</p><pre><code>db.myCappedColl.isCapped()true</code></pre><p>如果需要将已存在的集合<code>转换为固定集合</code>可以使用以下命令：</p><pre><code>&gt;db.runCommand({&quot;convertToCapped&quot;:&quot;myColl&quot;,size:10000}){ &quot;ok&quot; : 1 }&gt;db.myColl.isCapped()true</code></pre><p>查看一个 <code>collection</code> 已经使用了多少空间</p><pre><code class="shell">&gt; db.user.validate();{    &quot;ns&quot; : &quot;db_mongo.user&quot;,    &quot;capped&quot; : true,    &quot;max&quot; : NumberLong(&quot;9223372036854775807&quot;),    &quot;datasize&quot; : 1680,    &quot;nrecords&quot; : 14,    &quot;lastExtentSize&quot; : 12288,    &quot;firstExtent&quot; : &quot;0:126000 ns:db_mongo.tmp.convertToCapped.user&quot;,    &quot;lastExtent&quot; : &quot;0:126000 ns:db_mongo.tmp.convertToCapped.user&quot;,    &quot;extentCount&quot; : 1,    &quot;firstExtentDetails&quot; : {        &quot;loc&quot; : &quot;0:126000&quot;,        &quot;xnext&quot; : &quot;null&quot;,        &quot;xprev&quot; : &quot;null&quot;,        &quot;nsdiag&quot; : &quot;db_mongo.tmp.convertToCapped.user&quot;,        &quot;size&quot; : 12288,        &quot;firstRecord&quot; : &quot;0:1260b0&quot;,        &quot;lastRecord&quot; : &quot;0:126798&quot;    },    &quot;deletedCount&quot; : 1,    &quot;deletedSize&quot; : 10208,    &quot;nIndexes&quot; : 1,    &quot;keysPerIndex&quot; : {            &quot;db_mongo.user.$_id_&quot; : 14    },    &quot;valid&quot; : true,    &quot;errors&quot; : [ ],    &quot;warning&quot; : &quot;Some checks omitted for speed. use {full:true} option to do more thorough scan.&quot;,    &quot;ok&quot; : 1}</code></pre><p>固定集合文档按照插入顺序储存的,默认情况下查询就是按照插入顺序返回的,也可以使用<code>$natural</code>调整返回顺序。</p><pre><code>&gt;db.user.find().sort({$natural:-1})</code></pre><p>查看<code>collection</code>最大存储大小，已经使用了多少空间等信息</p><pre><code class="shell">&gt;db.user.stats(){    &quot;ns&quot; : &quot;db_mongo.user&quot;,    &quot;count&quot; : 15,    &quot;size&quot; : 1712,    &quot;avgObjSize&quot; : 114,    &quot;numExtents&quot; : 1,    &quot;storageSize&quot; : 12288,    &quot;lastExtentSize&quot; : 12288,    &quot;paddingFactor&quot; : 1,    &quot;paddingFactorNote&quot; : &quot;paddingFactor is unused and unmaintained in 3.0.It remains hard coded to 1.0 for compatibility only.&quot;,    &quot;userFlags&quot; : 1,    &quot;capped&quot; : true,    &quot;max&quot; : NumberLong(&quot;9223372036854775807&quot;),    &quot;maxSize&quot; : 12288,    &quot;nindexes&quot; : 1,    &quot;totalIndexSize&quot; : 8176,    &quot;indexSizes&quot; : {        &quot;_id_&quot; : 8176    },    &quot;ok&quot; : 1}</code></pre><ul><li>可以插入及更新，但更新不能超出 <code>collection</code> 的大小，否则更新失败。</li><li>不允许删除单行，但是可以调用 <code>drop()</code> 删除集合中的所有行，但是 <code>drop</code> 后需要显式地重建集合。</li><li>在 32 位机上，一 个<code>capped collection</code>的最大值约为<code>482.5M</code>，64 位上只受系统文件大小的限制。</li><li>如果超出大小限制，再添加会将前面添加的数据<strong>替换掉</strong>。</li></ul><br>]]></content>
      
      
      <categories>
          
          <category> MongoDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB学习笔记02-MongoDB简介及安装</title>
      <link href="/2017/07/17/MongoDB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002-MongoDB%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%AE%89%E8%A3%85/"/>
      <url>/2017/07/17/MongoDB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002-MongoDB%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>本文源自本人原博<a href="http://blog.csdn.net/u011008734/article/details/47723251" target="_blank" rel="noopener">MongoDB简介及安装 - CSDN博客</a></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li><code>MongoDB</code>是一个基于分布式文件存储的数据库开源项目。由<code>C++</code>语言编写。旨在为WEB应用提供可护展的高性能数据存储解决方案。<a id="more"></a></li><li><code>MongoDB</code>是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。</li><li>他支持的数据结构非常松散，是类似<code>json</code>的<code>bjson</code>格式，因此可以存储比较复杂的数据类型。</li><li><code>Mongo</code>最大的特点是他支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。</li><li><code>Mongo</code>主要解决的是海量数据的访问效率问题，根据官方的文档，当数据量达到50GB以上的时候，<code>Mongo</code>的数据库访问速度是<code>MySQL</code>的10倍以上。<code>Mongo</code>的并发读写效率不是特别出色，根据官方提供的性能测试表明，大约每秒可以处理0.5万－1.5次读写请求。</li></ul><h2 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h2><ul><li><strong>面向集合存储</strong>：意思是数据被分组存储在数据集中， 被称为一个集合<code>Collenction</code>。每个集合在数据库中都有一个唯一的标识名，并且可以包含无限数目的文档。集合的概念类似关系型数据库<code>RDBMS</code>里的表<code>table</code>，不同的是它不需要定义任何模式<code>schema</code>。</li><li><strong>模式自由</strong>：意味着对于存储在<code>MongoDB</code>数据库中的文件，我们不需要知道它的任何结构定义。提了这么多次&quot;无模式&quot;或&quot;模式自由&quot;，它到是个什么概念呢？例如，下面两个记录可以存在于同一个集合里面：<br><code>{&quot;welcome&quot; : &quot;Beijing&quot;} {&quot;age&quot; : 25}</code></li><li><strong>文档型</strong>：存储在集合中的文档，被存储为键-值对的形式。键用于唯一标识一个文档，为字符串类型，而值则可以是各种复杂的文件类型</li><li><strong>高效的数据存储</strong>：支持二进制数据及大型对象</li><li><strong>支持复制和故障恢复</strong>：提供<code>Master-Master</code>、<code>Master-Slave</code>模式的数据复制及服务器之间的数据复制</li><li><strong>自动分片</strong>：以支持云级别的伸缩性，支持水平的数据库集群，可动态添加额外的服务器</li></ul><h2 id="适用场合"><a href="#适用场合" class="headerlink" title="适用场合"></a>适用场合</h2><ul><li><strong>网站数据</strong>：<code>Mongo</code>非常适合实时的插入，更新与查询，并具备网站实时数据存储所需的复制及高度伸缩性。</li><li><strong>缓存</strong>：由于性能很高，<code>Mongo</code>也适合作为信息基础设施的缓存层。在系统重启之后，由<code>Mongo</code>搭建的持久化缓存层可以避免下层的数据源过载。</li><li><strong>大尺寸，低价值的数据</strong>：使用传统的关系型数据库存储一些数据时可能会比较昂贵，在此之前，很多时候程序员往往会选择传统的文件进行存储。</li><li><strong>高伸缩性的场景</strong>：<code>Mongo</code>非常适合由数十或数百台服务器组成的数据库。<code>Mongo</code>的路线图中已经包含对<code>MapReduce</code>引擎的内置支持。</li><li><strong>用于对象及<code>JSON</code>数据的存储</strong>：<code>Mongo</code>的<code>BSON</code>数据格式非常适合文档化格式的存储及查询。</li></ul><h2 id="不适用的场合"><a href="#不适用的场合" class="headerlink" title="不适用的场合"></a>不适用的场合</h2><ul><li>要求高度事务性的系统</li><li>传统的商业智能应用</li><li>复杂的跨文档（表）级联查询</li></ul><h2 id="MongoDB-工具"><a href="#MongoDB-工具" class="headerlink" title="MongoDB 工具"></a>MongoDB 工具</h2><p>有几种可用于MongoDB的管理工具。</p><h3 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h3><ul><li><code>MongoDB</code>提供了网络和系统监控工具<code>Munin</code>，它作为一个插件应用于<code>MongoDB</code>中。</li><li><code>Gangila</code>是<code>MongoDB</code>高性能的系统监视的工具，它作为一个插件应用于<code>MongoDB</code>中。</li><li>基于图形界面的开源工具 <code>Cacti</code>, 用于查看CPU负载, 网络带宽利用率,它也提供了一个应用于监控 <code>MongoDB</code> 的插件。</li></ul><h2 id="在Windows系统下安装MongoDB"><a href="#在Windows系统下安装MongoDB" class="headerlink" title="在Windows系统下安装MongoDB"></a>在Windows系统下安装MongoDB</h2><blockquote><p><font color="green"><strong>运行平台：</strong></font><br/> 从2.2版本开始,<code>MongoDB</code>不支持<code>Windows XP</code>。请使用“最近版本的<code>Windows</code>使用<code>MongoDB</code>的最近版本。</p></blockquote><h3 id="1-MongoDB的下载"><a href="#1-MongoDB的下载" class="headerlink" title="1. MongoDB的下载"></a>1. MongoDB的下载</h3><p>下载最新产品发布版的<code>MongoDB</code>到官网下载页面<a href="http://www.mongodb.org/downloads" target="_blank" rel="noopener">http://www.mongodb.org/downloads</a></p><h3 id="2-安装下载文件"><a href="#2-安装下载文件" class="headerlink" title="2. 安装下载文件"></a>2. 安装下载文件</h3><p>在Windows资源管理器,找到下载MongoDB msi文件,通常“位于默认“下载”文件夹中</p><h3 id="3-手动创建一个MongoDB的Windows服务"><a href="#3-手动创建一个MongoDB的Windows服务" class="headerlink" title="3. 手动创建一个MongoDB的Windows服务"></a>3. 手动创建一个MongoDB的Windows服务</h3><ul><li>为数据库创建目录和日志文件：<pre><code>mkdir c:\data\dbmkdir c:\data\log</code></pre></li><li>创建配置文件，同时指定 日志文件路径和<code>DBPATH</code>在配置文件中的设置：<pre><code>echo logpath=c:\data\log\mongod.log&gt; &quot;C:\Program Files\MongoDB 2.6 Standard\mongod.cfg&quot;echo dbpath=c:\data\db&gt;&gt; &quot;C:\Program Files\MongoDB 2.6 Standard\mongod.cfg&quot;</code></pre></li><li>创建<code>MongoDB</code>的服务<pre><code>sc.exe create MongoDB binPath= &quot;\&quot;C:\Program Files\MongoDB 2.6 Standard\bin\mongod.exe\&quot; --service --config=\&quot;C:\Program Files\MongoDB 2.6 Standard\mongod.cfg\&quot;&quot; DisplayName= &quot;MongoDB 2.6 Standard&quot; start= &quot;auto&quot;</code></pre>如果创建成功，会显示以下日志消息：<pre><code>[SC] CreateService SUCCESS</code></pre></li><li>开启 <code>MongoDB</code> 服务<pre><code>net start MongoDB</code></pre></li><li>查看是否开启成功<br>在浏览器里面键入<a href="http://localhost:27017/" target="_blank" rel="noopener">http://localhost:27017/</a><br>出现 <font color="grey">It looks like you are trying to access MongoDB over HTTP on the native driver port. </font>说明成功开启</li><li>停止<code>MongoDB</code>的服务<pre><code>net stop MongoDB</code></pre></li><li>要删除的<code>MongoDB</code>服务，先停止服务，然后运行以下命令：<pre><code>sc.exe delete MongoDB</code></pre></li></ul><h2 id="开启Web管理信息界面"><a href="#开启Web管理信息界面" class="headerlink" title="开启Web管理信息界面"></a>开启Web管理信息界面</h2><p><code>MongoDB</code>自带一个微型的<code>web</code>管理信息界面，需要修改<code>/mongod.conf</code>中的一个配置项：</p><pre><code>httpinterface=true</code></pre><p>打开浏览器访问<a href="http://127.0.0.1:28017" target="_blank" rel="noopener">http://127.0.0.1:28017</a><br>这个页面可以看到</p><ol><li>当前<code>Mongodb</code>的所有连接</li><li>各个数据库和<code>Collection</code>的访问统计，包括：<code>Reads</code>, <code>Writes</code>, <code>Queries</code>, <code>GetMores</code> ,<code>Inserts</code>, <code>Updates</code>, <code>Removes</code></li><li>写锁的状态</li><li>以及日志文件的最后几百行</li><li>所有的<code>MongoDB</code>命令</li></ol><h2 id="windows-下启动MongoDB的rest接口"><a href="#windows-下启动MongoDB的rest接口" class="headerlink" title="windows 下启动MongoDB的rest接口"></a>windows 下启动MongoDB的rest接口</h2><p>启动<code>mongodb</code>后，在<code>web</code>端口访问情况下，点击<code>List all commands</code>会出现如下错误</p><pre><code>REST is not enabled.  use --rest to turn on.check that port 28017 is secured for the network too.</code></pre><p>需要修改<code>/mongod.conf</code>中的一个配置项：</p><pre><code>rest = true</code></pre><h2 id="在RedHat-Enterprise下安装MongoDB"><a href="#在RedHat-Enterprise下安装MongoDB" class="headerlink" title="在RedHat Enterprise下安装MongoDB"></a>在RedHat Enterprise下安装MongoDB</h2><p>详情见<a href="https://docs.mongodb.com/manual/tutorial/install-mongodb-on-red-hat/" target="_blank" rel="noopener">官方文档</a></p><ol><li><p>如果您安装社区版请链接：<br><code>/etc/yum.repos.d/mongodb-org-3.4.repo</code>文件创建：</p><pre><code>[mongodb-org-3.4]name=MongoDB Repositorybaseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/3.4/x86_64/gpgcheck=1enabled=1gpgkey=https://www.mongodb.org/static/pgp/server-3.4.asc</code></pre><p>之后执行<code>yum install mongodb-org</code></p></li><li><p>如果您安装企业版请链接：<br><code>/etc/yum.repos.d/mongodb-enterprise.repo</code>文件创建：</p><pre><code>[mongodb-enterprise]name=MongoDB Enterprise Repositorybaseurl=https://repo.mongodb.com/yum/redhat/$releasever/mongodb-enterprise/3.4/$basearch/gpgcheck=1enabled=1gpgkey=https://www.mongodb.org/static/pgp/server-3.4.asc</code></pre><p>之后执行<code>yum install mongodb-enterprise</code></p></li><li><p>使用下列命令启动停止重启<code>mongod</code>进程</p><pre><code class="shell">sudo service mongod startsudo service mongod stopsudo service mongod restart</code></pre></li></ol><br>]]></content>
      
      
      <categories>
          
          <category> MongoDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB学习笔记01-NoSQL</title>
      <link href="/2017/07/17/MongoDB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001-NoSQL/"/>
      <url>/2017/07/17/MongoDB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001-NoSQL/</url>
      
        <content type="html"><![CDATA[<p>本文源自本人原博<a href="http://blog.csdn.net/u011008734/article/details/47723231" target="_blank" rel="noopener">NoSQL - CSDN博客</a></p><blockquote><p>最近开始学习MongoDB 先了解下NoSQL</p></blockquote><h2 id="NoSQL-简介"><a href="#NoSQL-简介" class="headerlink" title="NoSQL 简介"></a>NoSQL 简介</h2><p><code>NoSQL</code>，全称是<code>Not Only Sql</code>,指的是非关系型的数据库。这类数据库主要有这些特点：<code>非关系型的</code>、<code>分布式的</code>、<code>开源的</code>、<code>水平可扩展的</code>。原始的目的是为了大规模web应用，这场全新的数据库革命运动早期就有人提出，发展至2009年趋势越发高涨。<code>NoSQL</code>的拥护者们提倡运用非关系型的数据存储，通常的应用如：模式自由、支持简易复制、简单的API、最终的一致性（非<code>ACID</code>）、大容量数据等。<code>NoSQL</code>被我们用得最多的当数<code>key-value存储</code>，当然还有其他的<code>文档型的</code>、<code>列存储</code>、<code>图型数据库</code>、<code>xml数据库</code>等。相对于目前铺天盖地的关系型数据库运用，这一概念无疑是一种全新思维的注入。</p><a id="more"></a><h2 id="NoSQL的优势"><a href="#NoSQL的优势" class="headerlink" title="NoSQL的优势"></a>NoSQL的优势</h2><ol><li>易扩展<br> <code>NoSQL</code>数据库种类繁多，但是一个共同的特点都是去掉关系数据库的关系型特性。数据之间无关系，这样就非常容易扩展。也无形之间，在架构的层面带来了可扩展的能力。甚至有多种<code>NoSQL</code>之间的整合。</li><li>灵活的数据模型<br> <code>NoSQL</code>无需事先为要存储的数据建立字段，随时可以存储自定义的数据格式。而在关系型数据库里，增删字段是一件非常麻烦的事情。如果是非常大数据量的表，增加字段简直就是一个噩梦。</li><li>高可用<br> <code>NoSQL</code>在不太影响性能的情况，就可以方便的实现高可用的架构。比如<code>Cassandra</code>，<code>HBase</code>模型，通过复制模型也能实现高可用。</li><li>大数据量，高性能<br> <code>NoSQL</code>数据库都具有非常高的读写性能，尤其在大数据量下，同样表现优秀。这得益于它的无关系性，数据库的结构简单。</li></ol><h2 id="NoSQL的缺点"><a href="#NoSQL的缺点" class="headerlink" title="NoSQL的缺点"></a>NoSQL的缺点</h2><ul><li>很难实现数据的完整性</li><li>缺乏强有力的技术支持</li><li>开源数据库从出现到用户接受需要一个漫长的过程</li><li>关系型数据库在设计时更能够体现实际</li><li><strong>弱事务性</strong>：在一些要求事物一致性较高、业务逻辑比较复杂，或者一些需要复杂分析查询的环境中，NoSQL难以担当重任。</li><li><strong>弱联表查询</strong>：只能提供简单的查询，无法进行多表联合查询等复杂的查询操作。</li><li><strong>非主流</strong>：大部分NoSQL都还处在前生产环境阶段，还有大量的关键特性有待实现。</li></ul><h2 id="CAP定理（CAP-theorem）"><a href="#CAP定理（CAP-theorem）" class="headerlink" title="CAP定理（CAP theorem）"></a>CAP定理（CAP theorem）</h2><blockquote><p><a href="http://www.runoob.com/mongodb/nosql.html" target="_blank" rel="noopener">http://www.runoob.com/mongodb/nosql.html</a></p></blockquote><p>在计算机科学中, <code>CAP定理</code>（CAP theorem）, 又被称作 <code>布鲁尔定理</code>（Brewer&#39;s theorem）, 它指出对于一个分布式计算系统来说，不可能同时满足以下三点:</p><ul><li><strong>一致性(Consistency)</strong> (所有节点在同一时间具有相同的数据)</li><li><strong>可用性(Availability)</strong> (保证每个请求不管成功或者失败都有响应)</li><li><strong>分隔容忍(Partition tolerance)</strong> (系统中任意信息的丢失或失败不会影响系统的继续运作)</li></ul><p><code>CAP</code>理论的核心是：一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求，最多只能同时较好的满足两个。<br>因此，根据 <code>CAP</code> 原理将 <code>NoSQL</code> 数据库分成了满足 <code>CA</code> 原则、满足 <code>CP</code> 原则和满足 <code>AP</code> 原则三 大类：</p><ul><li>CA - 单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大。</li><li>CP - 满足一致性，分区容忍性的系统，通常性能不是特别高。</li><li>AP - 满足可用性，分区容忍性的系统，通常可能对一致性要求低一些。</li></ul><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/cap-theoram-image.png" alt=""></p><h2 id="NoSQL-数据库分类"><a href="#NoSQL-数据库分类" class="headerlink" title="NoSQL 数据库分类"></a>NoSQL 数据库分类</h2><style>table th:first-of-type {    width: 150px;}table th:nth-of-type(2) {    width: 200px;}</style><table><thead><tr><th align="center">类型</th><th align="center">部分代表</th><th align="center">特点</th></tr></thead><tbody><tr><td align="center">列存储</td><td align="center">Hbase <br />Cassandra<br /> Hypertable</td><td align="center">顾名思义，是按列存储数据的。最大的特点是方便存储结构化和半结构化数据，方便做数据压缩，对针对某一列或者某几列的查询有非常大的IO优势。</td></tr><tr><td align="center">文档存储</td><td align="center">MongoDB<br/>CouchDB</td><td align="center">文档存储一般用类似json的格式存储，存储的内容是文档型的。这样也就有有机会对某些字段建立索引，实现关系数据库的某些功能。</td></tr><tr><td align="center">key-value存储</td><td align="center">Tokyo Cabinet / Tyrant<br/>Berkeley DB<br/>MemcacheDB<br/>Redis</td><td align="center">可以通过key快速查询到其value。一般来说，存储不管value的格式，照单全收。（Redis包含了其他功能）</td></tr><tr><td align="center">图存储</td><td align="center">Neo4J<br/>FlockDB</td><td align="center">图形关系的最佳存储。使用传统关系数据库来解决的话性能低下，而且设计使用不方便。</td></tr><tr><td align="center">对象存储</td><td align="center">db4o<br/>Versant</td><td align="center">通过类似面向对象语言的语法操作数据库，通过对象的方式存取数据。</td></tr><tr><td align="center">xml数据库</td><td align="center">Berkeley DB XML<br/>BaseX</td><td align="center">高效的存储XML数据，并支持XML的内部查询语法，比如XQuery,Xpath。</td></tr></tbody></table><br>]]></content>
      
      
      <categories>
          
          <category> MongoDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>支付宝APP支付接口-Java服务端</title>
      <link href="/2017/05/27/%E6%94%AF%E4%BB%98%E5%AE%9DAPP%E6%94%AF%E4%BB%98%E6%8E%A5%E5%8F%A3-Java%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
      <url>/2017/05/27/%E6%94%AF%E4%BB%98%E5%AE%9DAPP%E6%94%AF%E4%BB%98%E6%8E%A5%E5%8F%A3-Java%E6%9C%8D%E5%8A%A1%E7%AB%AF/</url>
      
        <content type="html"><![CDATA[<h3 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h3><p><a href="https://doc.open.alipay.com/docs/doc.htm?spm=a219a.7629140.0.0.4qQzLr&treeId=204&articleId=105051&docType=1" target="_blank" rel="noopener">官方文档</a><br><a href="https://doc.open.alipay.com/docs/doc.htm?spm=a219a.7629140.0.0.RLJecF&treeId=54&articleId=106370&docType=1" target="_blank" rel="noopener">官方Demo及sdk下载</a></p><a id="more"></a><h3 id="设置支付宝账户有关参数"><a href="#设置支付宝账户有关参数" class="headerlink" title="设置支付宝账户有关参数"></a>设置支付宝账户有关参数</h3><p>接口功能：外部商户App唤起快捷SDK创建订单并支付。</p><pre><code class="java">public class AlipayConfig {    public static final String COMMODITY_SUBJECT = &quot;&quot;;//商品的标题    /**     * 支付宝网关（固定）     */    public static final String URL = &quot;https://openapi.alipay.com/gateway.do&quot;;    /**     * APPID即创建应用后生成     */    public static String APP_ID = &quot;&quot;;    /**     * 开发者应用私钥，由开发者自己生成     */    public static final String APP_PRIVATE_KEY = &quot;XXX&quot;;//设置成自己，也可以需改为可配置的    /**     * 参数返回格式，只支持json     */    public static final String FORMAT = &quot;json&quot;;    /**     * 请求和签名使用的字符编码格式，支持GBK和UTF-8     */    public static final String CHARSET = &quot;UTF-8&quot;;    /**     * 支付宝公钥，由支付宝生成     */    public static String ALIPAY_PUBLIC_KEY = &quot;&quot;;    /**     * 商户生成签名字符串所使用的签名算法类型，目前支持RSA2和RSA，推荐使用RSA2     */    public static final String SIGN_TYPE = &quot;RSA2&quot;;    /**     * 支付宝异步通知地址     */    public static String ALIPAY_NOTIFY_URL = &quot;&quot;;    /**     * 支付超时时间     */    public static String TIMEOUT_EXPRESS = &quot;&quot;;    /**     * 可支付的渠道     */    public static String ENABLE_PAY_CHANNELS = &quot;&quot;;    static {        /**          * 设置配置项，具体请重写          */        Configuration conf = null;        PathUtil pathUtil = new PathUtil();        try {            conf = new Configuration(pathUtil.getWebRoot() + &quot;/WEB-INF/classes/sysconfig.properties&quot;);            ALIPAY_NOTIFY_URL = conf.getValue(&quot;alipay_notify_url&quot;)==null?&quot;&quot;:conf.getValue(&quot;alipay_notify_url&quot;);            TIMEOUT_EXPRESS = conf.getValue(&quot;timeout_express&quot;)==null?&quot;&quot;:conf.getValue(&quot;timeout_express&quot;);            ENABLE_PAY_CHANNELS = conf.getValue(&quot;enable_pay_channels&quot;)==null?&quot;&quot;:conf.getValue(&quot;enable_pay_channels&quot;);            APP_ID = conf.getValue(&quot;appid&quot;)==null?&quot;&quot;:conf.getValue(&quot;appid&quot;);            FileReader fr;            BufferedReader bufr = null;            try {                fr = new FileReader(pathUtil.getWebRoot()+&quot;/WEB-INF/classes/alipay_public_key.txt&quot;);                bufr = new BufferedReader(fr);                ALIPAY_PUBLIC_KEY = bufr.readLine();            } catch (FileNotFoundException e) {                // TODO Auto-generated catch block                e.printStackTrace();            } catch (IOException e) {                // TODO Auto-generated catch block                e.printStackTrace();            } finally{                if(bufr != null){                    try {                        bufr.close();                    } catch (IOException e) {                        // TODO Auto-generated catch block                        e.printStackTrace();                    }                }            }        } catch (IllegalAccessException e) {            // TODO Auto-generated catch block            e.printStackTrace();        }    }    /**     * 销售产品码，商家和支付宝签约的产品码，为固定值QUICK_MSECURITY_PAY     */    public static final String PRODUCT_CODE = &quot;QUICK_MSECURITY_PAY&quot;;}</code></pre><h3 id="获取签名后订单信息"><a href="#获取签名后订单信息" class="headerlink" title="获取签名后订单信息"></a>获取签名后订单信息</h3><p><a href="https://doc.open.alipay.com/docs/doc.htm?spm=a219a.7629140.0.0.9zCNvl&treeId=204&articleId=105465&docType=1" target="_blank" rel="noopener">文档--App支付请求参数说明</a></p><pre><code class="java">/** * 生成APP支付订单信息 * @param amount 总金额 * @param body 商品描述 * @param outTradeNo 订单编码 * @return */public String aliPay(String amount, String body, String outTradeNo) {    // 实例化客户端    AlipayClient alipayClient = new DefaultAlipayClient(AlipayConfig.URL,            AlipayConfig.APP_ID, AlipayConfig.APP_PRIVATE_KEY,            AlipayConfig.FORMAT, AlipayConfig.CHARSET,            AlipayConfig.ALIPAY_PUBLIC_KEY, AlipayConfig.SIGN_TYPE);    // 实例化具体API对应的request类,类名称和接口名称对应,当前调用接口名称：alipay.trade.app.pay    AlipayTradeAppPayRequest request = new AlipayTradeAppPayRequest();    // SDK已经封装掉了公共参数，这里只需要传入业务参数。以下方法为sdk的model入参方式(model和biz_content同时存在的情况下取biz_content)。    AlipayTradeAppPayModel model = new AlipayTradeAppPayModel();    model.setPassbackParams(URLEncoder.encode(body)); // 描述信息 添加附加数据    model.setSubject(AlipayConfig.COMMODITY_SUBJECT); // 商品标题    model.setOutTradeNo(outTradeNo); // 商家订单编号(13位时间戳+4位认证人员信息表id后四位，不足前面补0)    model.setTimeoutExpress(AlipayConfig.TIMEOUT_EXPRESS); // 超时关闭该订单时间    model.setTotalAmount(amount); // 订单总金额    model.setProductCode(AlipayConfig.PRODUCT_CODE); // 销售产品码，商家和支付宝签约的产品码，为固定值QUICK_MSECURITY_PAY    model.setEnablePayChannels(AlipayConfig.ENABLE_PAY_CHANNELS);    request.setBizModel(model);    request.setNotifyUrl(AlipayConfig.ALIPAY_NOTIFY_URL); // 回调地址    String orderStr = &quot;&quot;;    try {        // 这里和普通的接口调用不同，使用的是sdkExecute        AlipayTradeAppPayResponse response = alipayClient                .sdkExecute(request);        orderStr = response.getBody();        System.out.println(orderStr);// 就是orderString 可以直接给客户端请求，无需再做处理。    } catch (AlipayApiException e) {        e.printStackTrace();    }    return orderStr;}</code></pre><h3 id="支付宝支付同步通知"><a href="#支付宝支付同步通知" class="headerlink" title="支付宝支付同步通知"></a>支付宝支付同步通知</h3><p><a href="https://doc.open.alipay.com/docs/doc.htm?spm=a219a.7629140.0.0.JDlYOK&treeId=204&articleId=105302&docType=1" target="_blank" rel="noopener">文档--App支付同步通知参数说明</a></p><blockquote><p>由于同步通知和异步通知都可以作为支付完成的凭证，且异步通知支付宝一定会确保发送给商户服务端。为了简化集成流程，商户可以将同步结果仅仅作为一个支付结束的通知（忽略执行校验），实际支付是否成功，完全依赖服务端异步通知。</p></blockquote><p><strong>忽略该接口</strong></p><h3 id="支付宝异步通知"><a href="#支付宝异步通知" class="headerlink" title="支付宝异步通知"></a>支付宝异步通知</h3><p><a href="https://doc.open.alipay.com/docs/doc.htm?spm=a219a.7629140.0.0.BBz3jJ&treeId=204&articleId=105301&docType=1" target="_blank" rel="noopener">文档--App支付服务器异步通知参数说明</a></p><pre><code class="java">import java.io.IOException;import java.io.PrintWriter;import java.util.HashMap;import java.util.Iterator;import java.util.Map;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.apache.log4j.Logger;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.transaction.annotation.Transactional;import org.springframework.web.bind.annotation.RequestMapping;import com.alipay.api.AlipayApiException;import com.alipay.api.internal.util.AlipaySignature;/** * 支付宝异步通知 * @author bin * */@Controllerpublic class AlipayAsynchronousNotificationREQ {    Logger logger = Logger.getLogger(AlipayAsynchronousNotificationREQ.class);    @Transactional(rollbackFor = Exception.class)    @RequestMapping(&quot;/getAsynchronousNotificationREQ&quot;)    public void getAsynchronousNotificationREQ(HttpServletRequest request,            HttpServletResponse response) throws AlipayApiException,            IOException {        PrintWriter out = response.getWriter();        // 获取支付宝POST过来反馈信息        logger.debug(&quot;支付宝异步回调&quot;);        Map&lt;String, String&gt; params = new HashMap&lt;String, String&gt;();        Map requestParams = request.getParameterMap();        for (Iterator iter = requestParams.keySet().iterator(); iter.hasNext();) {            String name = (String) iter.next();            String[] values = (String[]) requestParams.get(name);            String valueStr = &quot;&quot;;            for (int i = 0; i &lt; values.length; i++) {                valueStr = (i == values.length - 1) ? valueStr + values[i]                        : valueStr + values[i] + &quot;,&quot;;                logger.debug(valueStr);            }            // 乱码解决，这段代码在出现乱码时使用。            // valueStr = new String(valueStr.getBytes(&quot;ISO-8859-1&quot;), &quot;utf-8&quot;);            params.put(name, valueStr);        }        boolean flag = AlipaySignature.rsaCheckV1(params,                AlipayConfig.ALIPAY_PUBLIC_KEY, AlipayConfig.CHARSET,                AlipayConfig.SIGN_TYPE);        if (flag) {            if (&quot;TRADE_SUCCESS&quot;.equals(params.get(&quot;trade_status&quot;))) {                // 订单金额                String amount = params.get(&quot;total_amount&quot;);                // 商户订单号                String out_trade_no = params.get(&quot;out_trade_no&quot;);                // 支付宝交易号                String trade_no = params.get(&quot;trade_no&quot;);                // 买家支付宝用户号                String buyer_id = params.get(&quot;buyer_id&quot;);                // 交易创建时间 格式为yyyy-MM-dd HH:mm:ss                String gmt_create = params.get(&quot;gmt_create&quot;);                // ...                // 添加自己的业务逻辑，如记录交易成功，支付宝返回的信息                // ...                out.print(&quot;success&quot;);                logger.debug(&quot;-----支付宝异步通知成功----&quot;);            } else {                logger.debug(&quot;-----支付宝异步通知，订单未成功付款----&quot;);                out.print(&quot;failure&quot;);            }        } else {            logger.debug(&quot;-----支付宝异步通知，订单验证错误----&quot;);            out.print(&quot;failure&quot;);        }    }}</code></pre><br>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 支付宝 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jython安装及使用</title>
      <link href="/2017/01/01/Jython%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
      <url>/2017/01/01/Jython%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="安装-Jython"><a href="#安装-Jython" class="headerlink" title="安装 Jython"></a>安装 Jython</h1><p>Jython 的官网为 <a href="http://www.jython.org/" target="_blank" rel="noopener">http://www.jython.org</a></p><h2 id="Jython-2-7-0"><a href="#Jython-2-7-0" class="headerlink" title="Jython 2.7.0"></a>Jython 2.7.0</h2><p><a href="http://search.maven.org/remotecontent?filepath=org/python/jython-installer/2.7.0/jython-installer-2.7.0.jar" target="_blank" rel="noopener">Download Jython 2.7.0 - Installer</a> : Executable jar for installing Jython(可以使用 java -jar jython-installer-x.x.x.jar 进行安装)</p><p>参考:<a href="http://0000-bigtree.github.io/blog/2014/01/10/windowsxia-jythonan-zhuang-zhi-nan.html" target="_blank" rel="noopener">Jython 安装配置指南 for Windows</a>，进行安装配置，注意可以添加<code>C:\jython2.7.0\bin</code>到<code>path环境变量</code>，添加JYTHON_HOME变量，值为<code>C:\jython2.7.0</code>。在cmd中 输入<code>jython</code>验证安装成功。</p><p><a href="http://search.maven.org/remotecontent?filepath=org/python/jython-standalone/2.7.0/jython-standalone-2.7.0.jar" target="_blank" rel="noopener">Download Jython 2.7.0 - Standalone Jar</a> : For embedding Jython in Java applications（在Java应用程序中嵌入Jython）</p><a id="more"></a><p>如果要在Java中使用Jython</p><pre><code class="py">import java.io.File;import java.net.URISyntaxException;import java.util.Properties;import org.python.core.PyString;import org.python.util.PythonInterpreter;import com.jav.CompressedFileUtil;public class Test1 {    public static void main(String[] args) {        Properties props = new Properties();        props.put(&quot;python.home&quot;,&quot;/lib/jython.jar&quot;);        props.put(&quot;python.console.encoding&quot;, &quot;UTF-8&quot;); // Used to prevent: console: Failed to install &#39;&#39;: java.nio.charset.UnsupportedCharsetException: cp0.        props.put(&quot;python.security.respectJavaAccessibility&quot;, &quot;false&quot;); //don&#39;t respect java accessibility, so that we can access protected members on subclasses        props.put(&quot;python.import.site&quot;,&quot;false&quot;);        Properties preprops = System.getProperties();        PythonInterpreter.initialize(preprops, props, new String[0]);        //加上上面这些可以解决 UnsupportedCharsetException问题，http://bugs.jython.org/issue2355，也可以在eclipse，run configurations 中在VM arguments 加上-Dpython.console.encoding=UTF-8        PythonInterpreter interpreter = new PythonInterpreter();////      interpreter.exec(&quot;days=(&#39;mod&#39;,&#39;Tue&#39;,&#39;Wed&#39;,&#39;Thu&#39;,&#39;Fri&#39;,&#39;Sat&#39;,&#39;Sun&#39;); &quot;);//      interpreter.exec(&quot;print days[1];&quot;); //可以直接执行Python语句        String path = &quot;&quot;;        try {            path = new File(new CompressedFileUtil().getClass().getClassLoader().getResource(&quot;&quot;).toURI()).getPath();        } catch (URISyntaxException e) {            // TODO Auto-generated catch block            e.printStackTrace();        }        interpreter.exec(&quot;url = &#39;http://XXX.com/xxxx.html&#39;&quot;);//可以直接执行Python语句        interpreter.execfile(path + &quot;\\agenttest.py&quot;);        PyString  res = (PyString)interpreter.get(&quot;host&quot;); //可以获得到Python中的变量值        System.out.println(res);    }}</code></pre><p>参考：<a href="http://blog.csdn.net/xingjiarong/article/details/49424253" target="_blank" rel="noopener">java调用python方法总结</a></p><br>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Python基础教程》读书笔记10-模块，标准库</title>
      <link href="/2017/01/01/%E3%80%8APython%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B010-%E6%A8%A1%E5%9D%97%EF%BC%8C%E6%A0%87%E5%87%86%E5%BA%93/"/>
      <url>/2017/01/01/%E3%80%8APython%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B010-%E6%A8%A1%E5%9D%97%EF%BC%8C%E6%A0%87%E5%87%86%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><h3 id="使用-dir"><a href="#使用-dir" class="headerlink" title="使用 dir"></a>使用 dir</h3><p>dir 函数可以将对象的所有属性（以及模块的所有函数、类、变量等）列出。</p><a id="more"></a><pre><code class="py">&gt;&gt;&gt; import copy&gt;&gt;&gt; dir(copy)[&#39;Error&#39;, &#39;PyStringMap&#39;, &#39;_EmptyClass&#39;, &#39;__all__&#39;, &#39;__builtins__&#39;, &#39;__cached__&#39;, &#39;__doc__&#39;, &#39;__file__&#39;, &#39;__loader__&#39;, &#39;__name__&#39;, &#39;__package__&#39;, &#39;__spec__&#39;, &#39;_copy_dispatch&#39;, &#39;_copy_immutable&#39;, &#39;_copy_with_constructor&#39;, &#39;_copy_with_copy_method&#39;, &#39;_deepcopy_atomic&#39;, &#39;_deepcopy_dict&#39;, &#39;_deepcopy_dispatch&#39;, &#39;_deepcopy_list&#39;, &#39;_deepcopy_method&#39;, &#39;_deepcopy_tuple&#39;, &#39;_keep_alive&#39;, &#39;_reconstruct&#39;, &#39;builtins&#39;, &#39;copy&#39;, &#39;deepcopy&#39;, &#39;dispatch_table&#39;, &#39;error&#39;, &#39;name&#39;, &#39;t&#39;, &#39;weakref&#39;]&gt;&gt;&gt; [n  for n in dir(copy) if not n.startswith(&#39;_&#39;)][&#39;Error&#39;, &#39;PyStringMap&#39;, &#39;builtins&#39;, &#39;copy&#39;, &#39;deepcopy&#39;, &#39;dispatch_table&#39;, &#39;error&#39;, &#39;name&#39;, &#39;t&#39;, &#39;weakref&#39;]</code></pre><h3 id="all变量"><a href="#all变量" class="headerlink" title="all变量"></a><strong>all</strong>变量</h3><pre><code class="py">&gt;&gt;&gt; copy.__all__[&#39;Error&#39;, &#39;copy&#39;, &#39;deepcopy&#39;]</code></pre><p>如果使用 <code>from copy import *</code>，那么就只能使用 <code>__all__</code> 变量中的函数。如果要使用其他函数，则需要 <code>from copy import XXX</code>。</p><h3 id="用-help-获取帮助"><a href="#用-help-获取帮助" class="headerlink" title="用 help 获取帮助"></a>用 help 获取帮助</h3><p>用 help 含函数与查看函数文档字符串相比，可以获得更多信息，比如所带参数。</p><pre><code class="py">&gt;&gt;&gt; help(copy.copy)Help on function copy in module copy:copy(x)    Shallow copy operation on arbitrary Python objects.    See the module&#39;s __doc__ string for more info.&gt;&gt;&gt; print(copy.copy.__doc__)Shallow copy operation on arbitrary Python objects.    See the module&#39;s __doc__ string for more info.</code></pre><h3 id="查看源代码"><a href="#查看源代码" class="headerlink" title="查看源代码"></a>查看源代码</h3><pre><code class="py">&gt;&gt;&gt; print (copy.__file__)C:\python3.5\lib\copy.py</code></pre><h2 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h2><h3 id="sys"><a href="#sys" class="headerlink" title="sys"></a>sys</h3><ol><li>变量<code>sys.argv</code>包含传递到Python解释器的参数，包括脚本名称。</li><li>函数<code>sys.exit</code>可以退出当前程序，大多数使用默认参数<code>0</code>，表示成功，也可以使用字符串用作错误信息。</li><li>映射<code>sys.modules</code>将模块名映射到实际存在的模块上，只应用于目前导入的模块。</li><li>变量<code>sys.path</code>一个字符串列表，解释器将从这些目录中查找模块。</li><li>变量<code>sys.platform</code>一个字符串，平台的名称，如：操作系统名字（win32），运行<code>Jython</code>就是java虚拟机（java1.6.12）.</li><li>变量<code>sys.stdin</code>,<code>sys.stdout</code>,<code>sys.stderr</code>，类文件流对象，标准输入、标准输出和标准错误。</li></ol><p>写一个脚本 test.py</p><pre><code class="py">import sysargs = sys.argv[1:] # 第一个参数是脚本的名字args.reverse()print(&#39; &#39;.join(args))</code></pre><p>在 Shell 中运行，或 MS-DOS 中运行</p><pre><code class="shell">$ python test.py this is a testtest a is this</code></pre><h3 id="fileinput"><a href="#fileinput" class="headerlink" title="fileinput"></a>fileinput</h3><p>遍历文本文件的所有行。</p><ol><li><code>fileinput.input([files[, inplace[, backup]]])</code>，返回能够用于for循环遍历的对象。<br>（1）files，序列或字符串，提供一个或多个文件名。<br>（2）inplace，布尔值，是否进行原地处理，对于要访问的每一行，需要打印出替代的内容，以返回到当前的输入文件中。容易破坏文件，应该在不使用这个参数时，仔细测试程序，确保正确后再修改文件。<br>（3）backup，当inplace为True时，backup参数将文件名扩展备份到通过原始文件创建的备份文件中。</li><li><code>fileinput.filename()</code>函数返回当前正在处理的文件名。</li><li><code>fileinput.lineon()</code>函数返回当前行数。如果处理多个文件，这个值是累计的，处理下一个文件时，行数不会重置。</li><li><code>fileinput.isfirstline()</code>函数判断当前行是否是当前文件的第一行，是返回True，否返回False。</li><li><code>fileinput.isstdin()</code>函数在当前文件为<code>sys.stdin</code>时返回真值，否则假值。</li><li><code>fileinput.nextfile()</code>函数会关闭当前文件，跳到下一个文件，跳过的行并不计。</li><li><code>fileinput.close()</code>函数关闭整个文件链。结束迭代。</li></ol><pre><code class="py"># numberlines.py# 为文本文件添加行号import fileinputfor line in fileinput.input(inplace=True):    line = line.rstrip()    num = fileinput.lineno()    print (&#39;%-40s # %2i&#39; % (line, num))</code></pre><p>运行程序</p><pre><code class="shell">$ python numberlines.py numberlines.py</code></pre><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>位于i位置上的元素总比i/2位置上的元素大（反之来说就是i位置上的元素总比2*i以及2*i+1位置上的元素小）。</p><p>Python中没有堆类型，有一个包含一些堆操作函数的模块，这个模块叫做<code>heapq</code>（<code>q</code>是<code>queue</code>的缩写，即队列）</p><h4 id="heappush函数"><a href="#heappush函数" class="headerlink" title="heappush函数"></a>heappush函数</h4><p><code>heappush</code> 函数用于增加堆的项。只能用于通过各种堆函数建立的列表中，不能是之前的普通列表。</p><pre><code class="py">&gt;&gt;&gt; from heapq import *&gt;&gt;&gt; from random import shuffle&gt;&gt;&gt; data = range(10)&gt;&gt;&gt; shuffle(data) # Python2.7不会报错，Python 3.5会报错，range() 返回的是“range object”，而不是实际的list 值Traceback (most recent call last):  File &quot;&lt;pyshell#54&gt;&quot;, line 1, in &lt;module&gt;    shuffle(data)  File &quot;C:\python3.5.2\lib\random.py&quot;, line 272, in shuffle    x[i], x[j] = x[j], x[i]TypeError: &#39;range&#39; object does not support item assignment&gt;&gt;&gt; data = list(range(10))&gt;&gt;&gt; shuffle(data)&gt;&gt;&gt; data[2, 5, 8, 0, 6, 3, 1, 7, 4, 9]&gt;&gt;&gt; heap = []&gt;&gt;&gt; for n in data:    heappush(heap, n)&gt;&gt;&gt; heappush(heap, 0.5)&gt;&gt;&gt; heap[0, 0.5, 1, 4, 2, 8, 3, 7, 5, 9, 6]</code></pre><h4 id="heappop-函数"><a href="#heappop-函数" class="headerlink" title="heappop 函数"></a>heappop 函数</h4><p><code>heappop</code> 函数弹出最小的元素，一般就是索引0处的元素。</p><pre><code class="py">&gt;&gt;&gt; heappop(heap)0&gt;&gt;&gt; heappop(heap)0.5&gt;&gt;&gt; heappop(heap)1&gt;&gt;&gt; heap[2, 4, 3, 5, 9, 8, 6, 7]</code></pre><h4 id="heapify-函数"><a href="#heapify-函数" class="headerlink" title="heapify 函数"></a>heapify 函数</h4><p><code>heapify</code> 函数使用任意列表作为参数，并将其转换为合法的堆。</p><pre><code class="py">&gt;&gt;&gt; heap = [3, 5, 6, 8, 4, 2, 7, 1, 9]&gt;&gt;&gt; heapify(heap)&gt;&gt;&gt; heap[1, 3, 2, 5, 4, 6, 7, 8, 9]</code></pre><h4 id="heapreplace-函数"><a href="#heapreplace-函数" class="headerlink" title="heapreplace 函数"></a>heapreplace 函数</h4><p><code>heapreplace</code> 函数弹出堆的最小元素，并将新元素推入。这样比 heappop 之后再调用 heappush 更高效。</p><pre><code class="py">&gt;&gt;&gt; heap[1, 3, 2, 5, 4, 6, 7, 8, 9]&gt;&gt;&gt; heapreplace(heap, 0.5)1&gt;&gt;&gt; heapreplace(heap, 10)0.5&gt;&gt;&gt; heap[2, 3, 6, 5, 4, 10, 7, 8, 9]</code></pre><h4 id="nlargest-n-iter"><a href="#nlargest-n-iter" class="headerlink" title="nlargest(n, iter)"></a>nlargest(n, iter)</h4><p>返回 <code>iter</code> 中第 <code>n</code> 大的元素。</p><h4 id="nsmllest-n-iter"><a href="#nsmllest-n-iter" class="headerlink" title="nsmllest(n, iter)"></a>nsmllest(n, iter)</h4><p>返回 <code>iter</code> 中第 <code>n</code> 小的元素。</p><h3 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h3><p>双端队列（double-ended queue，或称deque），<code>collections</code> 模块。</p><pre><code class="py">&gt;&gt;&gt; from collections import deque&gt;&gt;&gt; q = deque(range(5))&gt;&gt;&gt; qdeque([0, 1, 2, 3, 4])&gt;&gt;&gt; q.append(5)&gt;&gt;&gt; q.appendleft(6)&gt;&gt;&gt; qdeque([6, 0, 1, 2, 3, 4, 5])&gt;&gt;&gt; q.pop()5&gt;&gt;&gt; q.popleft()6&gt;&gt;&gt; q.rotate(3) # 元素左移3个，或者说指针，指向第一个元素的指针&gt;&gt;&gt; qdeque([2, 3, 4, 0, 1])&gt;&gt;&gt; q.rotate(-1) # 元素右移1个&gt;&gt;&gt; qdeque([3, 4, 0, 1, 2])</code></pre><h3 id="shelve"><a href="#shelve" class="headerlink" title="shelve"></a>shelve</h3><p>在文件中存储数据，进行普通字典(键是字符串)来操作。</p><pre><code class="py">&gt;&gt;&gt; import shelve&gt;&gt;&gt; s = shelve.open(r&#39;C:\Users\bin\Desktop\python\test\shelve.dat&#39;) # Python3.5，2.7，目录中有这个shelve.dat文件，且文件不是shelve创建的，就会报错，Traceback (most recent call last):  File &quot;&lt;pyshell#37&gt;&quot;, line 1, in &lt;module&gt;    s = shelve.open(r&#39;C:\Users\bin\Desktop\python\test\shelve.dat&#39;)  File &quot;C:\python3.5.2\lib\shelve.py&quot;, line 243, in open    return DbfilenameShelf(filename, flag, protocol, writeback)  File &quot;C:\python3.5.2\lib\shelve.py&quot;, line 227, in __init__    Shelf.__init__(self, dbm.open(filename, flag), protocol, writeback)  File &quot;C:\python3.5.2\lib\dbm\__init__.py&quot;, line 88, in open    raise error[0](&quot;db type could not be determined&quot;)dbm.error: db type could not be determined&gt;&gt;&gt; s = shelve.open(r&#39;C:\Users\bin\Desktop\python\test\shelve.dat&#39;) # 如果源文件不存在 Python3.5 会生成shelve.dat.dat文件，文件大小0kb。# 如果源文件不存在 Python2.7 会生成shelve.dat文件，文件大小24kb&gt;&gt;&gt; s[&#39;x&#39;] = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] # Python3.5 生成shelve.dat.dir文件&gt;&gt;&gt; s[&#39;x&#39;].append(&#39;d&#39;)&gt;&gt;&gt; s[&#39;x&#39;] # 刚新增的&#39;d&#39;，不存在[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]&gt;&gt;&gt; temp = s[&#39;x&#39;] # 可以这么做，保存在临时变量中，再新增&#39;d&#39;，最后重新存储这个副本&gt;&gt;&gt; temp.append(&#39;d&#39;)&gt;&gt;&gt; s[&#39;x&#39;] = temp&gt;&gt;&gt; s[&#39;x&#39;][&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]&gt;&gt;&gt; s.close() # 记得关闭 Python3.5 生成shelve.dat.bak文件</code></pre><pre><code class="py"># 也可以将open函数的writeback参数设置为True，这样所有读取或赋值操作都会保存在内存中，在close后保存到磁盘中。数据小可以这么做。&gt;&gt;&gt; s = shelve.open(r&#39;C:\Users\bin\Desktop\python\test\shelve.dat&#39;,writeback=True)&gt;&gt;&gt; s[&#39;x&#39;].append(&#39;e&#39;)&gt;&gt;&gt; s[&#39;x&#39;][&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]&gt;&gt;&gt; s.close()</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Python基础教程》读书笔记09-魔法方法、属性和迭代器</title>
      <link href="/2017/01/01/%E3%80%8APython%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B009-%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95%E3%80%81%E5%B1%9E%E6%80%A7%E5%92%8C%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
      <url>/2017/01/01/%E3%80%8APython%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B009-%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95%E3%80%81%E5%B1%9E%E6%80%A7%E5%92%8C%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><p>一个对象被创建后，会立即调用构造方法。</p><pre><code class="py">class FooBar:    def __init__(self): # 也可以有参数        self.somevar = 42&gt;&gt;&gt; f = FooBar()&gt;&gt;&gt; f.somevar42</code></pre><a id="more"></a><h1 id="super-函数"><a href="#super-函数" class="headerlink" title="super 函数"></a>super 函数</h1><pre><code class="py">class Bird:    def __init__(self):        self.hungry = True    def eat(self):        if self.hungry:            print (&#39;Aaaah...&#39;)            self.hungry = False        else:            print (&#39;No, thanks!&#39;)class SongBird(Bird):    def __init__(self):        super(SongBird, self).__init__() # Python3 可以 super().__init__()，super 函数不带任何参数调用        # 在老版本中没有 super 函数，可以 Bird.__init__(self)，新式类中就不要这么做了，因为如果继承了多个类        self.sound = &#39;Squawk!&#39;    def sing(self):        print (self.sound)&gt;&gt;&gt; sb = SongBird()&gt;&gt;&gt; sb.sing()Squawk!&gt;&gt;&gt; sb.eat()Aaaah...</code></pre><h1 id="基本的序列和映射规则"><a href="#基本的序列和映射规则" class="headerlink" title="基本的序列和映射规则"></a>基本的序列和映射规则</h1><p>如果对象是不可变，只有两个方法，可变 4 个方法</p><ol><li><code>__len__(self)</code>：返回集合中的元素数，如果 <code>__len__</code> 返回 <code>0</code>（而且没重写该行为的 <code>__nonzero__</code>），对象会被当作一个布尔变量中的假值。</li><li><code>__getitem__(self, key)</code>：返回所给键对应的值。</li><li><code>__setitem__(self, key, value)</code>：</li><li><code>__delitem__(self, key)</code>：在对象使用 del 语句时被调用，同时必修删除和键相关的键。</li></ol><p>对于这些方法的附加要求：</p><ul><li>对于一个序列，如果键是负数，那么要从末尾开始计数，即 <code>x[-n]</code> 和 <code>x[len(x)-n]</code> 是一样的</li><li>如果键是不合适的类型（如：序列使用字符串作为键），会引发一个 TypeError 异常。</li><li>如果索引超出了范围，引发 IndexError 异常。</li></ul><p>子类化列表，字典和字符串</p><p>标准库有3个关于序列和映射规则（UserList、UserString 和 UserDict）可以立即使用的实现</p><p>也可以子类化内建类型（list、str 和 dict）</p><h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><p>通过访问器定义的特性被称为属性</p><pre><code class="py">class Rectangle:    def __init__(self):        self.width = 0        self.height = 0    def setSize(self, size):        self.width, self.height = size    def getSize(self):        return self.width, self.height&gt;&gt;&gt; r = Rectangle()&gt;&gt;&gt; r.width = 10&gt;&gt;&gt; r.height = 5&gt;&gt;&gt; r.getSize()(10, 5)&gt;&gt;&gt; r.setSize((150, 100))&gt;&gt;&gt; r.width150</code></pre><p>上面的例子中，如果 size 需要称为真正的特性，并不修改 getSize 和 setSize 方法</p><h2 id="property-函数"><a href="#property-函数" class="headerlink" title="property 函数"></a>property 函数</h2><p>只需要添加一句话</p><pre><code class="py">size = property(getSize, setSize)</code></pre><p>size 特性仍然取决于 getSize 和 setSize 中的计算，但他们看起来就像普通的属性一样。</p><p><code>property</code> 函数有四个参数<code>(fget, fset, fdel, doc)</code></p><ul><li>没有参数，产生的属性不可读不可写</li><li>只有一个参数调用（一个取值的方法），产生的属性只读</li><li>只有第二个参数（用关键字参数），属性只写</li><li>第三个参数是一个用于删除的特性的方法（这个方法不要参数）</li><li>第四个参数是一个文档字符串</li></ul><p>实际上，<code>property</code> 函数不是一个真正的函数，它是其实例拥有很多特殊方法的类。<code>__get__</code>, <code>__set__</code> 和 <code>__delete__</code>，这3个方法合在一起，就定义了描述符的规则。实现了其中任何一个方法的对象就叫<strong>描述符</strong>。描述符的特殊之处在于它们如何被访问的，如，程序读取一个特性时（尤其是在实例中访问该特性，但该特性在类中定义时），<strong>如果该特性被绑定到实现了 <code>__get__</code> 方法的对象上，那么就会调用 <code>__get__</code> 方法</strong>（结果值也会被返回）。</p><h2 id="静态方法和类成员方法"><a href="#静态方法和类成员方法" class="headerlink" title="静态方法和类成员方法"></a>静态方法和类成员方法</h2><p>静态方法 没有 self 参数</p><p>类成员方法 需要有 cls 参数，可以由类的对象调用，但 cls 参数是自动被绑定到类的</p><pre><code class="py">class MyClass:    @staticmethod    def smeth():        print (&quot;静态方法&quot;)    # smeth = staticmethod(smeth)  # 也可以这样    @classmethod    def cmeth(cls):        print (&quot;类成员方法&quot;, cls)    # cmeth = classmethod(cmeth)   # 也可以这样&gt;&gt;&gt; MyClass.smeth()静态方法&gt;&gt;&gt; MyClass.cmeth()类成员方法 &lt;class &#39;__main__.MyClass&#39;&gt;&gt;&gt;&gt; x = MyClass()&gt;&gt;&gt; x.smeth() # 对象也可以调用静态方法&gt;&gt;&gt; x.cmeth()类成员方法 &lt;class &#39;__main__.MyClass&#39;&gt;</code></pre><h2 id="拦截对象的所有特性访问"><a href="#拦截对象的所有特性访问" class="headerlink" title="拦截对象的所有特性访问"></a>拦截对象的所有特性访问</h2><ul><li><code>__getattribute__(self, name)</code>：当特性 name 被访问时自动被调用</li><li><code>__getattr__(self, name)</code>：当特性 name 被访问且对象没有相应的特性时被调用</li><li><code>__setattr__(self, name, value)</code>：当试图给特性 name 赋值时会被自动调用</li><li><code>__delattr__(self, name)</code>：当试图删除特性 name 时被自动调用</li></ul><pre><code class="py">&gt;&gt;&gt; class Rectangle:    def __init__(self):        self.width = 0        self.height = 0    def __setattr__(self, name, value):        if name == &#39;size&#39;:            self.width, self.height = value        else:            self.__dict__[name] = value # __dict__方法包含一个字典，是所有实例的属性    def __getattr__(self, name):        if name == &#39;size&#39;:            return self.width, self.height        else:            raise AttributeError&gt;&gt;&gt; r = Rectangle()&gt;&gt;&gt; r.size(0, 0)&gt;&gt;&gt; r.width = 100&gt;&gt;&gt; r.height = 200&gt;&gt;&gt; r.size(100, 200)&gt;&gt;&gt; r.size = (10,20)&gt;&gt;&gt; r.width10</code></pre><ul><li><code>__setattr__</code> 方法在所涉及的特性不是 size 时也会被调用。</li><li><code>__getattr__</code> 方法<strong>只在普通的特性没有被找到的时候调用</strong>，可以使用 hasattr，getattr 函数找到 size 属性。</li><li><code>__getattribute__</code> 方法会拦截所有特性的访问，也拦截 <code>__dict__</code> 的访问。访问 <code>__getattribute__</code> 中与 <code>self</code> 相关的特性时，使用超类的 <code>__getattribute__</code> 方法（super 函数）是唯一安全的途径。</li></ul><h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p><code>__iter__</code> 方法是迭代器规则的基础，返回一个迭代器（iterator），所谓的迭代器就是具有 <code>next</code> 方法（不需要参数）的对象。在调用 <code>next</code> 方法时，迭代器会返回它的下一个值。</p><p>Python3.0，迭代器应该实现 <code>__next__</code> 方法，而不是 next。而新的内建函数 <code>next</code> 可以访问这个方法，即：<code>next(it)</code> 等同于之前的版本中的 <code>it.next()</code>。</p><p><strong>一个实现了 <code>__iter__</code> 方法的对象是可迭代的，一个实现了 <code>next</code>(<code>__next__</code>) 方法的对象则是迭代器。</strong></p><pre><code class="py">&gt;&gt;&gt; class Fibs:    def __init__(self):        self.a = 0        self.b = 1    def __next__(self):        self.a, self.b = self.b, self.a + self.b        return self.a    def __iter__(self):        return self&gt;&gt;&gt; fibs = Fibs()&gt;&gt;&gt; for f in fibs:    if f &gt; 1000:        print (f)        break1597</code></pre><h2 id="内建函数-iter"><a href="#内建函数-iter" class="headerlink" title="内建函数 iter"></a>内建函数 <code>iter</code></h2><p>可以从可迭代的对象中获得迭代器</p><pre><code class="py">&gt;&gt;&gt; it = iter([1, 2, 3])&gt;&gt;&gt; next(it) #Pyhton2.7  it.next()1</code></pre><h2 id="从迭代器得到序列"><a href="#从迭代器得到序列" class="headerlink" title="从迭代器得到序列"></a>从迭代器得到序列</h2><p>使用 <code>list</code> 构造方法将迭代器转化为列表</p><pre><code class="py">&gt;&gt;&gt; class TextIterator:    value = 0    def __next__(self):        self.value += 1        if self.value &gt; 10: raise StopIteration        return self.value    def __iter__(self):        return self&gt;&gt;&gt; t = TextIterator()&gt;&gt;&gt; list(t)[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</code></pre><h1 id="生成器-generator"><a href="#生成器-generator" class="headerlink" title="生成器 generator"></a>生成器 generator</h1><p>要创建一个generator，有很多种方法。第一种方法很简单，只要把一个列表生成式的[]改成()，就创建了一个generator：</p><pre><code class="py">&gt;&gt;&gt; L = [x * x for x in range(10)]  # list&gt;&gt;&gt; L[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]&gt;&gt;&gt; g = (x * x for x in range(10))  # generator&gt;&gt;&gt; g&lt;generator object &lt;genexpr&gt; at 0x1022ef630&gt;# 可以通过next()函数获得generator的下一个返回值：&gt;&gt;&gt; next(g)0...# 直到计算到最后一个元素，没有更多的元素时，抛出 StopIteration 的错误。&gt;&gt;&gt; next(g)Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;StopIteration</code></pre><p>按顺序打印列表中的数字 <code>nested = [[1, 2], [3, 4], [5]]</code></p><pre><code class="py">&gt;&gt;&gt; def flatten(nested):    for sublist in nested:        for element in sublist:            yield element    return 123  # for 循环，无法获得该值&gt;&gt;&gt; nested = [[1, 2], [3, 4], [5]]&gt;&gt;&gt; for num in flatten(nested):    print (num)12345&gt;&gt;&gt; list(flatten(nested))[1, 2, 3, 4, 5]</code></pre><p>用 for 循环调用 generator 时，发现拿不到 generator 的 return 语句的返回值。如果想要拿到返回值，必须捕获 <code>StopIteration</code> 错误，返回值包含在 <code>StopIteration</code> 的 <code>value</code> 中：</p><pre><code class="py">&gt;&gt;&gt; a = flatten(nested)&gt;&gt;&gt; next(a)1&gt;&gt;&gt; next(a)2&gt;&gt;&gt; a.__next__()3&gt;&gt;&gt; a.__next__()4&gt;&gt;&gt; a.__next__()5&gt;&gt;&gt; try:        x = next(a)    except StopIteration as e:        print(&#39;Generator return value:&#39;, e.value)Generator return value: 111</code></pre><p>任何包含 <code>yield</code> 语句的函数称为<strong>生成器</strong>。每次产生一个值，函数就会被冻结：即函数停在那点等待被重新唤醒。</p><h2 id="生成器推导式"><a href="#生成器推导式" class="headerlink" title="生成器推导式"></a>生成器推导式</h2><pre><code class="py">&gt;&gt;&gt; g = ((i+2)**2 for i in range(2,27))&gt;&gt;&gt; next(g) # Python2.7   g.next()16</code></pre><p>和列表推导式的不同，使用普通括号 <code>()</code>，这个例子还是列表推导式好，但如果生成大量的值，还是生成器推导式好。<br>在函数调用中，不用另外加一对括号 <code>sum(i**2 for i in range(0,10))</code></p><h2 id="递归生成器"><a href="#递归生成器" class="headerlink" title="递归生成器"></a>递归生成器</h2><p>如果要处理任意层的嵌套。</p><pre><code class="py">&gt;&gt;&gt; def flatten(nested):    try:        # 不要迭代类似字符串的对象        try: nested + &#39;&#39; # 这是检查一个对象是不是类似于字符串对象的最简单最快速的方法        except TypeError: pass        else: raise TypeError # 检查字符串 end        for sublist in nested:            for element in flatten(sublist):                yield element    except TypeError: # 如果对一个数字进行迭代        yield nested&gt;&gt;&gt; list(flatten([[[1],2],3,4,[5,[6,7]],8]))[1, 2, 3, 4, 5, 6, 7, 8]</code></pre><h2 id="生成器方法"><a href="#生成器方法" class="headerlink" title="生成器方法"></a>生成器方法</h2><p><code>send</code> 方法，生成器和外部进行交流的渠道。需要一个参数（需要发送的消息——任意对象）</p><p>在内部挂起生成器（<code>yield</code> 方法执行一次），<code>yield</code> 作为表达式而不是语句使用。</p><p>即：当生成器重新运行的时候，<code>yield</code> 方法返回一个值，也就是外部通过 <code>send</code> 方法发送的值，如果 <code>next</code> 方法被使用，那么 <code>yield</code> 方法返回 <code>None</code>。</p><pre><code class="py">&gt;&gt;&gt; def re(value):    while True:        new = (yield value) # 安全起见，加上括号        if new is not None:            print (&#39;yield--Send&#39;)            value = new&gt;&gt;&gt; r = re(42)&gt;&gt;&gt; r.next()42&gt;&gt;&gt; r.next() # 因为while True，可以重复调用r.next()，yield方法返回None42&gt;&gt;&gt; r.send(&#39;hello, world!&#39;)yield--Send&#39;hello, world!&#39;</code></pre><pre><code class="py">&gt;&gt;&gt; nested = [[1, 2], [3]]&gt;&gt;&gt; def flatten(nested):    for sublist in nested:        for element in sublist:            new = (yield element)            if new is not None:                print (&#39;new = &#39; + new)                # element = new # 这里不知道怎么可以让迭代器返回 new&gt;&gt;&gt; x = flatten(nested)&gt;&gt;&gt; x.next()1&gt;&gt;&gt; x.send(&#39;test&#39;)new = test2&gt;&gt;&gt; x.send(&#39;test2&#39;)new = test23&gt;&gt;&gt; x.send(&#39;test3&#39;)new = test3Traceback (most recent call last):  File &quot;&lt;pyshell#113&gt;&quot;, line 1, in &lt;module&gt;    x.send(&#39;test5&#39;)StopIteration</code></pre><p>生成器的两个方法</p><ol><li>throw 方法，使用异常类型调用，还有可选值以及回溯对象，用于在生成器中引发一个异常（在 yield 表达式中）</li><li>close 方法，调用时不用参数，用于停止生成器</li></ol><h2 id="模拟生成器"><a href="#模拟生成器" class="headerlink" title="模拟生成器"></a>模拟生成器</h2><pre><code class="py">&gt;&gt;&gt; def flatten(nested):    result = []    try:        for sublist in nested:            for element in flatten(sublist):                result.append(element)    except TypeError:        result.append(nested)    return result</code></pre><h1 id="八皇后问题"><a href="#八皇后问题" class="headerlink" title="八皇后问题"></a>八皇后问题</h1><p>水平垂直对角线，只能有一个皇后，n 个皇后则棋盘 n*n</p><pre><code class="py"># 判断下一个的皇后位置会不会有冲突def conflict(state, nextX): # nextX：X坐标；如果state[0] = 3，代表第一行的皇后在第四列    nextY = len(state) # nextY：Y坐标    for i in range(nextY):        if abs(state[i] - nextX) in (0, nextY - i):            return True    return Falsedef queens(num=8, state=()):    for pos in range(num):        if not conflict(state, pos):            if len(state) == num - 1: # 最后一个皇后位置                yield (pos,)            else:                for result in queens(num, state + (pos,)):                    yield (pos,) + result&gt;&gt;&gt; list(queens(4))[(1, 3, 0, 2), (2, 0, 3, 1)]</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Python基础教程》读书笔记08-异常</title>
      <link href="/2017/01/01/%E3%80%8APython%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B008-%E5%BC%82%E5%B8%B8/"/>
      <url>/2017/01/01/%E3%80%8APython%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B008-%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<p><strong>尽可能使用 <code>try/except</code> 语句</strong></p><h1 id="raise-语句"><a href="#raise-语句" class="headerlink" title="raise 语句"></a>raise 语句</h1><p>抛出异常</p><pre><code class="py">raise Exception(&#39;出错啦&#39;) # 参数可选# Traceback (most recent call last):#   File &quot;&lt;pyshell#117&gt;&quot;, line 1, in &lt;module&gt;#     raise Exception(&#39;出错啦&#39;)# Exception: 出错啦</code></pre><a id="more"></a><h1 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h1><p>继承 Exception 即可</p><pre><code class="py">class MyException(Exception):    pass</code></pre><h1 id="捕捉异常"><a href="#捕捉异常" class="headerlink" title="捕捉异常"></a>捕捉异常</h1><p>try except finally</p><h2 id="捕捉多个异常"><a href="#捕捉多个异常" class="headerlink" title="捕捉多个异常"></a>捕捉多个异常</h2><pre><code class="py">try:    1/0except (ZeroDivisionError, TypeError, NameError):    print(&quot;出错啦&quot;)# 出错啦</code></pre><h1 id="异常对象"><a href="#异常对象" class="headerlink" title="异常对象"></a>异常对象</h1><h2 id="Python2-7"><a href="#Python2-7" class="headerlink" title="Python2.7"></a>Python2.7</h2><pre><code class="py">try:    1/0except (ZeroDivisionError, TypeError), e:    print e# integer division or modulo by zero</code></pre><h2 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h2><pre><code class="py">try:    1/0except (ZeroDivisionError, TypeError) as e:    print(e)# division by zero</code></pre><h1 id="全捕捉"><a href="#全捕捉" class="headerlink" title="全捕捉"></a>全捕捉</h1><pre><code class="py">try:    1/0except: # 一般还是用 except Exception, e    print(&quot;出错啦&quot;)# 出错啦</code></pre><h1 id="else"><a href="#else" class="headerlink" title="else"></a>else</h1><p>没有发生异常运行</p><pre><code class="py">try:    print(1/1)except:    print(&quot;出错啦&quot;)else:    print(&#39;运算完成&#39;)# 1.0# 运算完成</code></pre><h1 id="异常中的信息"><a href="#异常中的信息" class="headerlink" title="异常中的信息"></a>异常中的信息</h1><blockquote><p><a href="https://www.cnblogs.com/klchang/p/4635040.html" target="_blank" rel="noopener">Python中获取异常（Exception）信息</a></p></blockquote><pre><code class="py">try:    1/0except Exception, e    print(e)</code></pre><ol><li>str(e)<br> 返回字符串类型，只给出异常信息，不包括异常信息的类型，如 1/0 的异常信息 <code>division by zero</code></li><li>repr(e)<br> 给出较全的异常信息，包括异常信息的类型，如 1/0 的异常信息 <code>ZeroDivisionError(&#39;division by zero&#39;,)</code></li><li>e.message<br> Python 3 不可用，Python 2.7 可用，获得的信息同 str(e)</li></ol><h1 id="采用-traceback-模块"><a href="#采用-traceback-模块" class="headerlink" title="采用 traceback 模块"></a>采用 traceback 模块</h1><p>需要导入 traceback 模块，此时获取的信息最全，与 python 命令行运行程序出现错误信息一致。</p><ul><li>使用 <code>traceback.print_exc()</code> 打印异常信息到标准错误，<strong>就像没有获取一样</strong>。</li><li>使用 <code>traceback.format_exc()</code> 将同样的输出获取为字符串。你可以向这些函数传递各种各样的参数来限制输出，或者重新打印到像文件类型的对象。</li></ul><pre><code class="py">import tracebacktry:    1/0except Exception as e:    print(traceback.print_exc())# Traceback (most recent call last):#   File &quot;&lt;pyshell#166&gt;&quot;, line 2, in &lt;module&gt;# ZeroDivisionError: division by zero# Nonetry:    1/0except Exception as e:    print (traceback.format_exc())# Traceback (most recent call last):#   File &quot;&lt;pyshell#168&gt;&quot;, line 2, in &lt;module&gt;# ZeroDivisionError: division by zero</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Python基础教程》读书笔记07-更加抽象</title>
      <link href="/2017/01/01/%E3%80%8APython%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B007-%E6%9B%B4%E5%8A%A0%E6%8A%BD%E8%B1%A1/"/>
      <url>/2017/01/01/%E3%80%8APython%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B007-%E6%9B%B4%E5%8A%A0%E6%8A%BD%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<p>多态，封装，继承</p><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><pre><code class="py">class Class:  # 类    def method(self):        print (&quot;self&quot;)    def function():        print (&quot;function&quot;)def func():  # 普通方法    print (&quot;func&quot;)&gt;&gt;&gt; x = Class()  # 对象&gt;&gt;&gt; x.method()self&gt;&gt;&gt; x.function()  # 对象调用方法，需要有self参数(可以是别的名字)Traceback (most recent call last):  File &quot;&lt;pyshell#43&gt;&quot;, line 1, in &lt;module&gt;    x.funvtion()TypeError: funvtion() takes 0 positional arguments but 1 was given&gt;&gt;&gt; Class.method()  # 当然 类名 也不能调用实例方法Traceback (most recent call last):  File &quot;&lt;pyshell#41&gt;&quot;, line 1, in &lt;module&gt;    Class.method()TypeError: method() missing 1 required positional argument: &#39;self&#39;&gt;&gt;&gt; Class.function()  # 类名 调用类方法function&gt;&gt;&gt; x.function = func  # 将对象的方法，重新绑定到一个普通函数上&gt;&gt;&gt; x.function()func</code></pre><a id="more"></a><h2 id="私有化"><a href="#私有化" class="headerlink" title="私有化"></a>私有化</h2><p>名字前面加<strong>双下划线</strong>，外部就无法访问了</p><pre><code class="py">class t:    __name = &quot;zhang&quot;  # 名字前面加双下划线(方法也一样)，外部就无法访问了    def getname(self):        return self.__name    def setname(self,name):        self.__name = name&gt;&gt;&gt; x = t()&gt;&gt;&gt; x.setname(&quot;xxxx&quot;)&gt;&gt;&gt; x.getname()&#39;xxxx&#39;&gt;&gt;&gt; x.__nameTraceback (most recent call last):  File &quot;&lt;pyshell#72&gt;&quot;, line 1, in &lt;module&gt;    x.__nameAttributeError: &#39;t&#39; object has no attribute &#39;__name&#39;&gt;&gt;&gt; x._t__name # 实际还是可以访问，但不要这么做（所有以双下划线开始的名字都被翻译成了前面加上单下划线和类名的形式）&#39;xxxx&#39;</code></pre><p>如果不要使用这种方法，又想要其他对象不要访问内部数据，可以使用<strong>单下划线</strong>（对象仍能访问），前面有下划线的名字都不会被带星号的 import 语句 <code>from module import *</code> 导入。</p><h2 id="类的命名空间"><a href="#类的命名空间" class="headerlink" title="类的命名空间"></a>类的命名空间</h2><pre><code class="py">class test:    print (&quot;class...test&quot;)  # 类加载 就运行    number = 0  # 可供所以实例访问    def init(self):        test.number += 1  # 类名.变量名    def testinit():  # 类方法，不能用 （实例.方法） 的形式访问        test.number += 1# class...test</code></pre><pre><code class="py">&gt;&gt;&gt; test.testinit()&gt;&gt;&gt; test.number1&gt;&gt;&gt; x = test()&gt;&gt;&gt; x.init()&gt;&gt;&gt; x.number2</code></pre><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><pre><code class="py">class Filter:    def init(self):        self.blocked = []    def filter(self, seq):        return [x for x in seq if x not in self.blocked]class SPAMFilter(Filter):  # 继承的父类写在括号内    def init(self):  # 重写父类方法        self.blocked = [&#39;SPAM&#39;]</code></pre><h3 id="检查继承"><a href="#检查继承" class="headerlink" title="检查继承"></a>检查继承</h3><pre><code class="py">&gt;&gt;&gt; issubclass(SPAMFilter, Filter)  # 检查 SPAMFilter 是不是 Filter 的子类True&gt;&gt;&gt; issubclass(Filter, Filter)True&gt;&gt;&gt; issubclass(Filter, SPAMFilter)False</code></pre><p>已知子类，查看父类</p><pre><code class="py">&gt;&gt;&gt; Filter.__bases__  # 返回元组，如果有多个会都返回(&lt;class &#39;object&#39;&gt;,)&gt;&gt;&gt; SPAMFilter.__bases__(&lt;class &#39;__main__.Filter&#39;&gt;,)</code></pre><p>检查一个对象是否是一个类的实例</p><pre><code class="py">&gt;&gt;&gt; s = SPAMFilter()&gt;&gt;&gt; isinstance(s, SPAMFilter)True&gt;&gt;&gt; isinstance(s, Filter)True&gt;&gt;&gt; isinstance(s, int)False</code></pre><p>查看一个对象所属的类</p><pre><code class="py">&gt;&gt;&gt; type(s)&lt;class &#39;__main__.SPAMFilter&#39;&gt;</code></pre><h3 id="多个超类"><a href="#多个超类" class="headerlink" title="多个超类"></a>多个超类</h3><p>多重继承，<strong>避免使用</strong>。<br>在括号内继续添加即可，用逗号分割。</p><p>必须要注意超类的顺序，先继承的类中的方法会重写后继承的类中的方法（写在前面的超类，优先级更高）</p><!--### 接口和内省不用像在 java 中显示地编写接口，可以在使用对象的时候假定它可以实现你所要求的行为。不能实现则程序出错。--><h3 id="检查所需方法是否存在"><a href="#检查所需方法是否存在" class="headerlink" title="检查所需方法是否存在"></a>检查所需方法是否存在</h3><pre><code class="py">&gt;&gt;&gt; hasattr(s, &#39;init&#39;)True&gt;&gt;&gt; hasattr(s, &#39;init2&#39;)False</code></pre><h3 id="查看或设置对象的方法或变量"><a href="#查看或设置对象的方法或变量" class="headerlink" title="查看或设置对象的方法或变量"></a>查看或设置对象的方法或变量</h3><p><code>getattr</code> 函数，可以在方法或变量不存在时提供默认值。<code>setattr</code> 函数可以设置对象的方法或变量</p><pre><code class="py">&gt;&gt;&gt; getattr(s, &#39;init&#39;, None)&lt;bound method SPAMFilter.init of &lt;__main__.SPAMFilter object at 0x03BF3FF0&gt;&gt;&gt;&gt;&gt; setattr(s, &#39;name&#39;, &#39;zhang&#39;)&gt;&gt;&gt; s.name&#39;zhang&#39;</code></pre><h3 id="查看对象内所有的变量"><a href="#查看对象内所有的变量" class="headerlink" title="查看对象内所有的变量"></a>查看对象内所有的变量</h3><pre><code class="py">&gt;&gt;&gt; s.__dict__{&#39;name&#39;: &#39;zhang&#39;}</code></pre><h3 id="检查方法是否可以调用"><a href="#检查方法是否可以调用" class="headerlink" title="检查方法是否可以调用"></a>检查方法是否可以调用</h3><h4 id="Python2-7"><a href="#Python2-7" class="headerlink" title="Python2.7"></a>Python2.7</h4><p><code>callcble</code> 函数</p><pre><code class="py">&gt;&gt;&gt; callable(getattr(s, &#39;init&#39;, None))True&gt;&gt;&gt; callable(getattr(s, &#39;init2&#39;, None))False</code></pre><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><p>表达式 <code>hasattr(func, &quot;__call__&quot;)</code></p><pre><code class="py">&gt;&gt;&gt; hasattr(x, &quot;__call__&quot;)False&gt;&gt;&gt; hasattr(y, &quot;__call__&quot;)True</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Python基础教程》读书笔记06-抽象</title>
      <link href="/2017/01/01/%E3%80%8APython%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B006-%E6%8A%BD%E8%B1%A1/"/>
      <url>/2017/01/01/%E3%80%8APython%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B006-%E6%8A%BD%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="判断函数是否可调用"><a href="#判断函数是否可调用" class="headerlink" title="判断函数是否可调用"></a>判断函数是否可调用</h2><pre><code class="py"># Python2，callcble 函数&gt;&gt;&gt; import math&gt;&gt;&gt; x = 1&gt;&gt;&gt; y = math.sqrt&gt;&gt;&gt; callable(x)False&gt;&gt;&gt; callable(y)True</code></pre><a id="more"></a><pre><code class="py"># Python3，表达式 hasattr(func, &quot;__call__&quot;)&gt;&gt;&gt; hasattr(x, &quot;__call__&quot;)False&gt;&gt;&gt; hasattr(y, &quot;__call__&quot;)True</code></pre><h2 id="文档化函数"><a href="#文档化函数" class="headerlink" title="文档化函数"></a>文档化函数</h2><p>在 <code>def</code> 语句的后面，及<code>模块</code>或<code>类</code>的开头，<code>文档字符串</code></p><pre><code class="py">def square(x):    &#39;文档注释：计算两个数的平方值&#39;    return x*x&gt;&gt;&gt; square.__doc__  # 获得文档字符串&#39;文档注释：计算两个数的平方值&#39;&gt;&gt;&gt; help(square)    # help函数Help on function square in module __main__:square(x)    文档注释：计算两个数的平方值</code></pre><h2 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h2><pre><code class="py">def hello(greet, name): # 一般的位置参数    print (greet + &quot;,&quot; + name + &quot;!&quot;)&gt;&gt;&gt; hello(&#39;hello&#39;, &#39;zhang&#39;)hello,zhang!&gt;&gt;&gt; hello(name=&#39;wang&#39;, greet=&#39;hi&#39;) # 参数多的时候，顺序不好记，可以提供参数的名字hi,wang!&gt;&gt;&gt; hello(&#39;hi&#39;, name=&#39;wang&#39;)hi,wang!&gt;&gt;&gt; hello(greet=&#39;hi&#39;, &#39;wang&#39;) # 如果使用关键参数，之后的就不能是 位置参数SyntaxError: positional argument follows keyword argument</code></pre><pre><code class="py">def hello(greet=&#39;hello&#39;, name=&#39;zhang&#39;): # 可以在函数中提供 默认值    print (greet + &quot;,&quot; + name + &quot;!&quot;)&gt;&gt;&gt; hello()hello,zhang!&gt;&gt;&gt; hello(name=&#39;wang&#39;)hello,wang!</code></pre><p>位置参数和关键字参数联合使用，<strong>位置参数需要在关键字的前面</strong>，避免使用联合</p><h3 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h3><p>如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收 city 和 job 作为关键字参数。这种方式定义的函数如下：</p><pre><code class="py">def person(name, age, *, city, job):    print(name, age, city, job)</code></pre><p><code>*</code> 后面的参数被视为命名关键字参数。</p><p>调用方式如下：</p><pre><code class="py">&gt;&gt;&gt; person(&#39;Jack&#39;, 24, city=&#39;Beijing&#39;, job=&#39;Engineer&#39;)Jack 24 Beijing Engineer</code></pre><p><strong>命名关键字参数必须传入参数名</strong>，这和位置参数不同。如果没有传入参数名，调用将报错：</p><pre><code class="py">&gt;&gt;&gt; person(&#39;Jack&#39;, 24, &#39;Beijing&#39;, &#39;Engineer&#39;)Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: person() takes 2 positional arguments but 4 were given</code></pre><p>由于调用时缺少参数名 city 和 job，Python 解释器把这 4 个参数均视为位置参数，但 person() 函数仅接受 2 个位置参数。</p><p>命名关键字参数也可以有缺省值，从而简化调用：</p><pre><code class="py">def person(name, age, *, city=&#39;Beijing&#39;, job):     print(name, age, city, job)</code></pre><p>由于命名关键字参数 city 具有默认值，调用时，可不传入 city 参数：</p><pre><code class="py">&gt;&gt;&gt; person(&#39;Jack&#39;, 24, job=&#39;Engineer&#39;)Jack 24 Beijing Engineer</code></pre><p>使用命名关键字参数时，要特别注意，<code>*</code> 不是参数，而是特殊分隔符。如果缺少 <code>*</code>，Python 解释器将无法识别位置参数和命名关键字参数。</p><h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><pre><code class="py">def print_params(name, *params):    print (name + &quot;:&quot; )    print (params)&gt;&gt;&gt; print_params(&quot;Number&quot;, 1,2,3,4,5)Number:(1, 2, 3, 4, 5)&gt;&gt;&gt; print_params(&quot;Number&quot;) # 可变参数，可选Number:()</code></pre><h2 id="关键字的可变参数"><a href="#关键字的可变参数" class="headerlink" title="关键字的可变参数"></a>关键字的可变参数</h2><p><code>**</code>，这些关键字参数在函数内部自动组装为一个 <code>dict</code>，也是可选的<br>也可以接收一个 <code>dict</code> 参数，但就不能像下方和普通的可变参数联合使用了，如：<code>extra = {&#39;foo&#39;: 1, &#39;bar&#39;: 2}</code>，注意 params 获得的 dict 是 extra 的一份拷贝，对 kw 的改动不会影响到函数外的 extra。</p><pre><code class="py">def print_params(x, y, z=3, *name, **params):    print (x,y,z)    print (name)    print (params)&gt;&gt;&gt; print_params(1,2,3,5,6,7, foo=1, bar=2)1 2 3(5, 6, 7){&#39;bar&#39;: 2, &#39;foo&#39;: 1}&gt;&gt;&gt; extra = {&#39;foo&#39;: 1, &#39;bar&#39;: 2}&gt;&gt;&gt; print_params(1,2,3,5,6,7, extra) # 传递dict参数，不能和普通的可变参数联合使用，使用 **extra 就可以1 2 3(5, 6, 7, {&#39;bar&#39;: 2, &#39;foo&#39;: 1}){}&gt;&gt;&gt; print_params(1,2,3,5,6,7, **extra)1 2 3(5, 6, 7){&#39;foo&#39;: 1, &#39;bar&#39;: 2}</code></pre><pre><code class="py">def person(name, age, **kw):  # 没有普通的可变参数，调用必须加 **    print(&#39;name:&#39;, name, &#39;age:&#39;, age, &#39;other:&#39;, kw)&gt;&gt;&gt; person(&#39;Jack&#39;, 24, **extra)  # 没有 ** 报错name: Jack age: 24 other: {&#39;bar&#39;: 2, &#39;foo&#39;: 1}</code></pre><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>内建函数 <code>vars()</code> 返回作用域值的字典</p><pre><code class="py">&gt;&gt;&gt; x = 1&gt;&gt;&gt; scope = vars() # 这个字典，不要修改&gt;&gt;&gt; scope[&#39;x&#39;]1</code></pre><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>局部变量和全局变量重名时，可以使用 <code>globals()</code> 函数返回全局变量的字典（<code>locals()</code> 函数返回局部变量的字典）</p><pre><code class="py">def combine(param):    print (param + &#39;:&#39; + globals()[&#39;param&#39;])&gt;&gt;&gt; param = &#39;zhang&#39;&gt;&gt;&gt; combine(&#39;name&#39;)name:zhang</code></pre><p>在函数内部<em>重绑定</em>全局变量，<code>global</code> <strong>没有 <code>global</code> 语句，是不可能为定义在函数外的变量赋值的</strong></p><pre><code class="py">x = 1def change_global():    global x    x = x + 1&gt;&gt;&gt; change_global()&gt;&gt;&gt; x2</code></pre><h3 id="嵌套作用域"><a href="#嵌套作用域" class="headerlink" title="嵌套作用域"></a>嵌套作用域</h3><p>Python 的函数是可以嵌套的</p><pre><code class="py">def multiplier(factor):    def multiplyByFactor(number):        return number * factor    return multiplyByFactor&gt;&gt;&gt; multiplier(2) # 函数本身被返回，包含函数的环境（和相关局部变量）&lt;function multiplyByFactor at 0x027CEB30&gt;&gt;&gt;&gt; multiplier(2)(5)10</code></pre><p>每次调用外层函数，它的内部函数都被重新绑定，factor 变量每次都有新的值，稍后会被内层函数访问</p><pre><code class="py">&gt;&gt;&gt; x = multiplier(2) # 每次调用都会返回一个新的函数&gt;&gt;&gt; x(3)6&gt;&gt;&gt; y = multiplier(5)&gt;&gt;&gt; y(5)25</code></pre><p>类似 multiplyByFactor 函数存储子封闭作用域的行为叫做 <strong><code>闭包</code></strong></p><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><pre><code class="py">def count():    fs = []    for i in range(1, 4):        def f():             return i*i        fs.append(f)    return fs&gt;&gt;&gt; f1, f2, f3 = count()&gt;&gt;&gt; f1(), f2(), f3() # 这里不是(1,4,9)(9, 9, 9)</code></pre><p>全部都是 <code>9</code>，原因就在于返回的函数引用了变量 <code>i</code>，但它并非立刻执行。等到 3 个函数都返回时，它们所引用的变量 <code>i</code> 已经变成了 <code>3</code>，因此最终结果为 <code>9</code>。</p><p>返回闭包时牢记的一点就是：<strong>返回函数不要引用任何循环变量，或者后续会发生变化的变量。</strong></p><p><strong>如果一定要引用循环变量</strong>，方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变：</p><pre><code class="py">def count():    def f(j):        def g():            return j*j        return g    fs = []    for i in range(1, 4):        fs.append(f(i)) # f(i) 立刻被执行，因此 i 的当前值被传入 f()    return fs&gt;&gt;&gt; f1, f2, f3 = count()&gt;&gt;&gt; f1(), f2(), f3()(1, 4, 9)</code></pre><p>缺点是代码较长，可利用 lambda 函数缩短代码。</p><h4 id="Python3-对外部作用域赋值"><a href="#Python3-对外部作用域赋值" class="headerlink" title="Python3 对外部作用域赋值"></a>Python3 对外部作用域赋值</h4><p><code>nonlocal</code> 关键字</p><pre><code class="py">def make_counter():    count = 0    def counter():        nonlocal count        count += 1        return count    return counter&gt;&gt;&gt; def make_counter_test():  mc = make_counter()  print(mc())  print(mc())  print(mc())&gt;&gt;&gt; make_counter_test()123</code></pre><h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><p><code>map</code>, <code>filter</code> 和 <code>reduce</code> 函数。</p><p><code>map</code>, <code>filter</code> 不是很有用，并可以用列表推导式替换。</p><h3 id="map-函数"><a href="#map-函数" class="headerlink" title="map 函数"></a>map 函数</h3><p>可以使用 <code>map</code> 函数将序列中的元素全部传递给一个函数。</p><pre><code class="py">&gt;&gt;&gt; [str(i) for i in range(10)] # 列表推导式[&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;]</code></pre><pre><code class="py"># Python3&gt;&gt;&gt; x = []&gt;&gt;&gt; map(str, range(10)): # map第一个参数为类型，也可以int&lt;map object at 0x000002B1FA21F940&gt;&gt;&gt;&gt; list(map(str, range(10)))[&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;]# Python2&gt;&gt;&gt; map(str, range(10))[&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;]</code></pre><h3 id="filter-函数"><a href="#filter-函数" class="headerlink" title="filter 函数"></a>filter 函数</h3><p><code>filter</code> 函数可以基于一个返回布尔值的函数对元素进行过滤。</p><pre><code class="py">def func(x):    return x.isalnum()&gt;&gt;&gt; seq = [&#39;foo&#39;, &#39;x41&#39;, &#39;?!&#39;, &#39;***&#39;]&gt;&gt;&gt; filter(func, seq)&lt;filter object at 0x03AAF6F0&gt; # Python2.7，返回 [&#39;foo&#39;, &#39;x41&#39;]&gt;&gt;&gt; list(filter(func, seq))[&#39;foo&#39;, &#39;x41&#39;]</code></pre><pre><code class="py"># 使用列表推导式：&gt;&gt;&gt; [x for x in seq if x.isalnum()][&#39;foo&#39;, &#39;x41&#39;]# 使用 lambda&gt;&gt;&gt; filter(lambda x: x.isalnum(), seq)[&#39;foo&#39;, &#39;x41&#39;]</code></pre><h3 id="reduce-函数"><a href="#reduce-函数" class="headerlink" title="reduce 函数"></a>reduce 函数</h3><p>将序列的前两个元素与给定的函数联合使用，并且将它们的返回值和第 3 个元素继续联合使用，直到整个序列处理完毕，得到一个最终结果。</p><pre><code class="py">&gt;&gt;&gt; from functools import *# 计算列表元素的合&gt;&gt;&gt; z = [11, 22, 33, 44, 55, 66, 77]&gt;&gt;&gt; reduce(lambda x, y: x + y, z)308&gt;&gt;&gt; sum(z) # 可以使用内建函数 sum308</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Python基础教程》读书笔记05-基础知识进阶</title>
      <link href="/2017/01/01/%E3%80%8APython%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B005-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%BF%9B%E9%98%B6/"/>
      <url>/2017/01/01/%E3%80%8APython%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B005-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="import"><a href="#import" class="headerlink" title="import"></a>import</h2><pre><code class="py">import somemodulefrom somemodule import somefunctionfrom somemodule import somefunction, anotherfunction, yetantherfunctionfrom somemodule import * # 如果确定从给定模块导入所有功能时使用。import math as foobar # 使用别名import math import sqrt as foobar # 为函数提供别名</code></pre><a id="more"></a><h2 id="range-函数和-xrange-函数"><a href="#range-函数和-xrange-函数" class="headerlink" title="range() 函数和 xrange() 函数"></a>range() 函数和 xrange() 函数</h2><p>Python3 取消了 <code>xrange()</code> 函数，并且和 <code>range()</code> 函数合并为 <code>range()</code>。</p><h3 id="Python2-7-环境"><a href="#Python2-7-环境" class="headerlink" title="Python2.7 环境"></a>Python2.7 环境</h3><pre><code class="py">&gt;&gt;&gt; range(8)[0, 1, 2, 3, 4, 5, 6, 7]&gt;&gt;&gt; a = range(8)&gt;&gt;&gt; print(type(a))&lt;type &#39;list&#39;&gt;&gt;&gt;&gt; b = xrange(8)&gt;&gt;&gt; type(b)&lt;type &#39;xrange&#39;&gt;&gt;&gt;&gt; [ x for x in b][0, 1, 2, 3, 4, 5, 6, 7]</code></pre><h3 id="Python3-环境"><a href="#Python3-环境" class="headerlink" title="Python3 环境"></a>Python3 环境</h3><pre><code class="py">&gt;&gt;&gt; a = range(8)&gt;&gt;&gt; type(a)&lt;class &#39;range&#39;&gt;&gt;&gt;&gt; [ x for x in a][0, 1, 2, 3, 4, 5, 6, 7]&gt;&gt;&gt; b = xrange(8)Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;NameError: name &#39;xrange&#39; is not defined</code></pre><h2 id="赋值魔法"><a href="#赋值魔法" class="headerlink" title="赋值魔法"></a>赋值魔法</h2><p>赋值语句的一些技巧</p><h3 id="序列解包"><a href="#序列解包" class="headerlink" title="序列解包"></a>序列解包</h3><pre><code class="py"># 多个赋值操作同时进行&gt;&gt;&gt; x, y, z = 1, 2, 3&gt;&gt;&gt; print (x, y, z)1 2 3</code></pre><pre><code class="py"># 交换两个或多个变量&gt;&gt;&gt; x, y = y, x&gt;&gt;&gt; print(x, y, z)2 1 3</code></pre><p>事实上，这里所做的事情叫做<em>序列解包</em>，或<em>递归解包</em>————将多个值的序列解开，然后放到变量中。更形象一点儿的表示就是：</p><pre><code class="py">&gt;&gt;&gt; value = 1, 2, 3&gt;&gt;&gt; value(1, 2, 3)&gt;&gt;&gt; x, y, z = value&gt;&gt;&gt; x1</code></pre><p>当函数返回元组(或序列字典等)时，这个特性十分有用。</p><pre><code class="py">&gt;&gt;&gt; x = {&#39;name&#39;: &#39;zhang&#39;, &#39;age&#39;: 18}&gt;&gt;&gt; key, value = x.popitem()&gt;&gt;&gt; key&#39;age&#39;&gt;&gt;&gt; value18</code></pre><p><strong>所解包的序列中元素数量必须和 &#39;=&#39; 号左边的变量数量完全一致</strong>。</p><p><strong>Python3 中有另一个解包的特性</strong>，可以使用星号运算符(可变参数)</p><pre><code class="py">&gt;&gt;&gt; a, *b = [1,2,3,4]&gt;&gt;&gt; a1&gt;&gt;&gt; b[2, 3, 4]&gt;&gt;&gt; *a, b = [1,2,3,4]&gt;&gt;&gt; a[1, 2, 3]&gt;&gt;&gt; b4</code></pre><h3 id="链式赋值"><a href="#链式赋值" class="headerlink" title="链式赋值"></a>链式赋值</h3><p>将一个值赋给多个变量</p><pre><code class="py">x = y = somefunction()# 和下面的语句等同x = somefunction()x = y# 注意上面的语句和下面的不一定等价x = somefunction()y = somefunction()</code></pre><h2 id="条件，bool"><a href="#条件，bool" class="headerlink" title="条件，bool"></a>条件，bool</h2><p><code>False None 0 &quot;&quot; () [] {}</code>这些值作为布尔表达式的时候，都会被认为 False，其他的一切都被认为 True。</p><p><strong><code>bool</code>函数</strong></p><pre><code class="py">&gt;&gt;&gt; bool(0)False</code></pre><p>条件语句：<strong><code>if</code> <code>elif</code> <code>else</code></strong></p><p>布尔运算符：<strong><code>and</code> <code>or</code> <code>not</code></strong></p><h3 id="布尔运算符的短路逻辑"><a href="#布尔运算符的短路逻辑" class="headerlink" title="布尔运算符的短路逻辑"></a>布尔运算符的短路逻辑</h3><p>表达式 <code>x and y</code> 中，如果 x 为假，表达式返回 x 的值，否则返回 y 的值。</p><pre><code class="py">&gt;&gt;&gt; x = {}&gt;&gt;&gt; y = 1&gt;&gt;&gt; z = x and y # 返回 x 的值&gt;&gt;&gt; z{}&gt;&gt;&gt; x = 2&gt;&gt;&gt; z = x and y # 返回 y 的值&gt;&gt;&gt; z1</code></pre><p>在表达式 <code>x or y</code> 中，x 为真返回 x 的值，否则返回 y 的值</p><pre><code class="py">&gt;&gt;&gt; x = &#39;&#39;&gt;&gt;&gt; z = x or &#39;unknown&#39; # 如果为空，返回默认值&gt;&gt;&gt; z&#39;unknown&#39;</code></pre><h3 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h3><p><strong><code>a if b else c</code></strong>：如果 b 为真，返回 a，否则返回 c。</p><h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><p>支持 <code>1&lt;= x &lt;= 10</code>，这种格式</p><h3 id="相等运算符-39-39"><a href="#相等运算符-39-39" class="headerlink" title="相等运算符&#39;==&#39;"></a>相等运算符&#39;==&#39;</h3><pre><code class="py">&gt;&gt;&gt; x = {&#39;name&#39;: &#39;zhang&#39;}&gt;&gt;&gt; y = {&#39;name&#39;: &#39;zhang&#39;}&gt;&gt;&gt; x==yTrue</code></pre><h3 id="is-同一性运算符"><a href="#is-同一性运算符" class="headerlink" title="is: 同一性运算符"></a>is: 同一性运算符</h3><pre><code class="py">&gt;&gt;&gt; x==yTrue&gt;&gt;&gt; z = x&gt;&gt;&gt; z is xTrue&gt;&gt;&gt; x is yFalse</code></pre><p><code>==</code> 运算符判断两对象是否相等，<code>is</code> 判定两者是否等同(同一对象)，<strong>避免将 <code>is</code> 运算符用于比较类似数值和字符串这类不可变值。</strong></p><h3 id="in-成员资格运算符"><a href="#in-成员资格运算符" class="headerlink" title="in: 成员资格运算符"></a>in: 成员资格运算符</h3><pre><code class="py">&gt;&gt;&gt; &#39;name&#39; in x.keys()True&gt;&gt;&gt; &#39;name&#39; not in x.keys()False</code></pre><h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><p>确保程序中的某个条件一定为真。</p><pre><code class="py">&gt;&gt;&gt; age = -1&gt;&gt;&gt; assert 0 &lt; age &lt; 100, &#39;The age must be realistic&#39; # 可以添加字符串解释断言Traceback (most recent call last):  File &quot;&lt;pyshell#58&gt;&quot;, line 1, in &lt;module&gt;    assert 0 &lt; age &lt; 100, &#39;The age must be realistic&#39;AssertionError: The age must be realistic</code></pre><h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><h3 id="并行迭代"><a href="#并行迭代" class="headerlink" title="并行迭代"></a>并行迭代</h3><pre><code class="py">x = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]y = [1, 2, 3]for i in range(len(x)):    print (x[i], &#39;:&#39;, y[i])# a : 1# b : 2# c : 3</code></pre><p>使用内建函数 <code>zip</code>，进行并行迭代，可以将两个序列“压缩”在一起，然后返回一个元组的列表。</p><pre><code class="py">zip(x, y)# [(&#39;a&#39;, 1), (&#39;b&#39;, 2), (&#39;c&#39;, 3)]  # Python2# &lt;zip object at 0x033B8378&gt; # Python3for i, j in zip(x, y):    print (i, &#39;:&#39;, j)# a : 1# b : 2# c : 3</code></pre><p><strong>zip 函数可以处理不等长序列</strong>，当最短的序列用完时就会停止。</p><pre><code class="py">&gt;&gt;&gt; zip(range(5), range(1000000))[(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)] # Python2</code></pre><h3 id="按索引迭代"><a href="#按索引迭代" class="headerlink" title="按索引迭代"></a>按索引迭代</h3><p>在一个字符串列表中替换所有包含 &#39;yy&#39; 的子字符串</p><pre><code class="py">strings = [&#39;xxx&#39;, &#39;yyy&#39;, &#39;zzz&#39;]index = 0for string in strings:    if &#39;yy&#39; in string:        strings[index] = &#39;aaa&#39;    index += 1&gt;&gt;&gt; strings[&#39;xxx&#39;, &#39;aaa&#39;, &#39;zzz&#39;]</code></pre><p>使用内建函数 <code>enumerate</code></p><pre><code class="py">for index, string in enumerate(strings):    if &#39;zz&#39; in string:        strings[index] = &#39;bbb&#39;&gt;&gt;&gt; strings[&#39;xxx&#39;, &#39;aaa&#39;, &#39;bbb&#39;]</code></pre><p>这个函数可以在提供索引的地方迭代<strong>索引——值</strong>对。</p><h3 id="翻转和排序迭代"><a href="#翻转和排序迭代" class="headerlink" title="翻转和排序迭代"></a>翻转和排序迭代</h3><p>reversed 和 sorted，同列表的 reverse 和 sort 的方法相似，在列表一节中有介绍。</p><p>作用于任何序列或可迭代对象，不修改原对象，返回修改后的版本（reversed 返回一个迭代对象）。</p><pre><code class="py">&gt;&gt;&gt; sorted([4, 2, 6, 8, 3])[2, 3, 4, 6, 8]&gt;&gt;&gt; sorted(&#39;Hello, World&#39;)[&#39; &#39;, &#39;,&#39;, &#39;H&#39;, &#39;W&#39;, &#39;d&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;, &#39;o&#39;, &#39;r&#39;]&gt;&gt;&gt; reversed(&#39;Hello, World&#39;) # 返回迭代对象，不能直接使用索引、分片、list 方法等，使用 list 转换就可以使用了&lt;reversed object at 0x033B3B30&gt;&gt;&gt;&gt; list(reversed(&#39;Hello, World&#39;))[&#39;d&#39;, &#39;l&#39;, &#39;r&#39;, &#39;o&#39;, &#39;W&#39;, &#39; &#39;, &#39;,&#39;, &#39;o&#39;, &#39;l&#39;, &#39;l&#39;, &#39;e&#39;, &#39;H&#39;]&gt;&gt;&gt; &#39;&#39;.join(reversed(&#39;Hello, World&#39;)) # 可以在 join 方法中使用&#39;dlroW ,olleH&#39;</code></pre><h2 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h2><pre><code class="py">&gt;&gt;&gt; [x * x for x in range(10)][0, 1, 4, 9, 16, 25, 36, 49, 64, 81]&gt;&gt;&gt; [x * x for x in range(10) if x % 3 == 0][0, 9, 36, 81]&gt;&gt;&gt; [(x, y) for x in range(3) for y in range(3)][(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)]&gt;&gt;&gt; boys = [&#39;a2&#39;, &#39;b2&#39;, &#39;c2&#39;]&gt;&gt;&gt; girls = [&#39;a1&#39;, &#39;b1&#39;, &#39;c1&#39;]&gt;&gt;&gt; [b + &#39;+&#39; + g for b in boys for g in girls if b[0] == g[0]][&#39;a2+a1&#39;, &#39;b2+b1&#39;, &#39;c2+c1&#39;]</code></pre><p>男孩/女孩名字对，有效率更高的方法</p><pre><code class="py">letterGirls = {}for girl in girls:    letterGirls.setdefault(girl[0], []).append(girl)[b + &#39;+&#39; + g for b in boys for g in letterGirls[b[0]]]# [&#39;a2+a1&#39;, &#39;b2+b1&#39;, &#39;c2+c1&#39;]</code></pre><p>创建了一个字典，以首字母为键，女孩名为值。字典创建后，列表推导式循环整个男孩集合。这样就不用尝试所有的男孩女孩组合了。</p><h2 id="pass"><a href="#pass" class="headerlink" title="pass"></a>pass</h2><p>在 Python 中空代码块是非法的。</p><pre><code class="py">if(True):    passelse:    print (&#39;False&#39;)if(True):else:    print (&#39;False&#39;)# SyntaxError: expected an indented block</code></pre><h2 id="del"><a href="#del" class="headerlink" title="del"></a>del</h2><pre><code class="py">&gt;&gt;&gt; x = [11,22,33]&gt;&gt;&gt; y = x&gt;&gt;&gt; del x&gt;&gt;&gt; y[11, 22, 33]&gt;&gt;&gt; xTraceback (most recent call last):  File &quot;&lt;pyshell#28&gt;&quot;, line 1, in &lt;module&gt;    xNameError: name &#39;x&#39; is not defined</code></pre><p><code>del</code> 不会删除列表本身，只是删除指向，Python 解释器会负责内存的回收。</p><h2 id="exec-和-eval"><a href="#exec-和-eval" class="headerlink" title="exec 和 eval"></a>exec 和 eval</h2><p>不常用。</p><h3 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h3><p>在使用 <code>exec()</code> 之前，你可能需要问下自己是否有其他更好的替代方案。大多数情况下当你要考虑使用 <code>exec()</code> 的时候， 还有另外更好的解决方案，比如装饰器、闭包、元类，或其他一些元编程特性。</p><p>执行一个字符串语句</p><pre><code class="py">&gt;&gt;&gt; exec(&#39;print (&quot;dd&quot;)&#39;) # Python3 exec,print都需要加()dd</code></pre><p>可以给 exec 语句 提供命名空间，从而使字符串代码不会干扰到其他代码。</p><pre><code class="py">&gt;&gt;&gt; from math import sqrt&gt;&gt;&gt; exec (&quot;sqrt = 1&quot;)&gt;&gt;&gt; sqrt(4)Traceback (most recent call last):  File &quot;&lt;pyshell#35&gt;&quot;, line 1, in &lt;module&gt;    sqrt(4)TypeError: &#39;int&#39; object is not callable</code></pre><p>因为字符串语句，很可能是从其他地方获得的。</p><h4 id="Python2"><a href="#Python2" class="headerlink" title="Python2"></a>Python2</h4><p>为了安全起见，可以增加一个字典，起到命名空间的作用</p><pre><code class="py">&gt;&gt;&gt; from math import sqrt&gt;&gt;&gt; scope = {}&gt;&gt;&gt; exec &#39;sqrt = 1&#39; in scope&gt;&gt;&gt; sqrt(4)2.0&gt;&gt;&gt; scope[&#39;sqrt&#39;]1</code></pre><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><p>见：<a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c09/p23_executing_code_with_local_side_effects.html" target="_blank" rel="noopener">9.23 在局部变量域中执行代码</a></p><pre><code class="py">def test():     a = 13     exec(&#39;b = a + 1&#39;)     print(b)&gt;&gt;&gt; test()Traceback (most recent call last):    File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;    File &quot;&lt;stdin&gt;&quot;, line 4, in testNameError: global name &#39;b&#39; is not defined&gt;&gt;&gt;</code></pre><pre><code class="py"># 大部分情况下，这种方式是使用 exec() 的最佳实践。 你只需要保证全局和局部字典在后面代码访问时已经被初始化。def test4():     a = 13     loc = { &#39;a&#39; : a }     glb = { }     exec(&#39;b = a + 1&#39;, glb, loc)     b = loc[&#39;b&#39;]     print(b)&gt;&gt;&gt; test4()14</code></pre><h3 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h3><p><code>eval</code>会计算 Python 表达式(以<strong>字符串</strong>形式书写)，实际使用需要防止安全问题。</p><p>语法：</p><blockquote><p>eval(expression[, globals[, locals]])</p></blockquote><p>参数</p><ul><li>expression -- 表达式。</li><li>globals -- 变量作用域，全局命名空间，如果被提供，则必须是一个字典对象。</li><li>locals -- 变量作用域，局部命名空间，如果被提供，可以是任何映射对象。</li></ul><pre><code class="py">&gt;&gt;&gt; eval(raw_input(&#39;input: &#39;)) # 等同于input()，Python3中，raw_input被重命名为inputinput: 6 + 5*321&gt;&gt;&gt; eval(&#39;1+2&#39;)3</code></pre><p><strong>为eval提供命名空间</strong>。</p><pre><code class="py">&gt;&gt;&gt; scope = {}&gt;&gt;&gt; scope[&#39;x&#39;] = 2&gt;&gt;&gt; scope[&#39;y&#39;] = 3&gt;&gt;&gt; eval(&#39;x * y&#39;, scope)6</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Python基础教程》读书笔记04-字典</title>
      <link href="/2017/01/01/%E3%80%8APython%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B004-%E5%AD%97%E5%85%B8/"/>
      <url>/2017/01/01/%E3%80%8APython%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B004-%E5%AD%97%E5%85%B8/</url>
      
        <content type="html"><![CDATA[<h2 id="创建字典和-dict-函数"><a href="#创建字典和-dict-函数" class="headerlink" title="创建字典和 dict 函数"></a>创建字典和 dict 函数</h2><pre><code class="py">&gt;&gt;&gt; x = {&quot;zhang&quot;: &quot;12321&quot;, &quot;wang&quot;: &quot;4321&quot;}&gt;&gt;&gt; y = {}&gt;&gt;&gt; x{&#39;wang&#39;: &#39;4321&#39;, &#39;zhang&#39;: &#39;12321&#39;}&gt;&gt;&gt; y{}</code></pre><a id="more"></a><p><strong>dict 函数</strong>，可以通过其他映射（如其他字典）或者(键,值)对的序列建立字典。</p><pre><code class="py">&gt;&gt;&gt; items = [(&#39;name&#39;, &#39;zhang&#39;), (&#39;age&#39;, 18)]&gt;&gt;&gt; x = dict(items)&gt;&gt;&gt; x{&#39;age&#39;: 18, &#39;name&#39;: &#39;zhang&#39;}&gt;&gt;&gt; x[&#39;age&#39;]18</code></pre><p>也可以使用关键字参数来创建字典。</p><pre><code class="py">&gt;&gt;&gt; x = dict(name=&#39;zhang&#39;, age=18)&gt;&gt;&gt; x{&#39;age&#39;: 18, &#39;name&#39;: &#39;zhang&#39;}&gt;&gt;&gt;</code></pre><h2 id="基本字典操作"><a href="#基本字典操作" class="headerlink" title="基本字典操作"></a>基本字典操作</h2><pre><code class="py">&gt;&gt;&gt; x{&#39;age&#39;: 18, &#39;name&#39;: &#39;zhang&#39;}&gt;&gt;&gt; len(x) # 返回键值对的数量2&gt;&gt;&gt; x[&#39;name&#39;] # 返回键所对应的值&#39;zhang&#39;&gt;&gt;&gt; x[&#39;id&#39;] = 1 # 将值关联到键上，键起始不存在x上，会自动添加&gt;&gt;&gt; x{&#39;age&#39;: 18, &#39;name&#39;: &#39;zhang&#39;, &#39;id&#39;: 1}&gt;&gt;&gt; x[&#39;id&#39;] = 2 # 如果键起始存在x上，则会更改值&gt;&gt;&gt; x{&#39;age&#39;: 18, &#39;name&#39;: &#39;zhang&#39;, &#39;id&#39;: 2}&gt;&gt;&gt; del x[&#39;id&#39;] # 删除键所对应的项&gt;&gt;&gt; x{&#39;age&#39;: 18, &#39;name&#39;: &#39;zhang&#39;}&gt;&gt;&gt; &#39;name&#39; in x # 检查是否存在该键True</code></pre><h2 id="字典的方法"><a href="#字典的方法" class="headerlink" title="字典的方法"></a>字典的方法</h2><h3 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h3><p>clear() 方法清除字典中的所有的项。无返回值 (None)</p><pre><code class="py">&gt;&gt;&gt; x{&#39;age&#39;: 18, &#39;name&#39;: &#39;zhang&#39;}&gt;&gt;&gt; x.clear()&gt;&gt;&gt; x{}</code></pre><h3 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h3><p>copy() 方法返回一个具有相同键值对的新字典（浅复制）。<br><strong>如果修改了某个值（不是替换），原字典也会改变。</strong></p><pre><code class="py">&gt;&gt;&gt; x = {&#39;username&#39;: &#39;admin&#39;, &#39;machines&#39;: [&#39;foo&#39;, &#39;bar&#39;, &#39;baz&#39;]}&gt;&gt;&gt; y = x.copy()&gt;&gt;&gt; y[&#39;username&#39;] = &#39;mlh&#39; # 不影响 x&gt;&gt;&gt; y{&#39;username&#39;: &#39;mlh&#39;, &#39;machines&#39;: [&#39;foo&#39;, &#39;bar&#39;, &#39;baz&#39;]}&gt;&gt;&gt; y[&#39;machines&#39;].remove(&#39;bar&#39;) # 影响 x&gt;&gt;&gt; y{&#39;username&#39;: &#39;mlh&#39;, &#39;machines&#39;: [&#39;foo&#39;, &#39;baz&#39;]}&gt;&gt;&gt; x{&#39;username&#39;: &#39;admin&#39;, &#39;machines&#39;: [&#39;foo&#39;, &#39;baz&#39;]}</code></pre><h3 id="deepcopy"><a href="#deepcopy" class="headerlink" title="deepcopy"></a>deepcopy</h3><p><strong>深复制</strong>，复制其包含的所有值。</p><pre><code class="py">&gt;&gt;&gt; from copy import deepcopy&gt;&gt;&gt; d = {&#39;name&#39;: [&#39;Alfred&#39;, &#39;Bertrand&#39;]}&gt;&gt;&gt; c = d.copy()&gt;&gt;&gt; dc = deepcopy(d)&gt;&gt;&gt; d[&#39;name&#39;].append(&#39;Clive&#39;)&gt;&gt;&gt; c{&#39;name&#39;: [&#39;Alfred&#39;, &#39;Bertrand&#39;, &#39;Clive&#39;]}&gt;&gt;&gt; dc{&#39;name&#39;: [&#39;Alfred&#39;, &#39;Bertrand&#39;]}</code></pre><h3 id="fromkeys"><a href="#fromkeys" class="headerlink" title="fromkeys"></a>fromkeys</h3><p>fromkeys 方法使用给定的键建立新的字典，每个键都对应一个默认的值 None。</p><pre><code class="py">&gt;&gt;&gt; {}.fromkeys([&#39;name&#39;, &#39;age&#39;]){&#39;name&#39;: None, &#39;age&#39;: None}&gt;&gt;&gt; dict.fromkeys([&#39;name&#39;, &#39;age&#39;]) # 不用多创建一个空字典{&#39;name&#39;: None, &#39;age&#39;: None}&gt;&gt;&gt; dict.fromkeys([&#39;name&#39;,&#39;age&#39;], &#39;(unknown)&#39;) # 默认值{&#39;name&#39;: &#39;(unknown)&#39;, &#39;age&#39;: &#39;(unknown)&#39;}</code></pre><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p>get 方法可以更宽松的访问字典。</p><pre><code class="py">&gt;&gt;&gt; x = {}&gt;&gt;&gt; x[&#39;name&#39;] # 访问不存在的键出错Traceback (most recent call last):  File &quot;&lt;pyshell#4&gt;&quot;, line 1, in &lt;module&gt;    x[&#39;name&#39;]KeyError: &#39;name&#39;&gt;&gt;&gt; print (x.get(&#39;name&#39;))None&gt;&gt;&gt; x.get(&#39;name&#39;, &#39;N/A&#39;) # 可以设置默认值&#39;N/A&#39;&gt;&gt;&gt; x[&#39;name&#39;] = &#39;zhang&#39;&gt;&gt;&gt; x.get(&#39;name&#39;) # 如果字典中存在该键，和普通查询一样&#39;zhang&#39;</code></pre><h3 id="setdefault"><a href="#setdefault" class="headerlink" title="setdefault"></a>setdefault</h3><p>setdefaule 方法和 get 方法类似，不同的是 setdefault 可以在字典不含有给定键时设置相应的键值。</p><pre><code class="py">&gt;&gt;&gt; x = {}&gt;&gt;&gt; print (x.setdefault(&#39;name&#39;)) # 不含给定键，设置相应的键值，默认值为NoneNone&gt;&gt;&gt; x{&#39;name&#39;: None}&gt;&gt;&gt; x.setdefault(&#39;age&#39;,&#39;N/A&#39;) # 不含给定键，设置相应的键值，提供默认值&#39;N/A&#39;&gt;&gt;&gt; x{&#39;age&#39;: &#39;N/A&#39;, &#39;name&#39;: None}&gt;&gt;&gt; x.setdefault(&#39;age&#39;,&#39;18&#39;) # 含有给定键，返回值，不修改&#39;N/A&#39;&gt;&gt;&gt; x{&#39;age&#39;: &#39;N/A&#39;, &#39;name&#39;: None}</code></pre><h3 id="items"><a href="#items" class="headerlink" title="items"></a>items</h3><p>items() 方法将字典的所有项以列表的方式返回。</p><pre><code class="py"># Python2&gt;&gt;&gt; x = {&#39;name&#39;: &#39;zhang&#39;,&#39;age&#39;: 18}&gt;&gt;&gt; x.items()[(&#39;age&#39;, 18), (&#39;name&#39;, &#39;zhang&#39;)]</code></pre><pre><code class="py"># Python3&gt;&gt;&gt; x = {&#39;name&#39;: &#39;zhang&#39;,&#39;age&#39;: 18}&gt;&gt;&gt; y = x.items()&gt;&gt;&gt; ydict_items([(&#39;name&#39;, &#39;zhang&#39;), (&#39;age&#39;, 18)])&gt;&gt;&gt; type(y)&lt;class &#39;dict_items&#39;&gt;</code></pre><h3 id="iteritems"><a href="#iteritems" class="headerlink" title="iteritems"></a>iteritems</h3><p>iteritems() 方法返回一个迭代器对象。Python3 无此方法</p><pre><code class="py">x.iteritems()# &lt;dictionary-itemiterator object at 0x030BF510&gt;for y in x.iteritems():    print y# (&#39;age&#39;, 18)# (&#39;name&#39;, &#39;zhang&#39;)</code></pre><h3 id="keys，iterkeys-和-values，itervalues"><a href="#keys，iterkeys-和-values，itervalues" class="headerlink" title="keys，iterkeys 和 values，itervalues"></a>keys，iterkeys 和 values，itervalues</h3><p>keys 方法将字典中的键以列表形式返回，iterkeys 返回迭代器。</p><p>Python3，keys 方法返回 <code>dict_keys([&#39;name&#39;, &#39;age&#39;])</code>，无 iterkeys 方法。</p><p>values 方法将字典中的键以列表形式返回，itervalues 返回迭代器。</p><p>Python3，values 方法返回 <code>dict_values([&#39;zhang&#39;, 18])</code>，无 itervalues 方法。</p><h3 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h3><p>pop 方法用来获得给定键的值，然后将这个键值对从字典中移除。</p><pre><code class="py">&gt;&gt;&gt; x{&#39;age&#39;: 18, &#39;name&#39;: &#39;zhang&#39;, &#39;id&#39;: 1}&gt;&gt;&gt; x.pop(&#39;id&#39;)1&gt;&gt;&gt; x{&#39;age&#39;: 18, &#39;name&#39;: &#39;zhang&#39;}&gt;&gt;&gt; x.pop(&#39;id&#39;) # 键不存在报错Traceback (most recent call last):  File &quot;&lt;pyshell#24&gt;&quot;, line 1, in &lt;module&gt;    x.pop(&#39;id&#39;)KeyError: &#39;id&#39;</code></pre><h3 id="popitem"><a href="#popitem" class="headerlink" title="popitem"></a>popitem</h3><p>popitem() 方法弹出随机的项，因为字典是无序的。如果想一个一个的移除并处理项，就很有用。</p><pre><code class="py">&gt;&gt;&gt; x{&#39;age&#39;: 18, &#39;name&#39;: &#39;zhang&#39;}&gt;&gt;&gt; x.popitem()(&#39;name&#39;, &#39;zhang&#39;)&gt;&gt;&gt; x{&#39;age&#39;: 18}</code></pre><h3 id="update"><a href="#update" class="headerlink" title="update"></a>update</h3><p>update 方法可以利用一个字典项更新另一个字典，提供的字典中的项会被添加到旧的字典中，若有相同的键则会进行覆盖。</p><pre><code class="py">&gt;&gt;&gt; x{&#39;age&#39;: 18, &#39;name&#39;: &#39;zhang&#39;}&gt;&gt;&gt; y = {&#39;age&#39;:&#39;N/A&#39;，&#39;a&#39;:&#39;N/A&#39;}&gt;&gt;&gt; x.update(y)&gt;&gt;&gt; x{&#39;age&#39;: &#39;N/A&#39;, &#39;name&#39;: &#39;zhang&#39;, &#39;a&#39;: &#39;N/A&#39;}</code></pre><h2 id="循环遍历字典"><a href="#循环遍历字典" class="headerlink" title="循环遍历字典"></a>循环遍历字典</h2><pre><code class="py">d = {&#39;x&#39;: 1, &#39;y&#39;: 2, &#39;z&#39;: 3}for key in d:    print(key, &#39;:&#39;, d[key])# x : 1# y : 2# z : 3</code></pre><pre><code class="py">for key,value in d.items():    print(key, &#39;:&#39;, value)# x : 1# y : 2# z : 3</code></pre><h2 id="循环删除"><a href="#循环删除" class="headerlink" title="循环删除"></a>循环删除</h2><pre><code class="py">for key in list(d.keys()):    del d[key]</code></pre><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="按-key-值对字典排序"><a href="#按-key-值对字典排序" class="headerlink" title="按 key 值对字典排序"></a>按 key 值对字典排序</h3><p>先来基本介绍一下 sorted 函数，<code>sorted(iterable, key, reverse)</code>，sorted 一共有 iterable, key, reverse 这三个参数。</p><ul><li>iterable：表示可以迭代的对象，例如可以是 dict.items()、dict.keys() 等</li><li>key：是一个函数，用来选取参与比较的元素</li><li>reverse：则是用来指定排序是倒序还是顺序，reverse=true 则是倒序，reverse=false 时则是顺序，默认时 reverse=false。</li></ul><pre><code class="py">&gt;&gt;&gt; d = {&#39;x&#39;: 12, &#39;y&#39;: 22, &#39;z&#39;: 3}&gt;&gt;&gt; sorted(d.keys())[&#39;x&#39;, &#39;y&#39;, &#39;z&#39;]</code></pre><h3 id="按-value-值对字典排序"><a href="#按-value-值对字典排序" class="headerlink" title="按 value 值对字典排序"></a>按 value 值对字典排序</h3><pre><code class="py">&gt;&gt;&gt; sorted(d.items(), key=lambda item:item[1])[(&#39;z&#39;, 3), (&#39;x&#39;, 12), (&#39;y&#39;, 22)]</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Python基础教程》读书笔记03-字符串</title>
      <link href="/2017/01/01/%E3%80%8APython%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B003-%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2017/01/01/%E3%80%8APython%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B003-%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<p>字符串都是不可变的。</p><h1 id="string-模块"><a href="#string-模块" class="headerlink" title="string 模块"></a>string 模块</h1><p>字符串方法完全源于 string 模块，这个模块还包括一些不能作为字符串方法使用的常量和函数。如：<code>maketrans</code> 函数<br>一些有用的字符串常量（<code>import string</code>）：</p><a id="more"></a><ul><li><code>string.digits</code>：<code>0-9</code>，包含数字 0~9 的字符串</li><li><code>string.letters</code>：<code>a-zA-Z</code>，包含所有字母的字符串(与地区有关，Python3.0 需要使用 <code>string.acill_letters</code>)</li><li><code>string.lowercase</code>：<code>a-z</code>，包含所有小写字母的字符串</li><li><code>string.uppercase</code>：<code>A-Z</code>，包含所有大写字母的字符串</li><li><code>string.punctuation</code>：<code>!&quot;#$%&amp;\&#39;()*+,-./:;&lt;=&gt;?@[\\]^_`{|}~</code>，包含所有标点的字符串</li><li><code>string.printable</code>：<code>0-9a-zA-Z!&quot;#$%&amp;\&#39;()*+,-./:;&lt;=&gt;?@[\\]^_`{|}~ \t\n\r\x0b\x0c</code>，包含所有可打印字符的字符串</li></ul><h1 id="查找-find，index，count，startswiith，endswiith"><a href="#查找-find，index，count，startswiith，endswiith" class="headerlink" title="查找 find，index，count，startswiith，endswiith"></a>查找 find，index，count，startswiith，endswiith</h1><ul><li><p><code>find</code> 方法可以子啊一个字符串中查找子串，返回子串所在位置的最左端索引，如果没有返回 <code>-1</code>。<br>可以<strong>设置起始和终止值指定的范围</strong>（第二个和第三个参数），包含前面不包含后边。</p><pre><code class="py">  &gt;&gt;&gt; x = &#39;12345678901234&#39;  &gt;&gt;&gt; x.find(&#39;345&#39;)  2  &gt;&gt;&gt; x.find(&#39;23&#39;, 10)  11  &gt;&gt;&gt; x.find(&#39;34&#39;, 2, 10)  2</code></pre></li><li><p><code>rfind(sub[, start[, end]])</code> 方法，返回子串 sub 被找到的位置的最后一个索引，不存在返回 -1，可以设置起始和终止值指定的范围。</p></li><li><p><code>index(sub[, start[, end]])</code> 方法，返回子串 sub 的第一个索引，如果<strong>不存在引发异常</strong>，可以设置起始和终止值指定的范围.</p></li><li><p><code>rindex(sub[, start[, end]])</code> 方法，返回子串 sub 被找到的位置的最后一个索引，如果<strong>不存在引发异常</strong>，可以设置起始和终止值指定的范围。</p></li><li><p><code>count(sub[, start[, end]])</code> 方法，返回子串 sub 出现的次数，可以设置起始和终止值指定的范围。</p></li><li><p><code>startswiith(prefix[, start[, end]])</code> 方法，检查 string 是否以 prefix 开始，返回 True、False，可以设置起始和终止值指定的范围。</p></li><li><p><code>endswiith(suffix[, start[, end]])</code> 方法，检查 string 是否以 suffix 结尾，返回 True、False，可以设置起始和终止值指定的范围。</p></li></ul><h1 id="连接-join，分割-split，splitlines"><a href="#连接-join，分割-split，splitlines" class="headerlink" title="连接 join，分割 split，splitlines"></a>连接 join，分割 split，splitlines</h1><ul><li><p><code>join</code> 方法是 split 方法的逆方法，用来连接序列中的元素，被连接的序列元素必须都是字符串，</p><pre><code class="py">  &gt;&gt;&gt; seq = [1, 2, 3, 4, 5]  &gt;&gt;&gt; sep = &#39;+&#39;  &gt;&gt;&gt; sep.join(seq) # 不能连接数字  Traceback (most recent call last):    File &quot;&lt;pyshell#20&gt;&quot;, line 1, in &lt;module&gt;      sep.join(seq)  TypeError: sequence item 0: expected string, int found  &gt;&gt;&gt; seq = [&#39;1&#39;,&#39;2&#39;,&#39;3&#39;,&#39;4&#39;,&#39;5&#39;,]  &gt;&gt;&gt; sep.join(seq)  &#39;1+2+3+4+5&#39;  &gt;&gt;&gt; dirs = &#39;&#39;, &#39;usr&#39;, &#39;bin&#39;, &#39;enc&#39;  &gt;&gt;&gt; &#39;/&#39;.join(dirs)  &#39;/usr/bin/enc&#39;</code></pre></li><li><p><code>split</code> 方法用来将字符串分割成序列，第二个参数可以指定最大分割数。</p><pre><code class="py">  &gt;&gt;&gt; &#39;1+2+3+4+5&#39;.split(&#39;+&#39;)  [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;]  &gt;&gt;&gt; &#39;Using the default&#39;.split() # 默认把所有空格作为分隔符（空格、制表、换行符等）  [&#39;Using&#39;, &#39;the&#39;, &#39;default&#39;]  &gt;&gt;&gt; &#39;1\n2&#39;.split()  [&#39;1&#39;, &#39;2&#39;]  &gt;&gt;&gt; &#39;Using the default&#39;.split(&#39; &#39;, 1) # 指定最大分割数  [&#39;Using&#39;, &#39;the default&#39;]</code></pre></li><li><p><code>rsplit</code> 方法，同 split，但指定了最大分割数时，从右向左计数。</p><pre><code class="py">  &gt;&gt;&gt; &#39;Using the default&#39;.rsplit(&#39; &#39;, 1)  [&#39;Using the&#39;, &#39;default&#39;]</code></pre></li><li><p><code>splitlinex([keepends])</code> 方法。返回 string 中所有行的列表，可选择是否包含换行符，会对 keepends 参数进行运算</p><pre><code class="py">  &gt;&gt;&gt; x = &#39;&#39;&#39;123  456  zbc  xyz  &#39;&#39;&#39;  &gt;&gt;&gt; x.splitlines()  [&#39;123&#39;, &#39;456&#39;, &#39;zbc&#39;, &#39;xyz&#39;]  &gt;&gt;&gt; x.splitlines(1)  [&#39;123\n&#39;, &#39;456\n&#39;, &#39;zbc\n&#39;, &#39;xyz\n&#39;]  &gt;&gt;&gt; x.splitlines(0)  [&#39;123&#39;, &#39;456&#39;, &#39;zbc&#39;, &#39;xyz&#39;]  &gt;&gt;&gt; x.splitlines(True)  [&#39;123\n&#39;, &#39;456\n&#39;, &#39;zbc\n&#39;, &#39;xyz\n&#39;]  &gt;&gt;&gt; x.splitlines(False)  [&#39;123&#39;, &#39;456&#39;, &#39;zbc&#39;, &#39;xyz&#39;]</code></pre></li></ul><h1 id="字母大小写-lower，upper，capitalize，swapcase，title"><a href="#字母大小写-lower，upper，capitalize，swapcase，title" class="headerlink" title="字母大小写 lower，upper，capitalize，swapcase，title"></a>字母大小写 lower，upper，capitalize，swapcase，title</h1><ul><li><p><code>lower</code>，返回字符串的小写字母版</p></li><li><p><code>islower</code>，检查字符串中所有的字符是否都是小写</p></li><li><p><code>upper</code>，返回字符串的大写字母版</p></li><li><p><code>isupper</code>，检查字符串中所有的字符是否都是大写</p></li><li><p><code>capitalize</code>，返回首字母大写的字符串，只是第一个字符大写</p></li><li><p><code>swapcase</code>，返回字符串所有字符交换大小写</p></li><li><p><code>title</code>，所有单词都以大写字母开头，</p><pre><code class="py">  &gt;&gt;&gt; x = &#39;what\&#39;s that&#39;  &gt;&gt;&gt; x.title()  # 以此为标题，不自然  &quot;What&#39;S That&quot;  &gt;&gt;&gt; import string  # 使用string模块下的capwords函数  &gt;&gt;&gt; string.capwords(x)  &quot;What&#39;s That&quot;</code></pre></li><li><p><code>istitle</code>，检查所有单词是否都以大写字母开头，且其他字符都是小写</p><pre><code class="py">  &gt;&gt;&gt; x = &quot;What&#39;S That&quot;  &gt;&gt;&gt; x.istitle()  True  &gt;&gt;&gt; x = &quot;WhaT&#39;S That&quot;  &gt;&gt;&gt; x.istitle()  False</code></pre></li></ul><h1 id="替换-replace，translate，expandtabs"><a href="#替换-replace，translate，expandtabs" class="headerlink" title="替换 replace，translate，expandtabs"></a>替换 replace，translate，expandtabs</h1><ul><li><p><code>replace(old, new[, max]</code>，返回某字符串的所有匹配项均被替换之后的字符串，可选择最多可替换 max 个</p></li><li><p><code>translate(table[,deletechars])</code>，和 replace 方法类似，<code>translate</code> <strong>只处理单个字符</strong>，有时候效率会高，使用前需要完成一张<strong><em>转换表</em></strong>，第二个参数（Python2），可选择删除 deletechars 所出现的字符</p><pre><code class="py">  # Python2  &gt;&gt;&gt; from string import maketrans  &gt;&gt;&gt; table = maketrans(&#39;he&#39;, &#39;wc&#39;)  &gt;&gt;&gt; len(table) # 包含ASCII字符集中的256个字符  256  &gt;&gt;&gt; table[97:123] # h和e，已被替换  &#39;abcdcfgwijklmnopqrstuvwxyz&#39;  &gt;&gt;&gt; &#39;hello&#39;.translate(table)  &#39;wcllo&#39;  &gt;&gt;&gt; &#39;hello&#39;.translate(table,&#39;o&#39;) # 第二个参数，可选择删除所出现的字符  &#39;wcll&#39;  &gt;&gt;&gt; &#39;helloc&#39;.translate(table,&#39;oc&#39;) # 看来是先删除，后替换  &#39;wcll&#39;  &gt;&gt;&gt; &#39;hello&#39;.translate(table,&#39;ol&#39;)  &#39;wc&#39;  &gt;&gt;&gt; table = maketrans(&#39;你&#39;, &#39;好&#39;) # 可以为表中添加其他字符  &gt;&gt;&gt; print &#39;你&#39;.translate(table)  好</code></pre><pre><code class="py">  # Python3  &gt;&gt;&gt; from string import maketrans  # 没有该函数  Traceback (most recent call last):  File &quot;&lt;pyshell#32&gt;&quot;, line 1, in &lt;module&gt;      from string import maketrans  ImportError: cannot import name &#39;maketrans&#39;  &gt;&gt;&gt; table = &#39;&#39;.maketrans(&#39;he&#39;, &#39;ab&#39;)  &gt;&gt;&gt; table  {104: 97, 101: 98}  &gt;&gt;&gt; &#39;wegerhtre&#39;.translate(table)  &#39;wbgbratrb&#39;  &gt;&gt;&gt; &#39;wegerhtre&#39;.translate(table, &#39;w&#39;)  # 没有第二个参数  Traceback (most recent call last):  File &quot;&lt;pyshell#40&gt;&quot;, line 1, in &lt;module&gt;      &#39;wegerhtre&#39;.translate(table, &#39;w&#39;)  TypeError: translate() takes exactly one argument (2 given)</code></pre></li><li><p><code>expandtabs(tabsize)</code>，其中的 tab 字符会用空格进行替换，可选择给定的 tabsize（默认为8）</p><pre><code class="py">  &gt;&gt;&gt; x = &#39;1\t1&#39;  &gt;&gt;&gt; x.expandtabs(1)  &#39;1 1&#39;  &gt;&gt;&gt; x.expandtabs()  &#39;1       1&#39;</code></pre></li></ul><h1 id="去除字符串两端-strip"><a href="#去除字符串两端-strip" class="headerlink" title="去除字符串两端 strip"></a>去除字符串两端 strip</h1><ul><li><code>strip([chars])</code>，去除字符串两端的 chars（默认空格，空白符）</li><li><code>lstrip([chars])，</code>去除字符串前端的 chars（默认空格，空白符）</li><li><code>rstrip([chars])，</code>去除字符串后端的 chars（默认空格，空白符）</li></ul><pre><code class="py">&gt;&gt;&gt; x = &#39;1  2  1&#39;&gt;&gt;&gt; x.strip(&#39;1&#39;)&#39;  2  &#39;</code></pre><h1 id="填充字符串两端-center，ljust，rjust，zfill"><a href="#填充字符串两端-center，ljust，rjust，zfill" class="headerlink" title="填充字符串两端 center，ljust，rjust，zfill"></a>填充字符串两端 center，ljust，rjust，zfill</h1><ul><li><p><code>center(width[, fillchar])</code>，返回一个长度为 max(len(string), width)，其中 String 的副本居中的字符串，两侧使用 fillchar（默认空白符，单个字符）填充</p><pre><code class="py">  &gt;&gt;&gt; x = &#39;123&#39;  &gt;&gt;&gt; x.center(10)  &#39;   123    &#39;  &gt;&gt;&gt; x.center(10,&#39;-&#39;)  &#39;---123----&#39;</code></pre></li><li><p><code>ljust(width[, fillchar])</code>，返回一个长度为 max(len(string), width)，其中 String 的副本左对齐的字符串，两侧使用 fillchar（默认空白符）填充</p></li><li><p><code>rjust(width[, fillchar])</code>，返回一个长度为 max(len(string), width)，其中 String 的副本右对齐的字符串，两侧使用 fillchar（默认空白符）填充</p><pre><code class="py">  &gt;&gt;&gt; x = &#39;a&#39;  &gt;&gt;&gt; x.ljust(10,&#39;b&#39;)  &#39;abbbbbbbbb&#39;  &gt;&gt;&gt; x.rjust(10,&#39;b&#39;)  &#39;bbbbbbbbba&#39;</code></pre></li><li><p><code>zfill(width)</code>，在 string 的左侧以 0 填充 width 个字符</p><pre><code class="py">  &gt;&gt;&gt; x.zfill(10)  &#39;0000000123&#39;</code></pre></li></ul><h1 id="编码解码-decode，encode"><a href="#编码解码-decode，encode" class="headerlink" title="编码解码 decode，encode"></a>编码解码 decode，encode</h1><ul><li><p><code>decode([encodeing[, errors]])</code>，返回使用给定编码方式的字符串的<strong>解码</strong>版本，由 errors 指定错误方式（&#39;strict&#39;、&#39;ignore&#39; 或 &#39;replace&#39;）</p></li><li><p><code>encode([encodeing[, errors]])</code>，返回使用给定编码方式的字符串的<strong>编码</strong>版本，由 errors 指定错误方式（&#39;strict&#39;、&#39;ignore&#39; 或 &#39;replace&#39;）</p></li></ul><h1 id="检查字符串组成-isalnum，isalpha，isdigit，isspace"><a href="#检查字符串组成-isalnum，isalpha，isdigit，isspace" class="headerlink" title="检查字符串组成 isalnum，isalpha，isdigit，isspace"></a>检查字符串组成 isalnum，isalpha，isdigit，isspace</h1><ul><li><code>isalnum</code>，检查字符串是否以字母或数字组成</li><li><code>isalpha</code>，检查字符串是否由字母组成</li><li><code>isdigit</code>，检查字符串是否由数字组成</li><li><code>isspace</code>，检查字符串是否由空格(空白字符)组成</li></ul><h1 id="搜索子字符串-partition，rpartition"><a href="#搜索子字符串-partition，rpartition" class="headerlink" title="搜索子字符串 partition，rpartition"></a>搜索子字符串 partition，rpartition</h1><ul><li><code>partition(sep)</code>，在字符串中搜索 sep 并返回 (head, sep, tail)</li><li><code>rpartition(sep)</code>，同 partition，但从右边找</li></ul><pre><code class="py">&gt;&gt;&gt; x = &#39;abcdefgabcedefg&#39;&gt;&gt;&gt; x.partition(&#39;de&#39;)(&#39;abc&#39;, &#39;de&#39;, &#39;fgabcedefg&#39;)&gt;&gt;&gt; x.rpartition(&#39;de&#39;)(&#39;abcdefgabce&#39;, &#39;de&#39;, &#39;fg&#39;)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Python基础教程》读书笔记02-列表和元组</title>
      <link href="/2017/01/01/%E3%80%8APython%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B002-%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/"/>
      <url>/2017/01/01/%E3%80%8APython%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B002-%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p>最基本的数据结构：序列（sequence），序列中每个元素被分配一个序列号（即元素的位置），也称为<strong>索引</strong>。</p><p>Python 包含六种内建的序列，<strong>列表、元组</strong>、字符串、Unicode 字符串、buffer 对象和 xrange 对象。</p><p>列表和元组的主要区别在于，列表可以修改，元组不能。<strong>内建函数一般会返回元组。</strong></p><p>在 dict 中可以使用元组作为键，而不能使用列表，因为<strong>键是不能修改的（不可变对象）。</strong></p><a id="more"></a><h2 id="通用序列操作"><a href="#通用序列操作" class="headerlink" title="通用序列操作"></a>通用序列操作</h2><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><pre><code class="py">&gt;&gt;&gt; x = &#39;hello&#39;&gt;&gt;&gt; x[0]&#39;h&#39;&gt;&gt;&gt; x[-1] # 可以使用负数索引&#39;o&#39;&gt;&gt;&gt; &#39;hello&#39;[0]&#39;h&#39;</code></pre><h3 id="分片（切片）"><a href="#分片（切片）" class="headerlink" title="分片（切片）"></a>分片（切片）</h3><pre><code class="py">&gt;&gt;&gt; numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]&gt;&gt;&gt; numbers[3:6][4, 5, 6]&gt;&gt;&gt; numbers[0:1] # 不包含第二个索引[1]&gt;&gt;&gt; numbers[-3:] # 可以使用负数索引[8, 9, 10]&gt;&gt;&gt; numbers[-3:-1] # 开始点必须小于结束点[8, 9]&gt;&gt;&gt; numbers[7:] # 如果分片所得的部分要包含序列结尾的元素[8, 9, 10]&gt;&gt;&gt; numbers[:3] # 也可以空置第一个索引[1, 2, 3]&gt;&gt;&gt; numbers[:] # 复制整个序列[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</code></pre><p><strong>步长</strong>，在上面的例子中步长默认为 1</p><pre><code class="py">&gt;&gt;&gt; numbers[0:10:1] # 默认不写，步长为1[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]&gt;&gt;&gt; numbers[0:10:2][1, 3, 5, 7, 9]&gt;&gt;&gt; numbers[::4][1, 5, 9]# 当使用负数作为步长时，必须开始点大于结束点&gt;&gt;&gt; numbers[8:3:-1] # 步长可以为负数，此时分片从右到左提取元素，同样开始点包含，结束点不包含[9, 8, 7, 6, 5]&gt;&gt;&gt; numbers[5::-2][6, 4, 2]&gt;&gt;&gt; numbers[:5:-2][10, 8]&gt;&gt;&gt; numbers[-1:-5:-2][10, 8]</code></pre><h3 id="序列相加"><a href="#序列相加" class="headerlink" title="序列相加"></a>序列相加</h3><p>相同类型的序列才可以相加，列表与字符串无法连接在一起</p><pre><code class="py">&gt;&gt;&gt; [1,2,3] + [4,5][1, 2, 3, 4, 5]&gt;&gt;&gt; [1,2] + &#39;hello&#39;Traceback (most recent call last):  File &quot;&lt;pyshell#37&gt;&quot;, line 1, in &lt;module&gt;    [1,2] + &#39;hello&#39;TypeError: can only concatenate list (not &quot;str&quot;) to list&gt;&gt;&gt; &#39;hello, &#39; + &#39;world&#39;&#39;hello, world&#39;&gt;&gt;&gt; [1, 1] + [&#39;a&#39;, &#39;b&#39;][1, 1, &#39;a&#39;, &#39;b&#39;]</code></pre><h3 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h3><pre><code class="py">&gt;&gt;&gt; &#39;python&#39; * 5&#39;pythonpythonpythonpythonpython&#39;&gt;&gt;&gt; [42] * 10[42, 42, 42, 42, 42, 42, 42, 42, 42, 42]&gt;&gt;&gt; sequence = [None] * 10 # 可以用于创建一个占用10个元素空间，却不包含任何有用内容的列表&gt;&gt;&gt; sequence[None, None, None, None, None, None, None, None, None, None]</code></pre><h3 id="成员资格（是否包含）"><a href="#成员资格（是否包含）" class="headerlink" title="成员资格（是否包含）"></a>成员资格（是否包含）</h3><p>包含返回 True，不包含返回 False</p><pre><code class="py">&gt;&gt;&gt; permissions = &#39;rw&#39;&gt;&gt;&gt; &#39;w&#39; in permissionsTrue&gt;&gt;&gt; &#39;x&#39; in permissionsFalse&gt;&gt;&gt; users = [&#39;zhang&#39;, &#39;wang&#39;, &#39;li&#39;]&gt;&gt;&gt; &#39;li&#39; in usersTrue&gt;&gt;&gt; &#39;zhao&#39; in usersFalse&gt;&gt;&gt; &#39;rw&#39; in permissionsTrue&gt;&gt;&gt; users = [[&#39;zhang&#39;, 1], [&#39;wang&#39;, 2], [&#39;li&#39;, 3]]&gt;&gt;&gt; [&#39;li&#39;, 3] in usersTrue</code></pre><h3 id="长度、最小值和最大值"><a href="#长度、最小值和最大值" class="headerlink" title="长度、最小值和最大值"></a>长度、最小值和最大值</h3><pre><code class="py">&gt;&gt;&gt; numbers = [100, 34, 678]&gt;&gt;&gt; len(numbers) # len函数返回序列中所包含元素的数量3&gt;&gt;&gt; max(numbers) # 返回最大元素678&gt;&gt;&gt; min(numbers) # 返回最小元素34&gt;&gt;&gt; max(2, 3)  # 这里的参数不是序列，而是以多个数字直接作为参数，可变参数3&gt;&gt;&gt; min(5, 3, 6)3</code></pre><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><pre><code class="py">&gt;&gt;&gt; x = list(&#39;hello&#39;) # list 是一种类型，不是函数&gt;&gt;&gt; x[&#39;h&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;]&gt;&gt;&gt; &#39;&#39;.join(x) # 将一个由字符串组成的列表转换为字符串&#39;hello&#39;</code></pre><h3 id="元素赋值"><a href="#元素赋值" class="headerlink" title="元素赋值"></a>元素赋值</h3><pre><code class="py">&gt;&gt;&gt; x[&#39;h&#39;, &#39;e&#39;, &#39;l&#39;, &#39;o&#39;]&gt;&gt;&gt; x[1] = &#39;2&#39; # 不能越界&gt;&gt;&gt; x[&#39;h&#39;, &#39;2&#39;, &#39;l&#39;, &#39;o&#39;]</code></pre><h3 id="分片赋值"><a href="#分片赋值" class="headerlink" title="分片赋值"></a>分片赋值</h3><pre><code class="py">&gt;&gt;&gt; name = list(&#39;Perl&#39;)&gt;&gt;&gt; name[&#39;P&#39;, &#39;e&#39;, &#39;r&#39;, &#39;l&#39;]&gt;&gt;&gt; name[2:] = list(&#39;ar&#39;) # 可以一次为多个元素赋值&gt;&gt;&gt; name[&#39;P&#39;, &#39;e&#39;, &#39;a&#39;, &#39;r&#39;]&gt;&gt;&gt; name[1:] = list(&#39;ython&#39;) # 可以更改列表的长度，并添加替换&gt;&gt;&gt; name[&#39;P&#39;, &#39;y&#39;, &#39;t&#39;, &#39;h&#39;, &#39;o&#39;, &#39;n&#39;]&gt;&gt;&gt; numbers = [1, 5]&gt;&gt;&gt; numbers[1:1] = [2, 3, 4] # 可以不替换任何元素的情况下，插入新的元素&gt;&gt;&gt; numbers[1, 2, 3, 4, 5]&gt;&gt;&gt; numbers[1:4] = [] # 删除元素&gt;&gt;&gt; numbers[1, 5]&gt;&gt;&gt; numbers[2:2] = [2] # 向最后的位置添加元素&gt;&gt;&gt; numbers[1, 5, 2]&gt;&gt;&gt; numbers = [1, 2, 3, 4, 5]&gt;&gt;&gt; numbers[4:1:-2] = [6] # 加入步长，所赋值的元素前后数量要一致Traceback (most recent call last):  File &quot;&lt;pyshell#100&gt;&quot;, line 1, in &lt;module&gt;    numbers[4:1:-2] = [6]ValueError: attempt to assign sequence of size 1 to extended slice of size 2&gt;&gt;&gt; numbers[4:1:-2] = [6,7]&gt;&gt;&gt; numbers[1, 2, 7, 4, 6]&gt;&gt;&gt; numbers[4:1:-3] = [8]&gt;&gt;&gt; numbers[1, 2, 7, 4, 8]</code></pre><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><h4 id="del"><a href="#del" class="headerlink" title="del"></a>del</h4><p>删除指定位置的元素 <code>del</code> 语句：</p><pre><code class="py">&gt;&gt;&gt; x[&#39;h&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;]&gt;&gt;&gt; del x[2]&gt;&gt;&gt; x[&#39;h&#39;, &#39;e&#39;, &#39;l&#39;, &#39;o&#39;]</code></pre><h4 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h4><p>要删除 list 末尾的元素，用 <code>pop()</code> 方法：</p><pre><code class="py">&gt;&gt;&gt; classmates[&#39;Michael&#39;, &#39;Jack&#39;, &#39;Bob&#39;, &#39;Tracy&#39;, &#39;Adam&#39;]&gt;&gt;&gt; classmates.pop()&#39;Adam&#39;&gt;&gt;&gt; classmates[&#39;Michael&#39;, &#39;Jack&#39;, &#39;Bob&#39;, &#39;Tracy&#39;]</code></pre><p>要删除指定位置的元素，用 <code>pop(i)</code> 方法，其中 <code>i</code> 是索引位置：</p><pre><code class="py">&gt;&gt;&gt; classmates.pop(1)&#39;Jack&#39;&gt;&gt;&gt; classmates[&#39;Michael&#39;, &#39;Bob&#39;, &#39;Tracy&#39;]</code></pre><h4 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h4><p>remove 方法用于移除列表中某个值的第一个匹配项：</p><pre><code class="py">&gt;&gt;&gt; x = [1, 2, 3, 4, 2]&gt;&gt;&gt; x.remove(2)&gt;&gt;&gt; x[1, 3, 4, 2]&gt;&gt;&gt; x.remove(5) # 如果列表不存在该元素则报错Traceback (most recent call last):  File &quot;&lt;pyshell#122&gt;&quot;, line 1, in &lt;module&gt;    x.remove(5)ValueError: list.remove(x): x not in list</code></pre><h4 id="循环中删除"><a href="#循环中删除" class="headerlink" title="循环中删除"></a>循环中删除</h4><pre><code class="py"># 删除 num_list 中为空的元素num_list = [1, 2, 3, 4, None, 6, 7, 8, None, 10, 11, None, 13, 14, None]# 方法一：使用逆序遍历for i in range(len(num_list) - 1, -1, -1):    if not num_list[i]:        num_list.pop(i)print(num_list)  # [1, 2, 3, 4, 6, 7, 8, 10, 11, 13, 14]# 方法二：使用逆序遍历，与一类似num_list = [1, 2, 3, 4, None, 6, 7, 8, None, 10, 11, None, 13, 14, None]for i in num_list[::-1]:    if not i:        num_list.remove(i)print(num_list)  # [1, 2, 3, 4, 6, 7, 8, 10, 11, 13, 14]# 方法三：写入新列表中num_list = [1, 2, 3, 4, None, 6, 7, 8, None, 10, 11, None, 13, 14, None]new_list = []for i in num_list:    if i:        new_list.append(i)print(new_list)  # [1, 2, 3, 4, 6, 7, 8, 10, 11, 13, 14]# 方法四：列表推导式new_list = [i for i in num_list if i]  # [1, 2, 3, 4, 6, 7, 8, 10, 11, 13, 14]# 方法五：使用 filter 和 lambdanew_list = list(filter(lambda x: x, num_list))  # [1, 2, 3, 4, 6, 7, 8, 10, 11, 13, 14]</code></pre><blockquote><p><a href="http://www.chenxm.cc/article/67.html" target="_blank" rel="noopener">http://www.chenxm.cc/article/67.html</a></p></blockquote><h3 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h3><p><code>append</code>，<code>insert</code>，<code>extend</code> 方法会直接修改原来的列表，<code>+</code> 连接不会修改原来的列表</p><h4 id="append"><a href="#append" class="headerlink" title="append"></a>append</h4><p>可以往 list 中追加元素到末尾</p><pre><code class="py">&gt;&gt;&gt; classmates.append(&#39;Adam&#39;)&gt;&gt;&gt; classmates[&#39;Michael&#39;, &#39;Bob&#39;, &#39;Tracy&#39;, &#39;Adam&#39;]</code></pre><h4 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h4><p>也可以把元素插入到指定的位置，比如索引号为 <code>1</code> 的位置：</p><pre><code class="py">&gt;&gt;&gt; classmates.insert(1, &#39;Jack&#39;)&gt;&gt;&gt; classmates[&#39;Michael&#39;, &#39;Jack&#39;, &#39;Bob&#39;, &#39;Tracy&#39;, &#39;Adam&#39;]</code></pre><h4 id="extend"><a href="#extend" class="headerlink" title="extend"></a>extend</h4><p>extend 方法可以在列表的末尾一次性追加另一个序列的多个值：</p><pre><code class="py">&gt;&gt;&gt; a = [1]&gt;&gt;&gt; b = [2]&gt;&gt;&gt; a.extend(b)&gt;&gt;&gt; a[1, 2]&gt;&gt;&gt; x = [1]&gt;&gt;&gt; y = [2]&gt;&gt;&gt; z = x + y&gt;&gt;&gt; z[1, 2]&gt;&gt;&gt; x[1]&gt;&gt;&gt; a = a + b # 效率要比extend低</code></pre><p>也可以使用分片，但可读性低</p><pre><code class="py">&gt;&gt;&gt; a = [1]&gt;&gt;&gt; b = [2]&gt;&gt;&gt; a[len(a):] = b&gt;&gt;&gt; a[1, 2]</code></pre><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p><code>index</code> 方法用于从列表中找出某个值第一个匹配项的<strong>索引位置</strong></p><pre><code class="py">&gt;&gt;&gt; x = [1, 2, 3, 4]&gt;&gt;&gt; x.index(2)1&gt;&gt;&gt; x.index(6) # 未找到引发异常Traceback (most recent call last):  File &quot;&lt;pyshell#126&gt;&quot;, line 1, in &lt;module&gt;    x.index(6)ValueError: 6 is not in list</code></pre><h3 id="元素出现次数"><a href="#元素出现次数" class="headerlink" title="元素出现次数"></a>元素出现次数</h3><p>count 方法统计某个元素在列表中出现的次数。</p><pre><code class="py">&gt;&gt;&gt; x = [1, 2, 3, 4, 5, 2, 2]&gt;&gt;&gt; x.count(2)3&gt;&gt;&gt; x.count(6)0</code></pre><h3 id="反转"><a href="#反转" class="headerlink" title="反转"></a>反转</h3><p>reverse 方法将列表中的元素反向存放，不返回值，直接修改列表</p><pre><code class="py">&gt;&gt;&gt; x = [1, 2, 3, 4]&gt;&gt;&gt; x.reverse()&gt;&gt;&gt; x[4, 3, 2, 1]</code></pre><p>如果需要对一个序列进行反向迭代，可以使用 <code>reversed</code> 函数，返回一个迭代器对象，可以使用 <code>list</code> 转换成列表</p><pre><code class="py">&gt;&gt;&gt; x[4, 3, 2, 1]&gt;&gt;&gt; y = list(reversed(x)) # 不改变原本序列&gt;&gt;&gt; y[1, 2, 3, 4]&gt;&gt;&gt; x[4, 3, 2, 1]&gt;&gt;&gt; x[::-1]  # 也可以使用分片[4, 3, 2, 1]</code></pre><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><p><code>sort</code> 方法修改原列表，不返回值</p><pre><code class="py">&gt;&gt;&gt; x = [23, 523, 25, 3]&gt;&gt;&gt; x.sort()&gt;&gt;&gt; x[3, 23, 25, 523]</code></pre><p>如果要不改变原列表，则需要复制整个列表：</p><pre><code class="py">&gt;&gt;&gt; x = [23, 523, 25, 3]&gt;&gt;&gt; y = x[:]&gt;&gt;&gt; y[23, 523, 25, 3]&gt;&gt;&gt; y.sort()&gt;&gt;&gt; y[3, 23, 25, 523]&gt;&gt;&gt; x[23, 523, 25, 3]</code></pre><h4 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h4><p>另一种不改变原列表，获得已排序列表的方法。<code>sorted</code> 可以用于任何可迭代的对象。</p><pre><code class="py">&gt;&gt;&gt; y = sorted(x)&gt;&gt;&gt; y[3, 23, 25, 523]&gt;&gt;&gt; x[23, 523, 25, 3]</code></pre><h4 id="Python2-自定义排序"><a href="#Python2-自定义排序" class="headerlink" title="Python2 自定义排序"></a>Python2 自定义排序</h4><p>可以通过 <code>compare(x, y)</code> 的形式自定义<strong>比较函数</strong>。在 <code>x&lt;y</code> 时返回负数，在 <code>x&gt;y</code> 时返回正数，在 <code>x=y</code> 时返回 0。定义好之后可以提供给 <code>sort</code> 方法作为参数了。内建函数 <code>cmp</code> 提供了比较函数的默认实现。</p><pre><code class="py">&gt;&gt;&gt; cmp(43, 34)1&gt;&gt;&gt; cmp(23, 34)-1&gt;&gt;&gt; cmp(20, 20)0&gt;&gt;&gt; x[23, 523, 25, 3]&gt;&gt;&gt; x.sort(cmp)&gt;&gt;&gt; x[3, 23, 25, 523]</code></pre><pre><code class="py">def pmc(x, y): # 自定义比较函数，从大到小    if x &gt; y:        return -1    if x &lt; y:        return 1    if x == y:        return 0&gt;&gt;&gt; x.sort(pmc)&gt;&gt;&gt; x[523, 25, 23, 3]</code></pre><h4 id="sort-的两个可选参数"><a href="#sort-的两个可选参数" class="headerlink" title="sort 的两个可选参数"></a>sort 的两个可选参数</h4><p><code>key</code> 和 <code>reverse</code>，如果要使用他们需要通过名字指定(<strong>关键字参数</strong>)。cmp, key, reverse 参数都可以用于 sorted 函数。</p><p>参数 <code>key</code> 和参数 <code>cmp</code> 类似，也是需要提供一个函数，然而，<strong>该函数不是直接用来确定对象的大小，而是为每个元素创建一个键，然后所有元素根据键来排序。</strong></p><p>如果需要根据元素长度进行排序，可以使用 len 函数作为键函数</p><pre><code class="py">x = [&#39;12345&#39;, &#39;123&#39;, &#39;1234&#39;]x.sort(key=len)x# [&#39;123&#39;, &#39;1234&#39;, &#39;12345&#39;]def acounts(x): # 自定义比较函数，根据&#39;a&#39;的数量排序    return x.count(&#39;a&#39;)&gt;&gt;&gt; x = [&#39;aa&#39;, &#39;a&#39;, &#39;aaa&#39;]&gt;&gt;&gt; x.sort(key=acounts)&gt;&gt;&gt; x[&#39;a&#39;, &#39;aa&#39;, &#39;aaa&#39;]# Python3 没有 cmp 函数，所以需要使用 key 参数&gt;&gt;&gt; random = [(2, 2), (3, 4), (4, 1), (1, 3)]&gt;&gt;&gt; random.sort(key=lambda x: x[1])&gt;&gt;&gt; random[(4, 1), (2, 2), (1, 3), (3, 4)]</code></pre><p>关键字参数 <code>reverse</code>，是简单的布尔值，用来指明列表是否要进行反向排序。</p><pre><code class="py">&gt;&gt;&gt; x = [23,234,26,41]&gt;&gt;&gt; x.sort(reverse=True)&gt;&gt;&gt; x[234, 41, 26, 23]</code></pre><h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><p>元组不能修改，用圆括号()括起来，</p><pre><code class="py">&gt;&gt;&gt; (1, 2, 3)(1, 2, 3)&gt;&gt;&gt; ()()&gt;&gt;&gt; (1) # 这个不是元组1&gt;&gt;&gt; (1,) # 单个元组，必须要加逗号(1,)&gt;&gt;&gt; 3 * (40 + 3)129&gt;&gt;&gt; 3 * (40 + 3,)(43, 43, 43)</code></pre><h3 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h3><p>可以将序列转换为元组</p><pre><code class="py">&gt;&gt;&gt; tuple([1, 2, 3])(1, 2, 3)&gt;&gt;&gt; tuple(&#39;asd&#39;)(&#39;a&#39;, &#39;s&#39;, &#39;d&#39;)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Effective Java》笔记08：避免使用 Finalizer 和 Cleaner 机制</title>
      <link href="/2016/11/06/%E3%80%8AEffective%20Java%E3%80%8B%E7%AC%94%E8%AE%B008%EF%BC%9A%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%20Finalizer%20%E5%92%8C%20Cleaner%20%E6%9C%BA%E5%88%B6/"/>
      <url>/2016/11/06/%E3%80%8AEffective%20Java%E3%80%8B%E7%AC%94%E8%AE%B008%EF%BC%9A%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%20Finalizer%20%E5%92%8C%20Cleaner%20%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h1><p>JDK8 及以下</p><pre><code class="java">protected void finalize() throws Throwable</code></pre><p>以下来自 <code>JAVA API文档</code>：<br>当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。子类重写 <code>finalize</code> 方法，以配置系统资源或执行其他清除。</p><a id="more"></a><p><code>finalize</code> 的常规协定是：当 <code>Java™</code> 虚拟机已确定尚未终止的任何线程无法再通过任何方法访问此对象时，将调用此方法，除非由于准备终止的其他某个对象或类的终结操作执行了某个操作。<code>finalize</code> 方法可以采取任何操作，其中包括再次使此对象对其他线程可用；不过，<code>finalize</code> 的主要目的是在不可撤消地丢弃对象之前执行清除操作。例如，表示输入/输出连接的对象的 <code>finalize</code> 方法可执行显式 <code>I/O</code> 事务，以便在永久丢弃对象之前中断连接。</p><p><code>Object</code> 类的 <code>finalize</code> 方法执行非特殊性操作；它仅执行一些常规返回。<code>Object</code> 的子类可以重写此定义。</p><p><code>Java</code> 编程语言不保证哪个线程将调用某个给定对象的 <code>finalize</code> 方法。但可以保证在调用 <code>finalize</code> 时，调用 <code>finalize</code> 的线程将不会持有任何用户可见的同步锁定。<strong>如果 <code>finalize</code> 方法抛出未捕获的异常，那么该异常将被忽略，并且该对象的终结操作将终止</strong>，并不会打印警告信息。</p><h2 id="合理使用"><a href="#合理使用" class="headerlink" title="合理使用"></a>合理使用</h2><ol><li>当对象忘记调用资源的关闭方法，可以在日志中记录一条警告。（<code>FileInputStream</code>，<code>FileOutputStream</code>，<code>Timer</code>，<code>Connection</code>）</li><li><code>本地对等体</code>（native peer），是一个本地对象（native object），普通对象通过本地方法（native method）委托给一个本地对象。因为本地对等体不是一个普通对象，所以垃圾回收器不会知道它，当它的 Java 对等体被回收时，它不会被回收。所以需要使用 <code>finalize</code> 方法。如果本地对等体拥有必须及时终止的资源，那么该类就应该具有一个显式的终止方法。终止方法应该完成所有必要的工作以便释放关键的资源。终止方法可以是本地方法，或者它也可以调用本地方法。</li></ol><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol><li>使用 <code>finalize</code> 方法有严重的性能损失。</li><li>如果类（不是 Object）有 <code>finalize</code> 方法，并且子类覆盖了这个方法，子类必须调用超类的 <code>finalize</code> 方法。应该在一个 <code>try</code> 块中终结子类，并在 <code>finally</code> 块中调用超类的终结方法。</li><li>如果没有调用终结方法，可以防范这个问题，为每一个将被终结的对象创建一个附加对象，不是把终结方法放在要求终结处理的类中，而是把终结方法放在一个匿名的类中，该匿名类的唯一用途就是终结它的外围实例。该匿名类的单个实例被称为<em>终结方法守卫者</em>，外围类的每个实例都会创建这样一个守卫者。外围实例在它的私有实例域中保存着一个对其终结方法守卫者的唯一引用，因此终结方法守卫者与外围实例可以同时启动终结过程，当守卫者被终结的时候，它执行外围实例所期望的终结行为，就好像它的终结方法是外围对象上的一个方法一样：</li></ol><pre><code class="java">public class Foo {    private final Object finalizerGuardian = new Object() {        @Overide        protected void finalize() throws Throwable {            ...//Finallize outer Foo object        };        ...//    }}</code></pre><p>公有类 Foo 并没有终结方法，所以子类的终结方法是否调用 <code>super.finalize</code> 并不重要。对于每一个带有终结方法的非 <code>final</code> 公有类，都应该考虑使用这种方法。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>除非是作为安全网，或者为了终止非关键的本地资源，否则请不要使用终结方法。<br>使用了就一定要记住调用<code>super.finalize</code>。考虑使用终结方法守卫者。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><pre><code class="java">/** * 终结方法守卫者 * @author xingle * http://www.cnblogs.com/xingele0917/p/4330182.html * @date 2015-3-11 下午3:49:47 */public class Parent {    public static void main(String[] args){        doSth();        System.gc();        try {            Thread.sleep(2000);        } catch (InterruptedException e) {            e.printStackTrace();        }    }    private static void doSth() {        Child c = new Child();        System.out.println(c);    }    private final Object guardian = new Object(){        @Override        protected void finalize(){             System.out.println(&quot;执行父类中匿名内部类--终结方法守卫者,重写的 finalize()&quot;);             // 在这里调用 Parent 重写的 finalize 即可在清理子类时调用父类自己的清理方法             parentlFinalize();        }    };    protected void parentlFinalize() {         System.out.println(&quot;执行父类自身的终结方法&quot;);    }}class Child extends Parent {    @Override    protected void finalize() {        System.out.println(&quot;执行子类 finalize 方法，注意，这里子类并没有调用 super.finalize()&quot;);        // 由于子类（忘记或者其他原因）没有调用 super.finalize()        // 使用终结方法守卫者可以保证子类执行 finalize() 时(没有调用 super.finalize())，父类的清理方法仍旧调用    }}</code></pre><p>结果：</p><pre><code class="log">Child@782bbb7b执行父类中匿名内部类--终结方法守卫者,重写的 finalize()执行父类自身的终结方法执行子类 finalize 方法，注意，这里子类并没有调用 super.finalize()</code></pre><h1 id="Cleaner"><a href="#Cleaner" class="headerlink" title="Cleaner"></a>Cleaner</h1><p>从 Java 9 开始，Finalizer 机制已被弃用，但仍被 Java 类库所使用。Java 9 中 Cleaner 机制代替了 Finalizer 机制。Cleaner 机制不如 Finalizer 机制那样危险，但仍然是不可预测，运行缓慢并且通常是不必要的。</p><p>两种合理使用的方式同上文。</p><p>Cleaner 机制使用起来有点棘手。下面是演示该功能的一个简单的 Room 类。假设 Room 对象必须在被回收前清理干净。Room 类实现 AutoCloseable 接口；它的自动清理安全网使用的是一个 Cleaner 机制，这仅仅是一个实现细节。与 Finalizer 机制不同，Cleaner 机制不污染一个类的公共 API：</p><pre><code class="java">// An autocloseable class using a cleaner as a safety netpublic class Room implements AutoCloseable {    private static final Cleaner cleaner = Cleaner.create();    // Resource that requires cleaning. Must not refer to Room!    private static class State implements Runnable {        int numJunkPiles; // Number of junk piles in this room        State(int numJunkPiles) {            this.numJunkPiles = numJunkPiles;        }        // Invoked by close method or cleaner        @Override        public void run() {            System.out.println(&quot;Cleaning room&quot;);            numJunkPiles = 0;        }    }    // The state of this room, shared with our cleanable    private final State state;    // Our cleanable. Cleans the room when it’s eligible for gc    private final Cleaner.Cleanable cleanable;    public Room(int numJunkPiles) {        state = new State(numJunkPiles);        cleanable = cleaner.register(this, state);    }    @Override    public void close() {        cleanable.clean();    }}</code></pre><p>静态内部 State 类拥有 Cleaner 机制清理房间所需的资源。在这里，它仅仅包含 numJunkPiles 属性，它代表混乱房间的数量。更实际地说，它可能是一个 final 修饰的 long 类型的指向本地对等类的指针。State 类实现了 Runnable 接口，其 run 方法最多只能调用一次，只能被我们在 Room 构造方法中用 Cleaner 机制注册 State 实例时得到的 Cleanable 调用。对 run 方法的调用通过以下两种方法触发：通常，通过调用 Room 的 close 方法内调用 Cleanable 的 clean 方法来触发。如果在 Room 实例有资格进行垃圾回收的时候客户端没有调用 close 方法，那么 Cleaner 机制将（希望）调用 State 的 run 方法。</p><p>　一个 State 实例不引用它的 Room 实例是非常重要的。如果它引用了，则创建了一个循环，阻止了 Room 实例成为垃圾收集的资格（以及自动清除）。因此，State 必须是静态的嵌内部类，因为非静态内部类包含对其宿主类的实例的引用。同样，使用 lambda 表达式也是不明智的，因为它们很容易获取对宿主类对象的引用。</p><p>　　就像我们之前说的，Room 的 Cleaner 机制仅仅被用作一个安全网。如果客户将所有 Room 的实例放在 try-with-resource 块中，则永远不需要自动清理。行为良好的客户端如下所示：</p><pre><code class="java">public class Adult {    public static void main(String[] args) {        try (Room myRoom = new Room(7)) {            System.out.println(&quot;Goodbye&quot;);        }    }}</code></pre><p>正如你所预料的，运行 Adult 程序会打印 Goodbye 字符串，随后打印 Cleaning room 字符串。但是如果时不合规矩的程序，它从来不清理它的房间会是什么样的?</p><pre><code class="java">public class Teenager {    public static void main(String[] args) {        new Room(99);        System.out.println(&quot;Peace out&quot;);    }}</code></pre><p>你可能期望它打印出 Peace out，然后打印 Cleaning room 字符串，但在我的机器上，它从不打印 Cleaning room 字符串；仅仅是程序退出了。这是我们之前谈到的不可预见性。Cleaner 机制的规范说：“System.exit 方法期间的清理行为是特定于实现的。不保证清理行为是否被调用。”虽然规范没有说明，但对于正常的程序退出也是如此。在我的机器上，将 System.gc() 方法添加到 Teenager 类的 main 方法足以让程序退出之前打印 Cleaning room，但不能保证在你的机器上会看到相同的行为。</p><p>总之，除了作为一个安全网或者终止非关键的本地资源，不要使用 Cleaner 机制，或者是在 Java 9 发布之前的 finalizers 机制。即使是这样，也要当心不确定性和性能影响。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Effective Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Effective Java》笔记07：消除过期的对象引用</title>
      <link href="/2016/11/04/%E3%80%8AEffective%20Java%E3%80%8B%E7%AC%94%E8%AE%B007%EF%BC%9A%E6%B6%88%E9%99%A4%E8%BF%87%E6%9C%9F%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8/"/>
      <url>/2016/11/04/%E3%80%8AEffective%20Java%E3%80%8B%E7%AC%94%E8%AE%B007%EF%BC%9A%E6%B6%88%E9%99%A4%E8%BF%87%E6%9C%9F%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p><strong>如果一个栈先是增长，然后再收缩，那么，从栈中弹出来的对象将不会被当作垃圾回收</strong>。即使使用栈的程序不再引用这些对象，它们也不会被回收。</p><a id="more"></a><pre><code class="java">public class Stack {    private Object[] elements;    private int size = 0;    private static final int DEFAULT_INITIAL_CAPACITY = 16;    public Stack() {        elements = new Object[DEFAULT_INITIAL_CAPACITY];    }    public void push(Object e) {        ensureCapacity();        elements[size++] = e;    }    public Object pop() {        if (size == 0)            throw new EmptyStackException();        return elements[--size];    }    private void ensureCapacity() {        if (elements.length == size)            elements = Arrays.copys(elements, 2 * size + 1);    }}</code></pre><p>以上示例代码，在正常的使用中不会产生任何逻辑问题，然而随着程序运行时间不断加长，内存泄露造成的副作用将会慢慢的显现出来，如磁盘页交换、OutOfMemoryError 等。因为栈内部维护着对这些对象的过期引用，永远不会被解除。</p><h2 id="修改方式"><a href="#修改方式" class="headerlink" title="修改方式"></a>修改方式</h2><pre><code class="java">public Object pop() {    if (size == 0)        throw new EmptyStackException();    Object result = elements[--size];    elements[size] = null; // 手工将数组中的该对象置空    return result;}</code></pre><p>清空过期引用的另一个好处是，如果他们以后又被错误的解除引用，程序就会立刻抛出 NullPointerException 异常，而不是悄悄的错误运行下去。</p><h2 id="不要被类似的问题困扰"><a href="#不要被类似的问题困扰" class="headerlink" title="不要被类似的问题困扰"></a>不要被类似的问题困扰</h2><p>当程序员第一次被类似这样的问题困扰的时候，他们往往会过分小心；对于每一个对象引用，一旦不再使用它，就把它清空，这是没有必要的，这样反而会把代码弄的混乱。<strong>清空对象的引用应该是一种例外，而不是一种规范行为</strong>。消除过期引用最好的办法是让包含该引用的变量结束其生命周期。如果是在最紧凑的作用域范围内定义每一个变量，这种情况就会自然而然地发生。</p><h2 id="何时清空引用"><a href="#何时清空引用" class="headerlink" title="何时清空引用"></a>何时清空引用</h2><p>一旦数组元素变成了非活动部分的一部分，就手工清空这些数组元素。</p><p><strong>一般而言，只要类是自己管理内存，就应该警惕内存泄漏问题。一旦元素被释放掉，则该元素中包含的任何对象引用都应该被清空。</strong></p><h2 id="内存泄漏常见来源"><a href="#内存泄漏常见来源" class="headerlink" title="内存泄漏常见来源"></a>内存泄漏常见来源</h2><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>一旦你把对象引用放到缓存中，它就很容易被遗忘掉，从而使得它不再有用之后很长一段时间内仍然留在缓存中。对于这个问题，有几种可能的解决方案。如果你正好要实现这样的缓存：只要在缓存之外存在对某个项的键的引用，该项就有意义，那么就可以用<code>WeakHashMap</code>（弱键映射，允许垃圾回收器回收无外界引用指向象 <code>Map</code> 中键）代表缓存；当缓存中的项过期之后，它们就会自动被删除。记住只有当所要的缓存项的任命周期是由该键的外部引用而不是由值决定时，<code>WeakHashMap</code> 才有用外。</p><h3 id="缓存项的生命周期是否意义"><a href="#缓存项的生命周期是否意义" class="headerlink" title="缓存项的生命周期是否意义"></a>缓存项的生命周期是否意义</h3><p>并不是很容易确定，随着时间的推移，其中的项会变的越来越没有价值，这种情况下，缓存应该时不时的清楚掉没有用的项。这项清楚工作可以由一个后台线程（可能是 <code>Timer</code> 或者 <code>ScheduledThreadPoolExecutor</code>）来完成，或者也可以在给缓存添加新条目的时候顺便进行清理。<code>LinkedHashMap</code> 类中 <code>removeEldestEntry</code> 方法可以很容易地实现后一种方案。对于更加复杂的缓存，必须直接使用 <code>java.lang.ref</code>。</p><p>如果要实现前一种功能，我们需继承 <code>LinkedHashMap</code> 并重写它的 <code>removeEldestEntry</code> 方法（默认返回<code>false</code>，即不会删除最旧项），<code>put</code> 和 <code>putAll</code> 将调用此方法，下面是<a href="http://www.cnblogs.com/jiangzhengjun/p/4254987.html" target="_blank" rel="noopener">测试项</a>：</p><pre><code class="java">public class CacheLinkedHashMap extends LinkedHashMap {    // 允许最大放入的个数，超过则可能删除最旧项    private static final int MAX_ENTRIES = 5;    @Override    // 是否删除最旧项（最先放入）实现    protected boolean removeEldestEntry(Map.Entry eldest) {        Integer num = (Integer) eldest.getValue();  // 最早项的值        // 如果老的项小于3且已达到最大允许容量则会删除最老的项        if (num.intValue() &lt; 3 &amp;&amp; size() &gt; MAX_ENTRIES) {            System.out.println(&quot;超容 - &quot; + this);            return true;        }        return false;    }    public static void main(String[] args) {        CacheLinkedHashMap lh = new CacheLinkedHashMap();        for (int i = 1; i &lt;= 5; i++) {            lh.put(&quot;K_&quot; + Integer.valueOf(i), Integer.valueOf(i));        }        System.out.println(lh);        // 放入时会删除最早放入的 k_1 项        lh.put(&quot;K_&quot; + Integer.valueOf(11), Integer.valueOf(0));        System.out.println(lh);    }}</code></pre><p>输出：</p><pre><code class="log">{K_1=1, K_2=2, K_3=3, K_4=4, K_5=5}超容 - {K_1=1, K_2=2, K_3=3, K_4=4, K_5=5, K_11=0}{K_2=2, K_3=3, K_4=4, K_5=5, K_11=0}</code></pre><h3 id="监听器和其他回调"><a href="#监听器和其他回调" class="headerlink" title="监听器和其他回调"></a>监听器和其他回调</h3><p>如果你实现了一个 API，客户端在这个 API 中注册回调（即将回调实例存储到某个容器中），却没有显示地取消注册，那么除非你采取某些动作，否则它们就会积聚。确保立即被垃圾回收的最佳方法是只保存它的弱引用，例如，只将它们保存成 WeakHashMap 中的键。</p><p>内存泄漏剖析工具：<code>Heap Profiler</code></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Effective Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript实现限制上传文件的大小</title>
      <link href="/2016/10/30/JavaScript%E5%AE%9E%E7%8E%B0%E9%99%90%E5%88%B6%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E7%9A%84%E5%A4%A7%E5%B0%8F/"/>
      <url>/2016/10/30/JavaScript%E5%AE%9E%E7%8E%B0%E9%99%90%E5%88%B6%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E7%9A%84%E5%A4%A7%E5%B0%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="在IE9及以下的版本"><a href="#在IE9及以下的版本" class="headerlink" title="在IE9及以下的版本"></a>在IE9及以下的版本</h2><p>可以通过如下方式检测需要上传文件的大小:</p><a id="more"></a><pre><code class="html">&lt;body&gt;    &lt;img id=&quot;tempimg&quot; dynsrc=&quot;&quot; src=&quot;&quot; style=&quot;display:none&quot; /&gt;    &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;fileuploade&quot; size=&quot;40&quot; /&gt;    &lt;input type=&quot;button&quot; name =&quot;check&quot; value=&quot;checkfilesize&quot; onclick=&quot;checksize()&quot;/&gt;&lt;/body&gt;&lt;script&gt;function checksize(){    var obj_file = document.getElementById(&quot;fileuploade&quot;);    var obj_img = document.getElementById(&#39;tempimg&#39;);    obj_img.dynsrc=obj_file.value;    var filesize = obj_img.fileSize;    alert(filesize);}&lt;/script&gt;</code></pre><p>上面的代码的运行原理是把上传的文件模拟成图片，通过其fileSize属性获取其大小，而由于浏览器的安全策略，其<strong>几乎只能运行在本地打开此网页</strong>的情况。</p><h2 id="html5"><a href="#html5" class="headerlink" title="html5"></a>html5</h2><p>不仅支持获取上传文件大小，还支持多文件同时上传</p><pre><code class="html">&lt;input type=&quot;file&quot; multiple=&quot;multiple&quot; onchange=&quot;checkinfo(this)&quot;&gt;&lt;script&gt;function checkinfo(obj){    var len = obj.files.length;    var text=&quot;&quot;;    for (var i =0 ; i &lt; len ; i++){            text += &quot;文件:&quot;+obj.files[i].name+&quot; ,大小:&quot;+obj.files[i].size+&quot;字节\n&quot;;    }    alert(text);}&lt;/script&gt;</code></pre><h2 id="兼容使用（不兼容IE10）"><a href="#兼容使用（不兼容IE10）" class="headerlink" title="兼容使用（不兼容IE10）"></a>兼容使用（不兼容IE10）</h2><pre><code class="html">&lt;img id=&quot;tempimg&quot; dynsrc=&quot;&quot; src=&quot;&quot; style=&quot;display:none&quot; /&gt;&lt;input type=&quot;file&quot; name=&quot;uploadFile&quot; id=&quot;uploadFile&quot; onchange=&quot;checkfile(this)&quot; /&gt;&lt;script type=&quot;text/javascript&quot;&gt;var maxsize = 10;var maxsizelength = 10*1024*1024;var errMsg = &quot;上传的附件大小不能超过&quot;+maxsize+&quot;M！&quot;;var tipMsg = &quot;您的浏览器版本暂不支持检验上传文件的大小，请确保上传文件不要超过&quot;+maxsize+&quot;M！&quot;;var  browserCfg = {};var ua = window.navigator.userAgent;if (ua.indexOf(&quot;MSIE&quot;)&gt;=1){    browserCfg.ie = true;}else if(ua.indexOf(&quot;Firefox&quot;)&gt;=1){    browserCfg.firefox = true;}else if(ua.indexOf(&quot;Chrome&quot;)&gt;=1){    browserCfg.chrome = true;}function checkfile(obj,num){    try{        var obj_file = obj;        var filesize = 0;        if(browserCfg.ie ){            var obj_img = document.getElementById(&#39;tempimg&#39;);            obj_img.dynsrc=obj_file.value;            filesize = obj_img.fileSize;        }else if(browserCfg.firefox || browserCfg.chrome || &quot;ActiveXObject&quot; in window ){ //包含IE11            filesize = obj_file.files[0].size;        }else{            alert(tipMsg);            return false;        }        if(filesize==-1){            $(&#39;#uploadFile&#39;).prop(&#39;value&#39; , &#39;&#39;);            alert(tipMsg);            return false;        }else if(filesize==0){            $(&#39;#uploadFile&#39;).prop(&#39;value&#39; , &#39;&#39;);            alert(&quot;上传附件内容不能为空！ 请重新填写！&quot;);            return false;        }else if(filesize&gt;maxsizelength){            $(&#39;#uploadFile&#39;).prop(&#39;value&#39; , &#39;&#39;);            alert(errMsg);            return false;        }else{            return true;        }    }catch(e){        $(&#39;#uploadFile&#39;).prop(&#39;value&#39; , &#39;&#39;);        alert(&quot;验证上传附件大小合法性失败！&quot;);        return false;    }}&lt;/script&gt;</code></pre><br>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Prettify.js使代码高亮</title>
      <link href="/2016/10/30/Prettify-js%E4%BD%BF%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE/"/>
      <url>/2016/10/30/Prettify-js%E4%BD%BF%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE/</url>
      
        <content type="html"><![CDATA[<p>在上一篇中演示，发现了<code>Prettify</code>可以很简单的使代码高亮。<br>项目地址 <a href="https://github.com/google/code-prettify" target="_blank" rel="noopener">https://github.com/google/code-prettify</a><br>教程 <a href="https://github.com/google/code-prettify/blob/master/docs/getting_started.md" target="_blank" rel="noopener">https://github.com/google/code-prettify/blob/master/docs/getting_started.md</a></p><a id="more"></a><h2 id="简单配置"><a href="#简单配置" class="headerlink" title="简单配置"></a>简单配置</h2><pre><code class="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; media=&quot;all&quot; href=&quot;http://cdn.staticfile.org/prettify/r224/prettify.min.css&quot; /&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.staticfile.org/prettify/r298/prettify.min.js&quot;&gt;&lt;/script&gt;</code></pre><p>在 <code>body</code> 标签的 <code>onload</code> 事件中添加代码高亮动作:</p><pre><code>&lt;body onload=&quot;prettyPrint()&quot;&gt;...&lt;/body&gt;</code></pre><p>在 body 中添加需要高亮的代码, <code>prettify</code> 依靠 <code>&lt;pre&gt;</code>, <code>&lt;code&gt;</code> 或 <code>&lt;xmp&gt;</code> 标签的 <code>class</code> 属性的 <code>prettyprint</code> 属性值作为高亮标识:</p><pre><code class="html">&lt;pre class=&quot;prettyprint&quot;&gt;int main(){    printf(&quot;Hello, world!\n&quot;);    return 0;}&lt;/pre&gt;</code></pre><p>开启显示行号, 在 <code>class</code> 属性中添加 <code>linenums</code>。<br>手动指定代码所用语言, <code>class</code> 属性中添加 <code>lang-xxx</code>:</p><pre><code class="html">&lt;pre class=&quot;prettyprint lang-c linenums&quot;&gt;int main(){    printf(&quot;Hello, world!\n&quot;);    return 0;}&lt;/pre&gt;</code></pre><h2 id="懒人模式-run-prettify-js"><a href="#懒人模式-run-prettify-js" class="headerlink" title="懒人模式 run_prettify.js"></a>懒人模式 run_prettify.js</h2><p><code>run_prettify.js</code> 是 <code>prettify.js</code> 的增强版, 引入后该 js 后, 能在页面加载完成后对所需高亮的代码块自动执行高亮, 此外还可以以添加请求参数的形式手动指定额外语言高亮规则, 使用哪种主题以及每段代码高亮完成后的回调动作, 如:</p><pre><code class="html">&lt;!-- 建议添加在 &lt;body&gt; 闭合标签前 --&gt;    &lt;script src=&quot;http://cdn.staticfile.org/prettify/r298/run_prettify.js?lang=lua&amp;lang=yaml&amp;skin=sons-of-obsidian&quot;&gt;&lt;/script&gt;&lt;/body&gt;</code></pre><p>run_prettify.js 完整参数指令表:</p><table><thead><tr><th align="left"><strong>参数</strong></th><th align="left">值</th><th align="left">meaning</th></tr></thead><tbody><tr><td align="left">autoload=(true or false)</td><td align="left">true</td><td align="left">页面加载完成后是否自动高亮, 默认为 true</td></tr><tr><td align="left">lang=...</td><td align="left">语言英文简称</td><td align="left">加载额外的 lang-xxx.js 高亮规则文件</td></tr><tr><td align="left">skin=...</td><td align="left">样式文件名</td><td align="left">加载高亮样式文件 xxx.css</td></tr><tr><td align="left">callback=js_ident</td><td align="left">回调函数名</td><td align="left">高亮完成后将调用 window.exports[函数名]</td></tr></tbody></table><h2 id="更多高亮主题"><a href="#更多高亮主题" class="headerlink" title="更多高亮主题"></a>更多高亮主题</h2><p><a href="http://jmblog.github.io/color-themes-for-google-code-prettify/" target="_blank" rel="noopener">http://jmblog.github.io/color-themes-for-google-code-prettify/</a></p><p>转自：<a href="http://www.widlabs.com/article/use-prettify-js-highlight-your-code" target="_blank" rel="noopener">http://www.widlabs.com/article/use-prettify-js-highlight-your-code</a></p><br>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript判断浏览器类型及版本</title>
      <link href="/2016/10/30/JavaScript%E5%88%A4%E6%96%AD%E6%B5%8F%E8%A7%88%E5%99%A8%E7%B1%BB%E5%9E%8B%E5%8F%8A%E7%89%88%E6%9C%AC/"/>
      <url>/2016/10/30/JavaScript%E5%88%A4%E6%96%AD%E6%B5%8F%E8%A7%88%E5%99%A8%E7%B1%BB%E5%9E%8B%E5%8F%8A%E7%89%88%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<p>实际效果可以查看<a href="/demo\JavaScript-browser-version/demo.html">在线演示</a></p><a id="more"></a><h2 id="userAgent"><a href="#userAgent" class="headerlink" title="userAgent"></a>userAgent</h2><pre><code class="html">&lt;script type=&quot;text/javascript&quot;&gt;    $(function () {        var Sys = {};        var ua = navigator.userAgent.toLowerCase();        var s;        (s = ua.match(/rv:([\d.]+)\) like gecko/)) ? Sys.ie = s[1] :        (s = ua.match(/msie ([\d.]+)/)) ? Sys.ie = s[1] :        (s = ua.match(/firefox\/([\d.]+)/)) ? Sys.firefox = s[1] :        (s = ua.match(/chrome\/([\d.]+)/)) ? Sys.chrome = s[1] :        (s = ua.match(/opera.([\d.]+)/)) ? Sys.opera = s[1] :        (s = ua.match(/version\/([\d.]+).*safari/)) ? Sys.safari = s[1] : 0;        if (Sys.ie) document.write(&#39;IE: &#39; + Sys.ie);        if (Sys.firefox) document.write(&#39;Firefox: &#39; + Sys.firefox);        if (Sys.chrome) document.write(&#39;Chrome: &#39; + Sys.chrome);        if (Sys.opera) document.write(&#39;Opera: &#39; + Sys.opera);        if (Sys.safari) document.write(&#39;Safari: &#39; + Sys.safari);    });&lt;/script&gt;</code></pre><p>IE11 使用了和之前版本不一样的 User-agent</p><pre><code>Mozilla/5.0 (Windows NT 6.3; Trident/7.0; rv 11.0) like Gecko</code></pre><p>而 IE10 是：</p><pre><code>Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; Trident/6.0)</code></pre><p>所以也可以通过正则判断 User-agent：</p><pre><code class="js">var isIE11 = (/Trident\/7\./).test(navigator.userAgent);</code></pre><h2 id="判断IE浏览器与非IE-浏览器"><a href="#判断IE浏览器与非IE-浏览器" class="headerlink" title="判断IE浏览器与非IE 浏览器"></a>判断IE浏览器与非IE 浏览器</h2><p>IE浏览器与非IE浏览器的区别是IE浏览器支持ActiveXObject，但是非IE浏览器不支持ActiveXObject。</p><pre><code class="js">function isIe(){    return window.ActiveXObject ? true : false;//IE11 false}</code></pre><p>兼容IE11</p><pre><code class="js">function isIe(){    return (&quot;ActiveXObject&quot; in window);}</code></pre><p>转自：<a href="http://keenwon.com/851.html" target="_blank" rel="noopener">keenwon</a><br><a href="http://www.cnblogs.com/javaee6/p/3721932.html" target="_blank" rel="noopener">js快速判断IE浏览器(兼容IE10与IE11)</a></p><br>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Python基础教程》读书笔记01-基础知识</title>
      <link href="/2016/07/19/%E3%80%8APython%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B001-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"/>
      <url>/2016/07/19/%E3%80%8APython%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B001-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><code>Python</code> 就是“一种解释型的、面向对象的、带有动态语义的高级程序设计语言”。</p><a id="more"></a><h2 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h2><pre><code class="py"># python3&gt;&gt;&gt; 1/2.0.5&gt;&gt;&gt; 1/20.5</code></pre><pre><code class="py"># python2&gt;&gt;&gt;1/20# 有浮点数参加的运算，结果为浮点数&gt;&gt;&gt;1/2.0.5# 如果希望Python只执行普通的除法&gt;&gt;&gt;from __future__ import division&gt;&gt;&gt; 1/20.5# 另外一个方法，命令行中运行 Python，可以使用命令开关 -Qnew</code></pre><p><strong>实现整除的操作符——<code>双斜线</code>：</strong></p><pre><code class="py"># python2，3&gt;&gt;&gt; 1 // 20&gt;&gt;&gt;  1.0 // 2.00.0</code></pre><h2 id="取余运算符"><a href="#取余运算符" class="headerlink" title="取余运算符"></a>取余运算符</h2><pre><code class="py">&gt;&gt;&gt; 2.75 % 0.50.25</code></pre><h2 id="幂运算符"><a href="#幂运算符" class="headerlink" title="幂运算符"></a>幂运算符</h2><pre><code class="py">&gt;&gt;&gt; 2 ** 38&gt;&gt;&gt; -3 ** 2-9&gt;&gt;&gt; (-3) ** 29# 幂运算符比取反的优先级高-3**2等同于-(3**2)</code></pre><h2 id="十六进制"><a href="#十六进制" class="headerlink" title="十六进制"></a>十六进制</h2><pre><code class="py">&gt;&gt;&gt; 0xaF175</code></pre><h2 id="八进制"><a href="#八进制" class="headerlink" title="八进制"></a>八进制</h2><pre><code class="py">&gt;&gt;&gt; 0108</code></pre><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><h3 id="Python2-7"><a href="#Python2-7" class="headerlink" title="Python2.7"></a>Python2.7</h3><p>使用 raw_input() 返回字符串，input() 需要合法的 Python 表达式。</p><pre><code class="py">&gt;&gt;&gt; x = input()1&gt;&gt;&gt; x = input()&#39;a&#39;&gt;&gt;&gt; x = input()aTraceback (most recent call last):  File &quot;&lt;pyshell#32&gt;&quot;, line 1, in &lt;module&gt;    x = input()  File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt;NameError: name &#39;a&#39; is not defined&gt;&gt;&gt; x = raw_input()1&gt;&gt;&gt; x = raw_input()a</code></pre><p>查看 <a href="http://docs.python.org/library/functions.html?highlight=input#built-in-functions" target="_blank" rel="noopener">Built-in Functions</a>  ，得知：</p><pre><code class="py">input([prompt])    Equivalent（等效） to eval(raw_input(prompt))</code></pre><p><code>input()</code> 本质上还是使用 <code>raw_input()</code> 来实现的，只是调用完 <code>raw_input()</code> 之后再调用 <code>eval()</code> 函数，所以，你甚至可以将表达式作为 <code>input()</code> 的参数，并且它会计算表达式的值并返回它。</p><p><strong>除非对 <code>input()</code> 有特别需要，否则一般情况下我们都是推荐使用 <code>raw_input()</code> 来与用户交互。</strong></p><h3 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h3><p>取消了 <code>raw_input()</code> 函数。</p><p><code>input()</code> 函数等同于 2.7 中的 <code>raw_input()</code> 函数，返回的是字符串，如果需要和整数比较，可以使用 <code>int()</code> 函数转换成整数。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><pre><code class="py"># 1. 幕函数&gt;&gt;&gt; pow(2,3)8# 2. 绝对值&gt;&gt;&gt; abs(-10)10# 3. 四舍五入&gt;&gt;&gt; round(1.0/2.0)1.0&gt;&gt;&gt; import math# 4. 向下取整&gt;&gt;&gt; math.floor(3.9)3.0# 5. 向上取整&gt;&gt;&gt; math.ceil(2.1)3.0</code></pre><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>使用<code>floor</code>函数</p><pre><code class="py">&gt;&gt;&gt; import math&gt;&gt;&gt; math.floor(32.0)32.0# 可以使用另外一种形式，不用每次调用函数的时候都写上模块的名字。&gt;&gt;&gt; from math import sqrt&gt;&gt;&gt; sqrt(9)3.0# 可以使用  变量引用函数:&gt;&gt;&gt; foo = math.sqrt&gt;&gt;&gt; foo(4)2.0</code></pre><h2 id="cmath和复数"><a href="#cmath和复数" class="headerlink" title="cmath和复数"></a>cmath和复数</h2><pre><code class="py">&gt;&gt;&gt; sqrt(-1)#普通sqrt函数不支持复数Traceback (most recent call last):  File &quot;&lt;pyshell#41&gt;&quot;, line 1, in &lt;module&gt;    sqrt(-1)ValueError: math domain error&gt;&gt;&gt; import cmath  # 如果使用from...import...会导致普通的sqrt函数无法使用&gt;&gt;&gt; cmath.sqrt(-1)1j&gt;&gt;&gt; (1+3j) * (9+4j)# python本身提供了对复数的支持(-3+31j)</code></pre><h2 id="字符串表示-str-和-repr"><a href="#字符串表示-str-和-repr" class="headerlink" title="字符串表示 str 和 repr"></a>字符串表示 str 和 repr</h2><pre><code class="py">&gt;&gt;&gt; &#39;hello&#39;&#39;hello&#39;&gt;&gt;&gt; 1000L1000L&gt;&gt;&gt; print &#39;hello&#39;hello&gt;&gt;&gt; print 1000L1000&gt;&gt;&gt; print repr(&quot;hello&quot;)&#39;hello&#39;&gt;&gt;&gt; print repr(1000L)1000L&gt;&gt;&gt; print str(1000L)1000&gt;&gt;&gt; print str(&#39;hello&#39;)hello&gt;&gt;&gt; t = 10&gt;&gt;&gt; print &#39;hello,&#39; + t         # repr(x) 也可以写做 `x`,但在python3.x 中不可用# 注意: 这里没有什么自动装箱，需要用 str() 或repr()转换Traceback (most recent call last):  File &quot;&lt;pyshell#11&gt;&quot;, line 1, in &lt;module&gt;    print &#39;hello,&#39; + tTypeError: cannot concatenate &#39;str&#39; and &#39;int&#39; objects&gt;&gt;&gt; print &#39;hello,&#39; +`t` # repr(x) 也可以写做 `x`，但在python3.x 中不可用hello,10&gt;&gt;&gt; print &#39;hello,&#39; + repr(t)hello,10</code></pre><p>值被转换为字符串的两种机制：</p><ol><li>str 函数：会把值转换成字符串</li><li>repr 函数：会创建一个字符串，以合法的 Python 表达式的形式来表示值</li></ol><p><a href="https://www.jianshu.com/p/2a41315ca47e" target="_blank" rel="noopener">Python中str()与repr()函数的区别</a></p><pre><code class="py">&gt;&gt;&gt; from datetime import datetime&gt;&gt;&gt; now = datetime.now()&gt;&gt;&gt; print(str(now))2017-04-22 15:41:33.012917&gt;&gt;&gt; print(repr(now))datetime.datetime(2017, 4, 22, 15, 41, 33, 12917)</code></pre><p>通过 <code>str()</code> 的输出结果我们能很好地知道 now 实例的内容，但是却丢失了 now 实例的数据类型信息。而通过 <code>repr()</code> 的输出结果我们不仅能获得 now 实例的内容，还能知道 now 是 <code>datetime.datetime</code> 对象的实例。</p><p>因此 <code>str()</code> 与 <code>repr()</code> 的不同在于：</p><ul><li><code>str()</code> 的输出追求可读性，输出格式要便于理解，适合用于输出内容到用户终端。</li><li><code>repr()</code> 的输出追求明确性，除了对象内容，还需要展示出对象的数据类型信息，适合开发和调试阶段使用。</li></ul><p>另外如果想要自定义类的实例能够被 <code>str()</code> 和 <code>repr()</code> 所调用，那么就需要在自定义类中重载 <code>__str__</code> 和 <code>__repr__</code> 方法。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UTF-8编码规则,及对包含汉字的字符串截取指定字节数</title>
      <link href="/2016/05/27/UTF-8%E7%BC%96%E7%A0%81%E8%A7%84%E5%88%99/"/>
      <url>/2016/05/27/UTF-8%E7%BC%96%E7%A0%81%E8%A7%84%E5%88%99/</url>
      
        <content type="html"><![CDATA[<p>UTF-8是一种变长字节编码方式。对于某一个字符的UTF-8编码，如果只有一个字节则其最高二进制位为0；如果是多字节，其第一个字节从最高位开始，连续的二进制位值为1的个数决定了其编码的位数，其余各字节均以10开头。UTF-8最多可用到6个字节。<br>如表：</p><pre><code>1字节 0xxxxxxx2字节 110xxxxx 10xxxxxx3字节 1110xxxx 10xxxxxx 10xxxxxx4字节 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</code></pre><a id="more"></a><p>UTF-8使用一至六个字节为每个字符编码（尽管如此，2003年11月UTF-8被RFC 3629重新规范，只能使用原来Unicode定义的区域，U+0000到U+10FFFF，也就是说<a href="https://zh.wikipedia.org/wiki/UTF-8" target="_blank" rel="noopener">最多四个字节</a>）</p><p>为了更好的理解后面的实际应用，我们这里简单的介绍下UTF-8的编码实现方法。即UTF-8的物理存储和Unicode序号的转换关系。<br>UTF-8编码为变长编码。最小编码单位（<code>code unit</code>）为一个字节。一个字节的前1-3个bit为描述性部分，后面为实际序号部分。</p><ul><li>如果一个字节的第一位为0，那么代表当前字符为单字节字符，占用一个字节的空间。0之后的所有部分（7个bit）代表在Unicode中的序号。</li><li>如果一个字节以110开头，那么代表当前字符为双字节字符，占用2个字节的空间。110之后的所有部分（7个bit）代表在Unicode中的序号。且第二个字节以10开头</li><li>如果一个字节以1110开头，那么代表当前字符为三字节字符，占用3个字节的空间。110之后的所有部分（7个bit）代表在Unicode中的序号。且第二、第三个字节以10开头</li><li>如果一个字节以10开头，那么代表当前字节为多字节字符的第二个字节。10之后的所有部分（6个bit）代表在Unicode中的序号。</li></ul><p>具体每个字节的特征可见上方，<strong>其中<code>x</code>代表序号部分，把各个字节中的所有x部分拼接在一起就组成了在Unicode字库中的序号</strong></p><p>我们分别看三个从一个字节到三个字节的UTF-8编码例子：</p><table><thead><tr><th align="center">实际字符</th><th align="center">在Unicode字库序号的十六进制</th><th align="center">在Unicode字库序号的二进制</th><th align="center">UTF-8编码后的二进制</th><th align="center">UTF-8编码后的十六进制</th></tr></thead><tbody><tr><td align="center">$</td><td align="center">0024</td><td align="center">010 0100</td><td align="center">0010 0100</td><td align="center">24</td></tr><tr><td align="center">¢</td><td align="center">00A2</td><td align="center">000 1010 0010</td><td align="center">1100 0010 1010 0010</td><td align="center">C2 A2</td></tr><tr><td align="center">€</td><td align="center">20AC</td><td align="center">0010 0000 1010 1100</td><td align="center">1110 0010 1000 0010 1010 1100</td><td align="center">E2 82 AC</td></tr></tbody></table><p>得出以下规律：</p><ul><li>4个字节以上的的UTF-8十六进制编码一定是以<code>F</code>开头的</li><li>3个字节的UTF-8十六进制编码一定是以<code>E</code>开头的</li><li>2个字节的UTF-8十六进制编码一定是以<code>C</code>或<code>D</code>开头的</li><li>1个字节的UTF-8十六进制编码一定是以比8小的数字开头的</li></ul><h2 id="面试题之——对包含汉字的字符串截取指定字节数"><a href="#面试题之——对包含汉字的字符串截取指定字节数" class="headerlink" title="面试题之——对包含汉字的字符串截取指定字节数"></a>面试题之——对包含汉字的字符串截取指定字节数</h2><p>题目：编写一个截取字符串的函数,输入为一个字符串和字节数, 输出为按字节截取的字符串,但要保证汉字不被截取半个,如&quot;我ABC&quot;,4,应该截取&quot;我AB&quot;,输入&quot;我ABC汉DEF&quot;,6, 应该输出&quot;我ABC&quot;,而不是&quot;我ABC+汉的半个&quot;。<br>我们都知道在计算机中，存储一个汉字需要至少两个字节。例如：gbk和gb2312都是用两个字节存储一个汉字，而UTF-8是用三个字节存储一个汉字。</p><h3 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h3><p>适用字符集：UTF-8，gb2312，gbk<br>思路：依次截取字符串的每个字符，根据字符编码获取其字节数temp_len,total用以记录每次截取字符后及之前截取字符字节数之和,然后判断total是否小于等于所需要截取字节长度（length）,如果小于说明还没超过所需要截取字节长度,那么截取字符的长度（len）+1，如果total&gt;length说明已经超出所需要截取的字节长度，此时的len就是所需要截取原字符串的长度</p><pre><code class="java">/** * @param input  需要截取的字符串 * @param length 需要截取的字节数 * @param encoding 字符的编码格式 * @return 截取后的字符串 * @throws UnsupportedEncodingException */public static String subString(String input, int length, String encoding)        throws UnsupportedEncodingException {    byte[] buf = input.getBytes(encoding);    int characterNum = input.length();    System.out.println(&quot;字符编码：&quot; +  encoding +&quot;,字符串的字符个数：&quot;        + characterNum + &quot;, 字节长度为：&quot; + buf.length);    //截取到当前字符时的字节数    int total = 0;    //应当截取到的字符的长度    int len = 0;    for(int i=0; i&lt;characterNum; i++) {        String temp = input.substring(i, i+1);        int temp_len = temp.getBytes(encoding).length;        total += temp_len;        if(total&lt;=length){            len++;        }    }    return input.substring(0, len);}</code></pre><h3 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h3><p>适用字符集：gb2312，gbk<br>gbk汉字编码是两个字节为一个字符，高字节是小于0的（原因我也不清楚），设置一标志变量bChineseFirstHalf为false，如果获取到的字节小于0且bChineseFirstHalf为false，说明这是汉字的前半个字节，则bChineseFirstHalf设置为true，否则，num（最终需要截取字符串长度）加1。一直循环到字节数i等于需要截取的字节数length</p><pre><code class="java">public static String subStr(String input, int length, String encoding)        throws UnsupportedEncodingException {    int num = 0;    byte[] buf = input.getBytes(encoding);    System.out.println(&quot;字符编码：&quot; +  encoding +&quot;,字符串的字符个数：&quot;        + input.length() + &quot;, 字节长度为：&quot; + buf.length);    boolean bChineseFirstHalf = false;    for (int i = 0; i &lt; length; i++) {        if (buf[i] &lt; 0 &amp;&amp; !bChineseFirstHalf) {            bChineseFirstHalf = true;        } else {            num++;            bChineseFirstHalf = false;        }    }    return input.substring(0, num);}</code></pre><h3 id="第三种方法"><a href="#第三种方法" class="headerlink" title="第三种方法"></a>第三种方法</h3><p>适用字符集：utf-8<br>第三种方法想到了，使用上一篇文章中的 UTF8Utils 类。</p><pre><code class="java">public static String subString1(String input, int length, String encoding)        throws UnsupportedEncodingException {    byte[] buf = input.getBytes(encoding);    String hex = UTF8Utils.bytesToHex(buf);    String firstChar = null;    //应当截取到的字符的长度    int len = 0;    wai : for(int i=0; i&lt;length; ) {        firstChar = hex.substring(0, 1);        for (int j = 0;j&lt;UTF8Utils.byteMap.get(firstChar);j++){            i++;            if(i&gt;length){                break wai;            }        }        hex = hex.substring(UTF8Utils.hexMap.get(firstChar), hex.length());        len++;    }    return input.substring(0, len);}</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/cenalulu/p/4251639.html" target="_blank" rel="noopener">十分钟搞清字符集和字符编码</a><br><a href="http://blog.csdn.net/zyh5540/article/details/11748985" target="_blank" rel="noopener">面试题之——对包含汉字的字符串截取指定字节数</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java.sql.SQLException: Incorrect string value: &#39;\xF0\x9F\x91\xBD\xF0\x9F…&#39;</title>
      <link href="/2016/05/26/java-sql-SQLException-Incorrect-string-value-xF0-x9F-x91-xBD-xF0-x9F%E2%80%A6/"/>
      <url>/2016/05/26/java-sql-SQLException-Incorrect-string-value-xF0-x9F-x91-xBD-xF0-x9F%E2%80%A6/</url>
      
        <content type="html"><![CDATA[<p>参考：<a href="https://segmentfault.com/a/1190000000616820" target="_blank" rel="noopener">mysql/Java服务端对emoji的支持</a><br><a href="https://segmentfault.com/q/1010000003040054" target="_blank" rel="noopener">mysql 数据库中varchar的长度与字节，字符串的关系</a><br><a href="http://www.cnblogs.com/nick-huang/p/5507262.html" target="_blank" rel="noopener">如何检测、替换4个字节的utf-8编码（此范围编码包含emoji表情）</a></p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>最近在做<code>oracle</code>库数据向<code>MySQL</code>数据库中迁移时，出现了这个问题，主要原因就是字符集不支持的异常。因为<code>UTF-8</code>编码有可能是一个、两个、三个、四个字节，其中Emoji表情是4个字节，而MySQL的<code>utf8</code>编码最多3个字节，所以导致了数据插不进去。需要修改为MySQL编码为<code>utf8mb4</code>即可。</p><a id="more"></a><h3 id="错误详情"><a href="#错误详情" class="headerlink" title="错误详情"></a>错误详情</h3><pre><code class="java">### Cause: java.sql.SQLException: Incorrect string value: &#39;\xF2\xB5\xBC\xBA\xEF\xBF...&#39; for column &#39;content&#39; at row 40    at org.apache.ibatis.exceptions.ExceptionFactory.wrapException(ExceptionFactory.java:23)    at org.apache.ibatis.session.defaults.DefaultSqlSession.update(DefaultSqlSession.java:147)ERROR [extractThread reportInfo ] -    at org.apache.ibatis.exceptions.ExceptionFactory.wrapException(ExceptionFactory.java:23)    at org.apache.ibatis.session.defaults.DefaultSqlSession.insert(DefaultSqlSession.java:134)    at org.apache.ibatis.binding.MapperMethod.execute(MapperMethod.java:79)    at org.apache.ibatis.binding.MapperProxy.invoke(MapperProxy.java:40)    at com.sun.proxy.$Proxy0.insertforMySQL(Unknown Source)    at com.oracletomysql.service.imp.ReportinfoService.insertforMySQL(ReportinfoService.java:189)    at com.oracletomysql.thread.ReportInfoThread.run(ReportInfoThread.java:63)    at java.lang.Thread.run(Thread.java:744)</code></pre><h3 id="升级步骤"><a href="#升级步骤" class="headerlink" title="升级步骤"></a>升级步骤</h3><ol><li><p><code>utf8mb4</code>的最低mysql版本支持版本为5.5.3+，若不是，请升级到较新版本。</p></li><li><p>修改<code>database</code>、<code>table</code>和<code>column</code>字符集。参考以下语句：</p><pre><code class="sql">ALTER DATABASE database_name CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci;ALTER TABLE table_name CONVERT TO CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;ALTER TABLE table_name CHANGE column_name VARCHAR(191) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;</code></pre></li><li><p>修改mysql配置文件<code>my.cnf</code>（windows为<code>my.ini</code>）<br><code>my.cnf</code>一般在<code>etc/mysql/my.cnf</code>位置。找到后请在以下三部分里添加如下内容：</p><pre><code class="sql">[client]default-character-set = utf8mb4</code></pre></li></ol><p>[mysql]<br>default-character-set = utf8mb4</p><p>[mysqld]<br>character-set-client-handshake = FALSE<br>character-set-server = utf8mb4<br>collation-server = utf8mb4_unicode_ci<br>init_connect=&#39;SET NAMES utf8mb4&#39;</p><pre><code>4. 重启 MySQL Server、检查字符集 1. 重启命令参考：`/etc/init.d/mysql restart` 2. 输入命令：`mysql`，进入mysql命令行（如果提示没权限，可以尝试输入`mysql -uroot -p你的密码`） 3. 在mysql命令行中输入：`SHOW VARIABLES WHERE Variable_name LIKE &#39;character_set_%&#39; OR Variable_name LIKE &#39;collation%&#39;;`检查是否如下：```sql+--------------------------+--------------------+| Variable_name            | Value              |+--------------------------+--------------------+| character_set_client    | utf8mb4            |  客户端来源数据使用的字符集| character_set_connection | utf8mb4            |  连接层字符集| character_set_database  | utf8mb4            |  当前选中数据库的默认字符集| character_set_filesystem | binary            || character_set_results    | utf8mb4            |  查询结果字符集| character_set_server    | utf8mb4            |  默认的内部操作字符集| character_set_system    | utf8              |  系统元数据(字段名等)字符集| collation_connection    | utf8mb4_unicode_ci || collation_database      | utf8mb4_unicode_ci || collation_server        | utf8mb4_unicode_ci |+--------------------------+--------------------+rows in set (0.00 sec)</code></pre><p>特别说明下：<code>collation_connection</code>/<code>collation_database</code>/<code>collation_server</code>如果是<code>utf8mb4_general_ci</code>，没有关系。但必须保证<code>character_set_client</code>/<code>character_set_connection</code>/<code>character_set_database</code>/<code>character_set_results</code>/<code>character_set_server</code>为<code>utf8mb4</code>。关于这些字符集配置是干什么用的，有什么区别，请参考：<a href="http://www.laruence.com/2008/01/05/12.html" target="_blank" rel="noopener">深入Mysql字符集设置</a></p><p>5.如果你用的是java服务器，升级或确保你的mysql connector版本高于5.1.13，否则仍然无法使用<code>utf8mb4</code><br>这是mysql官方release note，大家可以查看说明，并下载最新的mysql connector for java的jar包。</p><p>6.检查你服务端的db配置文件：</p><pre><code class="properties">jdbc.driverClassName=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/database?useUnicode=true&amp;characterEncoding=utf8&amp;autoReconnect=true&amp;rewriteBatchedStatements=TRUEjdbc.username=rootjdbc.password=password</code></pre><p>特别说明其中的jdbc.url配置：如果你已经升级好了mysql-connector，其中的characterEncoding=utf8可以被自动被识别为utf8mb4（当然也兼容原来的utf8），而autoReconnect配置我强烈建议配上，我之前就是忽略了这个属性，导致因为缓存缘故，没有读取到DB最新配置，导致一直无法使用utf8mb4字符集，多么痛的领悟！！</p><h2 id="1118-Row-size-too-large"><a href="#1118-Row-size-too-large" class="headerlink" title="1118 - Row size too large."></a>1118 - Row size too large.</h2><p>在上面的修改表的字符集时，出现了这个错误。</p><pre><code>1118 - Row size too large.The maximum row size for the used table type, not counting BLOBs, is 65535.This includes storage overhead, check the manual.You have to change some columns to TEXT or BLOBs.</code></pre><p><strong>MySQL要求一个行的定义长度不能超过65535</strong></p><h3 id="mysql-数据库中varchar的长度与字节，字符串的关系"><a href="#mysql-数据库中varchar的长度与字节，字符串的关系" class="headerlink" title="mysql 数据库中varchar的长度与字节，字符串的关系"></a>mysql 数据库中varchar的长度与字节，字符串的关系</h3><pre><code class="sql">CREATE TABLE `test` (    `id` int(10) unsigned NOT NULL AUTO_INCREMENT,    `content` varchar(5) NOT NULL DEFAULT &#39;&#39;,    PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8 COLLATE=utf8_general_ci;INSERT INTO `test`(`content`) VALUES (&#39;123456&#39;);INSERT INTO `test`(`content`) VALUES (&#39;中国人民银行&#39;);SELECT * FROM `test`;返回:id  content1   123452   中国人民银</code></pre><p><strong>可见,varchar(5)能存储5个字符,不管是数字,字母,还是汉字.</strong></p><pre><code class="sql">CREATE TABLE `test2` (    `id` int(10) unsigned NOT NULL AUTO_INCREMENT,    `content` varchar(21842) NOT NULL DEFAULT &#39;&#39;,    PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8 COLLATE=utf8_general_ci;</code></pre><p>该表中varchar类型的字段能容纳的最大字符数21842是怎么得来的?<br><strong>21842 = (65535-1-2-4)/3</strong>(如果是utf8mb4，则除以4)</p><ul><li><strong>MySQL要求一个行的定义长度不能超过65535(包括多个字段)</strong>,所以有65535.</li><li>varchar的最大有效长度取决于最大行大小.</li><li>减1的原因是实际行的存储从第2个字节开始.</li><li>减2的原因是varchar头部的2个字节表示长度.</li><li>减4的原因是字段id的int类型占用4个字节.</li><li>除以3的原因是一个utf8字符占用3个字节.</li></ul><p>如果你在test2表里把varchar(21842)改为varchar(21844),那么就会报上面的错误: <code>Row size too large</code></p><p>MySQL中char,varchar与text类型的选用:</p><ul><li>知道固定长度的用char,比如MD5串固定是32位。</li><li>经常变化的字段用varchar。</li><li>超过255字符的只能用varchar或者text,不能用char。</li><li>能用varchar的地方不用text。</li></ul><h2 id="如何检测、替换、去除4个字节的utf-8编码"><a href="#如何检测、替换、去除4个字节的utf-8编码" class="headerlink" title="如何检测、替换、去除4个字节的utf-8编码"></a>如何检测、替换、去除4个字节的utf-8编码</h2><p>由于上面的错误，需要修改表字段的类型，新项目基本已经完工，所以老大决定不支持4个字节UTF-8编码的字符。而且这些数据并不重要，这就要对旧数据中4个字节UTF-8编码的字符进行除去。</p><p>请先阅读<a href="/2016/05/27/UTF-8编码规则/">UTF-8编码规则</a></p><pre><code class="java">public class UTF8Utils {    public static Map&lt;String, Integer&gt; hexMap = new HashMap&lt;String, Integer&gt;();    public static Map&lt;String, Integer&gt; byteMap = new HashMap&lt;String, Integer&gt;();    static {        hexMap.put(&quot;0&quot;, 2);        hexMap.put(&quot;1&quot;, 2);        hexMap.put(&quot;2&quot;, 2);        hexMap.put(&quot;3&quot;, 2);        hexMap.put(&quot;4&quot;, 2);        hexMap.put(&quot;5&quot;, 2);        hexMap.put(&quot;6&quot;, 2);        hexMap.put(&quot;7&quot;, 2);        hexMap.put(&quot;c&quot;, 4);        hexMap.put(&quot;d&quot;, 4);        hexMap.put(&quot;e&quot;, 6);        hexMap.put(&quot;f&quot;, 8);        byteMap.put(&quot;0&quot;, 1);        byteMap.put(&quot;1&quot;, 1);        byteMap.put(&quot;2&quot;, 1);        byteMap.put(&quot;3&quot;, 1);        byteMap.put(&quot;4&quot;, 1);        byteMap.put(&quot;5&quot;, 1);        byteMap.put(&quot;6&quot;, 1);        byteMap.put(&quot;7&quot;, 1);        byteMap.put(&quot;c&quot;, 2);        byteMap.put(&quot;d&quot;, 2);        byteMap.put(&quot;e&quot;, 3);        byteMap.put(&quot;f&quot;, 4);    }}</code></pre><h3 id="是否包含4字节UTF-8编码的字符1"><a href="#是否包含4字节UTF-8编码的字符1" class="headerlink" title="是否包含4字节UTF-8编码的字符1"></a>是否包含4字节UTF-8编码的字符1</h3><pre><code class="java">/** * 是否包含4字节UTF-8编码的字符（先转换16进制再判断） * @param s 字符串 * @return 是否包含4字节UTF-8编码的字符 */public static boolean contains4BytesChar(String s) {    if (s == null || s.trim().length() == 0) {        return false;    }    String hex = UTF8Utils.bytesToHex(s.getBytes());    System.out.println(&quot;full hex : &quot; + hex);    String firstChar = null;    while (hex != null &amp;&amp; hex.length() &gt; 1) {        firstChar = hex.substring(0, 1);        System.out.println(&quot;firstChar : &quot; + firstChar);        if (&quot;f&quot;.equals(firstChar)) {            System.out.println(&quot;it is f start, it is 4 bytes, return.&quot;);            return true;        }        if (hexMap.get(firstChar) == null) {            System.out.println(&quot;it is f start, it is 4 bytes, return.&quot;);            // todo, throw exception for this case            return false;        }        hex = hex.substring(hexMap.get(firstChar), hex.length());        System.out.println(&quot;remain hex : &quot; + hex);    }    return false;}</code></pre><h3 id="是否包含4字节UTF-8编码的字符2"><a href="#是否包含4字节UTF-8编码的字符2" class="headerlink" title="是否包含4字节UTF-8编码的字符2"></a>是否包含4字节UTF-8编码的字符2</h3><pre><code class="java">/** * 是否包含4字节UTF-8编码的字符 * @param s 字符串 * @return 是否包含4字节UTF-8编码的字符 */public static boolean contains4BytesChar2(String s) {    if (s == null || s.trim().length() == 0) {        return false;    }    byte[] bytes = s.getBytes();    if (bytes == null || bytes.length == 0) {        return false;    }    int index = 0;    byte b;    String hex = null;    String firstChar = null;    int step;    while (index &lt;= bytes.length - 1) {        System.out.println(&quot;while loop, index : &quot; + index);        b = bytes[index];        hex = byteToHex(b);        if (hex == null || hex.length() &lt; 2) {            System.out.println(&quot;fail to check whether contains 4 bytes char(1 byte hex char too short), default return false.&quot;);            // todo, throw exception for this case            return false;        }        firstChar = hex.substring(0, 1);        if (firstChar.equals(&quot;f&quot;)) {            return true;        }        if (byteMap.get(firstChar) == null) {            System.out.println(&quot;fail to check whether contains 4 bytes char(no firstchar mapping), default return false.&quot;);            // todo, throw exception for this case            return false;        }        step = byteMap.get(firstChar);        System.out.println(&quot;while loop, index : &quot; + index + &quot;, step : &quot; + step);        index = index + step;    }    return false;}</code></pre><h3 id="去除4字节UTF-8编码的字符"><a href="#去除4字节UTF-8编码的字符" class="headerlink" title="去除4字节UTF-8编码的字符"></a>去除4字节UTF-8编码的字符</h3><pre><code class="java">/** * 去除4字节UTF-8编码的字符 * @param s 字符串 * @return 已去除4字节UTF-8编码的字符 */public static byte[] remove4BytesUTF8Char(String s) {    byte[] bytes = s.getBytes();    byte[] removedBytes = new byte[bytes.length];    int index = 0;    String hex = null;    String firstChar = null;    for (int i = 0; i &lt; bytes.length; ) {        hex = UTF8Utils.byteToHex(bytes[i]);        if (hex == null || hex.length() &lt; 2) {            System.out.println(&quot;fail to check whether contains 4 bytes char(1 byte hex char too short), default return false.&quot;);            // todo, throw exception for this case            return null;        }        firstChar = hex.substring(0, 1);        if (byteMap.get(firstChar) == null) {            System.out.println(&quot;fail to check whether contains 4 bytes char(no firstchar mapping), default return false.&quot;);            // todo, throw exception for this case            return null;        }        if (firstChar.equals(&quot;f&quot;)) {            for (int j = 0; j &lt; byteMap.get(firstChar); j++) {                i++;            }            continue;        }        for (int j = 0; j &lt; byteMap.get(firstChar); j++) {            removedBytes[index++] = bytes[i++];        }    }    return Arrays.copyOfRange(removedBytes, 0, index);}</code></pre><h3 id="将每个字符的16进制-分隔格式化-空格分隔"><a href="#将每个字符的16进制-分隔格式化-空格分隔" class="headerlink" title="将每个字符的16进制 分隔格式化(空格分隔)"></a>将每个字符的16进制 分隔格式化(空格分隔)</h3><pre><code class="java">/** * 将字符串的16进制转换为HEX，并按每个字符的16进制分隔格式化 * @param s 字符串 */public static String splitForReading(String s) {    if (s == null || s.trim().length() == 0) {        return &quot;&quot;;    }    String hex = UTF8Utils.bytesToHex(s.getBytes());    System.out.println(&quot;full hex : &quot; + hex);    if (hex == null || hex.length() == 0) {        System.out.println(&quot;fail to translate the bytes to hex.&quot;);        // todo, throw exception for this case        return &quot;&quot;;    }    StringBuilder sb = new StringBuilder();    int index = 0;    String firstChar = null;    String splittedString = null;    while (index &lt; hex.length()) {        firstChar = hex.substring(index, index + 1);        if (hexMap.get(firstChar) == null) {            System.out.println(&quot;fail to check whether contains 4 bytes char(no firstchar mapping), default return false.&quot;);            // todo, throw exception for this case            return &quot;&quot;;        }        splittedString = hex.substring(index, index + hexMap.get(firstChar));        sb.append(splittedString).append(&quot; &quot;);        index = index + hexMap.get(firstChar);    }    System.out.println(&quot;formated sb : &quot; + sb);    return sb.toString();}</code></pre><h3 id="字节数组转十六进制"><a href="#字节数组转十六进制" class="headerlink" title="字节数组转十六进制"></a>字节数组转十六进制</h3><pre><code class="java">/** * 字节数组转十六进制 * @param bytes 字节数组 * @return 十六进制 */public static String bytesToHex(byte[] bytes) {    if (bytes == null || bytes.length == 0) {        return null;    }    StringBuilder sb = new StringBuilder();    for (int i = 0; i &lt; bytes.length; i++) {        int r = bytes[i] &amp; 0xFF;        String hexResult = Integer.toHexString(r);        if (hexResult.length() &lt; 2) {            sb.append(0); // 前补0        }        sb.append(hexResult);    }    return sb.toString();}</code></pre><h3 id="字节转十六进制"><a href="#字节转十六进制" class="headerlink" title="字节转十六进制"></a>字节转十六进制</h3><pre><code class="java">/** * 字节转十六进制 * @param b 字节 * @return 十六进制 */public static String byteToHex(byte b) {    int r = b &amp; 0xFF;//获得低8位    String hexResult = Integer.toHexString(r);    StringBuilder sb = new StringBuilder();    if (hexResult.length() &lt; 2) {        sb.append(0); // 前补0    }    sb.append(hexResult);    return sb.toString();}</code></pre><p>int r = b &amp; 0xFF; 如有疑问，可以查看：<a href="http://www.blogjava.net/orangelizq/archive/2008/07/20/216228.html" target="_blank" rel="noopener">java中byte转换int时为何与0xff进行与运算</a><br>主要原因是<br>1.byte的大小为8bits而int的大小为32bits<br>2.java的二进制采用的是补码形式<br>Java中的一个byte，其范围是-128~127的，而Integer.toHexString的参数本来是int，如果不进行&amp;0xff，那么当一个byte会转换成int时，对于负数，会做位扩展，举例来说，一个byte的-1（即0xff），会被转换成int的-1（即0xffffffff），那么转化出的结果就不是我们想要的了。</p><p>而0xff默认是整形，所以，<strong>一个byte跟0xff相与会先将那个byte转化成整形运算，这样，结果中的高的24个比特就总会被清0</strong>，于是结果总是我们想要的。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《第一行代码》读书笔记-第三章01 常见控件的使用方法</title>
      <link href="/2016/05/18/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%89%E7%AB%A001-%E5%B8%B8%E8%A7%81%E6%8E%A7%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
      <url>/2016/05/18/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%89%E7%AB%A001-%E5%B8%B8%E8%A7%81%E6%8E%A7%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="TextView"><a href="#TextView" class="headerlink" title="TextView"></a>TextView</h2><p>我们使用<code>android:gravity</code> 来指定文字的对齐方式，可选值有<code>top</code>、<code>bottom</code>、<code>left</code>、<code>right</code>、<code>center</code>等， 可以用<code>|</code> 来同时指定多个值， 指定<code>center</code> ， 效果等同于<code>center_vertical|center_horizontal</code>，表示文字在垂直和水平方向都居中对齐。</p><p>通过<code>android:textSize</code> 属性可以指定文字的大小，通过<code>android:textColor</code> 属性可以指定文字的颜色</p><a id="more"></a><h2 id="Button"><a href="#Button" class="headerlink" title="Button"></a>Button</h2><p>每当点击按钮时，就会执行监听器中的onClick()方法，我们只需要在这个方法中加入待处理的逻辑就行了。除了前面所使用匿名类的方式来注册监听器，也可以使用实现接口的方式来进行注册，代码如下所示：</p><pre><code class="java">public class MainActivity extends Activity implements OnClickListener {    private Button button;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        button = (Button) findViewById(R.id.button);        button.setOnClickListener(this);    }    @Override    public void onClick(View v) {        switch (v.getId()) {        case R.id.button:            // 在此处添加逻辑            break;        default:            break;        }    }}</code></pre><h2 id="EditText"><a href="#EditText" class="headerlink" title="EditText"></a>EditText</h2><p>允许用户在控件里输入和编辑内容，并可以在程序中对这些内容进行处理</p><p>通过<code>android:hint</code>属性设置 提示性文字。<br>通过<code>android:maxLines</code>属性 指定了EditText 的最大行数，这样当输入的内容超过设置值时，文本就会向上滚动，而EditText 则不会再继续拉伸。</p><p>获得<code>EditText</code>中的内容，首先通过<code>findViewById()</code>方法得到<code>EditText</code> 的实例，然后在按钮的点击事件里调用<code>EditText</code> 的<code>getText()</code>方法获取到输入的内容，再调用<code>toString()</code>方法转换成字符串。</p><h2 id="ImageView"><a href="#ImageView" class="headerlink" title="ImageView"></a>ImageView</h2><p><code>ImageView</code> 是用于在界面上展示图片的一个控件。</p><p>使用<code>android:src</code> 属性给ImageView 指定了一张图片</p><p>在程序中通过代码动态地更改ImageView 中的图片:</p><pre><code class="java">ImageView imageView = (ImageView) findViewById(R.id.image_view);imageView.setImageResource(R.drawable.jelly_bean);</code></pre><h2 id="ProgressBar"><a href="#ProgressBar" class="headerlink" title="ProgressBar"></a>ProgressBar</h2><p><code>ProgressBar</code> 用于在界面上显示一个圆形进度条(旋转)，表示我们的程序正在加载一些数据。</p><p>还可以给ProgressBar 指定不同的样式，刚刚是圆形进度条，通过style 属性可以将它指定成水平进度条。通过android:max 属性给进度条设置一个最大值。</p><pre><code class="xml">style=&quot;?android:attr/progressBarStyleHorizontal&quot;android:max=&quot;100&quot;</code></pre><p>在代码中动态地更改进度条的进度。修改MainActivity 中的代码，如下所示：</p><pre><code class="java">    public class MainActivity extends Activity implements OnClickListener {    ……    @Override    public void onClick(View v) {        switch (v.getId()) {        case R.id.button:            int progress = progressBar.getProgress();            progress = progress + 10;            progressBar.setProgress(progress);            break;        default:            break;        }    }}</code></pre><p>每点击一次按钮，我们就获取进度条的当前进度，然后在现有的进度上加10 作为更新后的进度</p><h2 id="Android-控件的可见属性"><a href="#Android-控件的可见属性" class="headerlink" title="Android 控件的可见属性"></a>Android 控件的可见属性</h2><p>所有的Android 控件都具有这个属性，可以通过<code>android:visibility</code>进行指定，可选值有三种，<code>visible</code>、<code>invisible</code> 和<code>gone</code>。</p><ul><li><code>visible</code> 表示控件是可见的，这个值是默认值，不指定<code>android:visibility</code> 时，控件都是可见的。</li><li><code>invisible</code> 表示控件不可见，但是它仍然占据着原来的位置和大小，可以理解成控件变成透明状态了。</li><li><code>gone</code> 则表示控件不仅不可见，而且不再占用任何屏幕空间。</li></ul><p>我们还可以通过代码来设置控件的可见性，使用的是<code>setVisibility()</code>方法，可以传入<code>View.VISIBLE</code>、<code>View.INVISIBLE</code> 和<code>View.GONE</code> 三种值。</p><h2 id="AlertDialog"><a href="#AlertDialog" class="headerlink" title="AlertDialog"></a>AlertDialog</h2><p>AlertDialog 可以在当前的界面弹出一个对话框，这个对话框是置顶于所有界面元素之上的，能够屏蔽掉其他控件的交互能力，因此一般AlertDialog 都是用于提示一些非常重要的内容或者警告信息。比如为了防止用户误删重要内容，在删除前弹出一个确认对话框。</p><pre><code class="java">public class MainActivity extends Activity implements OnClickListener {    ……    @Override    public void onClick(View v) {        switch (v.getId()) {        case R.id.button:            AlertDialog.Builder dialog = new AlertDialog.Builder(MainActivity.this);            dialog.setTitle(&quot;This is Dialog&quot;);//标题            dialog.setMessage(&quot;Something important.&quot;);//信息            dialog.setCancelable(false);//可否取消(true点击空白处,Back键消失)            dialog.setPositiveButton(&quot;OK&quot;, new DialogInterface.OnClickListener() {//可以不写就是一个按钮了                @Override                public void onClick(DialogInterface dialog, int which) {                }            });            dialog.setNegativeButton(&quot;Cancel&quot;, new DialogInterface.OnClickListener() {                @Override                public void onClick(DialogInterface dialog, int which) {                }            });            dialog.show();//将对话框显示出来            break;        default:            break;        }    }}</code></pre><h2 id="ProgressDialog"><a href="#ProgressDialog" class="headerlink" title="ProgressDialog"></a>ProgressDialog</h2><p>ProgressDialog 和AlertDialog 有点类似，都可以在界面上弹出一个对话框，都能够屏蔽掉其他控件的交互能力。不同的是，ProgressDialog 会在对话框中显示一个进度条，一般是用于表示当前操作比较耗时，让用户耐心地等待。</p><pre><code class="java">public class MainActivity extends Activity implements OnClickListener {    ……    @Override    public void onClick(View v) {//几个方法同上        switch (v.getId()) {        case R.id.button:            ProgressDialog progressDialog = new ProgressDialog(MainActivity.this);            progressDialog.setTitle(&quot;This is ProgressDialog&quot;);            progressDialog.setMessage(&quot;Loading...&quot;);            progressDialog.setCancelable(true);//如果false不能Back键取消，一直存在，需要在代码中控制//当数据加载完成后必须要调用ProgressDialog 的dismiss()方法来关闭对话框            progressDialog.show();            break;        default:            break;        }    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 第一行代码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《第一行代码》读书笔记-第二章05 活动的最佳实践</title>
      <link href="/2016/05/18/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A005-%E6%B4%BB%E5%8A%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
      <url>/2016/05/18/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A005-%E6%B4%BB%E5%8A%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="知晓当前是在哪一个活动"><a href="#知晓当前是在哪一个活动" class="headerlink" title="知晓当前是在哪一个活动"></a>知晓当前是在哪一个活动</h2><p>阅读别人的代码时有一个很头疼的问题，就是你需要在某个界面上修改一<br>些非常简单的东西，可以快速找到界面对应的活动是哪一个。</p><p>新建一个BaseActivity 继承自Activity，然后在BaseActivity 中重写onCreate()方法，</p><pre><code class="java">public class BaseActivity extends AppCompatActivity {    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        Log.d(&quot;BaseActivity&quot;,getClass().getSimpleName());    }}</code></pre><p>让项目中其他活动继承BaseActivity，这样我们每次进入到一个活动中，该活动的类名就会被打印出来，就可以时时刻刻知晓当前界面对应的是哪一个活动了。</p><a id="more"></a><h2 id="随时随地退出程序"><a href="#随时随地退出程序" class="headerlink" title="随时随地退出程序"></a>随时随地退出程序</h2><p>如果我们的程序需要一个注销或者退出的功能该怎么办呢？必须要有一个随时随地都能退出程序的方案。<br><strong>需要用一个专门的集合类对所有的活动进行管理</strong><br>新建一个<code>ActivityCollector</code> 类作为活动管理器</p><pre><code class="java">public class ActivityCollector {    public static List&lt;Activity&gt; activities = new ArrayList&lt;&gt;();    public static void addActivity(Activity activity) {        activities.add(activity);    }    public static void removeActivity(Activity activity) {        activities.remove(activity);    }    public static void finishAll() {        for (Activity activity : activities) {            if (!activity.isFinishing()) {                activity.finish();            }        }    }}</code></pre><p>在活动管理器中，我们通过一个List 来暂存活动，然后提供了一个addActivity()方法用于向List 中添加一个活动，提供了一个removeActivity()方法用于从List 中移除活动，最后提供了一个finishAll()方法用于将List 中存储的活动全部都销毁掉。<br>接下来修改BaseActivity 中的代码</p><pre><code class="java">public class BaseActivity extends AppCompatActivity {    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        Log.d(&quot;BaseActivity&quot;,getClass().getSimpleName());        ActivityCollector.addActivity(this);    }    @Override    protected void onDestroy() {        super.onDestroy();        ActivityCollector.removeActivity(this);    }}</code></pre><p>在BaseActivity 的onCreate()方法中调用了ActivityCollector 的addActivity()方法，表明将当前正在创建的活动添加到活动管理器里。然后在BaseActivity 中重写onDestroy()方法，并调用了ActivityCollector 的removeActivity()方法，表明将一个马上要销毁的活动从活动管理器里移除。</p><p><strong>如果要退出程序，只需要调用ActivityCollector.finishAll()方法就可以了</strong></p><h2 id="启动活动的最佳写法"><a href="#启动活动的最佳写法" class="headerlink" title="启动活动的最佳写法"></a>启动活动的最佳写法</h2><p>假设SecondActivity 中需要用到两个非常重要的字符串参数，在启动SecondActivity 的时候必须要传递过来，那么我们之前的写法：</p><pre><code class="java">Intent intent = new Intent(FirstActivity.this, SecondActivity.class);intent.putExtra(&quot;param1&quot;, &quot;data1&quot;);intent.putExtra(&quot;param2&quot;, &quot;data2&quot;);startActivity(intent);</code></pre><p>这样写是完全正确的，但是在真正的项目开发中经常会有对接的问题出现。比如SecondActivity 并不是由你开发的，但现在你负责的部分需要有启动SecondActivity 这个功能，而你却不清楚启动这个活动需要传递哪些数据。这时无非就有两种办法，一个是你自己去阅读SecondActivity 中的代码，二是询问负责编写SecondActivity的同事。就会很麻烦。</p><p>修改SecondActivity 中的代码，如下所示：</p><pre><code class="java">public class SecondActivity extends BaseActivity {    public static void actionStart(Context context, String data1, String data2) {        Intent intent = new Intent(context, SecondActivity.class);        intent.putExtra(&quot;param1&quot;, data1);        intent.putExtra(&quot;param2&quot;, data2);        context.startActivity(intent);    }    ……}</code></pre><p>我们在SecondActivity 中添加了一个actionStart()方法，在这个方法中完成了Intent 的构建，另外所有SecondActivity 中需要的数据都是通过actionStart()方法的参数传递过来的，然后把它们存储到Intent 中，最后调用startActivity()方法启动SecondActivity。<br>这样写的好处，最重要的一点就是一目了然，SecondActivity 所需要的数据全部都在方法参数中体现出来了，这样即使不用阅读SecondActivity 中的代码，或者询问负责编写SecondActivity 的同事，你也可以非常清晰地知道启动SecondActivity 需要传递哪些数据。另外，这样写还简化了启动活动的代码，现在只需要一行代码就可以启动SecondActivity，如下所示：</p><pre><code class="java">button1.setOnClickListener(new OnClickListener() {    @Override    public void onClick(View v) {        SecondActivity.actionStart(FirstActivity.this, &quot;data1&quot;, &quot;data2&quot;);    }});</code></pre>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 第一行代码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ADB常用命令</title>
      <link href="/2016/05/18/ADB%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2016/05/18/ADB%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>转自：<a href="http://blog.csdn.net/shuaihj/article/details/8889465" target="_blank" rel="noopener">ADB命令详细介绍</a><br><a href="https://developer.android.com/studio/command-line/adb.html" target="_blank" rel="noopener">官方说明</a></p><h2 id="adb-介绍"><a href="#adb-介绍" class="headerlink" title="adb 介绍"></a>adb 介绍</h2><p>adb的全称为Android Debug Bridge 调试桥，是连接Android手机与PC端的桥梁，通过adb可以管理、操作模拟器和设备，如安装软件、系统升级、运行shell命令等。</p><a id="more"></a><h2 id="管理设备"><a href="#管理设备" class="headerlink" title="管理设备"></a>管理设备</h2><p>注：android手机、模拟器统一称为“设备”</p><pre><code class="shell">adb devices  // 显示连接到计算机的设备adb get-serialno // 获取设备的ID和序列号serialNumber------------------重启----------------------------------------------adb reboot  // 重启设备adb reboot bootloader  // 重启到bootloader，即刷机模式adb reboot recovery  // 重启到recovery，即恢复模式------------------发送命令到设备--------------------------------------adb [-d|-e|-s &lt;serialNumber&gt;] &lt;command&gt;-d 发送命令给usb连接的设备-e 发送命令到模拟器设备-s &lt;serialNumber&gt; 发送命令到指定设备</code></pre><h2 id="adb相关"><a href="#adb相关" class="headerlink" title="adb相关"></a>adb相关</h2><pre><code class="shell">adb kill-server // 终止adb服务进程adb start-server // 重启adb服务进程adb root // 已root权限重启adb服务adb wait-for-device // 在模拟器/设备连接之前把命令转载在adb的命令器中</code></pre><h2 id="获取设备硬件信息"><a href="#获取设备硬件信息" class="headerlink" title="获取设备硬件信息"></a>获取设备硬件信息</h2><pre><code class="shell">adb shell  cat /sys/class/net/wlan0/address  // 获取mac地址adb shell cat /proc/cpuinfo  // 获取cpu序列号</code></pre><h2 id="管理设备app"><a href="#管理设备app" class="headerlink" title="管理设备app"></a>管理设备app</h2><pre><code class="shell">aapt d badging &lt;apkfile&gt; // 获取apk的packagename 和 classname------------------安装----------------------------------------------adb install &lt;apkfile&gt;  // 安装apkadb install -r &lt;apkfile&gt; // 保留数据和缓存文件，重新安装apk，adb install -s &lt;apkfile&gt;  // 安装apk到sd卡------------------卸载----------------------------------------------adb uninstall &lt;package&gt;  // 卸载appadb uninstall -k &lt;package&gt;  // 卸载app但保留数据和缓存文件------------------启动app-------------------------------------------adb shell am start -n &lt;package_name&gt;/.&lt;activity_class_name&gt; // 启动应用------------------查看内存占用----------------------------------------adb shell top  // 查看设备cpu和内存占用情况adb shell top -m 6 // 查看占用内存前6的appadb shell top -n 1 // 刷新一次内存信息，然后返回adb shell procrank // 查询各进程内存使用情况adb shell kill [pid] // 杀死一个进程adb shell ps // 查看进程列表adb shell ps -x [PID] // 查看指定进程状态adb shell service list // 查看后台services信息adb shell cat /proc/meminfo // 查看当前内存占用adb shell cat /proc/iomem // 查看IO内存分区</code></pre><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><p>//android中，sdcard代表内置存储，不同系统中tf卡的设备名可能不同，使用查看adb shell ls mnt查看所有存储设备名。</p><pre><code class="shell">adb remount  // 将system分区重新挂载为可读写分区adb push &lt;local&gt; &lt;remote&gt; // 从本地复制文件到设备adb pull &lt;remote&gt;  &lt;local&gt; // 从设备复制文件到本地adb shell ls // 列出目录下的文件和文件夹，等同于dos中的dir命令adb shell cd &lt;folder&gt; // 进入文件夹，等同于dos中的cd 命令adb shell rename path/oldfilename path/newfilename // 重命名文件adb shell rm /system/avi.apk  // 删除system/avi.apkadb shell rm -r &lt;folder&gt; // 删除文件夹及其下面所有文件adb shell mv path/file newpath/file // 移动文件adb shell chmod 777 /system/fonts/DroidSansFallback.ttf // 设置文件权限adb shell mkdir path/foldelname // 新建文件夹adb shell cat &lt;file&gt; // 查看文件内容</code></pre><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><pre><code class="shell">adb shell cat /data/misc/wifi/*.conf  //查看wifi密码adb logcat -c  //清除log缓存adb bugreport  //查看bug报告adb shell cat /system/build.prop  //获取设备名称adb shell monkey -v -p your.package.name 500 //跑monkey(测试)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android任务和返回栈完全解析，细数那些你所不知道的细节</title>
      <link href="/2016/05/17/Android%E4%BB%BB%E5%8A%A1%E5%92%8C%E8%BF%94%E5%9B%9E%E6%A0%88%E5%AE%8C%E5%85%A8%E8%A7%A3%E6%9E%90%EF%BC%8C%E7%BB%86%E6%95%B0%E9%82%A3%E4%BA%9B%E4%BD%A0%E6%89%80%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E7%BB%86%E8%8A%82/"/>
      <url>/2016/05/17/Android%E4%BB%BB%E5%8A%A1%E5%92%8C%E8%BF%94%E5%9B%9E%E6%A0%88%E5%AE%8C%E5%85%A8%E8%A7%A3%E6%9E%90%EF%BC%8C%E7%BB%86%E6%95%B0%E9%82%A3%E4%BA%9B%E4%BD%A0%E6%89%80%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E7%BB%86%E8%8A%82/</url>
      
        <content type="html"><![CDATA[<p>前面的东西大多前文有讲，可以直接从<a href="./#使用intent-flags">使用Intent flags</a>看。</p><p>转载请注明出处：<a href="http://blog.csdn.net/guolin_blog/article/details/41087993" target="_blank" rel="noopener">http://blog.csdn.net/guolin_blog/article/details/41087993</a><br>本篇文章主要内容来自于Android Doc，我翻译之后又做了些加工，英文好的朋友也可以直接去读原文。<br><a href="http://developer.android.com/guide/components/tasks-and-back-stack.html" target="_blank" rel="noopener">http://developer.android.com/guide/components/tasks-and-back-stack.html</a></p><a id="more"></a><h2 id="任务和返回栈"><a href="#任务和返回栈" class="headerlink" title="任务和返回栈"></a>任务和返回栈</h2><p>一个应用程序当中通常都会包含很多个Activity，每个Activity都应该设计成为一个具有特定的功能，并且可以让用户进行操作的组件。另外，Activity之间还应该是可以相互启动的。比如，一个邮件应用中可能会包含一个用于展示邮件列表的Activity，而当用户点击了其中某一封邮件的时候，就会打开另外一个Activity来显示该封邮件的具体内容。<br>除此之外，一个Activity甚至还可以去启动其它应用程序当中的Activity。打个比方，如果你的应用希望去发送一封邮件，你就可以定义一个具有&quot;send&quot;动作的Intent，并且传入一些数据，如对方邮箱地址、邮件内容等。这样，如果另外一个应用程序中的某个Activity声明自己是可以响应这种Intent的，那么这个Activity就会被打开。在当前场景下，这个Intent是为了要发送邮件的，所以说邮件应用程序当中的编写邮件Activity就应该被打开。当邮件发送出去之后，仍然还是会回到你的应用程序当中，这让用户看起来好像刚才那个编写邮件的Activity就是你的应用程序当中的一部分。所以说，即使有很多个Activity分别都是来自于不同应用程序的，Android系统仍然可以将它们无缝地结合到一起，之所以能实现这一点，就是因为这些Activity都是存在于一个相同的任务(Task)当中的。<br> <font color="red">任务是一个Activity的集合，它使用栈的方式来管理其中的Activity，这个栈又被称为返回栈(back stack)，栈中Activity的顺序就是按照它们被打开的顺序依次存放的。</font><br>手机的Home界面是大多数任务开始的地方，当用户在Home界面上点击了一个应用的图标时，这个应用的任务就会被转移到前台。如果这个应用目前并没有任何一个任务的话(说明这个应用最近没有被启动过)，系统就会去创建一个新的任务，并且将该应用的主Activity放入到返回栈当中。<br>当一个Activity启动了另外一个Activity的时候，新的Activity就会被放置到返回栈的栈顶并将获得焦点。前一个Activity仍然保留在返回栈当中，但会处于停止状态。当用户按下Back键的时候，栈中最顶端的Activity会被移除掉，然后前一个Activity则会得重新回到最顶端的位置。返回栈中的Activity的顺序永远都不会发生改变，我们只能向栈顶添加Activity，或者将栈顶的Activity移除掉。因此，返回栈是一个典型的后进先出(last in, first out)的数据结构。下图通过时间线的方式非常清晰地向我们展示了多个Activity在返回栈当中的状态变化：<br><img src="/demo/photo/activity/20141224210418616.png" alt=""><br>如果用户一直地按Back键，这样返回栈中的Activity会一个个地被移除，直到最终返回到主屏幕。当返回栈中所有的Activity都被移除掉的时候，对应的任务也就不存在了。<br>任务除了可以被转移到前台之外，当然也是可以被转移到后台的。当用户开启了一个新的任务，或者点击Home键回到主屏幕的时候，之前任务就会被转移到后台了。当任务处于后台状态的时候，返回栈中所有的Activity都会进入停止状态，但这些Activity在栈中的顺序都会原封不动地保留着，如下图所示：<br><img src="/demo/photo/activity/20141225121645399.png" alt=""><br>这个时候，用户还可以将任意后台的任务切换到前台，这样用户应该就会看到之前离开这个任务时处于最顶端的那个Activity。举个例子来说，当前任务A的栈中有三个Activity，现在用户按下Home键，然后点击桌面上的图标启动了另外一个应用程序。当系统回到桌面的时候，其实任务A就已经进入后台了，然后当另外一个应用程序启动的时候，系统会为这个程序开启一个新的任务(任务B)。当用户使用完这个程序之后，再次按下Home键回到桌面，这个时候任务B也进入了后台。然后用户又重新打开了第一次使用的程序，这个时候任务A又会回到前台，A任务栈中的三个Activity仍然会保留着刚才的顺序，最顶端的Activity将重新变为运行状态。之后用户仍然可以通过Home键或者多任务键来切换回任务B，或者启动更多的任务，这就是Android中多任务切换的例子。<br>由于返回栈中的Activity的顺序永远都不会发生改变，所以如果你的应用程序中允许有多个入口都可以启动同一个Activity，那么每次启动的时候就都会创建该Activity的一个新的实例，而不是将下面的Activity的移动到栈顶。这样的话就容易导致一个问题的产生，即同一个Activity有可能会被实例化很多次，如下图所示：<br><img src="/demo/photo/activity/20141225142319679.png" alt=""><br>但是呢，如果你不希望同一个Activity可以被多次实例化，那当然也是可以的，马上我们就将开始讨论如果实现这一功能，现在我们先把默认的任务和Activity的行为简单概括一下：</p><ul><li>当Activity A启动Activity B时，Activity A进入停止状态，但系统仍然会将它的所有相关信息保留，比如滚动的位置，还有文本框输入的内容等。如果用户在Activity B中按下Back键，那么Activity A将会重新回到运行状态。</li><li>当用户通过Home键离开一个任务时，该任务会进入后台，并且返回栈中所有的Activity都会进入停止状态。系统会将这些Activity的状态进行保留，这样当用户下一次重新打开这个应用程序时，就可以将后台任务直接提取到前台，并将之前最顶端的Activity进行恢复。</li><li>当用户按下Back键时，当前最顶端的Activity会被从返回栈中移除掉，移除掉的Activity将被销毁，然后前面一个Activity将处于栈顶位置并进入活动状态。当一个Activity被销毁了之后，系统不会再为它保留任何的状态信息。<br>每个Activity都可以被实例化很多次，即使是在不同的任务当中。</li></ul><h2 id="管理任务"><a href="#管理任务" class="headerlink" title="管理任务"></a>管理任务</h2><p>Android系统管理任务和返回栈的方式，正如上面所描述的一样，就是把所有启动的Activity都放入到一个相同的任务当中，通过一个“后进先出”的栈来进行管理的。这种方式在绝大多数情况下都是没问题的，开发者也无须去关心任务中的Activity到底是怎么样存放在返回栈当中的。但是呢，如果你想打破这种默认的行为，比如说当启动一个新的Activity时，你希望它可以存在于一个独立的任务当中，而不是现有的任务当中。或者说，当启动一个Activity时，如果这个Activity已经存在于返回栈中了，你希望能把这个Activity直接移动到栈顶，而不是再创建一个它的实例。再或者，你希望可以将返回栈中除了最底层的那个Activity之外的其它所有Activity全部清除掉。这些功能甚至更多功能，都是可以通过在manifest文件中设置<code>&lt;activity&gt;</code>元素的属性，或者是在启动Activity时配置Intent的flag来实现的。<br> <font color="red">在<code>&lt;activity&gt;</code>元素中，有以下几个属性是可以使用的：</font></p><ul><li>taskAffinity</li><li>launchMode</li><li>allowTaskReparenting</li><li>clearTaskOnLaunch</li><li>alwaysRetainTaskState</li><li>finishOnTaskLaunch</li></ul><p>而在Intent当中，有以下几个flag是比较常用的：</p><ul><li>FLAG_ACTIVITY_NEW_TASK</li><li>FLAG_ACTIVITY_CLEAR_TOP</li><li>FLAG_ACTIVITY_SINGLE_TOP</li></ul><p>下面我们就将开始讨论，如何通过manifest参数，以及Intent flag来改变Activity在任务中的默认行为。</p><h2 id="定义启动模式"><a href="#定义启动模式" class="headerlink" title="定义启动模式"></a>定义启动模式</h2><p>启动模式允许你去定义如何将一个Activity的实例和当前的任务进行关联，你可以通过以下两种不同的方式来定义启动模式：</p><ol><li>使用manifest文件<br>当你在manifest文件中声明一个Activity的时候，你可以指定这个Activity在启动的时候该如何与任务进行关联。</li><li>使用Intent flag<br>当你调用startActivity()方法时，你可以在Intent中加入一个flag，从而指定新启动的Activity该如何与当前任务进行关联。<br>也就是说，如果Activity A启动了Activity B，Activity B可以定义自己该如何与当前任务进行关联，而Activity A也可以要求Activity B该如何与当前任务进行关联。如果Activity B在manifest中已经定义了该如何与任务进行关联，而Activity A同时也在Intent中要求了Activity B该怎么样与当前任务进行关联，那么此时Intent中的定义将覆盖manifest中的定义。</li></ol><p>需要注意的是，有些启动模式在manifest中可以指定，但在Intent中是指定不了的。同样，也有些启动模式在Intent中可以指定，但在manifest中是指定不了的，下面我们就来具体讨论一下。</p><h3 id="使用manifest文件"><a href="#使用manifest文件" class="headerlink" title="使用manifest文件"></a>使用manifest文件</h3><p>当在manifest文件中定义Activity的时候，你可以通过<activity>元素的launchMode属性来指定这个Activity应该如何与任务进行关联。launchMode属性一共有以下四种可选参数：</p><h4 id="quot-standard-quot-默认启动模式"><a href="#quot-standard-quot-默认启动模式" class="headerlink" title="&quot;standard&quot;(默认启动模式)"></a>&quot;standard&quot;(默认启动模式)</h4><p>standard是默认的启动模式，即如果不指定launchMode属性，则自动就会使用这种启动模式。这种启动模式表示每次启动该Activity时系统都会为创建一个新的实例，并且总会把它放入到当前的任务当中。声明成这种启动模式的Activity可以被实例化多次，一个任务当中也可以包含多个这种Activity的实例。</p><h4 id="quot-singleTop-quot"><a href="#quot-singleTop-quot" class="headerlink" title="&quot;singleTop&quot;"></a>&quot;singleTop&quot;</h4><p>这种启动模式表示，如果要启动的这个Activity在当前任务中已经存在了，并且还处于栈顶的位置，那么系统就不会再去创建一个该Activity的实例，而是调用栈顶Activity的onNewIntent()方法。声明成这种启动模式的Activity也可以被实例化多次，一个任务当中也可以包含多个这种Activity的实例。<br>举个例子来讲，一个任务的返回栈中有A、B、C、D四个Activity，其中A在最底端，D在最顶端。这个时候如果我们要求再启动一次D，并且D的启动模式是&quot;standard&quot;，那么系统就会再创建一个D的实例放入到返回栈中，此时栈内元素为：A-B-C-D-D。而如果D的启动模式是&quot;singleTop&quot;的话，由于D已经是在栈顶了，那么系统就不会再创建一个D的实例，而是直接调用D Activity的onNewIntent()方法，此时栈内元素仍然为：A-B-C-D。</p><h4 id="quot-singleTask-quot"><a href="#quot-singleTask-quot" class="headerlink" title="&quot;singleTask&quot;"></a>&quot;singleTask&quot;</h4><p>这种启动模式表示，系统会创建一个新的任务，并将启动的Activity放入这个新任务的栈底位置。但是，如果现有任务当中已经存在一个该Activity的实例了，那么系统就不会再创建一次它的实例，而是会直接调用它的onNewIntent()方法。声明成这种启动模式的Activity，在同一个任务当中只会存在一个实例。注意这里我们所说的启动Activity，都指的是启动其它应用程序中的Activity，因为&quot;singleTask&quot;模式在默认情况下只有启动其它程序的Activity才会创建一个新的任务，启动自己程序中的Activity还是会使用相同的任务，具体原因会在下面 处理<a href="./#处理affinity">affinity</a> 部分进行解释。</p><h4 id="quot-singleInstance-quot"><a href="#quot-singleInstance-quot" class="headerlink" title="&quot;singleInstance&quot;"></a>&quot;singleInstance&quot;</h4><p>这种启动模式和&quot;singleTask&quot;有点相似，只不过系统不会向声明成&quot;singleInstance&quot;的Activity所在的任务当中再添加其它Activity。也就是说，这种Activity所在的任务中始终只会有一个Activity，通过这个Activity再打开的其它Activity也会被放入到别的任务当中。<br>再举一个例子，Android系统内置的浏览器程序声明自己浏览网页的Activity始终应该在一个独立的任务当中打开，也就是通过在<activity>元素中设置&quot;singleTask&quot;启动模式来实现的。这意味着，当你的程序准备去打开Android内置浏览器的时候，新打开的Activity并不会放入到你当前的任务中，而是会启动一个新的任务。而如果浏览器程序在后台已经存在一个任务了，则会把这个任务切换到前台。<br>其实不管是Activity在一个新任务当中启动，还是在当前任务中启动，返回键永远都会把我们带回到之前的一个Activity中的。但是有一种情况是比较特殊的，就是如果Activity指定了启动模式是&quot;singleTask&quot;，并且启动的是另外一个应用程序中的Activity，这个时候当发现该Activity正好处于一个后台任务当中的话，就会直接将这整个后台任务一起切换到前台。此时按下返回键会优先将目前最前台的任务(刚刚从后台切换到最前台)进行回退，下图比较形象地展示了这种情况：<br><img src="/demo/photo/activity/20141229122743077.png" alt=""><br>更多关于如何在manifest文件中使用启动模式的讲解，可以去参考<a href="http://blog.csdn.net/guolin_blog/article/details/26365913" target="_blank" rel="noopener">《第一行代码——Android》</a>第二章部分的内容。</p><h3 id="使用Intent-flags"><a href="#使用Intent-flags" class="headerlink" title="使用Intent flags"></a>使用Intent flags</h3><p>除了使用manifest文件之外，你也可以在调用startActivity()方法的时候，为Intent加入一个flag来改变Activity与任务的关联方式，下面我们来一一讲解一下每种flag的作用：</p><pre><code class="java">Intent intent = new Intent(ThirdActivity.this,FirstActivity.class);intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);startActivity(intent);</code></pre><h4 id="FLAG-ACTIVITY-NO-HISTORY"><a href="#FLAG-ACTIVITY-NO-HISTORY" class="headerlink" title="FLAG_ACTIVITY_NO_HISTORY"></a>FLAG_ACTIVITY_NO_HISTORY</h4><p>例如现在栈情况为：A B C。C通过intent跳转到D，这个intent添加FLAG_ACTIVITY_NO_HISTORY标志，则此时界面显示D的内容，但是它并不会压入栈中。如果按返回键，返回到C，栈的情况还是：A B C。如果此时D中又跳转到E，栈的情况变为：A B C E，此时按返回键会回到C，因为D根本就没有被压入栈中。简而言之，<strong>跳转到的activity不压在栈中</strong>。</p><h4 id="FLAG-ACTIVITY-NEW-TASK"><a href="#FLAG-ACTIVITY-NEW-TASK" class="headerlink" title="FLAG_ACTIVITY_NEW_TASK"></a>FLAG_ACTIVITY_NEW_TASK</h4><p>设置了这个flag，新启动Activity就会被放置到一个新的任务当中(与&quot;singleTask&quot;有点类似，但不完全一样)，当然这里讨论的仍然还是启动其它程序中的Activity。这个flag的作用通常是模拟一种Launcher的行为，即列出一推可以启动的东西，但启动的每一个Activity都是在运行在自己独立的任务当中的。</p><p><span style="font-size:13px"><strong>FLAG_ACTIVITY_NEW_TASK：</strong>例如现在栈1的情况是：A B C。C通过intent跳转到D，并且这个intent添加了FLAG_ACTIVITY_NEW_TASK标记，如果D这个Activity在Manifest.xml中的声明中添加了Task affinity，系统首先会查找有没有和D的Task affinity相同的task栈存在，如果有存在，将D压入那个栈，如果不存在则会新建一个D的affinity的栈将其压入。如果D的Taskaffinity默认没有设置，则会把其压入栈1，变成：A B C D，这样就和不加FLAG_ACTIVITY_NEW_TASK标记效果是一样的了。注意如果试图从非activity的非正常途径启动一个activity，比如从一个service中启动一个activity，则intent必须要添加FLAG_ACTIVITY_NEW_TASK标记（<span style="color:#ff0000">activity要存在于activity的栈中，而非activity的途径启动activity时必然不存在一个activity的栈，所以要新起一个栈装入启动的activity</span>）。<span style="color:#ff0000">简而言之，跳转到的activity根据情况，可能压在一个新建的栈中。</span></span></p><h4 id="FLAG-ACTIVITY-SINGLE-TOP"><a href="#FLAG-ACTIVITY-SINGLE-TOP" class="headerlink" title="FLAG_ACTIVITY_SINGLE_TOP"></a>FLAG_ACTIVITY_SINGLE_TOP</h4><p>设置了这个flag，如果要启动的Activity在当前任务中已经存在了，并且还处于栈顶的位置，那么就不会再次创建这个Activity的实例，而是直接调用它的onNewIntent()方法。这种flag和在launchMode中指定<strong>&quot;singleTop&quot;模式所实现的效果是一样的</strong>。</p><h4 id="FLAG-ACTIVITY-CLEAR-TOP"><a href="#FLAG-ACTIVITY-CLEAR-TOP" class="headerlink" title="FLAG_ACTIVITY_CLEAR_TOP"></a>FLAG_ACTIVITY_CLEAR_TOP</h4><p>设置了这个flag，如果要启动的Activity在当前任务中已经存在了，就不会再次创建这个Activity的实例，而是会把这个Activity之上的所有Activity全部关闭掉。比如说，一个任务当中有A、B、C、D四个Activity，然后D调用了startActivity()方法来启动B，并将flag指定成FLAG_ACTIVITY_CLEAR_TOP，那么此时C和D就会被关闭掉，现在返回栈中就只剩下A和B了。<br>那么此时Activity B会接收到这个启动它的Intent，你可以决定是让Activity B调用onNewIntent()方法(不会创建新的实例)，还是将Activity B销毁掉并重新创建实例。如果Activity B没有在manifest中指定任何启动模式(也就是&quot;standard&quot;模式)，并且Intent中也没有加入一个FLAG_ACTIVITY_SINGLE_TOP flag，那么此时Activity B就会销毁掉，然后重新创建实例。而如果Activity B在manifest中指定了任何一种启动模式，或者是在Intent中加入了一个FLAG_ACTIVITY_SINGLE_TOP flag，那么就会调用Activity B的onNewIntent()方法。</p><p><span style="font-size:13px">例如现在的栈情况为：A B C D 。D此时通过intent跳转到B，如果这个intent添加FLAG_ACTIVITY_CLEAR_TOP标记，则栈情况变为：A B。如果没有添加这个标记，则栈情况将会变成：A B C D B。也就是说，如果添加了FLAG_ACTIVITY_CLEAR_TOP标记，并且目标Activity在栈中已经存在，则将会把位于该目标activity之上的activity从栈中弹出销毁。这跟上面把B的Launch mode设置成<code>singleTask</code>类似。<span style="color:#ff0000">简而言之，跳转到的activity若已在栈中存在，则将其上的activity都销掉。</span></span></p><p><strong>FLAG_ACTIVITY_CLEAR_TOP和FLAG_ACTIVITY_NEW_TASK结合在一起使用也会有比较好的效果，比如可以将一个后台运行的任务切换到前台，并把目标Activity之上的其它Activity全部关闭掉。这个功能在某些情况下非常有用，比如说从通知栏启动Activity的时候。</strong></p><h2 id="处理affinity"><a href="#处理affinity" class="headerlink" title="处理affinity"></a>处理affinity</h2><p>affinity可以用于指定一个Activity更加愿意依附于哪一个任务，在默认情况下，同一个应用程序中的所有Activity都具有相同的affinity，所以，这些Activity都更加倾向于运行在相同的任务当中。当然了，你也可以去改变每个Activity的affinity值，通过<activity>元素的taskAffinity属性就可以实现了。<br>taskAffinity属性接收一个字符串参数，你可以指定成任意的值(经我测试<strong>字符串中至少要包含一个.</strong>)，但必须不能和应用程序的包名相同，因为系统会使用包名来作为默认的affinity值。<br>affinity主要有以下两种应用场景：</p><ul><li>当调用startActivity()方法来启动一个Activity时，默认是将它放入到当前的任务当中。但是，如果在Intent中加入了一个FLAG_ACTIVITY_NEW_TASK flag的话(或者该Activity在manifest文件中声明的启动模式是&quot;singleTask&quot;)，系统就会尝试为这个Activity单独创建一个任务。但是规则并不是只有这么简单，系统会去检测要启动的这个Activity的affinity和当前任务的affinity是否相同，如果相同的话就会把它放入到现有任务当中，如果不同则会去创建一个新的任务。而同一个程序中所有Activity的affinity默认都是相同的，这也是前面为什么说，同一个应用程序中即使声明成&quot;singleTask&quot;，也不会为这个Activity再去创建一个新的任务了。</li><li>当把Activity的<strong>allowTaskReparenting</strong>属性设置成true时，Activity 就拥有了一个转移所在任务的能力。具体点来说，就是一个Activity现在是处于某个任务当中的，但是它与另外一个任务具有相同的affinity值，那么当另外这个任务切换到前台的时候，该Activity就可以转移到现在的这个任务当中。<br>那还是举一个形象点的例子吧，比如有一个天气预报程序，它有一个Activity是专门用于显示天气信息的，这个Activity和该天气预报程序的所有其它Activity具体相同的affinity值，并且还将allowTaskReparenting属性设置成true了。这个时候，你自己的应用程序通过Intent去启动了这个用于显示天气信息的Activity，那么此时这个Activity应该是和你的应用程序是在同一个任务当中的。但是当把天气预报程序切换到前台的时候，这个Activity又会被转移到天气预报程序的任务当中，并显示出来，因为它们拥有相同的affinity值，并且将allowTaskReparenting属性设置成了true。</li></ul><h2 id="清空返回栈"><a href="#清空返回栈" class="headerlink" title="清空返回栈"></a>清空返回栈</h2><p>如何用户将任务切换到后台之后过了很长一段时间，系统会将这个任务中除了最底层的那个Activity之外的其它所有Activity全部清除掉。当用户重新回到这个任务的时候，最底层的那个Activity将得到恢复。这个是系统默认的行为，因为既然过了这么长的一段时间，用户很有可能早就忘记了当时正在做什么，那么重新回到这个任务的时候，基本上应该是要去做点新的事情了。<br>当然，既然说是默认的行为，那就说明我们肯定是有办法来改变的，在<activity>元素中设置以下几种属性就可以改变系统这一默认行为：</p><h3 id="alwaysRetainTaskState"><a href="#alwaysRetainTaskState" class="headerlink" title="alwaysRetainTaskState"></a>alwaysRetainTaskState</h3><p>如果将最底层的那个Activity的这个属性设置为true，那么上面所描述的默认行为就将不会发生，任务中所有的Activity即使过了很长一段时间之后仍然会被继续保留。</p><h3 id="clearTaskOnLaunch"><a href="#clearTaskOnLaunch" class="headerlink" title="clearTaskOnLaunch"></a>clearTaskOnLaunch</h3><p>如果将最底层的那个Activity的这个属性设置为true，那么只要用户离开了当前任务，再次返回的时候就会将最底层Activity之上的所有其它Activity全部清除掉。简单来讲，就是一种和alwaysRetainTaskState完全相反的工作模式，它保证每次返回任务的时候都会是一种初始化状态，即使用户仅仅离开了很短的一段时间。</p><h3 id="finishOnTaskLaunch"><a href="#finishOnTaskLaunch" class="headerlink" title="finishOnTaskLaunch"></a>finishOnTaskLaunch</h3><p>这个属性和clearTaskOnLaunch是比较类似的，不过它不是作用于整个任务上的，而是作用于单个Activity上。如果某个Activity将这个属性设置成true，那么用户一旦离开了当前任务，再次返回时这个Activity就会被清除掉。</p><p><strong>第一时间获得博客更新提醒，以及更多技术信息分享，欢迎关注我的微信公众号，扫一扫下方二维码或搜索微信号guolin_blog，即可关注。</strong><br> <font color="red"><b>强烈推荐</b></font><br><img src="/demo/photo/activity/20150201224858245.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《第一行代码》读书笔记-第二章04 活动的启动模式</title>
      <link href="/2016/05/14/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A004-%E6%B4%BB%E5%8A%A8%E7%9A%84%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>/2016/05/14/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A004-%E6%B4%BB%E5%8A%A8%E7%9A%84%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="task"><a href="#task" class="headerlink" title="task"></a>task</h3><p><code>task</code>是在程序运行时，只针对activity的概念。说白了，<strong>task是一组相互关联的activity的集合</strong>，它是存在于framework层的一个概念，控制界面的跳转和返回。这个task存在于一个称为<code>back stack</code>的数据结构中，也就是说，framework是以栈的形式管理用户开启的activity。这个栈的基本行为是，当用户在多个activity之间跳转时，执行压栈操作，当用户按返回键时，执行出栈操作。</p><a id="more"></a><p>举例来说，如果应用程序中存在A,B,C三个activity，当用户在Launcher或Home Screen点击应用程序图标时，启动主Activity A，接着A开启B，B开启C，这时栈中有三个Activity，并且这三个Activity默认在同一个任务（task）中，当用户按返回时，弹出C，栈中只剩A和B，再按返回键，弹出B，栈中只剩A，再继续按返回键，弹出A，任务被移除。</p><p><strong>task是可以跨应用的</strong>，这正是task存在的一个重要原因。有的Activity，虽然不在同一个app中，但为了保持用户操作的连贯性，把他们放在同一个任务中。例如，在我们的应用中的一个Activity A中点击发送邮件，会启动邮件程序的一个Activity B来发送邮件，这两个activity是存在于不同app中的，但是被系统放在一个任务中，这样当发送完邮件后，用户按back键返回，可以返回到原来的Activity A中，这样就确保了用户体验。</p><h3 id="process"><a href="#process" class="headerlink" title="process"></a>process</h3><p>process一般翻译成进程，进程是操作系统内核中的一个概念，表示直接受内核调度的执行单位。在应用程序的角度看，我们用java编写的应用程序，运行在dalvik虚拟机中，可以认为一个运行中的dalvik虚拟机实例占有一个进程，所以，在默认情况下，一个应用程序的所有组件运行在同一个进程中。但是这种情况也有例外，即，应用程序中的不同组件可以运行在不同的进程中。只需要在manifest中用process属性指定组件所运行的进程的名字。</p><pre><code class="xml">&lt;activity android:name=&quot;.MyActivity&quot; android:label=&quot;@string/app_nam&quot;    android:process=&quot;:remote&quot;&gt;&lt;/activity&gt;</code></pre><p>这样的话这个activity会运行在一个独立的进程中。</p><h3 id="Activity四种启动模式详解"><a href="#Activity四种启动模式详解" class="headerlink" title="Activity四种启动模式详解"></a>Activity四种启动模式详解</h3><p>启动模式一共有四种，分别是<code>standard</code>、<code>singleTop</code>、<code>singleTask</code> 和<code>singleInstance</code> ， 可以在<code>AndroidManifest.xml</code> 中通过给<code>&lt;activity&gt;</code> 标签指定<code>android:launchMode</code> 属性来选择启动模式。</p><h4 id="standard"><a href="#standard" class="headerlink" title="standard"></a>standard</h4><p><code>standard</code> 是活动<strong>默认的启动模式</strong>。对于使用<code>standard</code> 模式的活动，系统不会在乎这个活动是否已经在返回栈中存在，每次启动都会创建该活动的一个新的实例。如：在A Activity中启动A，会新建一个A 实例，在返回栈中存在两个A。</p><h4 id="singleTop"><a href="#singleTop" class="headerlink" title="singleTop"></a>singleTop</h4><p>在启动活动时如果发现返回栈的栈顶已经是该活动，则认为可以直接使用它，不会再创建新的活动实例。并且会调用该实例的 onNewIntent()方法将Intent对象传递到这个实例中。</p><pre><code class="java">@Overrideprotected void onNewIntent(Intent intent) {    super.onNewIntent(intent);    Toast.makeText(FirstActivity.this, &quot;调用了onNewIntent()方法&quot; + intent.getStringExtra(&quot;name&quot;), Toast.LENGTH_SHORT).show();}</code></pre><p>如果以singleTop模式启动的activity的一个实例已经存在与任务桟中，<strong>但是不在桟顶</strong>，那么它的行为和standard模式相同，也会创建多个实例。</p><h4 id="singleTask"><a href="#singleTask" class="headerlink" title="singleTask"></a>singleTask</h4><p>注意：此处讨论的均是以<code>startActivity(intent)</code>的方式启动意图，如果以<code>startActivityForResult(intent, 0)</code>的方式启动，在<code>AndroidManifest.xml</code>配置<code>taskAffinity</code>属性无效，不会开启一个新的<code>task</code>。测试代码同下，日志打印出相同的ID。</p><p>谷歌的官方文档上称，如果一个activity的启动模式为<code>singleTask</code>，那么系统总会在一个新任务的最底部（root）启动这个activity，并且被这个activity启动的其他activity会和该activity同时存在于这个新任务中。如果系统中已经存在这样的一个activity则会重用这个实例，并且调用他的<code>onNewIntent()</code>方法。并把在这<br>个活动之上的所有活动统统出栈，如果没有发现就会创建一个新的活动实例。即，这样的一个activity在系统中只会存在一个实例。</p><p>其实官方文档中的这种说法并不准确，启动模式为singleTask的activity并不会总是开启一个新的任务。详情请参考 <a href="http://http//blog.csdn.net/luoshengyang/article/details/6714543" target="_blank" rel="noopener">解开Android应用程序组件Activity的&quot;singleTask&quot;之谜</a>。</p><h5 id="验证启动singleTask模式的activity时是否会创建新的任务"><a href="#验证启动singleTask模式的activity时是否会创建新的任务" class="headerlink" title="验证启动singleTask模式的activity时是否会创建新的任务"></a>验证启动singleTask模式的activity时是否会创建新的任务</h5><p>转自：<a href="http://blog.csdn.net/zhangjg_blog/article/details/10923643" target="_blank" rel="noopener">Android中Activity四种启动模式和taskAffinity属性详解</a><br>以下为验证示例AndroidTaskTest。这个实例中有三个Activity，分别为：MainActivity，SecondActivity和ThirdActivity。以下为这个示例的manifest文件。</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    package=&quot;com.jg.zhang.androidtasktest&quot;    android:versionCode=&quot;1&quot;    android:versionName=&quot;1.0&quot; &gt;    &lt;uses-sdk android:minSdkVersion=&quot;10&quot; android:targetSdkVersion=&quot;17&quot; /&gt;    &lt;application android:icon=&quot;@drawable/ic_launcher&quot; android:label=&quot;@string/app_name&quot;&gt;        &lt;activity  android:label=&quot;@string/app_name&quot;            android:name=&quot;com.jg.zhang.androidtasktest.MainActivity&quot;&gt;            &lt;intent-filter&gt;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;            &lt;/intent-filter&gt;        &lt;/activity&gt;        &lt;!--android:taskAffinity=&quot;com.jg.zhang.androidtasktest.second&quot;            android:alwaysRetainTaskState=&quot;true&quot;            android:allowBackup=&quot;true&quot; --&gt;         &lt;activity android:name=&quot;com.jg.zhang.androidtasktest.SecondActivity&quot;             android:launchMode=&quot;singleTask&quot;&gt;            &lt;intent-filter &gt;                &lt;action android:name=&quot;com.jg.zhang.androidtasktest.SecondActivity&quot;/&gt;                &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;            &lt;/intent-filter&gt;        &lt;/activity&gt;         &lt;activity android:name=&quot;com.jg.zhang.androidtasktest.ThirdActivity&quot;            android:label=&quot;@string/app_name&quot; &gt;        &lt;/activity&gt;    &lt;/application&gt;&lt;/manifest&gt;</code></pre><p>由此可见，MainActivity和ThirdActivity都是标准的启动模式，而<strong>SecondActivity的启动模式为singleTask</strong>。</p><p>三个Activity的界面，很简单，在MainActivity中点击按钮启动SecondActivity，在SecondActivity中点击按钮启动ThirdActivity。</p><p>以下为这三个activity的主要代码：</p><p><strong>MainActivity</strong></p><pre><code class="java">public class MainActivity extends Activity {    private static final String ACTIVITY_NAME = &quot;MainActivity&quot;;    private static final String LOG_TAG = &quot;xxxx&quot;;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        findViewById(R.id.button1).setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View v) {                Intent intent = new Intent(MainActivity.this, SecondActivity.class);                startActivity(intent);            }        });        int taskId = getTaskId();        Log.i(LOG_TAG, ACTIVITY_NAME +&quot;所在的任务的id为: &quot; +  taskId);    }</code></pre><p><strong>SecondActivity</strong></p><pre><code class="java">public class SecondActivity extends Activity {    private static final String ACTIVITY_NAME = &quot;SecondActivity&quot;;    private static final String LOG_TAG = &quot;xxxx&quot;;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_second);        findViewById(R.id.button2).setOnClickListener(new OnClickListener() {            @Override            public void onClick(View v) {                    Intent intent = new Intent(SecondActivity.this, ThirdActivity.class);                    startActivity(intent);            }        });        int taskId = getTaskId();        Log.i(LOG_TAG, ACTIVITY_NAME +&quot;所在的任务的id为: &quot; +  taskId);    }</code></pre><p><strong>ThirdActivity</strong></p><pre><code class="java">public class ThirdActivity extends Activity {    private static final String ACTIVITY_NAME = &quot;ThirdActivity&quot;;    private static final String LOG_TAG = &quot;xxxx&quot;;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_third);        int taskId = getTaskId();        Log.i(LOG_TAG, ACTIVITY_NAME +&quot;所在的任务的id为: &quot; +  taskId);    }</code></pre><p>以上三个activity只列出了onCreate()方法中的内容，实现的逻辑为在MainActivity中点击按钮启动SecondActivity，在SecondActivity中点击按钮启动ThirdActivity。并且在onCreate方法中会以log的形式打印出当前activity所属的任务（Task）的Id。</p><p>现在执行以下操作，运行该示例，并且点击MainActivity界面中的按钮，开启SecondActivity。在该示例中SecondActivity的启动模式为singleTask。按照官方文档的说法，SecondActivity会在一个新的任务中开启。但是查看打印出的log，<strong>发现MainActivity和SecondActivity所在的任务的Id相同</strong>。</p><p>在命令行中执行以下命令 <code>adb shell dumpsys activity</code> ， 有以下输出：</p><pre><code class="shell">TaskRecord{412ded08 #8 A com.jg.zhang.androidtasktest}    Run #2: ActivityRecord{412c91e8 com.jg.zhang.androidtasktest/.SecondActivity}    Run #1: ActivityRecord{412c08a0 com.jg.zhang.androidtasktest/.MainActivity}</code></pre><p>所以，和官方文档表述的不同，MainActivity和SecondActivity是<strong>启动在同一个任务中的</strong>。其实，把启动模式设置为singleTask，framework在启动该activity时只会把它标示为可在一个新任务中启动，至于是否在一个新任务中启动，还要受其他条件的限制。现在在SecondActivity增加一个<code>taskAffinity</code>属性，如下所示：</p><pre><code class="xml">&lt;activity android:name=&quot;com.jg.zhang.androidtasktest.SecondActivity&quot;    android:launchMode=&quot;singleTask&quot;    android:taskAffinity=&quot;com.jg.zhang.androidtasktest.second&quot;&gt;   &lt;intent-filter &gt;       &lt;action android:name=&quot;com.jg.zhang.androidtasktest.SecondActivity&quot;/&gt;       &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;   &lt;/intent-filter&gt;&lt;/activity&gt;</code></pre><p>重新运行该示例，执行相同的操作，即：点击MainActivity界面中的按钮，开启SecondActivity，并且点击SecondActivity中的按钮，启动ThirdActivity，log中输出的内容为：</p><pre><code>xxxx    MainActivity所在的任务id为：5xxxx    SecondActivity所在的任务id为：6xxxx    ThirdActivity所在的任务id为：6</code></pre><p>在命令行中执行<code>adb shell dumpsys activity</code>命令，有以下输出：</p><pre><code>TaskRecord{411e6a88 #6 A com.jg.zhang.androidtasktest.second}    Run #3: ActivityRecord{411c8ea0 com.jg.zhang.androidtasktest/.ThirdActivity}    Run #2: ActivityRecord{412bc870 com.jg.zhang.androidtasktest/.SecondActivity}TaskRecord{412ece18 #5 A com.jg.zhang.androidtasktest}    Run #1: ActivityRecord{412924c0 com.jg.zhang.androidtasktest/.MainActivity}</code></pre><p><strong>由此可见，MainActivity和SecondActivity运行在不同的任务中了，并且被SecondActivity启动的ThirdActivity和SecondActivity运行在同一个任务中。</strong></p><h5 id="taskAffinity"><a href="#taskAffinity" class="headerlink" title="taskAffinity"></a>taskAffinity</h5><p>在这里便引出了manifest文件中<activity>的一个重要属性，<strong>taskAffinity</strong>。在官方文档中可以得到关于taskAffinity的以下信息</p><ol><li><code>taskAffinity</code>表示当前activity具有亲和力的一个任务，大致可以这样理解，这个 taskAffinity表示一个任务，这个任务就是当前activity所在的任务。</li><li>在概念上，具设置了相同<code>taskAffinity</code>属性的activity，属于同一个任务。</li><li>一个任务的affinity决定于这个任务的根activity（root activity）的taskAffinity。(如：上面，被SecondActivity启动的ThirdActivity和SecondActivity运行在同一个任务中)</li><li>这个属性决定两件事：①当activity被re-parent时，它可以被re-paren哪个任务中；②当activity以FLAG_ACTIVITY_NEW_TASK标志启动时，它会被启动到哪个任务中。</li><li>默认情况下，一个应用中的所有activity具有相同的taskAffinity，即应用程序的包名。我们可以通过设置不同的taskAffinity属性给应用中的activity分组，也可以把不同的       应用中的activity的taskAffinity设置成相同的值。</li><li>为一个activity的taskAffinity设置一个空字符串，表明这个activity不属于任何task。</li></ol><p>在MainActivity启动SecondActivity时，发现启动模式为<code>singleTask</code>，会设定他的<a href="http://blog.csdn.net/berber78/article/details/7278408" target="_blank" rel="noopener">启动标志</a>为<code>FLAG_ACTIVITY_NEW_TASK</code></p><p>其实framework中对任务和activity的调度是很复杂的，尤其是把启动模式设为singleTask或者以FLAG_ACTIVITY_NEW_TASK标志启动时。所以，在使用<code>singleTask</code>和<code>FLAG_ACTIVITY_NEW_TASK</code>时，<strong>要仔细测试应用程序</strong>。这也是官方文档上的建议，make sure to test the usability of the activity during launch。</p><h5 id="不同的应用中的activity的taskAffinity设置成相同的值"><a href="#不同的应用中的activity的taskAffinity设置成相同的值" class="headerlink" title="不同的应用中的activity的taskAffinity设置成相同的值"></a>不同的应用中的activity的taskAffinity设置成相同的值</h5><p>可以把不同的应用中的activity的<code>taskAffinity</code>设置成相同的值，这样的话这两个activity虽然不在同一应用中，却会在运行时分配到同一任务中</p><p>这样如果同时开启两个应用，应用中有的Activity设置相同的<code>taskAffinity</code>。启动一个应用跳转到该Activity，按Home键退出，再启动另一个应用跳转到相应的Activity，点击Back键，将会退回到上一个应用中去。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>设置了&quot;singleTask&quot;启动模式的Activity的特点：</p><ol><li><p>设置了<code>&quot;singleTask&quot;</code>启动模式的Activity，它在启动的时候，会先在系统中查找属性值<code>affinity</code>等于它的属性值<code>taskAffinity</code>的任务存在；如果存在这样的任务，它就会在这个任务中启动，否则就会在新任务中启动。因此，如果我们想要设置了<code>&quot;singleTask&quot;</code>启动模式的Activity在新的任务中启动，就要为它设置一个独立的<code>taskAffinity</code>属性值。</p></li><li><p>如果设置了<code>&quot;singleTask&quot;</code>启动模式的Activity不是在新的任务中启动时，它会在已有的任务中查看是否已经存在相应的Activity实例，如果存在，就会把位于这个Activity实例上面的Activity全部结束掉，即最终这个Activity实例会位于任务的堆栈顶端中。</p></li></ol><h4 id="singleInstance"><a href="#singleInstance" class="headerlink" title="singleInstance"></a>singleInstance</h4><p><strong>总是在新的任务中开启，并且这个新的任务中有且只有这一个实例</strong>，也就是说被该实例启动的其他activity会自动运行于另一个任务中。当再次启动该activity的实例时，会重用已存在的任务和实例。并且会调用这个实例的<code>onNewIntent()</code>方法，将Intent实例传递到该实例中。和singleTask相同，同一时刻在系统中只会存在一个这样的Activity实例。</p><p>想象以下场景，假设我们的程序中有一个活动是允许其他程序调用的，如果我们想实现其他程序和我们的程序可以共享这个活动的实例，应该如何实现呢？使用前面三种启动模式肯定是做不到的，因为每个应用程序都会有自己的返回栈，同一个活动在不同的返回栈中入栈时必然是创建了新的实例。而使用singleInstance 模式就可以解决这个问题，在这种模式下会有一个单独的返回栈来管理这个活动，不管是哪个应用程序来访问这个活动，都共用的同一个返回栈，也就解决了共享活动实例的问题。</p><p>修改上面的例子，</p><pre><code class="xml">android:name=&quot;.SecondActivity&quot;android:launchMode=&quot;singleInstance&quot;</code></pre><p>在 MainActivity 界面点击按钮进入到 SecondActivity ， 然后在SecondActivity 界面点击按钮进入到 ThirdActivity 。</p><pre><code>xxxx    MainActivity所在的任务id为：10xxxx    SecondActivity所在的任务id为：11xxxx    ThirdActivity所在的任务id为：10</code></pre><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a href="http://blog.csdn.net/zhangjg_blog/article/details/10923643" target="_blank" rel="noopener">Android中Activity四种启动模式和taskAffinity属性详解</a></li><li><a href="http://blog.csdn.net/luoshengyang/article/details/6714543" target="_blank" rel="noopener">解开Android应用程序组件Activity的&quot;singleTask&quot;之谜</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 第一行代码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Parcelable接口的使用</title>
      <link href="/2016/05/14/Parcelable%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2016/05/14/Parcelable%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>转自：<a href="http://www.cnblogs.com/hpboy/archive/2012/07/12/2587797.html" target="_blank" rel="noopener">Kenny技术博客</a></p><h3 id="什么是Parcelable-？"><a href="#什么是Parcelable-？" class="headerlink" title="什么是Parcelable ？"></a>什么是Parcelable ？</h3><p>Parcelable是一个接口、用来实现序列化。与此类似的还有一个接口<code>Serializable</code>，这是JavaSE本身支持的，而<code>Parcelable</code>是Android特有的。二者比较：</p><ol><li><code>Parcelable</code>使用起来稍复杂点，而后者使用起来非常简单。下面例子中会看到。</li><li><code>Parcelabl</code>e效率比<code>Serializable</code>高，支持Intent数据传递，也支持进程间通信（IPC）。</li><li><code>Parcelable</code>使用时要用到一个<code>Parcel</code>，可以简单将其看为一个容器，序列化时将数据写入<code>Parcel</code>，反序列化时从中取出。<a id="more"></a></li><li>在使用内存的时候，<code>Parcelable</code>比<code>Serializable</code>性能高，所以<strong>推荐使用Parcelable</strong>。<code>Serializable</code>在序列化的时候会产生大量的临时变量，从而引起频繁的GC。<code>Parcelable</code><strong>不能使用在要将数据存储在磁盘上的情况</strong>，因为<code>Parcelable</code>在外界有变化的情况下不能很好的保证数据的持续性。尽管<code>Serializable</code>效率低点，但此时还是建议使用<code>Serializable</code> 。</li></ol><h3 id="Parcelable-传递对象"><a href="#Parcelable-传递对象" class="headerlink" title="Parcelable 传递对象"></a>Parcelable 传递对象</h3><p>Android序列化对象主要有两种方法：</p><p>1.实现Serializable接口<a href="/2016/05/12/《第一行代码》读书笔记-第二章02-使用Intent在活动之间穿梭/#serializable方式">通过intent来传递对象-Serializable方式</a>;</p><p>2.实现<code>Parcelable</code>接口,<code>Parcelable</code>是Android特有的功能，效率比实现Serializable接口高，像用于Intent数据传递也都支持，而且还可以用在进程间通信(IPC)，除了基本类型外，只有实现了Parcelable接口的类才能被放入Parcel中。</p><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><pre><code class="java">package android.os;/** * Interface for classes whose instances can be written to * and restored from a {@link Parcel}.  Classes implementing the Parcelable * interface must also have a non-null static field called &lt;code&gt;CREATOR&lt;/code&gt; * of a type that implements the {@link Parcelable.Creator} interface. * * &lt;p&gt;A typical implementation of Parcelable is:&lt;/p&gt; * Parcelable的典型实现是: * &lt;pre&gt; * public class MyParcelable implements Parcelable { *     private int mData; * *     public int describeContents() { *         return 0; *     } * *     public void writeToParcel(Parcel out, int flags) { *         out.writeInt(mData); *     } * *     public static final Parcelable.Creator&lt;MyParcelable&gt;; CREATOR *             = new Parcelable.Creator&lt;MyParcelable&gt;;() { *         public MyParcelable createFromParcel(Parcel in) { *             return new MyParcelable(in); *         } * *         public MyParcelable[] newArray(int size) { *             return new MyParcelable[size]; *         } *     }; * *     private MyParcelable(Parcel in) { *         mData = in.readInt(); *     } * }&lt;/pre&gt; */public interface Parcelable {    /**     * Flag for use with {@link #writeToParcel}: the object being written     * is a return value, that is the result of a function such as     * &quot;&lt;code&gt;Parcelable someFunction()&lt;/code&gt;&quot;,     * &quot;&lt;code&gt;void someFunction(out Parcelable)&lt;/code&gt;&quot;, or     * &quot;&lt;code&gt;void someFunction(inout Parcelable)&lt;/code&gt;&quot;.  Some implementations     * may want to release resources at this point.     */    public static final int PARCELABLE_WRITE_RETURN_VALUE = 0x0001;    /**     * Bit masks for use with {@link #describeContents}: each bit represents a     * kind of object considered to have potential special significance when     * marshalled.     */    public static final int CONTENTS_FILE_DESCRIPTOR = 0x0001;    /**     * Describe the kinds of special objects contained in this Parcelable&#39;s     * marshalled representation.     * 内容描述接口，基本不用管,return 0;     * @return a bitmask indicating the set of special object types marshalled     * by the Parcelable.     */    public int describeContents();    /**     * Flatten this object in to a Parcel.     * //写入接口函数，打包     * @param dest The Parcel in which the object should be written.     * @param flags Additional flags about how the object should be written.     * May be 0 or {@link #PARCELABLE_WRITE_RETURN_VALUE}.     */    public void writeToParcel(Parcel dest, int flags);    /**     * Interface that must be implemented and provided as a public CREATOR     * field that generates instances of your Parcelable class from a Parcel.     */    //读取接口，目的是要从Parcel中构造一个实现了Parcelable的类的实例处理。    //因为实现类在这里还是不可知的，所以需要用到模板的方式，继承类名通过模板参数传入。    //为了能够实现模板参数的传入，这里定义Creator嵌入接口,内含两个接口函数分别返回单个和多个继承类实例。    public interface Creator&lt;T&gt; {        /**         * Create a new instance of the Parcelable class, instantiating it         * from the given Parcel whose data had previously been written by         * {@link Parcelable#writeToParcel Parcelable.writeToParcel()}.         *         * @param source The Parcel to read the object&#39;s data from.         * @return Returns a new instance of the Parcelable class.         */        public T createFromParcel(Parcel source);        /**         * Create a new array of the Parcelable class.         *         * @param size Size of the array.         * @return Returns an array of the Parcelable class, with every entry         * initialized to null.         */        public T[] newArray(int size);    }    /**     * Specialization of {@link Creator} that allows you to receive the     * ClassLoader the object is being created in.     */    public interface ClassLoaderCreator&lt;T&gt; extends Creator&lt;T&gt; {        /**         * Create a new instance of the Parcelable class, instantiating it         * from the given Parcel whose data had previously been written by         * {@link Parcelable#writeToParcel Parcelable.writeToParcel()} and         * using the given ClassLoader.         *         * @param source The Parcel to read the object&#39;s data from.         * @param loader The ClassLoader that this object is being created in.         * @return Returns a new instance of the Parcelable class.         */        public T createFromParcel(Parcel source, ClassLoader loader);    }}</code></pre><h3 id="怎么实现Parcelable接口？"><a href="#怎么实现Parcelable接口？" class="headerlink" title="怎么实现Parcelable接口？"></a>怎么实现Parcelable接口？</h3><p>从parcelable接口定义中，我们可以看到，实现parcelable接口，需要我们实现下面几个方法：</p><ol><li><p><code>describeContents</code>方法。内容接口描述，默认返回0就可以;</p></li><li><p><code>writeToParcel</code> 方法。该方法将类的数据写入外部提供的<code>Parcel</code>中.即打包需要传递的数据到<code>Parcel</code>容器保存，以便从<code>parcel</code>容器获取数据，该方法声明如下：<br><code>writeToParcel (Parcel dest, int flags)</code></p></li><li><p>静态的<code>Parcelable.Creator</code>接口，本接口有两个方法：<br><code>createFromParcel(Parcel in)</code>  从<code>Parcel</code>容器中读取传递数据值，封装成<code>Parcelable</code>对象返回逻辑层。<br><code>newArray(int size)</code> 创建一个类型为T，长度为size的数组，仅一句话<code>（return new T[size])</code>即可。方法是供外部类反序列化本类数组使用。</p></li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>1.封装数据，把实现parcelable接口的Person对象传递到TwoActivity里;</p><pre><code class="java">public class DemoActivity extends Activity {    /** Called when the activity is first created. */    @Override    public void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.main);        // 封装数据        Person p = new Person();        p.setId(1);        p.setName(&quot;xiaoming&quot;);        // 用Intent传递Person对象        Intent i = new Intent(this, TwoActivity.class);        i.putExtra(&quot;Person&quot;, p);        startActivity(i);    }}</code></pre><p>2.TwoActivity获取数据，从DemoActivity传递的Person对象给解析</p><pre><code class="java">public class TwoActivity extends Activity {    @Override    protected void onCreate(Bundle savedInstanceState) {        // TODO Auto-generated method stub        super.onCreate(savedInstanceState);        Person p = (Person)getIntent().getParcelableExtra(&quot;Person&quot;);        System.out.println(&quot;p_id&quot;+p.getId());        System.out.println(&quot;p_name&quot;+p.getName());    }}</code></pre><p>3.parcelable接口的实现</p><pre><code class="java">public class Person implements Parcelable{    // 成员变量    private int id;    private String name;    // 1.必须实现Parcelable.Creator接口,否则在获取Person数据的时候，会报错，如下：    // android.os.BadParcelableException:    // Parcelable protocol requires a Parcelable.Creator object    // called  CREATOR on class com.um.demo.Person    // 2.这个接口实现了从Percel容器读取Person数据，并返回Person对象给逻辑层使用    // 3.实现Parcelable.Creator接口对象名必须为CREATOR，不如同样会报错上面所提到的错；    // 4.在读取Parcel容器里的数据事，必须按成员变量声明的顺序读取数据，不然会出现获取数据出错    // 5.反序列化对象    public static final Parcelable.Creator&lt;Person&gt; CREATOR = new Creator(){        @Override        public Person createFromParcel(Parcel source) {            // TODO Auto-generated method stub            // 必须按成员变量声明的顺序读取数据，不然会出现获取数据出错            Person p = new Person();            p.setId(source.readInt());            p.setName(source.readString());            return p;        }        @Override        public Person[] newArray(int size) {            // TODO Auto-generated method stub            return new Person[size];        }    };    public int getId() {        return id;    }    public void setId(int id) {        this.id = id;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    @Override    public int describeContents() {        // TODO Auto-generated method stub        return 0;    }    @Override    public void writeToParcel(Parcel dest, int flags) {        // TODO Auto-generated method stub        // 1.必须按成员变量声明的顺序封装数据，不然会出现获取数据出错        // 2.序列化对象        dest.writeInt(id);        dest.writeString(name);    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《第一行代码》读书笔记-第二章03 活动的生命周期</title>
      <link href="/2016/05/12/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A003-%E6%B4%BB%E5%8A%A8%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2016/05/12/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A003-%E6%B4%BB%E5%8A%A8%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<p>Android 是使用任务（Task）来管理活动的，一个任务就是一组存放在栈里的活动的集合，这个栈也被称作<strong>返回栈</strong>（Back Stack）。栈是一种后进先出的数据结构，在默认情况下，每当我们启动了一个新的活动，它会在返回栈中入栈，并处于栈顶的位置。而每当我们按下Back 键或调用finish()方法去销毁一个活动时，处于栈顶的活动会出栈，这时前一个入栈的活动就会重新处于栈顶的位置。系统总是会显示处于栈顶的活动给用户。</p><a id="more"></a><h3 id="活动状态"><a href="#活动状态" class="headerlink" title="活动状态"></a>活动状态</h3><p>每个活动在其生命周期中最多可能会有四种状态。</p><ol><li>运行状态<br>当一个活动<strong>位于返回栈的栈顶</strong>时，这时活动就处于运行状态。系统最不愿意回收的就是处于运行状态的活动，因为这会带来非常差的用户体验。</li><li>暂停状态<br>当一个活动不再处于栈顶位置，但<strong>仍然可见时</strong>，这时活动就进入了暂停状态。你可能会觉得既然活动已经不在栈顶了，还怎么会可见呢？这是因为并不是每一个活动都会占满整个屏幕的，比如对话框形式的活动只会占用屏幕中间的部分区域，你很快就会在后面看到这种活动。处于暂停状态的活动仍然是完全存活着的，系统也不愿意去回收这种活动（因为它还是可见的，回收可见的东西都会在用户体验方面有不好的影响），只有在内存极低的情况下，系统才会去考虑回收这种活动。</li><li>停止状态<br>当一个活动不再处于栈顶位置，并且<strong>完全不可见</strong>的时候，就进入了停止状态。系统仍然会为这种活动保存相应的状态和成员变量，但是这并不是完全可靠的，当其他地方需要内存时，处于停止状态的活动有可能会被系统回收。</li><li>销毁状态<br>当一个活动<strong>从返回栈中移除</strong>后就变成了销毁状态。系统会最倾向于回收处于这种状态的活动，从而保证手机的内存充足。</li></ol><h3 id="活动的生存期"><a href="#活动的生存期" class="headerlink" title="活动的生存期"></a>活动的生存期</h3><p>Activity 类中定义了七个回调方法，覆盖了活动生命周期的每一个环节，下面我来一一介绍下这七个方法。</p><ol><li>onCreate()<br>这个方法你已经看到过很多次了，每个活动中我们都重写了这个方法，它会在<strong>活动第一次被创建的时候</strong>调用。你应该在这个方法中完成活动的初始化操作，比如说加载布局、绑定事件等。</li><li>onStart()<br>这个方法在<strong>活动由不可见变为可见的时候</strong>调用。</li><li>onResume()<br>这个方法在<strong>活动准备好和用户进行交互的时候</strong>调用。此时的活动<strong>一定位于返回栈的栈顶</strong>，并且处于运行状态。</li><li>onPause()<br>这个方法在<strong>系统准备去启动或者恢复另一个活动的时候</strong>调用。我们通常会在这个方法中将一些消耗CPU 的资源释放掉，以及保存一些关键数据，但这个方法的执行速度一定要快，不然会影响到新的栈顶活动的使用。</li><li>onStop()<br>这个方法在<strong>活动完全不可见的时候</strong>调用。它和onPause()方法的主要区别在于，如果启动的新活动是一个对话框式的活动，那么onPause()方法会得到执行，而onStop()方法并不会执行。</li><li>onDestroy()<br>这个方法在<strong>活动被销毁之前</strong>调用，之后活动的状态将变为销毁状态。</li><li>onRestart()<br>这个方法在<strong>活动由停止状态变为运行状态之前</strong>调用，也就是活动被重新启动了。</li></ol><p><img src="/demo/photo/Thefirstlineofcode/02-04.png" alt="活动的生存期"></p><h3 id="对话框式的活动"><a href="#对话框式的活动" class="headerlink" title="对话框式的活动"></a>对话框式的活动</h3><p>在AndroidManifest.xml 的<activity>标签中添加如下代码：</p><activity android:name=".SecondActivity" android:theme="@android:style/Theme.Dialog" ></activity>![对话框式的活动](/demo/photo/Thefirstlineofcode/02-05.png)<h3 id="活动被回收了怎么办"><a href="#活动被回收了怎么办" class="headerlink" title="活动被回收了怎么办"></a>活动被回收了怎么办</h3><p>假设，MainActivity 中有一个文本输入框，现在你输入了一段文字，然后启动NormalActivity，这时MainActivity 由于系统内存不足被回收掉，过了一会你又点击了Back 键回到MainActivity，你会发现刚刚输入的文字全部都没了，因为MainActivity 被重新创建了。</p><p>Activity 中还提供了一个<code>onSaveInstanceState()</code>回调方法，这个方法会保证<strong>一定在活动被回收之前调用</strong></p><pre><code class="java">@Overrideprotected void onSaveInstanceState(Bundle outState) {    super.onSaveInstanceState(outState);    String tempData = &quot;Something you just typed&quot;;    outState.putString(&quot;data_key&quot;, tempData);    Student student = new Student();    student.setAge(10);    student.setName(&quot;zhangzhang&quot;);    outState.putParcelable(&quot;student&quot;, student);    Person person = new Person.Builder(2).setName(&quot;person&quot;).build();    outState.putSerializable(&quot;person&quot;,person);}</code></pre><p><code>onSaveInstanceState()</code>方法会携带一个<code>Bundle</code> 类型的参数，<code>Bundle</code> 提供了一系列的方法用于保存数据，比如可以使用<code>putString()</code>方法保存字符串，使用<code>putInt()</code>方法保存整型数据，以此类推。同样可以使用<code>putParcelable()</code>，<code>putSerializable()</code>保存对象。每个保存方法需要传入两个参数，第一个参数是键，用于后面从<code>Bundle</code> 中取值，第二个参数是真正要保存的内容。</p><p>恢复数据，使用的<code>onCreate()</code>方法有一个<code>Bundle</code> 类型的参数。这个参数在一般情况下都是<code>null</code>，但是当活动被系统回收之前有通过<code>onSaveInstanceState()</code>方法来保存数据的话，这个参数就会带有之前所保存的全部数据，我们只需要再通过相应的取值方法将数据取出即可。<br>修改MainActivity 的onCreate()方法，如下所示：</p><pre><code class="java">@Overrideprotected void onCreate(Bundle savedInstanceState) {    super.onCreate(savedInstanceState);    Log.d(TAG, &quot;onCreate&quot;);    requestWindowFeature(Window.FEATURE_NO_TITLE);    setContentView(R.layout.activity_main);    if (savedInstanceState != null) {        String tempData = savedInstanceState.getString(&quot;data_key&quot;);        Person person = (Person) savedInstanceState.getSerializable(&quot;person&quot;);        Student student = savedInstanceState.getParcelable(&quot;student&quot;);    }    ……}</code></pre><p><code>Intent</code> 还可以结合<code>Bundle</code> 一起用于传递数据的，首先可以把需要传递的数据都保存在<code>Bundle</code> 对象中，然后再将<code>Bundle</code> 对象存放在<code>Intent</code> 里。到了目标活动之后先从<code>Intent</code> 中取出<code>Bundle</code>，再从<code>Bundle</code>中一一取出数据。</p><h3 id="Activity状态方法"><a href="#Activity状态方法" class="headerlink" title="Activity状态方法"></a>Activity状态方法</h3><ul><li><p><code>onWindowFocusChanged</code>方法：在Activity窗口获得或失去焦点时被调用，例如创建时首次呈现在用户面前；当前Activity被其他Activity覆盖；当前Activity转到其他Activity或按Home键回到主屏，自身退居后台；用户退出当前Activity。</p></li><li><p><code>onSaveInstanceState</code>：(1)在Activity被覆盖或退居后台之后，系统资源不足将其杀死，此方法会被调用，此方法会被调用，此方法携带一个Bundle类型的参数，利用bundle.putString(或者putInt，put~）向bundle写入数据，在onCreate(Bundle savedInstanceState),或者onRestoreInstanceState(Bundle savedInstanceState)，中获取数据，恢复之前活动被回收的状态；(2)在用户改变屏幕方向时，此方法会被调用；(3)在当前Activity跳转到其他Activity或者按Home键回到主屏，自身退居后台时，此方法会被调用。onSaveInstanceState的调用顺序是在onPause之前。</p></li><li><p><code>onRestoreInstanceState</code>：(1)在Activity被覆盖或退居后台之后，系统资源不足时被回收，然后用户又回到了此Activity；(2)在用户改变屏幕方向时，重建的过程中，此方法会被调用。我们可以重写此方法，以便可以恢复一些临时数据。onRestoreInstanceState的调用顺序是在onStart之后。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 第一行代码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《第一行代码》读书笔记-第二章02 使用Intent在活动之间穿梭</title>
      <link href="/2016/05/12/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A002-%E4%BD%BF%E7%94%A8Intent%E5%9C%A8%E6%B4%BB%E5%8A%A8%E4%B9%8B%E9%97%B4%E7%A9%BF%E6%A2%AD/"/>
      <url>/2016/05/12/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A002-%E4%BD%BF%E7%94%A8Intent%E5%9C%A8%E6%B4%BB%E5%8A%A8%E4%B9%8B%E9%97%B4%E7%A9%BF%E6%A2%AD/</url>
      
        <content type="html"><![CDATA[<p>主Activity如何跳转到其他Activity</p><h3 id="使用显式Intent"><a href="#使用显式Intent" class="headerlink" title="使用显式Intent"></a>使用显式Intent</h3><p>新建一个<code>second_layout.xml</code>布局文件，内容和<code>first_layout.xml</code>一样，Button的id为<code>button_2</code>。然后在新建活动SecondActivity，再到<code>Androidmanifest.xml</code>为<code>SecondActivity</code>进行注册<code>&lt;activity android:name=&quot;.SecondActivity&quot; &gt;</code></p><a id="more"></a><p><code>Intent</code> 是Android 程序中各组件之间进行交互的一种重要方式，它不仅可以指明当前组件想要执行的动作，还可以在不同组件之间传递数据。<strong>Intent 一般可被用于启动活动、启动服务、以及发送广播等场景</strong>。</p><p>Intent的一个构造函数为<code>Intent(Context packageContext, Class&lt;?&gt; cls)</code>。<br>第一个参数Context要求提供一个启动活动的上下文，第二个参数Class则是指定想要启动的目标活动，通过Activity类中提供的方法<code>startActivity()</code>方法，启动活动，它接收一个<code>Intent</code>参数。<br>修改FirstActivity中按钮点击事件。这样我们就可以成功启动SecondActivity这个活动了。</p><pre><code class="java">button.setOnClickListener(new View.OnClickListener() {    @Override    public void onClick(View v) {        Intent intent = new Intent(FirstActivity.this,SecondActivity.class);        startActivity(intent);    }});</code></pre><h3 id="使用隐式Intent"><a href="#使用隐式Intent" class="headerlink" title="使用隐式Intent"></a>使用隐式Intent</h3><p>隐式Intent并不明确指出想要启动那一个活动，而是指定了一系列更为抽象的action和category等信息。<br>修改AndroidManifest.xml</p><pre><code class="xml">&lt;activity android:name=&quot;.SecondActivity&quot;&gt;    &lt;intent-filter&gt;        &lt;action android:name=&quot;com.example.bin.helloworld.ACTION_START&quot;/&gt;        &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;    &lt;/intent-filter&gt;&lt;/activity&gt;</code></pre><p>在<code>&lt;action&gt;</code> 标签中我们指明了当前活动可以响应com.example.bin.helloworld.ACTION_START 这个action，而<code>&lt;category&gt;</code>标签则包含了一些附加信息，更精确地指明了当前的活动能够响应的Intent 中还可能带有的category。<strong>只有<action>和<category>中的内容同时能够匹配上Intent 中指定的action 和category 时，这个活动才能响应该Intent</strong>。<br>每个Intent 中只能指定一个action，但却能指定多个category。</p><p>修改FirstActivity 中按钮的点击事件，代码如下所示：</p><pre><code class="java">button.setOnClickListener(new View.OnClickListener() {    @Override    public void onClick(View v) {        Intent intent = new Intent(&quot;com.example.bin.helloworld.ACTION_START&quot;);        //intent.addCategory(&quot;android.intent.category.DEFAULT&quot;);        startActivity(intent);    }});</code></pre><p><code>android.intent.category.DEFAULT</code> 是一种默认的<code>category</code>， 在调用<br><code>startActivity()</code>方法的时候会自动将这个<code>category</code> 添加到<code>Intent</code> 中。<br>可以调用Intent 中的<code>addCategory()</code>方法来添加一个<code>category</code>。</p><h3 id="更多隐式Intent-的用法"><a href="#更多隐式Intent-的用法" class="headerlink" title="更多隐式Intent 的用法"></a>更多隐式Intent 的用法</h3><p>使用隐式Intent，我们不仅可以启动自己程序内的活动，还可以启动其他程序的活动，这使得Android 多个应用程序之间的功能共享成为了可能。<br>比如调用系统的浏览器打开网页。<br>修改FirstActivity 中按钮点击事件的代码，如下所示：</p><pre><code class="java">button.setOnClickListener(new View.OnClickListener() {    @Override    public void onClick(View v) {        Intent intent = new Intent(Intent.ACTION_VIEW);        intent.setData(Uri.parse(&quot;https://www.github.com/&quot;));        startActivity(intent);    }});</code></pre><p>这里我们首先指定了<code>Intent</code> 的<code>action</code> 是<code>Intent.ACTION_VIEW</code>，这是一个Android 系统内置的动作，其常量值为<code>android.intent.action.VIEW</code>。然后通过<code>Uri.parse()</code>方法，将一个网址字符串解析成一个<code>Uri</code> 对象，再调用<code>Intent</code> 的<code>setData()</code>方法将这个<code>Uri</code> 对象传递进去。</p><p>于此对应，还可以在<code>&lt;intent-filter&gt;</code>标签中再配置一个<code>&lt;data&gt;</code>标签，用于更精确地指定当前活动能够响应什么类型的数据。<strong><data>标签中主要可以配置一下内容</strong>。</p><ol><li>android:scheme<br>用于指定数据的协议部分，如上例的http部分。</li><li>android:host<br>用于指定数据的主机名部分，如上例中的<a href="http://www.github.com部分。" target="_blank" rel="noopener">www.github.com部分。</a></li><li>android:port<br>用于指定数据的端口部分，一般紧随在主机名之后。</li><li>android:path<br>用于指定主机名和端口之后的部分，如一段网址中跟在域名之后的内容。</li><li>android:mimeType<br>用于指定可以处理的数据类型，允许使用通配符的方式进行指定。</li></ol><p>除了http 协议外，我们还可以指定很多其他协议，比如<code>geo</code> 表示显示地理位置、<code>tel</code> 表示拨打电话。<strong>调用系统拨号界面</strong>。</p><pre><code class="java">button.setOnClickListener(new View.OnClickListener() {    @Override    public void onClick(View v) {        Intent intent = new Intent(Intent.ACTION_DIAL);        intent.setData(Uri.parse(&quot;tel:10086&quot;));        startActivity(intent);    }});</code></pre><h3 id="向下一个活动传递数据"><a href="#向下一个活动传递数据" class="headerlink" title="向下一个活动传递数据"></a>向下一个活动传递数据</h3><p>Intent 中提供了一系列<code>putExtra()</code>方法的重载，可以把我们想要传递的数据暂存在Intent 中，启动了另一个活动后，只需要把这些数据再从Intent 中取出就可以了。<br><code>putExtra()</code>方法接收<strong>两个参数</strong>，第一个参数是键，用于后面从Intent中取值，第二个参数才是真正要传递的数据。<br>FirstActivity中编写</p><pre><code class="java">button.setOnClickListener(new View.OnClickListener() {    @Override    public void onClick(View v) {        String data = &quot;我从FirstActivity而来&quot;;        Intent intent = new Intent(FirstActivity.this,SecondActivity.class);        intent.putExtra(&quot;extra_data&quot;,data);        startActivity(intent);    }});</code></pre><p>SecondActivity中编写</p><pre><code class="java">@Overrideprotected void onCreate(Bundle savedInstanceState) {    super.onCreate(savedInstanceState);    requestWindowFeature(Window.FEATURE_NO_TITLE);    setContentView(R.layout.second_layout);    //获得传递过来的意图    Intent intent = getIntent();    //获得意图中的信息，getStringExtra获得字符串类型，getBooleanExtra获得布尔类型。    String data = intent.getStringExtra(&quot;extra_data&quot;);    Button button = (Button)findViewById(R.id.button_2);    button.setText(data);}</code></pre><h3 id="通过intent来传递对象"><a href="#通过intent来传递对象" class="headerlink" title="通过intent来传递对象"></a>通过intent来传递对象</h3><h4 id="Serializable方式"><a href="#Serializable方式" class="headerlink" title="Serializable方式"></a>Serializable方式</h4><p>只需要让该对象implement Serializable接口，将整个对象序列化。 写一系列set，get方法来为对象的数据做赋值和读取，也可以用构建器 Builder。<br>比如，FirstActivity：</p><pre><code class="java">Person person=new Person();person.setName(&quot;TellH&quot;);Person.setAge(20);Intent intent=new Intent(FirstActivity.this,SecondActivity.class);intent.putExtra(&quot;person_data&quot;,person):///假如Person类已经实现了Serializable接口startActivity(intent);</code></pre><p>SecondActivity:</p><pre><code>Person person=(Person)getIntent().getSerializableExtra(&quot;person_data&quot;);</code></pre><h4 id="Parcelable方式"><a href="#Parcelable方式" class="headerlink" title="Parcelable方式"></a>Parcelable方式</h4><p>详见 <a href="/2016/05/14/Parcelable接口的使用/">Parcelable接口的使用</a></p><h3 id="返回数据给上一个活动"><a href="#返回数据给上一个活动" class="headerlink" title="返回数据给上一个活动"></a>返回数据给上一个活动</h3><p>Activity 中还有一个<code>startActivityForResult()</code>方法也是用于启动活动的，但这个方法期望在活动销毁的时候能够返回一个结果给上一个活动</p><pre><code class="java">button.setOnClickListener(new View.OnClickListener() {    @Override    public void onClick(View v) {        Intent intent = new Intent(FirstActivity.this,SecondActivity.class);//第一个参数还是Intent//第二个参数是请求码，用于在之后的回调中判断数据的来源        startActivityForResult(intent,1);    }});</code></pre><p>SecondActivity 中给按钮注册点击事件</p><pre><code class="java">button.setOnClickListener(new View.OnClickListener() {    @Override    public void onClick(View v) {        Intent intent = new Intent();        intent.putExtra(&quot;data_return&quot;,&quot;hello FirstActivity&quot;);//setResult()方法接收两个参数//第一个参数用于向上一个活动返回处理结果， 一般只使用RESULT_OK 或 RESULT_CANCELED(按Back键后返回)//第二个参数则是把带有数据的Intent 传递回去，        setResult(RESULT_OK,intent);        finish();    }});</code></pre><p>由于我们是使用<code>startActivityForResult()</code>方法来启动SecondActivity 的，在SecondActivity被销毁之后会回调上一个活动的<code>onActivityResult()</code>方法，因此我们需要在FirstActivity 中重写这个方法来得到返回的数据，如下所示：</p><pre><code class="java">@Overrideprotected void onActivityResult(int requestCode, int resultCode, Intent data) {//第一个参数requestCode，即我们在启动活动时传入的请求码。//第二个参数resultCode，即我们在返回数据时传入的处理结果。//第三个参数data，即携带着返回数据的Intent    switch (requestCode) {        case 1:            if (resultCode == RESULT_OK) {                String returnData = data.getStringExtra(&quot;data_return&quot;);                Toast.makeText(FirstActivity.this, &quot;返回的值：&quot; + returnData, Toast.LENGTH_SHORT).show();            }            break;        default:    }}</code></pre><p>如果用户点击Back键，也需要返回值，我们可以重写SecondActivity中的<code>onBackPressed()</code>方法。</p><pre><code class="java">@Overridepublic void onBackPressed() {    Intent intent = new Intent();    intent.putExtra(&quot;data_return&quot;, &quot;Hello FirstActivity&quot;);    setResult(RESULT_OK, intent);    finish();}</code></pre><p>也可以重写<code>onKeyDown()</code>方法</p><pre><code class="java">@Overridepublic boolean onKeyDown(int keyCode, KeyEvent event) {    // 是否触发按键为back键    if (keyCode == KeyEvent.KEYCODE_BACK) {        Intent intent = new Intent();        intent.putExtra(&quot;data_return&quot;, &quot;Hello FirstActivity&quot;);        setResult(RESULT_OK, intent);        this.finish();        return true;    }else {        return super.onKeyDown(keyCode, event);    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 第一行代码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《第一行代码》读书笔记-第二章01 活动的基本用法</title>
      <link href="/2016/05/11/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A001%20%E6%B4%BB%E5%8A%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/"/>
      <url>/2016/05/11/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A001%20%E6%B4%BB%E5%8A%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="活动的基本用法"><a href="#活动的基本用法" class="headerlink" title="活动的基本用法"></a>活动的基本用法</h3><p>活动是一种可以包含用户界面的组件，主要用于和用户进行交互。</p><h4 id="手动创建活动"><a href="#手动创建活动" class="headerlink" title="手动创建活动"></a>手动创建活动</h4><a id="more"></a><p><img src="/demo/photo/Thefirstlineofcode/01-03.png" alt="创建Activity"><br>新建一个名为FirstActivity的类，并让它继承自<code>Activity</code>，重写<code>onCreate()</code>方法。</p><pre><code class="java">public class FiratActivity extends Activity {    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        requestWindowFeature(Window.FEATURE_NO_TITLE);//隐藏标题栏，要在加载布局前进行        setContentView(R.layout.first_layout);//给当前Activity加载一个布局        //注意R文件，不能是android包下的那个    }}</code></pre><h4 id="创建和加载布局"><a href="#创建和加载布局" class="headerlink" title="创建和加载布局"></a>创建和加载布局</h4><p>在res/layout目录下，<br><img src="/demo/photo/Thefirstlineofcode/02-01.png" alt="创建布局文件"><br>我们给这个布局文件命名为 <code>first_layout</code>，根元素默认为 <code>LinearLayout</code>。<br><img src="/demo/photo/Thefirstlineofcode/02-02.png" alt="在Android 视图下创建布局文件"></p><p>Android视图下创建布局文件时，功能更多一些，所以尽量还是在Android视图下创建。在布局文件中再加一个<code>Button</code>元素。</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:orientation=&quot;vertical&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;&gt;    &lt;Button        android:id=&quot;@+id/button_1&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:text=&quot;@string/app_name&quot;        android:textAllCaps=&quot;false&quot;/&gt;&lt;/LinearLayout&gt;</code></pre><p><strong>说明</strong></p><pre><code>android:orientation=&quot;vertical&quot;垂直方向布局，horizontal水平android:layout_width=&quot;match_parent&quot;指定了元素的宽度，match_parent表示让当前元素和父元素一样宽，fill_parent已过时Google不推荐使用，效果和match_parent一样，wrap_content表示内容包裹，当前元素宽度刚好包含里面的内容。android:layout_height，指定元素的高度，同上android:text=&quot;@string/app_name&quot;引用资源文件res/values/string.xml&lt;resources&gt;    &lt;string name=&quot;app_name&quot;&gt;HelloWorld&lt;/string&gt;&lt;/resources&gt;android:text指定了元素中显示的文字内容android:id=&quot;@+id/button_1&quot;如果需要在XML中引用一个id，就用@id/id_name，如果需要在XML中定义一个id，则需要使用@+id/id_name这种语法。注意引用的id必须在当前位置之前定义过。android:textAllCaps=&quot;false&quot;Button的文本，英文显示不自动全为大写</code></pre><h4 id="在AndroidManifest文件中注册"><a href="#在AndroidManifest文件中注册" class="headerlink" title="在AndroidManifest文件中注册"></a>在AndroidManifest文件中注册</h4><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;          package=&quot;com.example.bin.helloworld&quot;&gt;    &lt;application        android:allowBackup=&quot;true&quot;        android:icon=&quot;@mipmap/ic_launcher&quot;        android:label=&quot;@string/app_name&quot;        android:supportsRtl=&quot;true&quot;        android:theme=&quot;@style/AppTheme&quot;&gt;        &lt;activity android:name=&quot;.MainActivity&quot;&gt;            &lt;intent-filter&gt;                &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt;            &lt;/intent-filter&gt;        &lt;/activity&gt;    &lt;/application&gt;&lt;/manifest&gt;</code></pre><p><strong>说明</strong></p><pre><code>package=&quot;com.example.bin.helloworld&quot;  指定程序的包名android:allowBackup=&quot;true&quot;默认情况下,这个标志被设置为true。当这个标志被设置为true,应用程序数据可以备份和恢复用户使用adb备份和恢复。这可能对一个应用程序带来安全后果。android:icon=&quot;@mipmap/ic_launcher&quot;  应用图标android:label=&quot;@string/app_name&quot;    应用名称android:supportsRtl=&quot;true&quot;  当切换系统语言为阿拉伯文时，actionbar布局变为从右向左排列。android:theme=&quot;@style/AppTheme&quot;     应用主题风格&lt;activity&gt;标签对活动进行注册，&lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt;&lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt;声明该Activity为程序的主活动(入口)</code></pre><h4 id="在活动中使用Toast"><a href="#在活动中使用Toast" class="headerlink" title="在活动中使用Toast"></a>在活动中使用Toast</h4><p><code>Toast</code>是<code>Android</code>系统提供的一种非常好的提醒方式<br><img src="/demo/photo/Thefirstlineofcode/02-03.png" alt="Toast"><br>在onCreate方法下继续添加如下代码</p><pre><code class="java">Button button = (Button)findViewById(R.id.button_1);button.setOnClickListener(new View.OnClickListener() {    @Override    public void onClick(View v) {        Toast.makeText(FirstActivity.this, &quot;我是一个Toast&quot;, Toast.LENGTH_SHORT).show();    }});</code></pre><p>在活动中，可以通过<code>findViewById()</code>方法获取到在布局文件中定义的元素，这里我们传入<code>R.id.button_1</code>，来得到按钮的实例，这个值是刚才在<code>first_layout.xml</code> 中通过<code>android:id</code> 属性指定的。<code>findViewById()</code>方法返回的是一个<code>View</code> 对象，我们需要向下转型将它转成<code>Button</code>对象。</p><p>得到了按钮的实例之后，我们通过调用<code>setOnClickListener()</code>方法为按钮注册一个监听器，点击按钮时就会执行监听器中的<code>onClick()</code>方法。</p><p><code>Toast.makeText()</code>方法需要传入三个参数。第一个参数是<strong>Context</strong>，也就是Toast 要求的上下文，由于活动本身就是一个<code>Context</code> 对象，因此这里直接传入<code>FirstActivity.this</code>即可。第二个参数是<code>Toast</code>显示的<strong>文本内容</strong>，第三个参数是<code>Toast</code><br>显示的<strong>时长</strong>，有两个内置常量可以选择<code>Toast.LENGTH_SHORT</code> 和<code>Toast.LENGTH_LONG</code></p><h4 id="在活动中使用Menu"><a href="#在活动中使用Menu" class="headerlink" title="在活动中使用Menu"></a>在活动中使用Menu</h4><p>在Activity中 有一个方法<code>onCreateOptionsMenu()</code>，是用于在活动中创建菜单的。<br>在res目录下创建<code>menu</code>文件夹，再新建一个名叫main的菜单文件。<br>在main.xml中添加如下代码：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;item        android:id=&quot;@+id/add_item&quot;        android:title=&quot;添加&quot;/&gt;    &lt;item        android:id=&quot;@+id/remove_item&quot;        android:title=&quot;移除&quot;/&gt;&lt;/menu&gt;</code></pre><p>这里我们创建了两个菜单项，其中<code>&lt;item&gt;</code>标签就是用来创建具体的某一个菜单项，<code>android:title</code> <strong>给这个菜单项指定一个名称</strong>。</p><p>然后打开FirstActivity，重写<code>onCreateOptionsMenu()</code>方法，代码如下所示：</p><pre><code class="java">@Overridepublic boolean onCreateOptionsMenu(Menu menu) {    getMenuInflater().inflate(R.menu.main, menu);    return true;}</code></pre><p>通过<code>getMenuInflater()</code>方法得到<code>MenuInflater</code>对象，在调用它的<code>inflate()</code>方法就可以给当前活动创建菜单了。</p><p><code>inflate()</code>方法接收两个参数，<strong>第一个参数</strong>用于指定我们通过哪一个资源文件来创建菜单，这里当然传入<code>R.menu.main</code>，<strong>第二个参数</strong>用于指定我们的菜单项将添加到哪一个Menu 对象当中，这里直接使用<code>onCreateOptionsMenu()</code>方法中传入的menu 参数。方法返回true表示显示菜单，返回false菜单不显示。</p><p><strong>定义菜单响应事件</strong><br>在FirstActivity 中重写<code>onOptionsItemSelected()</code>方法：</p><pre><code class="java">@Overridepublic boolean onOptionsItemSelected(MenuItem item) {    switch (item.getItemId()) {        case R.id.add_item:            Toast.makeText(MainActivity.this, &quot;点击了添加&quot;, Toast.LENGTH_SHORT).show();            break;        case R.id.remove_item:            Toast.makeText(MainActivity.this, &quot;点击了移除&quot;, Toast.LENGTH_SHORT).show();            break;        default:    }    return true;}</code></pre><h4 id="销毁一个活动"><a href="#销毁一个活动" class="headerlink" title="销毁一个活动"></a>销毁一个活动</h4><p>按一下Back 键就可以销毁当前的活动了。<br>Activity类也提供了一个<code>finish()</code>方法</p><pre><code class="java">button.setOnClickListener(new View.OnClickListener() {    @Override    public void onClick(View v) {        finish();    }});</code></pre>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 第一行代码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Effective Java》笔记06：避免创建不必要的对象</title>
      <link href="/2016/05/11/%E3%80%8AEffective%20Java%E3%80%8B%E7%AC%94%E8%AE%B006%EF%BC%9A%E9%81%BF%E5%85%8D%E5%88%9B%E5%BB%BA%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E5%AF%B9%E8%B1%A1/"/>
      <url>/2016/05/11/%E3%80%8AEffective%20Java%E3%80%8B%E7%AC%94%E8%AE%B006%EF%BC%9A%E9%81%BF%E5%85%8D%E5%88%9B%E5%BB%BA%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<p>一般来说，最好能重用对象而不是在每次需要的时候就创建一个相同功能的新对象。重用方式即快速，又流行。<strong>如果对象是不可变的，它就始终可以被重用</strong>。</p><h1 id="重用不可变的对象"><a href="#重用不可变的对象" class="headerlink" title="重用不可变的对象"></a>重用不可变的对象</h1><pre><code class="java">String s = new String(&quot;stringette&quot;); // 不要这样做，会创建新的 String 实例String s = &quot;stringette&quot;; // 对于所有在同一台虚拟机中运行的代码，只要它们包含相同的字符串字面常量，该对象就会被重用。在常量池中。</code></pre><p>对于同时提供了静态工厂方法和构造器的类，通常使用静态工厂方法，以避免创建不必要的对象。如，静态工厂方法 <code>Boolean.valueOf(String)</code>，总是优先于构造器 <code>Boolean(String)</code>，<strong>后者在 Java 9 中被弃用</strong>。构造器每次被调用都会创建一个新对象，而静态工厂方法不要求这样做。</p><a id="more"></a><h1 id="重用已知不会被修改的对象"><a href="#重用已知不会被修改的对象" class="headerlink" title="重用已知不会被修改的对象"></a>重用已知不会被修改的对象</h1><p>假设我们需要：检验一个人是否是出生在 1946-1964 年之间</p><pre><code class="java">public class Person{    private final Date birthDate;    //Dont do this    public boolean isBabyBoomer(){        // Unecessary allocationof expensive object        Calendar gmtCal = Calendar.getInstance(TimeZone.getTimeZone(&quot;GMT&quot;))        gmtCal.set(1946,Calendar.JANUARY,1,0,0,0);        Data boomStart = gmtCal.getTime();        gmtCal = Calendar.getInstance(TimeZone.getTimeZone(&quot;GMT&quot;))        gmtCal.set(1965,Calendar.JANUARY,1,0,0,0);        Data boomEnd = gmtCal.getTime();        return birthDate.compareTo(boomStart) &gt;= 0 &amp;&amp;            bitrthDate.compareTo(boomEnd) &lt; 0;    }}</code></pre><p>在以上这个实例中，我们发现，每次每次方法的调用 都会创建 一个 Calendar 、一个 TimeZone、和两个 Date 实例，而且我们只是需要比较 Date而已，并且这个 Date 的值其实是不变，我们可以用一个静态的初始化器，避免这种效率低下的实现方式。</p><pre><code class="java">public class Person{    private final Date birthDate;    private static final Date BOOMT_START;    private static final Date BOOMT_END;    static {  // 我们在静态方法块中初始化这些字段        Calendar gmtCal = Calendar.getInstance(TimeZone.getTimeZone(&quot;GMT&quot;))        gmtCal.set(1946,Calendar.JANUARY,1,0,0,0);        BOOMT_START = gmtCal.getTime();        gmtCal = Calendar.getInstance(TimeZone.getTimeZone(&quot;GMT&quot;))        gmtCal.set(1965,Calendar.JANUARY,1,0,0,0);        BOOMT_END = gmtCal.getTime();    }    public boolean isBabyBoomer(){        return birthDate.compareTo(BOOM_START) &gt;= 0 &amp;&amp; birthDate.compareTo(BOOM_END) &lt;0;}</code></pre><h1 id="自动装箱-autoboxing"><a href="#自动装箱-autoboxing" class="headerlink" title="自动装箱 autoboxing"></a>自动装箱 autoboxing</h1><p>自动装箱允许我们将基本类型和装箱基本类型(Boxed Primitive Type)混用,按需自动装箱和拆箱</p><p>它们俩之间性能是有明显的差别的（基本类型更优）</p><pre><code class="java">public static void main(String[] args) {    Long sum = 0L;    for(long i=0; i&lt;Integer.MAX_VALUE; i++) {        sum += i;    }    System.out.println(sum);}</code></pre><p>sum 的类型为 Long，这样会比 long 多创建约 2 的 31 次方的 Long 实例，影响性能，所需时间大约是 long 的 6 倍多</p><p><strong>优先使用基本类型</strong>!</p><p><strong>这里要说的不是创建对象非常昂贵,因为小对象的创建和回收是非常廉价的</strong>，特别是在现代的jvm实现更是如此。通过创建附加的对象，提升程序的清晰性，简洁行和功能性，这通常是件好事。</p><blockquote><p>类初始化的顺序： 先初始化父类的静态代码 —&gt; 初始化子类的静态代码 —&gt; 初始化父类的非静态代码 —&gt; 初始化父类构造函数<br>—&gt; 初始化子类非静态代码 —&gt;初始化子类构造函数。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Effective Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《第一行代码》读书笔记-第一章 开启启程，你的第一行代码</title>
      <link href="/2016/05/09/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BC%80%E5%90%AF%E5%90%AF%E7%A8%8B%EF%BC%8C%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/"/>
      <url>/2016/05/09/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BC%80%E5%90%AF%E5%90%AF%E7%A8%8B%EF%BC%8C%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>《第一行代码》重新拿出来，重新看一遍并写下笔记，书中采用的IDE为Eclipse，笔记中统一使用Android Studio2.1</p><h3 id="使用studio的必要性"><a href="#使用studio的必要性" class="headerlink" title="使用studio的必要性"></a>使用studio的必要性</h3><ul><li>官方推荐的工具就是studio;</li><li>Google已经宣布终止Eclipse Android工具的开发与支持。这包括ADT插件、Ant构建系统、DDMS、Traceview与其他性能和监控工具;</li><li>众多开源软件都是使用as构建;</li><li>as基于强大的是<code>最智能的JAVA IDE -IntelliJ IDEA</code>;</li></ul><a id="more"></a><p><strong>随便举几个优点</strong></p><ol><li>集成了Gradle 打包工具</li><li>所见即所得的效果</li><li>可拖拽的UI操作</li><li>代码自动补全</li><li>更多的操作接口</li><li>Google Cloud的集成</li><li>全新的JUnit</li><li>Maven仓库的集成</li></ol><p><strong>下载地址</strong></p><ul><li>官方地址：<a href="http://developer.android.com/sdk/index.html" target="_blank" rel="noopener">http://developer.android.com/sdk/index.html</a></li><li>由于众所周知的原因，推荐：<a href="http://www.androiddevtools.cn/" target="_blank" rel="noopener">http://www.androiddevtools.cn/</a> 或 <a href="http://www.android-studio.org/" target="_blank" rel="noopener">http://www.android-studio.org/</a></li><li>fq：<a href="http://wsgzao.github.io/post/fq/" target="_blank" rel="noopener">http://wsgzao.github.io/post/fq/</a></li></ul><h3 id="Android模拟器"><a href="#Android模拟器" class="headerlink" title="Android模拟器"></a>Android模拟器</h3><ul><li>可以使用Android Studio所带的AVD Manager去创建模拟器</li><li><a href="https://www.genymotion.com/" target="_blank" rel="noopener">Genymotion</a>优点：速度很快</li><li>最好还是使用真机，使用真机推荐一个chrome插件<a href="https://chrome.google.com/webstore/detail/vysor-beta/gidgenkbbabolejbgbpnhbimgjbffefm" target="_blank" rel="noopener">Vysor</a>，使用Vysor可以十分方便的在计算机上查看和控制你的Android设备。</li></ul><h3 id="创建HelloWorld项目"><a href="#创建HelloWorld项目" class="headerlink" title="创建HelloWorld项目"></a>创建HelloWorld项目</h3><p><img src="/demo/photo/Thefirstlineofcode/01-01.png" alt="创建HelloWorld项目01"><br><img src="/demo/photo/Thefirstlineofcode/01-02.png" alt="创建HelloWorld项目02"><br><img src="/demo/photo/Thefirstlineofcode/01-03.png" alt="创建HelloWorld项目03"></p><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><blockquote><p><a href="http://developer.android.com/intl/zh-cn/tools/projects/index.html" target="_blank" rel="noopener">http://developer.android.com/intl/zh-cn/tools/projects/index.html</a></p></blockquote><pre><code>│  build.gradle     项目Gradle构建脚本│  gradle.properties  项目Gradle属性文件│  gradlew      在没有安装gradle的pc上使用,没用│  gradlew.bat  在没有安装gradle的pc上使用,没用│  local.properties  指定sdk所在目录│  settings.gradle  项目Gradle设置文件│├─.gradle├─.idea├─app│  │  .gitignore   git忽略文件列表│  │  app.iml  临时文件,不需要关心│  │  build.gradle  Module Gradle构建脚本│  │  proguard-rules.pro    proguard混淆规则│  ││  ├─build  构建目录，相当于Eclipse中默认Java工程的bin目录。编译生成的apk在此目录│  ├─libs   依赖包│  └─src│      ├─androidTest  测试相关代码文件夹│      │  └─java│      │      └─com│      │          └─example│      │              └─myapplication│      │                      ApplicationTest.java│      ││      └─main│          │  AndroidManifest.xml   清单文件│          ││          ├─java       项目源码│          │  └─com│          │      └─example│          │          └─myapplication│          │                  MainActivity.java│          ││          └─res        资源文件│              ├─drawable  .9图片只能放到drawable目录下│              ├─layout│              │      activity_main.xml│              ││              ├─menu│              │      menu_main.xml│              ││              ├─mipmap-hdpi            类似drawable-hdpi│              │      ic_launcher.png│              ││              ├─mipmap-mdpi            类似drawable-mdpi│              │      ic_launcher.png│              ││              ├─mipmap-xhdpi           类似drawable-xdpi│              │      ic_launcher.png│              ││              ├─mipmap-xxhdpi           类似drawable-xxdpi│              │      ic_launcher.png│              ││              ├─values│              │      dimens.xml│              │      strings.xml│              │      styles.xml│              ││              └─values-w820dp│                      dimens.xml│├─build└─gradle    └─wrapper   gradle wrapper可以看作是对gradle的封装，它可以使得在没有安装gradle的电脑上也可以使用Gradle进行构建.没啥用            gradle-wrapper.jar            gradle-wrapper.properties</code></pre><h3 id="需要自己建立的文件夹"><a href="#需要自己建立的文件夹" class="headerlink" title="需要自己建立的文件夹"></a>需要自己建立的文件夹</h3><pre><code>main/assets/main/aidl/main/jni/  --&gt;放置c代码main/jniLibs/ --&gt;放置so库main/res/raw/main/res/anim/</code></pre><h3 id="gradle构建"><a href="#gradle构建" class="headerlink" title="gradle构建"></a>gradle构建</h3><p>这个以后再说，十分重要</p><h3 id="日志工具（LogCat）"><a href="#日志工具（LogCat）" class="headerlink" title="日志工具（LogCat）"></a>日志工具（LogCat）</h3><p>在 Android Studio的最下方点击 Android Moniter或者在工具条中点击Android那个小图标<br><img src="/demo/photo/Thefirstlineofcode/01-04.png" alt="Android Moniter"></p><h3 id="使用Android的日志工具Log"><a href="#使用Android的日志工具Log" class="headerlink" title="使用Android的日志工具Log"></a>使用Android的日志工具Log</h3><ol><li><code>Log.v()</code>  对应级别<code>verbose</code></li><li><code>Log.d()</code>  对应级别<code>debug</code>，用于打印一些调试信息</li><li><code>Log.i()</code>  对应级别<code>info</code>，用于打印一些比较重要的数据，这些数据应该是你非常想看到的，可以帮你分析用户行为的那种</li><li><code>Log.w()</code>  对应级别<code>warm</code>，打印一些警告信息，提示程序在这个地方可能会存在潜在的风险</li><li><code>Log.e()</code>  对应级别<code>error</code>，打印程序中的错误信息，比如程序进入到了catch语句中</li></ol><pre><code class="java">Log.d(&quot;MainActivity&quot;,&quot;onCreate 方法运行&quot;);//第一个参数是tag，一般传入当前的类名就行，主要用于对日志进行过滤。//第二个参数msg，既想要打印的具体内容。</code></pre>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 第一行代码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Effective Java》笔记04：通过私有构造器强化不可实例化的能力</title>
      <link href="/2016/05/06/%E3%80%8AEffective%20Java%E3%80%8B%E7%AC%94%E8%AE%B004%EF%BC%9A%E9%80%9A%E8%BF%87%E7%A7%81%E6%9C%89%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%BA%E5%8C%96%E4%B8%8D%E5%8F%AF%E5%AE%9E%E4%BE%8B%E5%8C%96%E7%9A%84%E8%83%BD%E5%8A%9B/"/>
      <url>/2016/05/06/%E3%80%8AEffective%20Java%E3%80%8B%E7%AC%94%E8%AE%B004%EF%BC%9A%E9%80%9A%E8%BF%87%E7%A7%81%E6%9C%89%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%BA%E5%8C%96%E4%B8%8D%E5%8F%AF%E5%AE%9E%E4%BE%8B%E5%8C%96%E7%9A%84%E8%83%BD%E5%8A%9B/</url>
      
        <content type="html"><![CDATA[<p><strong>不可实例化</strong>是指<strong>只包含静态方法和静态域的类</strong></p><p>比如 <em>BitmapUtil</em> 等各种 Utils，它们包含各种静态方法，但是实际上我们不会也不需要去实例化它！</p><a id="more"></a><p><strong>静态域</strong>(static-field) 比如：<code>public static Object obj</code><strong>提供一个私有构造器，并在里面抛出异常即可</strong>。</p><pre><code class="java">public class Util{    private Util{        // Suppress default constructor for noninstantiability        throw new AssertionError();    }}</code></pre><p>这种用法也有副作用，它使得一个<strong>类不能被子类化</strong>。</p><p>相信都会感觉这多此一举，谁没事去实例化工具类啊，直到在优秀的库中看到这写法，比如 RxJava 中的 <code>Subscriptions</code> 类：</p><pre><code class="java">public final class Subscriptions {    private Subscriptions() {        throw new IllegalStateException(&quot;No instances!&quot;);    }    //...}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Effective Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Effective Java》笔记03：用私有构造器或者枚举类型强化Singleton属性</title>
      <link href="/2016/05/06/%E3%80%8AEffective%20Java%E3%80%8B%E7%AC%94%E8%AE%B003%EF%BC%9A%E7%94%A8%E7%A7%81%E6%9C%89%E6%9E%84%E9%80%A0%E5%99%A8%E6%88%96%E8%80%85%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E5%BC%BA%E5%8C%96Singleton%E5%B1%9E%E6%80%A7/"/>
      <url>/2016/05/06/%E3%80%8AEffective%20Java%E3%80%8B%E7%AC%94%E8%AE%B003%EF%BC%9A%E7%94%A8%E7%A7%81%E6%9C%89%E6%9E%84%E9%80%A0%E5%99%A8%E6%88%96%E8%80%85%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E5%BC%BA%E5%8C%96Singleton%E5%B1%9E%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>Singleton 即单例，指仅仅被实例化一次的类。</p><h1 id="私有构造器强化"><a href="#私有构造器强化" class="headerlink" title="私有构造器强化"></a>私有构造器强化</h1><p>通过私有化构造函数，使客户端不能通过 new 关键字的形式来创建对象，同时我们需要提供静态工厂方法来使得外部能够通过调用调用静态方法取得该类的唯一实例。</p><a id="more"></a><p>延迟初始化的好处是：降低了初始化类或创建实例的开销。</p><p>延迟初始化的坏处是：增加了访问被延迟初始化的字段的开销。</p><p>如果对象的初始化的开销非常昂贵，而且多个线程不会频繁调用 getInstance() 来获取被延迟初始化的对象时，可以考虑使用延迟初始化。<br><strong>一般情况下，正常的初始化要优于延迟初始化</strong></p><h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><pre><code class="java">class Single{ //类一加载，对象就已经存在了    private static final Single s = new Single();    private Single(){}    public static Single getInstance() {        return s;    }}</code></pre><h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h2><pre><code class="java">class Single{ //类加载进来，没有对象，只有调用了getInstance方法时，才会创建对象。    //延迟加载形式。    private Single s;    private Single(){}    public static Single getInstance() {        if (s == null) {            s = new Single();        }        return s;    }}</code></pre><h2 id="懒汉式解决多线程安全问题"><a href="#懒汉式解决多线程安全问题" class="headerlink" title="懒汉式解决多线程安全问题"></a>懒汉式解决多线程安全问题</h2><pre><code class="java">//加入同步为了解决多线程安全问题。//加入双重判断是为了解决效率问题。class Single{    private static Single s = null;    private Single(){}    public static Single getInstance() {        if(s == null) {            synchronized(Single.class) {                if (s == null)                    s = new Single();            }        }        return s;    }}</code></pre><p>上面的代码在多线程还是有可能出现问题，详情参见<a href="http://www.infoq.cn/articles/double-checked-locking-with-delay-initialization" target="_blank" rel="noopener">双重检查锁定与延迟初始化</a><br>解决方法可以使用下面两种</p><h2 id="基于-volatile-的双重检查锁定的解决方案"><a href="#基于-volatile-的双重检查锁定的解决方案" class="headerlink" title="基于 volatile 的双重检查锁定的解决方案"></a>基于 volatile 的双重检查锁定的解决方案</h2><pre><code class="java">public class SafeDoubleCheckedLocking {    private volatile static Instance instance;    public static Instance getInstance() {        if (instance == null) {            synchronized (SafeDoubleCheckedLocking.class) {                if (instance == null)                    instance = new Instance();//instance 为 volatile，现在没问题了            }        }        return instance;    }}</code></pre><h2 id="基于类初始化的解决方案"><a href="#基于类初始化的解决方案" class="headerlink" title="基于类初始化的解决方案"></a>基于类初始化的解决方案</h2><pre><code class="java">public class A {      // 私有静态内部类, 只有当有引用时, 该类才会被装载      private A(){ }    private static class LazyA {          public static A A = new A();      }      public static A getInstance() {          return LazyA.A;  //这里将导致LazyA类被初始化    }  }</code></pre><p>延迟初始化降低了初始化类或创建实例的开销，但增加了访问被延迟初始化的字段的开销。在大多数时候，正常的初始化要优于延迟初始化。<br>如果确实需要对实例字段使用线程安全的延迟初始化，请使用上面介绍的基于volatile的延迟初始化的方案；如果确实需要对静态字段使用线程安全的延迟初始化，请使用上面介绍的基于类初始化的方案</p><h1 id="防止反射机制调用私有构造器"><a href="#防止反射机制调用私有构造器" class="headerlink" title="防止反射机制调用私有构造器"></a>防止反射机制调用私有构造器</h1><p>享有特权的客户端可以借助 <code>AccessibleObject.setAccessible</code> 方法，通过反射机制调用私有构造器。如果需要抵御这种攻击，可以修改构造器，让它在被要求创建第二个实例的时候抛出异常。</p><pre><code class="java">public class Single {    private final static Single SINGLETON = new Single();    private Single(){        if(SINGLETON != null){            throw new IllegalArgumentException(&quot;不能存在第二个实例&quot;);        }    }    public static Single getInstance(){        return SINGLETON;    }    @SuppressWarnings(&quot;rawtypes&quot;)    public static void main(String[] args) throws Exception {        Single s = Single.SINGLETON;        // 利用反射调用私有构造器        Constructor[] arrayConstructor = s.getClass().getDeclaredConstructors();        for (Constructor constructor : arrayConstructor) {            // 调用setAccessible(true);            constructor.setAccessible(true);            // 实例化,这里一定会抛出异常            constructor.newInstance();        }    }}</code></pre><h1 id="Singleton-序列化"><a href="#Singleton-序列化" class="headerlink" title="Singleton 序列化"></a>Singleton 序列化</h1><p>为了使 Singleton 类变成<strong>可序列化的</strong>，仅仅在声明中加上 <code>implements Serializable</code> 是不够的。为了维护并保证 Singleton，必须声明所有实例都是瞬时 <code>transient</code> 的（非静态数据不想被序列化可以使用这个关键字修饰），并提供 一个 <code>readResolve</code> 方法。否则每次反序列化一个序列化的实例时，都会创建一个新的实例。</p><pre><code class="java">private Object readResolve() {    return SINGLETON;}</code></pre><h1 id="使用枚举类型来实现单例"><a href="#使用枚举类型来实现单例" class="headerlink" title="使用枚举类型来实现单例"></a>使用枚举类型来实现单例</h1><p>从Java 1.5发行版本起，实现 Singleton 还有另一种方法。只需编写一个包含单个元素的枚举类型。</p><pre><code class="java">// https://stackoverflow.com/questions/70689/what-is-an-efficient-way-to-implement-a-singleton-pattern-in-java// 第77(89)条：对于实例控制，枚举类型优先于 readResolvepublic enum Elvis {    INSTANCE;    private final String[] favoriteSongs = { &quot;Hound Dog&quot;, &quot;Heartbreak Hotel&quot; };    public void printFavorites() {        System.out.println(Arrays.toString(favoriteSongs));    }}</code></pre><pre><code class="java">public enum SingleEnum {    SINGLETON;}public class Test {    public static void main(String args[]) throws Exception {        // 测试，是否可以反射生成枚举        // 利用反射调用私有构造器        Constructor[] arrayConstructor = SingleEnum.SINGLETON.getClass().getDeclaredConstructors();        for (Constructor constructor : arrayConstructor) {            // 调用setAccessible(true);            constructor.setAccessible(true);            // 实例化,这里一定会抛出异常            constructor.newInstance();// 报错: Exception in thread &quot;main&quot; java.lang.IllegalArgumentException: Cannot reflectively create enum objects.        }    }}</code></pre><p>这种方法在功能上与公有域方法相近，但是其更加简洁，无偿提供了序列化机制，绝对防止多次实例化，即使是面对复杂的序列化或者反射攻击的时候。虽然这种方法还没有广泛使用，但是<strong>单元素的枚举类型已经成为实现 Singleton 的最佳方法</strong>。</p><p>然而，<code>Android</code> 并不推荐使用枚举，相对于使用静态常量而言，它会消耗两倍以上的内存 <a href="http://developer.android.com/intl/zh-cn/training/articles/memory.html#Overhead" target="_blank" rel="noopener">Enums often require more than twice as much memory as static constants. You should strictly avoid using enums on Android</a>.</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Effective Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AndroidAnnotations - AndroidStudio配置</title>
      <link href="/2016/05/04/AndroidAnnotations%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001-AndroidStudio%E9%85%8D%E7%BD%AE/"/>
      <url>/2016/05/04/AndroidAnnotations%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001-AndroidStudio%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="app-build-gradle"><a href="#app-build-gradle" class="headerlink" title="app/build.gradle"></a>app/build.gradle</h3><p>You can use the <a href="https://bitbucket.org/hvisser/android-apt" target="_blank" rel="noopener">android-apt</a> Gradle plugin to launch AndroidAnnotation processing.</p><p>Here is a quick working sample:</p><p><strong>app/build.gradle修改</strong></p><a id="more"></a><pre><code class="gradle">buildscript {    repositories {        mavenCentral()    }    dependencies {        // replace with the current version of the Android plugin        classpath &#39;com.android.tools.build:gradle:2.1.0&#39;        // replace with the current version of the android-apt plugin        classpath &#39;com.neenbedankt.gradle.plugins:android-apt:1.8&#39;    }}repositories {    mavenCentral()    mavenLocal()}apply plugin: &#39;com.android.application&#39;apply plugin: &#39;android-apt&#39;def AAVersion = &#39;3.3.2&#39;dependencies {    compile fileTree(dir: &#39;libs&#39;, include: [&#39;*.jar&#39;])    testCompile &#39;junit:junit:4.12&#39;    compile &#39;com.android.support:appcompat-v7:23.3.0&#39;    compile &#39;com.android.support:design:23.3.0&#39;    apt &quot;org.androidannotations:androidannotations:$AAVersion&quot;    compile &quot;org.androidannotations:androidannotations-api:$AAVersion&quot;}apt {    arguments {        androidManifestFile variant.outputs[0]?.processResources?.manifestFile        // if you have multiple outputs (when using splits), you may want to have other index than 0        // you should set your package name here if you are using different application IDs        resourcePackageName &quot;com.zbin.bin.myapp51&quot;        // You can set optional annotation processing options here, like these commented options:        // logLevel &#39;INFO&#39;        // logFile &#39;/var/log/aa.log&#39;    }}android {    compileSdkVersion 23    buildToolsVersion &quot;23.0.3&quot;    defaultConfig {        applicationId &quot;com.zbin.bin.myapp51&quot;        minSdkVersion 15        targetSdkVersion 23        versionCode 1        versionName &quot;1.0&quot;    }    buildTypes {        release {            minifyEnabled false            proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39;        }    }}</code></pre><p>然后直接在项目里使用就可以了</p><pre><code class="java">import org.androidannotations.annotations.Click;import org.androidannotations.annotations.EActivity;import org.androidannotations.annotations.ViewById;@EActivity(R.layout.activity_main)public class MainActivity extends AppCompatActivity {}</code></pre><p>最后，不要忘了修改 AndroidManifest.xml 里面的 Activity，在最后添加 _</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><h4 id="创建一个Activity"><a href="#创建一个Activity" class="headerlink" title="创建一个Activity"></a>创建一个Activity</h4><p>使用 <code>@EActivity</code>, <code>@ViewById</code> 和 <code>@Click</code></p><pre><code class="java">import android.app.Activity;import android.widget.EditText;import android.widget.TextView;import org.androidannotations.annotations.Click;import org.androidannotations.annotations.EActivity;import org.androidannotations.annotations.ViewById;@EActivity(R.layout.main)public class MyActivity extends Activity {    @ViewById(R.id.myInput)    EditText myInput;    @ViewById(R.id.myTextView)    TextView textView;    @Click    void myButton() {         String name = myInput.getText().toString();         textView.setText(&quot;Hello &quot;+name);    }}</code></pre><h4 id="布局文件"><a href="#布局文件" class="headerlink" title="布局文件"></a>布局文件</h4><p>main.xml</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:orientation=&quot;vertical&quot;    android:layout_width=&quot;fill_parent&quot;    android:layout_height=&quot;fill_parent&quot;    &gt;    &lt;EditText        android:id=&quot;@+id/myInput&quot;        android:layout_width=&quot;fill_parent&quot;        android:layout_height=&quot;wrap_content&quot;        /&gt;    &lt;Button        android:id=&quot;@+id/myButton&quot;        android:layout_width=&quot;fill_parent&quot;        android:layout_height=&quot;wrap_content&quot;        android:text=&quot;Click me!&quot;        /&gt;    &lt;TextView        android:id=&quot;@+id/myTextView&quot;        android:layout_width=&quot;fill_parent&quot;        android:layout_height=&quot;wrap_content&quot;        /&gt;&lt;/LinearLayout&gt;</code></pre><h4 id="在清单文件中注册"><a href="#在清单文件中注册" class="headerlink" title="在清单文件中注册"></a>在清单文件中注册</h4><pre><code class="xml">&lt;activity android:name=&quot;.MyActivity_&quot; /&gt;</code></pre><blockquote><p><a href="https://github.com/excilys/androidannotations/wiki/Building-Project-Gradle" target="_blank" rel="noopener">https://github.com/excilys/androidannotations/wiki/Building-Project-Gradle</a><br><a href="https://github.com/excilys/androidannotations/wiki/FirstActivity" target="_blank" rel="noopener">https://github.com/excilys/androidannotations/wiki/FirstActivity</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis密码管理</title>
      <link href="/2016/05/03/redis%E5%AF%86%E7%A0%81%E7%AE%A1%E7%90%86/"/>
      <url>/2016/05/03/redis%E5%AF%86%E7%A0%81%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="redis密码管理"><a href="#redis密码管理" class="headerlink" title="redis密码管理"></a>redis密码管理</h2><h3 id="一-如何初始化redis的密码？"><a href="#一-如何初始化redis的密码？" class="headerlink" title="一.  如何初始化redis的密码？###"></a>一.  如何初始化redis的密码？###</h3><p>总共2个步骤：</p><ul><li>在配置文件C:\Program Files\Redis\conf\redis.conf中有个参数： <code>requirepass</code>  这个就是配置redis访问密码的参数,比如:<pre><code>requirepass 123</code></pre></li><li>配置文件中参数生效需要<strong>重启</strong>redis 。<a id="more"></a></li></ul><h3 id="二-不重启redis如何配置密码-（推荐！！！）"><a href="#二-不重启redis如何配置密码-（推荐！！！）" class="headerlink" title="二 .不重启redis如何配置密码? （推荐！！！）"></a>二 .不重启redis如何配置密码? （推荐！！！）</h3><ul><li>在配置文件中配置<code>requirepass</code>的密码（当redis重启时密码依然有效）。<pre><code>requirepass 123</code></pre>如  修改成 :<pre><code>requirepass  1234</code></pre></li><li>进入redis重定义参数</li></ul><p>查看当前的密码：</p><pre><code class="cmd">C:\Program Files\Redis&gt;redis-cli.exe -p 6379redis 127.0.0.1:6379&gt;redis 127.0.0.1:6379&gt; config get requirepass(error) ERR operation not permittedredis 127.0.0.1:6379&gt; auth 123 #密码认证redis 127.0.0.1:6379&gt; config get requirepass1) &quot;requirepass&quot;2) &quot;123&quot;</code></pre><p>显示密码是之前的，然后设置密码：</p><pre><code class="shell">redis 127.0.0.1:6379&gt; config set requirepass 1234OK</code></pre><p>再次查询密码：</p><pre><code class="shell">redis 127.0.0.1:6379&gt; config get requirepass1) &quot;requirepass&quot;2) &quot;1234&quot;</code></pre><p>密码已经得到修改。</p><h3 id="三-如何登录有密码的redis？"><a href="#三-如何登录有密码的redis？" class="headerlink" title="三. 如何登录有密码的redis？"></a>三. 如何登录有密码的redis？</h3><ul><li><p>在登录的时候 密码就输入</p><pre><code class="cmd">C:\Program Files\Redis&gt;redis-cli.exe -p 6379 -a 1234redis 127.0.0.1:6379&gt;redis 127.0.0.1:6379&gt; config get requirepass1) &quot;requirepass&quot;2) &quot;1234&quot;</code></pre></li><li><p>先登录再验证：</p><pre><code class="cmd">C:\Program Files\Redis&gt;redis-cli.exe -p 6379redis 127.0.0.1:6379&gt;redis 127.0.0.1:6379&gt; auth 123OKredis 127.0.0.1:6379&gt; config get requirepass1) &quot;requirepass&quot;2) &quot;1234&quot;</code></pre></li></ul><h3 id="四-master-有密码-slave-如何配置？"><a href="#四-master-有密码-slave-如何配置？" class="headerlink" title="四.  master 有密码,slave 如何配置？"></a>四.  master 有密码,slave 如何配置？</h3><p>当 <code>master</code> 有密码的时候 配置 <code>slave</code> 的时候 相应的密码参数也得相应的配置好。不然 <code>slave</code> 是无法进行正常复制的。</p><p>相应的参数是：</p><pre><code>#masterauth</code></pre><p>比如:</p><pre><code>masterauth  mstpassword</code></pre><hr><blockquote><p>来源：  <a href="http://www.cnblogs.com/kenshinobiy/p/4624952.html" target="_blank" rel="noopener">http://www.cnblogs.com/kenshinobiy/p/4624952.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Effective Java》笔记02：遇到多个构造器参数时要考虑用构建器 Builder</title>
      <link href="/2016/04/28/%E3%80%8AEffective%20Java%E3%80%8B%E7%AC%94%E8%AE%B002%EF%BC%9A%E9%81%87%E5%88%B0%E5%A4%9A%E4%B8%AA%E6%9E%84%E9%80%A0%E5%99%A8%E5%8F%82%E6%95%B0%E6%97%B6%E8%A6%81%E8%80%83%E8%99%91%E7%94%A8%E6%9E%84%E5%BB%BA%E5%99%A8/"/>
      <url>/2016/04/28/%E3%80%8AEffective%20Java%E3%80%8B%E7%AC%94%E8%AE%B002%EF%BC%9A%E9%81%87%E5%88%B0%E5%A4%9A%E4%B8%AA%E6%9E%84%E9%80%A0%E5%99%A8%E5%8F%82%E6%95%B0%E6%97%B6%E8%A6%81%E8%80%83%E8%99%91%E7%94%A8%E6%9E%84%E5%BB%BA%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>静态工厂方法和构造器，它们都<strong>不能很好的扩展到大量的可选参数</strong>。</p><h1 id="重叠构造器"><a href="#重叠构造器" class="headerlink" title="重叠构造器"></a>重叠构造器</h1><p>当参数过多时可以采用重叠构造器（telescoping constructor）模式，类有多个重载的构造函数，但是当有许多参数的时候，客户端代码会很难编写，且难以阅读。</p><h1 id="JavaBeans-模式"><a href="#JavaBeans-模式" class="headerlink" title="JavaBeans 模式"></a>JavaBeans 模式</h1><p>在这种模式下，调用一个无参构造器来创建对象，然后调用 setter 方法来设置每个参数。<br>这种模式弥补了重叠构造器模式的不足。说的明白一点，就是创建实例很容易，产生的代码读起来也很容易。</p><p>不过，<strong>JavaBeans 模式自身有很严重的缺点</strong>。因为构造过程被分到了几个调用中，在构造过程中 JavaBean 可能处于<strong>不一致的状态</strong>。类无法仅仅通过检验构造器参数的有效性来保证一致性。试图使用处于不一致状态的对象，将会导致失败。JavaBeans 模式阻止了<strong>把类做成不可变的可能</strong>，并需要确保它的线程安全。</p><a id="more"></a><h1 id="Builder模式"><a href="#Builder模式" class="headerlink" title="Builder模式"></a>Builder模式</h1><p>Builder 模式，既能保证像重叠构造器模式那样的安全性，也能保证像 JavaBeans 模式那么好的可读性。</p><p>不直接生成想要的对象，而是让客户端利用所有必要的参数调用构造器（或者静态工厂），得到一个 <code>Builder</code> 对象。然后客户端在 <code>builder</code> 对象上调用类似于 <code>setter</code> 的方法，来设置每个相关的可选参数。最后，客户端调用无参的 <code>build</code> 方法来生成不可变的对象。这个 <code>builder</code> 是他构建的类的<strong>静态成员类</strong>。</p><pre><code class="java">class NutritionFacts {    private final int servingSize;    private final int servings;    private final int calories;    private final int fat;    private final int sodium;    private final int carbohydrate;    public static class Builder {        // 对象的必选参数        private final int servingSize;        private final int servings;        // 对象的可选参数的缺省值初始化        private int calories = 0;        private int fat = 0;        private int carbohydrate = 0;        private int sodium = 0;        // 只用少数的必选参数作为构造器的函数参数        public Builder(int servingSize,int servings) {            this.servingSize = servingSize;            this.servings = servings;        }        public Builder calories(int val) {            calories = val;            return this;        }        public Builder fat(int val) {            fat = val;            return this;        }        public Builder carbohydrate(int val) {            carbohydrate = val;            return this;        }        public Builder sodium(int val) {            sodium = val;            return this;        }        public NutritionFacts build() {            return new NutritionFacts(this);        }    }    private NutritionFacts(Builder builder) {        servingSize = builder.servingSize;        servings = builder.servings;        calories = builder.calories;        fat = builder.fat;        sodium = builder.sodium;        carbohydrate = builder.carbohydrate;    }    // 使用方式    public static void main(String[] args) {        NutritionFacts cocaCola = new NutritionFacts.Builder(240, 8).calories(100)        .sodium(35).carbohydrate(27).build();        System.out.println(cocaCola);    }}</code></pre><p>这样的客户端代码很容易编写,更为重要的是，易于阅读。builder 模式模拟了<strong>具名的可选参数</strong></p><blockquote><p>具名的可选参数，类似 Python 中关键字参数，可以参考：<a href="http://www.cnblogs.com/similar/p/5006705.html" target="_blank" rel="noopener">http://www.cnblogs.com/similar/p/5006705.html</a></p></blockquote><p>就像构造器那样，builder 可以强加给它的参数变量，build 方法实例化实体类，实例化前，可以对参数进行检查，如果不满足条件的，应该抛出 IllegalStateException，或者其他自定义异常。</p><p>另外一个小优点是 builder <strong>可以有多个可变参数</strong>。构造器，像方法一样，可能只有一个可变参数。因为 builder 用不同的方法设置参数，只要你喜欢，他们可以有很多可变参数。</p><h2 id="泛化建造者模式"><a href="#泛化建造者模式" class="headerlink" title="泛化建造者模式"></a>泛化建造者模式</h2><p><strong>泛化建造者模式</strong>（Abstract Factory）<br>通过生命静态工厂方法的返回值为父类型来实现。用泛型让建造者模式和抽象工厂模式融合：</p><pre><code class="java">// A builder for objects of type Tpublic interface Builder&lt;T&gt; {    public T build();}</code></pre><p>这里我们的 NutritionFacts.Builder 类应该这样来声明实现：Builder<NutritionFacts>。</p><h2 id="类层次结构"><a href="#类层次结构" class="headerlink" title="类层次结构"></a>类层次结构</h2><p>Builder 模式非常适合类层次结构。使用平行层次的 builder，每个嵌套在相应的类中。抽象类有抽象的 builder；具体的类有具体的 builder。例如，考虑代表各种比萨饼的根层次结构的抽象类：</p><pre><code class="java">// Builder pattern for class hierarchiesimport java.util.EnumSet;import java.util.Objects;import java.util.Set;public abstract class Pizza {    public enum Topping {HAM, MUSHROOM, ONION, PEPPER, SAUSAGE}    final Set&lt;Topping&gt; toppings;    abstract static class Builder&lt;T extends Builder&lt;T&gt;&gt; {        EnumSet&lt;Topping&gt; toppings = EnumSet.noneOf(Topping.class);        public T addTopping(Topping topping) {            toppings.add(Objects.requireNonNull(topping));            return self();        }        abstract Pizza build();        // Subclasses must override this method to return &quot;this&quot;        protected abstract T self();    }    Pizza(Builder&lt;?&gt; builder) {        toppings = builder.toppings.clone(); // See Item 50    }}</code></pre><p>请注意，<code>Pizza.Builder</code> 是一个带有递归类型参数（ recursive type parameter）（详见第 30 条）的泛型类型。这与抽象的 <code>self</code> 方法一起，允许方法链在子类中正常工作，而不需要强制转换。Java 缺乏自我类型的这种变通解决方法被称为模拟自我类型（simulated self-type）的习惯用法。</p><p>这里有两个具体的 <code>Pizza</code> 的子类，其中一个代表标准的纽约风格的披萨，另一个是半圆形烤乳酪馅饼。前者有一个所需的尺寸参数，而后者则允许指定酱汁是否应该在里面或在外面：</p><pre><code class="java">import java.util.Objects;public class NyPizza extends Pizza {    public enum Size { SMALL, MEDIUM, LARGE }    private final Size size;    public static class Builder extends Pizza.Builder&lt;Builder&gt; {        private final Size size;        public Builder(Size size) {            this.size = Objects.requireNonNull(size);        }        @Override        public NyPizza build() {            return new NyPizza(this);        }        @Override        protected Builder self() {            return this;        }    }    private NyPizza(Builder builder) {        super(builder);        size = builder.size;    }}public class Calzone extends Pizza {    private final boolean sauceInside;    public static class Builder extends Pizza.Builder&lt;Builder&gt; {        private boolean sauceInside = false; // Default        public Builder sauceInside() {            sauceInside = true;            return this;        }        @Override        public Calzone build() {            return new Calzone(this);        }        @Override        protected Builder self() {            return this;        }    }    private Calzone(Builder builder) {        super(builder);        sauceInside = builder.sauceInside;    }}</code></pre><p>请注意，每个子类 builder 中的 <code>build</code> 方法被声明为返回正确的子类：<code>NyPizza.Builder</code> 的 <code>build</code> 方法返回 <code>NyPizza</code>，而 <code>Calzone.Builder</code> 中的 <code>build</code> 方法返回 <code>Calzone</code>。这种技术，其一个子类的方法被声明为返回在超类中声明的返回类型的子类型，称为协变返回类型（covariant return typing）。它允许客户端使用这些 builder，而不需要强制转换。</p><p>这些「分层 builder（hierarchical builders）」的客户端代码基本上与简单的 <code>NutritionFacts</code> builder 的代码相同。为了简洁起见，下面显示的示例客户端代码假设枚举常量的静态导入：</p><pre><code class="java">NyPizza pizza = new NyPizza.Builder(SMALL).addTopping(SAUSAGE).addTopping(ONION).build();Calzone calzone = new Calzone.Builder().addTopping(HAM).sauceInside().build();</code></pre><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>builder 对构造方法的一个微小的优势是，builder 可以有多个可变参数，因为每个参数都是在它自己的方法中指定的。或者，builder 可以将传递给多个调用的参数聚合到单个属性中，如前面的 <code>addTopping</code> 方法所演示的那样。</p><p>Java 中传统的传统的抽象工厂是 Class 对象，它用 newInstance 方法充当 build 方法的一部分，newInstance 默认会调用类的无参构造函数，但是这个类的无参构造函数可能根本不存在，而且可怕的是你不会受到编译期的错误，你必须在运行期对异常进行处理。相反，使用 Builder 模式，在编译器就能知道出错了。</p><p><strong>劣势</strong>：为了创建一个对象，必须先创建一个 builder，可能在某些情况下会有性能问题。并且它应该并用于有四个或者更多的参数时，否则应该用 telescoping constructor 的形式（即，构造器传参的形式）。但是你需要记住未来的扩展情况。</p><p>总之，当类的参数过多的时候，Builder 模式是一个不错的选择。用 Builder 的模式，对传统的 telescoping constructor 模式而言，客户端代码更容易阅读和书写；比 JavaBeans 模式更加的安全。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Effective Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Effective Java》笔记01：考虑用静态工厂方法替代构造器</title>
      <link href="/2016/04/28/%E3%80%8AEffective%20Java%E3%80%8B%E7%AC%94%E8%AE%B001%EF%BC%9A%E8%80%83%E8%99%91%E7%94%A8%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%9B%BF%E4%BB%A3%E6%9E%84%E9%80%A0%E5%99%A8/"/>
      <url>/2016/04/28/%E3%80%8AEffective%20Java%E3%80%8B%E7%AC%94%E8%AE%B001%EF%BC%9A%E8%80%83%E8%99%91%E7%94%A8%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%9B%BF%E4%BB%A3%E6%9E%84%E9%80%A0%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>对于类而言，为了创建对象，最常见的方法就是提供一个<strong>公有的构造器</strong>。</p><p>还有一种方法，类可以提供一个<strong>公有的静态工厂方法</strong>(<code>static factory method</code>)(不同于设计模式中的工厂方法)，它是一个返回类实例的静态方法。下面是一个来自 Boolean 的简单示例，这个方法将 boolean 基本类型值，String 类型转换成了一个 Boolean 对象引用：</p><a id="more"></a><pre><code class="java">public final class Boolean implements java.io.Serializable, Comparable&lt;Boolean&gt; {    public static final Boolean TRUE = new Boolean(true);    public static final Boolean FALSE = new Boolean(false);    public static Boolean valueOf(boolean b) {        return (b ? TRUE : FALSE);    }    public static Boolean valueOf(String s) {        return toBoolean(s) ? TRUE : FALSE;    }    private static boolean toBoolean(String name) {        return ((name != null) &amp;&amp; name.equalsIgnoreCase(&quot;true&quot;));    }}</code></pre><h1 id="公有构造器的方式的缺点"><a href="#公有构造器的方式的缺点" class="headerlink" title="公有构造器的方式的缺点"></a>公有构造器的方式的缺点</h1><ul><li>只能通过 new className() 的方式来实现</li><li>每次调用必然返回一个新的对象</li><li>返回类型就是该类</li></ul><h1 id="使用静态工厂方法的优势"><a href="#使用静态工厂方法的优势" class="headerlink" title="使用静态工厂方法的优势"></a>使用静态工厂方法的优势</h1><h2 id="静态工厂方法是有名称的"><a href="#静态工厂方法是有名称的" class="headerlink" title="静态工厂方法是有名称的"></a>静态工厂方法是有名称的</h2><p>使用有适当的名称的静态工厂方法，会更加便于阅读。</p><p>如果一个类有多个构造器，而且构造器的参数没有确切的描述被返回的对象，如果 2 个构造函数拥有相同个数和类型的参数，虽说可以改变顺序，但这样会不便于阅读。</p><p>例如：一个类 <code>Complex</code>(复数，就是数学课上学的，有实数部和虚数部)，对它的构造可能有这样 2 种需求：</p><ol><li>分别给出实数部和虚数部来构造之；</li><li>基于极坐标来构造（提供“半径”和“角度”）</li></ol><p>由于这两种构造方式，都是由两个 float 型参数的，对于构造函数将无能为力，而静态工厂方法可以从方法名来区别开，而且还带来了易于辨识的好处：</p><pre><code class="java">public class Complex {    private final float re;    private final float im;    private Complex(float re, float im){        this.re = re;        this.im = im;    }    public static Complex valueOf(float re, float im){        return new Complex(re, im);    }    public static Complex valueOfPolar(float r, float theta){        return new Complex((float)(r * Math.cos(theta)), (float)(r * Math.sin(theta)));    }}</code></pre><h2 id="不必在每次调用它们的时候都创建一个新的对象"><a href="#不必在每次调用它们的时候都创建一个新的对象" class="headerlink" title="不必在每次调用它们的时候都创建一个新的对象"></a>不必在每次调用它们的时候都创建一个新的对象</h2><p>我们调用静态工厂方法返回的可能是缓存的一个对象，而不是新对象。可以进行重复利用，从而避免创建不必要的重复对象。</p><p>如果程序经常请求创建相同的对象，并且创建的代价很高，则静态工厂方法可以极大地提升性能。</p><p>前面提到的 Boolean.valueOf(boolean) 便说明了这项技术，还有单例，枚举(enum)类型。</p><h2 id="可以返回原返回类型的的任何子类型的对象"><a href="#可以返回原返回类型的的任何子类型的对象" class="headerlink" title="可以返回原返回类型的的任何子类型的对象"></a>可以返回原返回类型的的任何子类型的对象</h2><p>这样在选择返回对象的类时就有了更大的灵活性。<strong>返回的对象可以不是公有的</strong>，java 的集合框架(<code>java.util.Collections</code>)就采用了这种实现，返回的子类都是非公有的，外部无法访问，对调用者来说并不知道是哪个子类的对象，隐藏了实现细节，减少了 API 的数量，提高了易用性。例如，EnumSet 中，创建一个空的 enum set</p><pre><code class="java">// 如果，枚举类型的元素个数不超过 64 个则返回 RegalarEnumSet 实例，否则返回 JumboEnumSet 实例。public static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; noneOf(Class&lt;E&gt; elementType) {    Enum[] universe = getUniverse(elementType);    if (universe == null)        throw new ClassCastException(elementType + &quot; not an enum&quot;);    if (universe.length &lt;= 64)        return new RegularEnumSet&lt;&gt;(elementType, universe);    else        return new JumboEnumSet&lt;&gt;(elementType, universe);}// 这两个实现类的存在对于客户端来说是不可见的。// 如果 RegularEnumSet 不能再给小的枚举类型提供性能优势，就可能从未来的发行版本中将它删除，不会造成不良的影响。// 同样的了，如果证明对性能要好处，也可能在未来的发行版本中添加第三甚至第四个 Enum 实现。// 客户端永远也不知道也不关心他们从工厂方法得到的对象的类，他们只关心他是 EnumSet 的某个子类即可。</code></pre><p>使用这种静态工厂方法时，甚至要求客户端通过<strong>接口</strong>来引用被返回的对象，而不是通过它的实现类来引用被返回的对象，这是一种良好的习惯。</p><h2 id="返回对象所属的类，在编写包含该方法时可以不存在"><a href="#返回对象所属的类，在编写包含该方法时可以不存在" class="headerlink" title="返回对象所属的类，在编写包含该方法时可以不存在"></a>返回对象所属的类，在编写包含该方法时可以不存在</h2><p><strong>静态工厂方法返回对象所属的类，在编写包含该静态工厂方法时可以不必存在</strong>。这种灵活的静态方法构成了<strong>服务提供者框架</strong>(Service Provide Framework)的基础，例如 JDBC(Java Database Connectivity) API。服务提供者框架是这样一个系统：<em>多个服务提供者实现一个服务，系统为服务提供者的客户端提供多个实现，并把他们从多个实现中解耦出来</em>。</p><p>服务提供者框架中有三个重要的组件：<strong>服务接口</strong>（Service Interface），这是<em>提供者实现的</em>；<strong>提供者注册API</strong>（Provide Registration API），这是<em>系统用来注册实现的</em>，让客户端访问它们的；<strong>服务访问API</strong>（Service Access API），是<em>客户端用来获取服务的实例的</em>。</p><p><strong>服务访问 API</strong> 一般允许但是不要求客户端指定某种选择提供者的条件。如果没有这样的规定，API 就会返回默认实现的一个实例。服务访问 API 是“灵活的静态工厂”，它构成了服务提供者框架的基础。</p><p>服务提供者框架的第四个组件是可选的：<strong>服务提供者接口</strong>（Service Provide Interface），这些提供者负责创建其服务实现的实例。如果没有服务提供者接口，实现就按照类名称注册，并通过反射方式进行实例化。</p><p>对于 JDBC 来说，<code>Connection</code> 就是它的服务接口，<code>DriverManager.registerDriver</code> 是提供者注册 API，<code>DriverManager.getConnection</code> 是服务访问 API，<code>Driver</code> 就是服务提供者接口。</p><pre><code class="java">DriverManager.registerDriver(new com.mysql.jdbc.Driver());// 使用服务提供者接口Class.forName(&quot;com.mysql.jdbc.Driver&quot;);// 不使用上面的// 由于 MySQL 在 Driver 类的实现中自己注册了一次,而我们又注册了一次,于是会导致 MySQL 驱动被注册两次// 创建 MySQL 的 Driver 对象时,导致了程序和具体的 MySQL 驱动绑死在了一起,在切换数据库时需要改动 Java 代码，所以不使用 new// 获取数据库连接java.sql.Connection conn = java.sql.DriverManager        .getConnection(&quot;jdbc:mysql:///databasename?user=root&amp;password=root&quot;);</code></pre><p>从 Java 6 开始，平台包含一个通用的服务提供者框架 <code>java.util.ServiceLoader</code>，所以你不需要，一般也不应该自己编写。 JDBC 不使用 ServiceLoader，因为前者早于后者。</p><h3 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h3><p><strong>服务提供者框架</strong>(Service Provide Framework)</p><p>服务接口（Service Interface）</p><pre><code class="java">// 相当于 Connection 接口，由 Sun 提供public interface Service {}</code></pre><p>服务提供者接口（Service Provide Interface）</p><pre><code class="java">// 相当于 Driver 接口，由第三方厂家实现public interface Provider {    Service newService();}</code></pre><p>无法实例化的类，用来注册和访问服务,</p><pre><code class="java">// 好比 DriverManagerpublic class Services{    private Services(){}    // 服务提供者 map    private static final Map&lt;String, Provider&gt; providers = new ConcurrentHashMap&lt;String, Provider&gt;();    // 默认的服务提供者名字    public static final String DEFAULT_PROVIDER_NAME = &quot;&lt;def&gt;&quot;;    // 服务提供者注册 API，即注册工厂实现，相当于 DriverManager.registerDriver    public static void registerDefaultProvider(Provider p){        registerProvider(DEFAULT_PROVIDER_NAME, p);    }    // 注册 Provider    public static void registerProvider(String name, Provider p){        providers.put(name, p);    }    // 服务访问 API，向外界提供业务实现，相当于 DriverManager.getConnectio    public static Service newInstance(){        return newInstance(DEFAULT_PROVIDER_NAME);    }    public static Service newInstance(String name){        Provider p = providers.get(name);        if (p == null) {            throw new IllegalArgumentException(&quot;No Provider registered with name:&quot; + name);        }        return p.newService();    }}</code></pre><h1 id="使用静态工厂方法的缺点"><a href="#使用静态工厂方法的缺点" class="headerlink" title="使用静态工厂方法的缺点"></a>使用静态工厂方法的缺点</h1><h2 id="类如果不含公有的或者受保护的构造器，就不能被子类化"><a href="#类如果不含公有的或者受保护的构造器，就不能被子类化" class="headerlink" title="类如果不含公有的或者受保护的构造器，就不能被子类化"></a>类如果不含公有的或者受保护的构造器，就不能被子类化</h2><p>对于公有的静态工厂所返回的非公有类，也同样如此。如，你想将 Collections Framework中的任何方便的实现类子类化，是不可能的。</p><p>但是这样有时候也有好处，即它鼓励程序员使用<strong>复合</strong>（compostion），而不是继承。</p><h2 id="程序员很难找到它们"><a href="#程序员很难找到它们" class="headerlink" title="程序员很难找到它们"></a>程序员很难找到它们</h2><p>在 API 文档中，他们没有像构造器那样在 API 文档中明确标识出来，因此对于提供了静态工厂方法而不是构造器的类来说，要想查明如何实例化一个类，这是非常困难的。javadoc 工具总有一天会注意到静态工厂方法。同时，你通过在类或者接口注释中关注静态工厂，并遵守标准的命名习惯，也可以弥补这一劣势。</p><p>下面是静态工厂的一些惯用名称:</p><ul><li><code>from</code>，A 类型转换方法，它接受单个参数并返回此类型的相应实例，例如：Date d = Date.from(instant);</li><li><code>of</code>，一个聚合方法，接受多个参数并返回该类型的实例，并把他们合并在一起，例如：Set<Rank> faceCards = EnumSet.of(JACK, QUEEN, KING);</li><li><code>valueOf</code>，不太严格讲，该方法返回的实例与它的参数具有相同的值。这样的静态工厂方法实际上是类型转换方法。例如：Integer.valueOf(1)</li><li><code>instance</code> 或 <code>getInstance</code>，返回的实例是通过方法的参数来描述的。但是不能够说与参数具有同样的值。对于单例 Singleton 来说，该方法没有参数，并返回唯一的实例。</li><li><code>create</code> 或 <code>newInstance</code>，向 getInstance 一样，但 newInstance 能够确保返回的每个实例都与所有其他实例不同。</li><li><code>getType</code>，就像 getInstance 一样，但是在工厂方法处于不同的类的时候使用(子类)。Type 表示工厂方法所返回的对象类型。例如：FileStore fs = Files.getFileStore(path);</li><li><code>newType</code>，就像 newInstance一样，但是在工厂方法处于不同的类的时候使用(子类)。Type 表示工厂方法所返回的对象类型。例如：BufferedReader br = Files.newBufferedReader(path);</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总之，静态工厂方法和公共构造方法都有它们的用途，并且了解它们的相对优点是值得的。<strong>通常，静态工厂更可取</strong>，因此避免在没有考虑静态工厂的情况下提供公共构造方法。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Effective Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jQuery each()方法</title>
      <link href="/2016/04/26/jQuery-each-%E6%96%B9%E6%B3%95/"/>
      <url>/2016/04/26/jQuery-each-%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="jQuery-each"><a href="#jQuery-each" class="headerlink" title="jQuery.each()"></a>jQuery.each()</h2><p>jQuery.each(collection, callback(indexInArray, valueOfElement))<br><strong>描述</strong>: 一个通用的迭代函数，它可以用来无缝迭代对象和数组。数组和类似数组的对象通过一个长度属性（如一个函数的参数对象）来迭代数字索引，从0到length - 1。其他对象通过其属性名进行迭代。</p><p>jQuery.each(object, callback)</p><ul><li><strong>object</strong></li></ul><p>遍历的对象。</p><ul><li><strong>callback</strong></li></ul><p>类型: Function( String index, Object value )<br>该函数会在每个对象上（迭代）调用。index 索引(键)， value 值。</p><a id="more"></a><p><code>$.each()</code>函数和 <code>$(selector).each()</code>是不一样的，那个是专门用来遍历一个<code>jQuery</code>对象。<code>$.each()</code>函数可用于迭代任何集合，无论是“名/值”对象（JavaScript对象）或数组。在迭代数组的情况下，回调函数每次传递一个数组索引和相应的数组值作为参数。（该值也可以通过访问<code>this</code>关键字得到，但是JavaScript将始终将<code>this</code>值作为一个<code>Object</code> ，即使它是一个简单的字符串或数字值。）。</p><p>注意: <code>$.each()</code>函数会在内部检索并且使用传递集合的 <code>length</code>属性。 所以，如果集合有一个名为length的属性 - 比如 <code>{bar: &#39;foo&#39;, length: 10}</code> - 这个函数可能无法正常工作(<em>未发现</em>)。</p><h3 id="例子一"><a href="#例子一" class="headerlink" title="例子一"></a>例子一</h3><pre><code class="js">$.each([52, 97], function(index, value) {  alert(index + &#39;: &#39; + value);});</code></pre><p>这将产生两个信息：</p><pre><code>0: 521: 97</code></pre><h3 id="例子二"><a href="#例子二" class="headerlink" title="例子二"></a>例子二</h3><p>如果对象是作为集合使用，回调函数每次传递一个键值对的：</p><pre><code class="js">var obj = {  &quot;flammable&quot;: &quot;inflammable&quot;,  &quot;duh&quot;: &quot;no duh&quot;};$.each( obj, function( key, value ) {  alert( key + &quot;: &quot; + value );});</code></pre><p>再次，这将产生两个信息：</p><pre><code>flammable: inflammableduh: no duh</code></pre><p>我们可以在<code>$.each()</code>返回<code>false</code>来终止迭代。返回非<code>false</code>相当于一个循环中的<code>continue</code>语句，这意味着，它会立即跳出当前的迭代，转到下一个迭代。</p><h2 id="selector-each"><a href="#selector-each" class="headerlink" title="$(selector).each()"></a>$(selector).each()</h2><p><code>each()</code> 方法规定为每个匹配元素规定运行的函数。专门用来遍历一个<code>jQuery</code>对象<br>返回 false 可用于及早停止循环。<br><strong>语法</strong><br>$(selector).each(function(index,element))</p><p><strong>function(index,element)</strong><br>必需。为每个匹配元素规定运行的函数。</p><ul><li><strong>index</strong> - 选择器的 <code>index</code> 位置</li><li><strong>element</strong> - 当前的元素（也可使用 &quot;this&quot; 选择器）</li></ul><pre><code class="html">&lt;ul&gt;    &lt;li&gt;foo&lt;/li&gt;    &lt;li&gt;bar&lt;/li&gt;&lt;/ul&gt;</code></pre><pre><code class="js">$( &quot;li&quot; ).each(function( index ) {  alert( index + &quot;: &quot;&quot; + $(this).text() );});</code></pre><p>列表中每一项会显示在下面的消息中：</p><pre><code>0: foo1: bar</code></pre><blockquote><p><a href="http://www.css88.com/jqapi-1.9/jQuery.each/" target="_blank" rel="noopener">http://www.css88.com/jqapi-1.9/jQuery.each/</a><br><a href="http://www.css88.com/jqapi-1.9/each/" target="_blank" rel="noopener">http://www.css88.com/jqapi-1.9/each/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> jQuery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jQuery text()，parseHTML() 方法</title>
      <link href="/2016/04/26/jQuery%20text()%EF%BC%8CparseHTML()%20%E6%96%B9%E6%B3%95/"/>
      <url>/2016/04/26/jQuery%20text()%EF%BC%8CparseHTML()%20%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><code>text()</code> 方法方法设置或返回被选元素的文本内容（会删除 <code>HTML</code> 标记）。</p><h2 id="设置文本内容"><a href="#设置文本内容" class="headerlink" title="设置文本内容"></a>设置文本内容</h2><a id="more"></a><pre><code class="html">&lt;html&gt;&lt;head&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/jquery/jquery.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;$(document).ready(function(){  $(&quot;.btn1&quot;).click(function(){    $(&quot;p&quot;).text(&quot;Hello world!&quot;);  });  //使用函数设置文本内容  //$(selector).text(function(index,oldcontent))  //index - 可选。接受选择器的 index 位置。  //oldcontent - 可选。接受选择器的当前内容。  $(&quot;button&quot;).click(function(){    $(&quot;p&quot;).text(function(n,x){      return x + &quot;这个 p 元素的 index 是：&quot; + n;    });  });});&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;This is a paragraph.&lt;/p&gt;&lt;p&gt;This is another paragraph.&lt;/p&gt;&lt;button class=&quot;btn1&quot;&gt;改变所有 p 元素的文本内容&lt;/button&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="在项目中遇到的问题"><a href="#在项目中遇到的问题" class="headerlink" title="在项目中遇到的问题"></a>在项目中遇到的问题</h2><p>需求：文本框使用富文本编辑器xheditor，要求文本框的内容不能为空。<br>分析：使用 <code>$(&quot;#textarea&quot;).val()</code> 获得的值，会包含 <code>html</code> 标签,如：<p>,这样无法判断是否为空。使用 <code>$(&quot;#textarea&quot;).text()</code> 获得的值一直为&quot;&quot;,所以采用以下方法。</p><pre><code class="js">String.prototype.LTrim = function () {  return this.replace(/(^\s*)|(\s*$)/g, &quot;&quot;);}var textarea = $(&quot;#textarea&quot;).val();var log = $( &quot;#log&quot; ), html = $.parseHTML( textarea );log.text(&quot;&quot;);//清空log.append( html );var textarea3 = log.text();if(textarea3== null || textarea3.LTrim()==&#39;&#39;){    alert(&quot;不能为空！&quot;);    return false;}</code></pre><p>在界面上加入</p><pre><code class="html">&lt;div id=&quot;log&quot; style=&quot;display: none;&quot;&gt;</code></pre><h2 id="jQuery-parseHTML"><a href="#jQuery-parseHTML" class="headerlink" title="jQuery.parseHTML"></a>jQuery.parseHTML</h2><p><strong>jQuery.parseHTML( data [, context ] [, keepScripts ] )</strong></p><ul><li><strong>data</strong><br>用来解析的HTML字符串。</li><li><strong>context</strong>(默认: <code>document</code>)<br>DOM元素的上下文，在这个上下文中将创建的HTML片段。</li><li><strong>keepScripts</strong> (默认: <code>false</code>)<br>一个布尔值，表明是否在传递的HTML字符串中包含脚本。</li></ul><p><code>jQuery.parseHTML</code>使用原生方法将字符串转换为一个DOM节点的集合，然后可以插入到文档。 这些方法渲染所有尾随或前导文本（即使只是空格）。 为了防止尾随/前导空格被转换为文本节点，你可以通过将HTML字符串传递给<a href="http://www.css88.com/jqapi-1.9/jQuery.trim/" target="_blank" rel="noopener"><code>jQuery .trim</code></a>。</p><p>默认情况下，如果没有指定或给定<code>null</code> 或 <code>undefined</code>，<code>context</code>是当前的<code>document</code>。如果<code>HTML</code>被用在另一个<code>document</code>中，比如一个<code>iframe</code>，该<code>frame</code>的文件可以使用。</p><h3 id="Security-Considerations（安全注意事项）"><a href="#Security-Considerations（安全注意事项）" class="headerlink" title="Security Considerations（安全注意事项）"></a>Security Considerations（安全注意事项）</h3><p>大多数的<code>jQuery</code>的<code>API</code>接受的<code>HTML</code>字符串将运行所包含在<code>HTML</code>中的脚本。<code>jQuery.parseHTML</code>不运行<code>HTML</code>中解析出来的脚本，除非 <code>keepScripts</code>参数为<code>true</code>。然而，它仍然是可能在大多数环境中间接地执行脚本，例如通过<code>&lt;img onerror&gt;</code>属性。调用者应该意识到这一点，并通过清理或避免任何不可信来源的输入，如<code>URL</code>或<code>cookies</code>，来防止它。为了未来的兼容性，当<code>keepScripts</code>为不确定的或<code>false</code>时，调用者不应该依赖于这个能力来运行任何脚本内容。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;  &lt;script src=&quot;http://code.jquery.com/jquery-latest.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;log&quot;&gt;  &lt;h3&gt;Content:&lt;/h3&gt;&lt;/div&gt;&lt;script&gt;var $log = $( &quot;#log&quot; ),    str = &quot;hello, &lt;b&gt;my name is&lt;/b&gt; jQuery.&quot;,    html = $.parseHTML( str ),    nodeNames = [];// Append the parsed HTML$log.append( html );// Gather the parsed HTML&#39;s node names$.each( html, function( i, el ) {    nodeNames[i] = &quot;&lt;li&gt;&quot; + el.nodeName + &quot;&lt;/li&gt;&quot;;});// Insert the node names$log.append( &quot;&lt;h3&gt;Node Names:&lt;/h3&gt;&quot; );$( &quot;&lt;ol&gt;&lt;/ol&gt;&quot; )  .append( nodeNames.join( &quot;&quot; ) )  .appendTo( $log );&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><div id="log">  <h3>Content:</h3>hello, <b>my name is</b> jQuery.<h3>Node Names:</h3><ol><li>#text</li><li>B</li><li>#text</li></ol></div><blockquote><p><a href="http://www.w3school.com.cn/jquery/manipulation_text.asp" target="_blank" rel="noopener">http://www.w3school.com.cn/jquery/manipulation_text.asp</a><br><a href="http://www.css88.com/jqapi-1.9/jQuery.parseHTML/" target="_blank" rel="noopener">http://www.css88.com/jqapi-1.9/jQuery.parseHTML/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> jQuery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>log4j使用笔记</title>
      <link href="/2016/04/13/log4j%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
      <url>/2016/04/13/log4j%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>日志是应用软件中不可缺少的部分，Apache的开源项目Log4j是一个功能强大的日志组件,提供方便的日志记录。<br>在<code>apache</code>网站：<a href="http://logging.apache.org/log4j/2.x/download.html" target="_blank" rel="noopener">http://logging.apache.org/log4j/2.x/download.html</a> 可以免费下载到Log4j 2最新版本的软件包。老版本<a href="http://logging.apache.org/log4j/1.2/download.html" target="_blank" rel="noopener">1.2.17</a>已停止维护。</p><h2 id="入门实例"><a href="#入门实例" class="headerlink" title="入门实例"></a>入门实例</h2><p>1、新建一个JAva工程，导入包log4j-1.2.17.jar<br>2、src同级创建并设置log4j.properties</p><a id="more"></a><pre><code class="properties">### 设置###log4j.rootLogger = debug,stdout,D,E### 输出信息到控制抬 ###log4j.appender.stdout = org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target = System.outlog4j.appender.stdout.layout = org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern = [%-5p] %d{yyyy-MM-dd HH:mm:ss,SSS} method:%l%n%m%n### 输出DEBUG 级别以上的日志到=E://logs/error.log ###log4j.appender.D = org.apache.log4j.DailyRollingFileAppenderlog4j.appender.D.File = E://logs/log.loglog4j.appender.D.Append = truelog4j.appender.D.Threshold = DEBUGlog4j.appender.D.layout = org.apache.log4j.PatternLayoutlog4j.appender.D.layout.ConversionPattern = %-d{yyyy-MM-dd HH:mm:ss}  [ %t:%r ] - [ %p ]  %m%n### 输出ERROR 级别以上的日志到=E://logs/error.log ###log4j.appender.E = org.apache.log4j.DailyRollingFileAppenderlog4j.appender.E.File =E://logs/error.loglog4j.appender.E.Append = truelog4j.appender.E.Threshold = ERROR# Keep three backup files.保持三个备份文件log4j.appender.logfile.MaxBackupIndex=3log4j.appender.E.layout = org.apache.log4j.PatternLayoutlog4j.appender.E.layout.ConversionPattern = %-d{yyyy-MM-dd HH:mm:ss}  [ %t:%r ] - [ %p ]  %m%n</code></pre><p>3、设置日志内容</p><pre><code class="java">import org.apache.log4j.Logger;public class Test {    private static Logger logger = Logger.getLogger(Test.class);    public static void main(String[] args) {        // 记录debug级别的信息        logger.debug(&quot;This is debug message.&quot;);        // 记录info级别的信息        logger.info(&quot;This is info message.&quot;);        // 记录error级别的信息        logger.error(&quot;This is error message.&quot;);    }}</code></pre><p>4、输出结果<br>（1）首先是控制台的信息<br>（2）再来看输出的文件<br>内容如下，发现已按照要求输出到对应的文档中去了。</p><h2 id="Log4j基本使用方法"><a href="#Log4j基本使用方法" class="headerlink" title="Log4j基本使用方法"></a>Log4j基本使用方法</h2><h3 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h3><p>每个Logger都被了一个日志级别（log level），用来控制日志信息的输出。日志级别从高到低分为：</p><ul><li>off       最高等级，用于关闭所有日志记录。</li><li>fatal     指出每个严重的错误事件将会导致应用程序的退出。</li><li>error     指出虽然发生错误事件，但仍然不影响系统的继续运行。</li><li>warm      表明会出现潜在的错误情形。</li><li>info      一般和在粗粒度级别上，强调应用程序的运行全程。</li><li>debug     一般用于细粒度级别上，对调试应用程序非常有帮助。</li><li>all       最低等级，用于打开所有日志记录。</li></ul><p>Log4j只建议使用4个级别，优先级从高到低分别是error,warn,info和debug。通过使用日志级别，可以控制应用程序中相应级别日志信息的输出。例如，如果使用b了info级别，则应用程序中所有低于info级别的日志信息(如debug)将不会被打印出来。</p><h3 id="定义配置文件"><a href="#定义配置文件" class="headerlink" title="定义配置文件"></a>定义配置文件</h3><p>1.配置根Logger，其语法为：</p><pre><code class="properties">log4j.rootLogger = [ level ] , appenderName, appenderName, …</code></pre><p>其中，<code>level</code> 是日志记录的优先级,<code>appenderName</code>就是指<code>B</code>日志信息输出到哪个地方。您可以同时指定多个输出目的地。<br>2.配置日志信息输出目的地Appender，其语法为：</p><pre><code class="properties">log4j.appender.appenderName = org.apache.log4j.ConsoleAppenderlog4j.appender.appenderName.option1 = value1…log4j.appender.appenderName.option = valueN</code></pre><p>其中，Log4j提供的appender有以下几种：</p><pre><code class="java">org.apache.log4j.ConsoleAppender（控制台），org.apache.log4j.FileAppender（文件），org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件），org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件），org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方）</code></pre><p>3.配置日志信息的格式（布局），其语法为：</p><pre><code class="properties">log4j.appender.appenderName.layout = fully.qualified.name.of.layout.classlog4j.appender.appenderName.layout.option1 = value1…log4j.appender.appenderName.layout.option = valueN</code></pre><p>其中，Log4j提供的layout有以e几种：</p><pre><code class="java">org.apache.log4j.HTMLLayout（以HTML表格形式布局），org.apache.log4j.PatternLayout（可以灵活地指定布局模式），org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串），org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息）</code></pre><p>Log4J采用类似C语言中的printf函数的打印格式格式化日志信息，打印参数如下： %m 输出代码中指定的消息</p><pre><code>log4j.appender.R.layout.ConversionPattern = %-d{yyyy-MM-dd HH\:mm\:ss} [%c]-[%p] %m%n%p 输出优先级，即DEBUG，INFO，WARN，ERROR，FATAL%r 输出自应用启动到输出该log信息耗费的毫秒数%c 输出所属的类目，通常就是所在类的全名%t 输出产生该日志事件的线程名%n 输出一个回车换行符，Windows平台为“rn”，Unix平台为“n”%d 输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d{yyy MMM dd HH:mm:ss,SSS}，输出类似：2002年10月18日 22：10：28，921%l 输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数。举例：Testlog4.main(TestLog4.java:10)</code></pre><blockquote><p><a href="http://blog.csdn.net/evankaka/article/details/45815047" target="_blank" rel="noopener">Log4j详细使用教程</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> log4j </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>将System.out输出到log4j</title>
      <link href="/2016/04/12/%E5%B0%86System-out%E8%BE%93%E5%87%BA%E5%88%B0log4j/"/>
      <url>/2016/04/12/%E5%B0%86System-out%E8%BE%93%E5%87%BA%E5%88%B0log4j/</url>
      
        <content type="html"><![CDATA[<p>在项目中我们通常有这样的需求，一般情况<code>System.out.println()</code>是输出到控制台，但我们希望<code>System.out</code>的输出也记录到<code>log</code>中，还有<code>System.err</code>同样也记录到<code>log</code>中，一些<code>runtime</code>的<code>exception</code>会通过<code>System.err</code>打出到控制台，我们同样希望把这些也都输出到<code>log</code>。<br><code>System</code>类有<code>setOut</code>方法，可以设置<code>output stream</code>，进行<code>output</code>重定向，所以我们可以传入一个新的<code>PrintStream</code>对象，重写<code>PrintStream</code>的<code>print</code>方法，把要<code>print</code>的值都通过<code>log4j</code>写入到<code>log</code>，因此我们实现一个这样的类：</p><a id="more"></a><pre><code class="java">import java.io.PrintStream;import org.apache.commons.logging.Log;import org.apache.commons.logging.LogFactory;public class StdOutErrRedirect {    private final static Log logger = LogFactory.getLog(StdOutErrRedirect.class);    public static void redirectSystemOutAndErrToLog() {        PrintStream printStreamForOut = createLoggingWrapper(System.out, false);        PrintStream printStreamForErr = createLoggingWrapper(System.out, true);        System.setOut(printStreamForOut);        System.setErr(printStreamForErr);    }    public static PrintStream createLoggingWrapper(final PrintStream printStream, final boolean isErr) {        return new PrintStream(printStream) {            @Override            public void print(final String string) {                if (!isErr){                    logger.debug(string);                }else{                    logger.error(string);                }            }            @Override            public void print(boolean b) {                if (!isErr){                    logger.debug(Boolean.valueOf(b));                }else{                    logger.error(Boolean.valueOf(b));                }            }            @Override            public void print(char c) {                if (!isErr){                    logger.debug(Character.valueOf(c));                }else{                    logger.error(Character.valueOf(c));                }            }            @Override            public void print(int i) {                if (!isErr){                    logger.debug(String.valueOf(i));                }else{                    logger.error(String.valueOf(i));                }            }            @Override            public void print(long l) {                if (!isErr){                    logger.debug(String.valueOf(l));                }else{                    logger.error(String.valueOf(l));                }            }            @Override            public void print(float f) {                if (!isErr){                    logger.debug(String.valueOf(f));                }else{                    logger.error(String.valueOf(f));                }            }            @Override            public void print(double d) {                if (!isErr){                    logger.debug(String.valueOf(d));                }else{                    logger.error(String.valueOf(d));                }            }            @Override            public void print(char[] x) {                if (!isErr){                    logger.debug(x == null ? null : new String(x));                }else{                    logger.error(x == null ? null : new String(x));                }            }            @Override            public void print(Object obj) {                if (!isErr){                    logger.debug(obj);                }else{                    logger.error(obj);                }            }        };    }}</code></pre><blockquote><p><a href="http://seeallsea.iteye.com/blog/2117458" target="_blank" rel="noopener">http://seeallsea.iteye.com/blog/2117458</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> log4j </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>批处理常用特殊符号</title>
      <link href="/2016/03/30/%E6%89%B9%E5%A4%84%E7%90%86%E5%B8%B8%E7%94%A8%E7%89%B9%E6%AE%8A%E7%AC%A6%E5%8F%B7/"/>
      <url>/2016/03/30/%E6%89%B9%E5%A4%84%E7%90%86%E5%B8%B8%E7%94%A8%E7%89%B9%E6%AE%8A%E7%AC%A6%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="1、-命令行回显屏蔽符"><a href="#1、-命令行回显屏蔽符" class="headerlink" title="1、@ 命令行回显屏蔽符"></a>1、@ 命令行回显屏蔽符</h2><p>这个字符在批处理中的意思是关闭当前行的回显。<br><code>ECHO OFF</code>可以关闭掉整个批处理命令的回显，但不能关掉<code>ECHO OFF</code>这个命令，现在我们在<code>ECHO OFF</code>这个命令前加个<code>@</code>，就可以达到所有命令均不回显的要求</p><pre><code class="bat">@echo offecho &quot;测试&quot;pause</code></pre><pre><code>&quot;测试&quot;请按任意键继续. . .</code></pre><a id="more"></a><h2 id="2、-批处理变量引导符"><a href="#2、-批处理变量引导符" class="headerlink" title="2、% 批处理变量引导符"></a>2、% 批处理变量引导符</h2><p>这个百分号严格来说是算不上命令的，它只是批处理中的参数而已</p><h3 id="1-多个-一起使用"><a href="#1-多个-一起使用" class="headerlink" title="1. 多个%一起使用"></a>1. 多个<code>%</code>一起使用</h3><p>如果要显示%本身时，需要在前面用%来转义。</p><pre><code class="bat">@echo offecho 一个百分号：%%echo 两个百分号：%%%%echo 三个百分号：%%%%%%pauseset /a num=4%%2echo 4除以2的余数为 %num%pause</code></pre><pre><code class="bat">@echo offecho %0echo %%0pause</code></pre><pre><code>&quot;E:\test\batch\11.bat&quot;%0请按任意键继续. . .</code></pre><h3 id="2-引用变量用-var"><a href="#2-引用变量用-var" class="headerlink" title="2. 引用变量用%var%"></a>2. <strong>引用变量</strong>用<code>%var%</code></h3><pre><code class="bat">@echo offset a=哈哈echo %a%pause</code></pre><pre><code>哈哈请按任意键继续. . .</code></pre><h3 id="3-调用程序外部参数用-1至-9等等"><a href="#3-调用程序外部参数用-1至-9等等" class="headerlink" title="3. 调用程序外部参数用%1至%9等等"></a>3. 调用程序外部参数用<code>%1</code>至<code>%9</code>等等</h3><p> <code>%0 %1 %2 %3 %4 %5 %6 %7 %8 %9 %*</code>为命令行传递给批处理的参数</p><ol><li><code>%0</code> 批处理文件本身，包括完整的路径和扩展名</li><li><code>%1</code> 第一个参数</li><li><code>%9</code> 第九个参数</li><li><code>%*</code> 从第一个参数开始的所有参数</li><li>参数<code>%0</code>具有特殊的功能，可以调用批处理自身，以达到批处理本身循环的目的，也可以复制文件自身等等。<br>例：最简单的复制文件自身的方法<pre><code class="bat">copy %0 d:\wind.bat</code></pre><h2 id="3、-gt-重定向符"><a href="#3、-gt-重定向符" class="headerlink" title="3、&gt; 重定向符##"></a>3、&gt; 重定向符##</h2>输出重定向命令<br>这个字符的意思是传递并且覆盖，他所起的作用是将运行的结果传递到后面的范围（后边可以是文件，也可以是默认的系统控制台） 在NT系列命令行中，重定向的作用范围由整个命令行转变为单个命令语句，受到了命令分隔符&amp;,&amp;&amp;,||和语句块的制约限制。<br>比如： 使用命令：<code>echo hello &gt;1.txt</code>将建立文件<code>1.txt</code>，内容为<code>hello</code>（注意行尾有一空格）<h2 id="4、-gt-gt-重定向符"><a href="#4、-gt-gt-重定向符" class="headerlink" title="4、&gt;&gt; 重定向符"></a>4、&gt;&gt; 重定向符</h2>输出重定向命令 这个符号的作用和&gt;有点类似，但他们的区别是&gt;&gt;是传递并在文件的末尾追加，而&gt;是覆盖<br>用法同上<br>同样拿1.txt做例子<br>使用命令：<pre><code class="bat">echo hello &gt; 1.txt echo world &gt;&gt;1.txt</code></pre>这时候1.txt 内容如下:<pre><code>hello world</code></pre><h2 id="5、-lt-重定向符"><a href="#5、-lt-重定向符" class="headerlink" title="5、&lt; 重定向符"></a>5、&lt; 重定向符</h2>这三个命令也是管道命令，但它们一般不常用</li></ol><ul><li><code>&lt;</code>，<strong>输入重定向命令，从文件中读入命令输入</strong>，而不是从键盘中读入。<pre><code class="bat">@echo offecho 2005-05-01&gt;temp.txtdate &lt;temp.txtdel temp.txt</code></pre>这样就可以不等待输入直接修改当前日期</li></ul><pre><code class="bat">@echo offset /p str=&lt;%0echo %str%pause</code></pre><p>运行显示批处理文件自身的第一行：</p><pre><code>@echo off</code></pre><h2 id="6、-命令管道符"><a href="#6、-命令管道符" class="headerlink" title="6、|  命令管道符"></a>6、|  命令管道符</h2><p>格式：第一条命令 | 第二条命令 [| 第三条命令...]<br>将第一条命令的结果作为第二条命令的参数来使用，记得在unix中这种方式很常见。</p><p>例如：</p><pre><code class="bat">E:\test\batch&gt;dir e:| find /n &quot;bat&quot;[4] E:\test\batch 的目录[9]2016/03/30  21:57                48 11.bat[10]2016/03/28  10:06                15 2.bat[11]2016/03/28  13:48               363 3.bat[12]2016/03/28  11:20               216 4.bat[13]2016/03/28  15:19               102 5.bat[14]2016/03/29  15:36               137 6.bat</code></pre><p>以上命令是：查找C：\所有，并发现TXT字符串。</p><p>在不使format的自动格式化参数时，我是这样来自动格式化A盘的</p><pre><code class="bat">echo y|format a: /s /q /v:system</code></pre><p>用过format的都知道，再格盘时要输入y来确认是否格盘，这个命令前加上echo y并用|字符来将echo y的结果传给format命令</p><p>从而达到自动输入y的目的</p><h2 id="7、-转义字符"><a href="#7、-转义字符" class="headerlink" title="7、^  转义字符"></a>7、^  转义字符</h2><p><code>^</code>是对特殊符号<code>&lt;,&gt;,&amp;</code>的前导字符，在命令中他将以上3个符号的特殊功能去掉，仅仅只把他们当成符号而不使用他们的特殊意义。</p><p>比如</p><pre><code class="bat">echo test ^&gt;1.txt::结果：test ^&gt;1.txt，没有追加在1.txt里</code></pre><p>另外，此转义字符还可以用作续行符号。<br>举个简单的例子：</p><pre><code class="bat">@echo offecho 英雄^是^男人pause::结果：英雄是男人</code></pre><p>为什么转义字符放在行尾可以起到续行符的作用呢？原因很简单，因为每行末尾还有一个看不见的符号，即回车符，转义字符位于行尾时就让回车符失效了，从而起到了续行的作用。</p><h2 id="8、-amp-组合命令"><a href="#8、-amp-组合命令" class="headerlink" title="8、&amp;  组合命令"></a>8、&amp;  组合命令</h2><p><strong>顺序执行</strong></p><p>语法：第一条命令 &amp; 第二条命令 [&amp; 第三条命令...]<br><code>&amp;、&amp;&amp;、||</code>为组合命令，顾名思义，就是可以把多个命令组合起来当一个命令来执行。这在批处理脚本里是允许的，而且用的非常广泛。因为<strong>批处理认行不认命令数目</strong>。</p><p><code>&amp;</code>这个符号允许在一行中使用2个以上不同的命令，<strong>当第一个命令执行失败了，也不影响后边的命令执行。</strong><br>这里&amp;两边的命令是顺序执行的，从前往后执行。<br>比如：</p><pre><code class="bat">E:\test\batch&gt;dir z:\ &amp; dir y:\ &amp; dir e:\系统找不到指定的路径。系统找不到指定的路径。 驱动器 E 中的卷没有标签。 卷的序列号是 08F6-60CC e:\ 的目录2016/03/28  10:15    &lt;DIR&gt;          test               0 个文件              0 字节               1 个目录 425,950,359,552 可用字节</code></pre><p>以上命令会连续显示z,y,e盘的内容，不理会该盘是否存在</p><h2 id="9、-amp-amp-组合命令"><a href="#9、-amp-amp-组合命令" class="headerlink" title="9、&amp;&amp; 组合命令"></a>9、&amp;&amp; 组合命令</h2><p><strong>前面指令成功，才执行后面指令</strong></p><p>语法：第一条命令 &amp;&amp; 第二条命令 [&amp;&amp; 第三条命令...]</p><p>用这种方法可以同时执行多条命令，当<strong>碰到执行出错的命令后将不执行后面的命令</strong>，如果一直没有出错则一直执行完所有命令<br>这个命令和上边的类似，但区别是，第一个命令失败时，后边的命令也不会执行</p><pre><code class="bat">E:\test\batch&gt;dir z:\ &amp;&amp; dir y:\ &amp;&amp; dir e:\系统找不到指定的路径。</code></pre><h2 id="10、-组合命令"><a href="#10、-组合命令" class="headerlink" title="10、||  组合命令"></a>10、||  组合命令</h2><p><strong>前面指令失败，才执行后面指令</strong></p><p>语法：第一条命令 || 第二条命令 [|| 第三条命令...]</p><p>用这种方法可以同时执行多条命令，<strong>当一条命令失败后才执行第二条命令</strong>，当碰到执行正确的命令后将不执行后面的命令，如果没有出现正确的命令则一直执行完所有命令。</p><pre><code class="bat">E:\test\batch&gt;dir z:\ || dir e:\ || dir c:\系统找不到指定的路径。 驱动器 E 中的卷没有标签。 卷的序列号是 08F6-60CC e:\ 的目录2016/03/28  10:15    &lt;DIR&gt;          test               0 个文件              0 字节               1 个目录 425,950,359,552 可用字节</code></pre><h2 id="11、-quot-quot-字符串界定符"><a href="#11、-quot-quot-字符串界定符" class="headerlink" title="11、&quot;&quot;  字符串界定符"></a>11、&quot;&quot;  字符串界定符</h2><p>双引号允许在字符串中包含空格，进入一个特殊目录可以用如下方法</p><pre><code class="bat">C:\&gt;cd &quot;Program Files&quot;C:\&gt;cd Pro*  :: C:\Program Files&gt;C:\&gt;cd Progra~1  :: C:\PROGRA~1&gt;</code></pre><p>以上三种方法都可以进入program files这个目录<br><strong>cd Progra<del>1  这种方式貌似要输入  前6位字母</del>1</strong></p><pre><code class="bat">C:\PROGRA~1&gt;dir C:\PROGRA~1 的目录2015/06/12  11:20    &lt;DIR&gt;          Common FilesC:\PROGRA~1&gt;cd com~1系统找不到指定的路径。C:\PROGRA~1&gt;cd Comm~1系统找不到指定的路径。C:\PROGRA~1&gt;cd Commo~1系统找不到指定的路径。C:\PROGRA~1&gt;cd Common~1 :: C:\PROGRA~1\COMMON~1&gt;</code></pre><h2 id="12、-逗号"><a href="#12、-逗号" class="headerlink" title="12、, 逗号"></a>12、, 逗号</h2><p>逗号相当于空格，在某些情况下“,”可以用来当做空格使</p><p>比如</p><pre><code class="bat">dir,c:\</code></pre><h2 id="13、-分号"><a href="#13、-分号" class="headerlink" title="13、; 分号"></a>13、; 分号</h2><p>分号，当命令相同时，可以将不同目标用；来隔离，但执行效果不变，如执行过程中发生错误，则只返回错误报告，但程序仍会执行。（有人说不会继续执行，其实测试一下就知道了）</p><h3 id="例1："><a href="#例1：" class="headerlink" title="例1："></a>例1：</h3><pre><code class="bat">dir c:\;d:\;e:\;z:\</code></pre><p>以上命令相当于</p><pre><code class="bat">dir c:\dir d:\dir e:\dir z:\</code></pre><p>不同的是：如果其中z盘不存在</p><pre><code class="bat">E:\test\batch&gt;dir c:\;d:\;e:\;z:\系统找不到指定的路径。</code></pre><h3 id="例2："><a href="#例2：" class="headerlink" title="例2："></a>例2：</h3><pre><code class="bat">dir c:\;e:\1.txt</code></pre><p>以上命令相当于</p><pre><code class="bat">dir c:\dir e:\1.txt</code></pre><p>其中文件e:\1.txt不存在，但e盘存在，有错误提示，但命令仍会执行。</p><pre><code class="bat">E:\test\batch&gt;dir c:\;e:\1.txt c:\ 的目录2015/11/23  15:20    &lt;DIR&gt;          data              22 个目录 15,621,087,232 可用字节 驱动器 E 中的卷没有标签。 卷的序列号是 08F6-60CC e:\ 的目录找不到文件</code></pre><p><strong>如果目标路径不存在，则终止执行；如果路径存在，仅文件不存在，则继续执行。</strong></p><h2 id="14、-括号"><a href="#14、-括号" class="headerlink" title="14、() 括号"></a>14、() 括号</h2><p>小括号在批处理编程中有特殊的作用，左右括号必须成对使用，括号中可以包括多行命令，这些命令将被看成一个整体，视为一条命令行。<br><strong>括号在for语句和if语句中常见</strong>，用来嵌套使用循环或条件语句，其实括号()也可以单独使用，请看例子。<br>例：<br>命令：</p><pre><code class="bat">echo 1 &amp; echo 2 &amp; echo 3::可以写成：(echo 1echo 2echo 3)</code></pre><p>上面两种写法效果一样，这两种写法都被视为是一条命令行。<br>注意：这种多条命令被视为一条命令行时，如果其中有变量，就涉及到变量延迟的问题。</p><h2 id="15、-感叹号"><a href="#15、-感叹号" class="headerlink" title="15、! 感叹号"></a>15、! 感叹号</h2><p>没啥说的，在<strong>变量延迟</strong>问题中，用来表示变量，即%var%应该表示为!var!，请看setlocal命令介绍。</p><blockquote><p><a href="http://xiangkg.blog.163.com/blog/static/5668850420101268115584" target="_blank" rel="noopener">http://xiangkg.blog.163.com/blog/static/5668850420101268115584</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>批处理同时运行多个程序</title>
      <link href="/2016/03/28/%E6%89%B9%E5%A4%84%E7%90%86%E5%90%8C%E6%97%B6%E8%BF%90%E8%A1%8C%E5%A4%9A%E4%B8%AA%E7%A8%8B%E5%BA%8F/"/>
      <url>/2016/03/28/%E6%89%B9%E5%A4%84%E7%90%86%E5%90%8C%E6%97%B6%E8%BF%90%E8%A1%8C%E5%A4%9A%E4%B8%AA%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>由于每次开机后需要开启的软件过多，所以使用批处理来同时打开多个程序。</p><pre><code class="bat">@echo off&quot;C:\Program Files (x86)\Tencent\QQLite\Bin\QQScLauncher.exe&quot;ECHO 开启QQ&quot;C:\Users\bin\AppData\Local\MyEclipse Professional 2014\myeclipse.exe&quot;ECHO 开启myEclipse</code></pre><p>这样运行结果是只运行了 QQ 就停下来了，Dos 是单任务运行方式，得关掉最新运行的 QQ 才能继续执行下面的命令。</p><a id="more"></a><h2 id="用start命令"><a href="#用start命令" class="headerlink" title="用start命令"></a>用start命令</h2><pre><code class="bat">@echo offstart &quot;C:\Program Files (x86)\Tencent\QQLite\Bin\QQScLauncher.exe&quot;ECHO 开启QQstart &quot;C:\Users\bin\AppData\Local\MyEclipse Professional 2014\myeclipse.exe&quot;ECHO 开启myEclipse</code></pre><p>这样更不行，弹出两个运行窗口，显示的内容是程序所在目录……</p><h2 id="原始的-dos-命令"><a href="#原始的-dos-命令" class="headerlink" title="原始的 dos 命令"></a>原始的 dos 命令</h2><pre><code class="bat">@echo offcd C:\Program Files (x86)\Tencent\QQLite\Bin\start QQScLauncher.exeECHO 开启QQcd C:\Users\bin\AppData\Local\MyEclipse Professional 2014\start myeclipse.exeECHO 开启myEclipse</code></pre><p>成功</p><h2 id="start正确的使用"><a href="#start正确的使用" class="headerlink" title="start正确的使用"></a>start正确的使用</h2><pre><code class="bat">@echo offstart &quot;&quot; &quot;C:\Program Files (x86)\Tencent\QQLite\Bin\QQScLauncher.exe&quot;ECHO 开启QQstart &quot;&quot; &quot;C:\Users\bin\AppData\Local\MyEclipse Professional 2014\myeclipse.exe&quot;ECHO 开启myEclipse</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript中Window对象</title>
      <link href="/2016/03/17/JavaScript%E4%B8%ADWindow%E5%AF%B9%E8%B1%A1/"/>
      <url>/2016/03/17/JavaScript%E4%B8%ADWindow%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="Window-对象"><a href="#Window-对象" class="headerlink" title="Window 对象"></a>Window 对象</h2><p><code>Window</code> 对象表示<strong>浏览器中打开的窗口</strong>。<br>如果文档包含框架（<code>frame</code> 或 <code>iframe</code> 标签），浏览器会为 <code>HTML</code> 文档创建一个 <code>window</code> 对象，并为每个框架创建一个额外的 <code>window</code> 对象。</p><h2 id="Window-对象集合frames"><a href="#Window-对象集合frames" class="headerlink" title="Window 对象集合frames[]"></a>Window 对象集合frames[]</h2><p>返回窗口中所有命名的框架。<br>该集合是 <code>Window</code> 对象的数组，每个 <code>Window</code> 对象在窗口中含有一个框架或 <code>&lt;iframe&gt;</code>。属性 <code>frames.length</code> 存放数组 <code>frames[]</code> 中含有的元素个数。注意，<code>frames[]</code> 数组中引用的框架可能还包括框架，它们自己也具有 <code>frames[]</code> 数组。</p><a id="more"></a><pre><code class="html">&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;demo&lt;/TITLE&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;&lt;/HEAD&gt;  &lt;frameset id =&quot;_content&quot; cols=&quot;178,*&quot; bordercolor=&quot;#2CA6DA&quot; BORDER = &quot;0&quot;&gt;    &lt;FRAME SRC=&quot;List.do&quot; name=&quot;tree&quot; noresize SCROLLING=&quot;auto&quot; MARGINWIDTH=0 MARGINHEIGHT=0&gt;    &lt;FRAME SRC=&quot;enterIn.do&quot; name=&quot;main&quot; noresize  SCROLLING=&quot;auto&quot; MARGINWIDTH=0 MARGINHEIGHT=0&gt;  &lt;/frameset&gt;&lt;/HTML&gt;</code></pre><pre><code class="js">window.frames[&quot;main&quot;]//获得main的window对象window.frames[&quot;tree&quot;]//获得tree的window对象</code></pre><h2 id="Window-对象属性"><a href="#Window-对象属性" class="headerlink" title="Window 对象属性"></a>Window 对象属性</h2><h3 id="closed"><a href="#closed" class="headerlink" title="closed"></a>closed</h3><p>closed 属性可返回一个布尔值，该值声明了窗口是否已经关闭。该属性为只读。<br>当浏览器窗口关闭时，表示该窗口的 Windows 对象并不会消失，它将继续存在，不过它的 closed 属性将设置为 true。</p><p><strong>实例：</strong><a href="/demo/JavaScript中Window对象/win_closed.html">检测窗口是否关闭</a></p><h3 id="document"><a href="#document" class="headerlink" title="document"></a>document</h3><p>对 <code>Document</code> 对象的只读引用。请参阅 <a href="http://www.w3school.com.cn/jsref/dom_obj_document.asp" target="_blank" rel="noopener">Document 对象</a>。</p><h3 id="history"><a href="#history" class="headerlink" title="history"></a>history</h3><p>对 <code>History</code> 对象的只读引用。请参数 <a href="http://www.w3school.com.cn/jsref/dom_obj_history.asp" target="_blank" rel="noopener">History 对象</a>。</p><h3 id="location"><a href="#location" class="headerlink" title="location"></a>location</h3><p>用于窗口或框架的 <code>Location</code> 对象。请参阅 <a href="http://www.w3school.com.cn/jsref/dom_obj_location.asp" target="_blank" rel="noopener">Location 对象</a>。</p><h3 id="Navigator"><a href="#Navigator" class="headerlink" title="Navigator"></a>Navigator</h3><p>对 <a href="http://www.w3school.com.cn/jsref/dom_obj_navigator.asp" target="_blank" rel="noopener">Navigator</a> 对象的只读引用。</p><h3 id="Screen"><a href="#Screen" class="headerlink" title="Screen"></a>Screen</h3><p>对 <a href="http://www.w3school.com.cn/jsref/dom_obj_screen.asp" target="_blank" rel="noopener">Screen</a> 对象的只读引用。</p><h3 id="name"><a href="#name" class="headerlink" title="name"></a>name</h3><p><code>window.name</code>属性用于设置当前浏览器窗口的名字。它有一个特点，就是浏览器刷新后，该属性保持不变。所以，可以把值存放在该属性内，然后<strong>跨页面、甚至跨域名使用</strong>。当然，这个值有可能被其他网站的页面改写。<br>该名称是在 <code>open()</code> 方法创建窗口时指定的或者使用一个 <code>&lt;frame&gt;</code> 标记的 <code>name</code> 属性指定的。<br>窗口的名称可以用作一个 <code>&lt;a&gt;</code> 或者 <code>&lt;form&gt;</code> 标记的 <a href="http://www.w3school.com.cn/jsref/prop_anchor_target.asp" target="_blank" rel="noopener">target</a> 属性的值。以这种方式使用 <a href="http://www.w3school.com.cn/jsref/prop_anchor_target.asp" target="_blank" rel="noopener">target</a> 属性<strong>声明了超链接文档或表单提交结果应该显示于指定的窗口或框架中</strong>。</p><pre><code class="js">window.name = &quot;Hello World!&quot;;console.log(window.name);</code></pre><p>各个浏览器对这个值的储存容量有所不同，但是一般来说，可以高达几MB。</p><p>该属性只能保存字符串，且当浏览器窗口关闭后，所保存的值就会消失。因此局限性比较大，但是与<code>iFrame</code>窗口通信时，非常有用。</p><p><a href="/demo/JavaScript中Window对象/win_name.html">返回新窗口的名称,设置超链接文档显示于指定的窗口或框架中</a></p><h3 id="innerheight-innerwidth"><a href="#innerheight-innerwidth" class="headerlink" title="innerheight,innerwidth"></a>innerheight,innerwidth</h3><p>返回窗口的文档显示区的高度，宽度。<br>只读属性，声明了窗口的文档显示区的高度和宽度，以像素计。<br>这里的宽度和高度不包括菜单栏、工具栏以及滚动条等的高度。<br>IE 不支持这些属性。它用 <code>document.documentElement</code> 或 <code>document.body</code> （与 IE 的版本相关）的 <code>clientWidth</code> 和 <code>clientHeight</code> 属性作为替代。</p><pre><code class="js">var winHeight = 0;var winWidth = 0;//获取窗口宽度if (window.innerWidth)    winWidth = window.innerWidth;else if ((document.body) &amp;&amp; (document.body.clientWidth))    winWidth = document.body.clientWidth;//获取窗口高度if (window.innerHeight)    winHeight = window.innerHeight;else if ((document.body) &amp;&amp; (document.body.clientHeight))    winHeight = document.body.clientHeight;//通过深入Document内部对body进行检测，获取窗口大小if (document.documentElement &amp;&amp; document.documentElement.clientHeight &amp;&amp; document.documentElement.clientWidth){    winHeight = document.documentElement.clientHeight;    winWidth = document.documentElement.clientWidth;}//Document.documentElement 是一个只读属性，返回文档对象（document）的根元素（例如，HTML文档的 &lt;html&gt; 元素）。//返回当前文档中的&lt;body&gt;元素或者&lt;frameset&gt;元素.</code></pre><h3 id="parent"><a href="#parent" class="headerlink" title="parent"></a>parent</h3><p>返回当前窗口的父窗口对象.</p><p>如果一个窗口没有父窗口,则它的 parent 属性为自身的引用.</p><h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><p>top 属性返回最顶层的先辈窗口。</p><h3 id="opener"><a href="#opener" class="headerlink" title="opener"></a>opener</h3><p>opener 属性是一个可读可写的属性，可返回对创建该窗口的 Window 对象的引用。<br>opener 属性非常有用，创建的窗口可以引用创建它的窗口所定义的属性和函数。</p><pre><code class="js">myWindow=window.open(&#39;&#39;,&#39;&#39;,&#39;width=200,height=100&#39;)myWindow.document.write(&quot;This is &#39;myWindow&#39;&quot;)myWindow.focus()myWindow.opener.document.write(&quot;This is the parent window&quot;)//调用父窗口</code></pre><h2 id="Window-对象方法"><a href="#Window-对象方法" class="headerlink" title="Window 对象方法"></a>Window 对象方法</h2><h3 id="open"><a href="#open" class="headerlink" title="open()"></a>open()</h3><p><strong>open() 方法用于打开一个新的浏览器窗口或查找一个已命名的窗口。</strong></p><table>   <tbody><tr>    <th style="width:15%">参数</th>    <th>描述</th>  </tr>    <tr>    <td>URL</td>    <td>一个可选的字符串，声明了要在新窗口中显示的文档的 URL。如果省略了这个参数，或者它的值是空字符串，那么新窗口就不会显示任何文档。</td>  </tr>  <tr>    <td>name</td>    <td>一个可选的字符串，该字符串是一个由逗号分隔的特征列表，其中包括数字、字母和下划线，该字符声明了新窗口的名称。这个名称可以用作标记 &lt;a&gt; 和 &lt;form&gt; 的属性 target 的值。如果该参数指定了一个已经存在的窗口，那么 open() 方法就不再创建一个新窗口，而只是返回对指定窗口的引用。在这种情况下，features 将被忽略。</td>  </tr>  <tr>    <td>features</td>    <td>一个可选的字符串，声明了新窗口要显示的标准浏览器的特征。如果省略该参数，新窗口将具有所有标准特征。在<a href="#窗口特征">窗口特征</a>这个表格中，我们对该字符串的格式进行了详细的说明。</td>  </tr>    <tr>    <td>replace<p></p></td>    <td>    <p>一个可选的布尔值。规定了装载到窗口的 URL 是在窗口的浏览历史中创建一个新条目，还是替换浏览历史中的当前条目。支持下面的值：</p>    <ul>        <li>true - URL 替换浏览历史中的当前条目。</li>        <li>false - URL 在浏览历史中创建新的条目。</li>    </ul>    </td>  </tr></tbody></table><h4 id="窗口特征"><a href="#窗口特征" class="headerlink" title="窗口特征"></a>窗口特征</h4><table>    <tbody><tr>    <td style="width:30%">channelmode=yes|no|1|0</td>    <td>是否使用剧院模式显示窗口。默认为 no。</td>    </tr>    <tr>    <td>directories=yes|no|1|0</td>    <td>是否添加目录按钮。默认为 yes。</td>    </tr>    <tr>    <td>fullscreen=yes|no|1|0</td>    <td>是否使用全屏模式显示浏览器。默认是 no。处于全屏模式的窗口必须同时处于剧院模式。</td>    </tr>    <tr>    <td>height=pixels</td>    <td>窗口文档显示区的高度。以像素计。</td>    </tr>    <tr>    <td>left=pixels</td>    <td>窗口的 x 坐标。以像素计。</td>    </tr>    <tr>    <td>location=yes|no|1|0</td>    <td>是否显示地址字段。默认是 yes。</td>    </tr>    <tr>    <td>menubar=yes|no|1|0</td>    <td>是否显示菜单栏。默认是 yes。</td>    </tr>    <tr>    <td>resizable=yes|no|1|0</td>    <td>窗口是否可调节尺寸。默认是 yes。</td>    </tr>    <tr>    <td>scrollbars=yes|no|1|0</td>    <td>是否显示滚动条。默认是 yes。</td>    </tr>    <tr>    <td>status=yes|no|1|0</td>    <td>是否添加状态栏。默认是 yes。</td>    </tr>    <tr>    <td>titlebar=yes|no|1|0</td>    <td>是否显示标题栏。默认是 yes。</td>    </tr>    <tr>    <td>toolbar=yes|no|1|0</td>    <td>是否显示浏览器的工具栏。默认是 yes。</td>    </tr>    <tr>    <td>top=pixels</td>    <td>窗口的 y 坐标。</td>    </tr>    <tr>    <td>width=pixels</td>    <td>窗口的文档显示区的宽度。以像素计。</td>    </tr></tbody></table><h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><table >  <tr>    <th style="width:25%">方法</th>    <th>描述</th>  </tr>  <tr>    <td><a href="http://www.w3school.com.cn/jsref/met_win_alert.asp" target="_blank" rel="noopener">alert()</a></td>    <td>显示带有一段消息和一个确认按钮的警告框。</td>  </tr> <tr>    <td><a href="http://www.w3school.com.cn/jsref/met_win_confirm.asp" target="_blank" rel="noopener">confirm()</a></td>    <td>显示带有一段消息以及确认按钮和取消按钮的对话框。</td>  </tr> <tr>    <td><a href="http://www.w3school.com.cn/jsref/met_win_blur.asp" target="_blank" rel="noopener">blur()</a></td>    <td>把键盘焦点从顶层窗口移开。</td>  </tr> <tr>   <td><a href="http://www.w3school.com.cn/jsref/met_win_focus.asp" target="_blank" rel="noopener">focus()</a></td>    <td>把键盘焦点给予一个窗口。</td>  </tr>   <tr>    <td><a href="http://www.w3school.com.cn/jsref/met_win_close.asp" target="_blank" rel="noopener">close()</a></td>    <td>关闭浏览器窗口。</td>  </tr>      <tr>    <td><a href="http://www.w3school.com.cn/jsref/met_win_moveby.asp" target="_blank" rel="noopener">moveBy()</a></td>    <td>可相对窗口的当前坐标把它移动指定的像素。</td>  </tr>  <tr>    <td><a href="http://www.w3school.com.cn/jsref/met_win_moveto.asp" target="_blank" rel="noopener">moveTo()</a></td>    <td>把窗口的左上角移动到一个指定的坐标。</td>  </tr>    <tr>    <td><a href="http://www.w3school.com.cn/jsref/met_win_print.asp" target="_blank" rel="noopener">print()</a></td>    <td>打印当前窗口的内容。</td>  </tr>  <tr>    <td><a href="http://www.w3school.com.cn/jsref/met_win_prompt.asp" target="_blank" rel="noopener">prompt()</a></td>    <td>显示可提示用户输入的对话框。</td>  </tr>  <tr>    <td><a href="http://www.w3school.com.cn/jsref/met_win_resizeby.asp" target="_blank" rel="noopener">resizeBy()</a></td>    <td>按照指定的像素调整窗口的大小。</td>  </tr>  <tr>    <td><a href="http://www.w3school.com.cn/jsref/met_win_resizeto.asp" target="_blank" rel="noopener">resizeTo()</a></td>    <td>把窗口的大小调整到指定的宽度和高度。</td>  </tr>  <tr>    <td><a href="http://www.w3school.com.cn/jsref/met_win_scrollby.asp" target="_blank" rel="noopener">scrollBy()</a></td>    <td>按照指定的像素值来滚动内容。</td>  </tr>  <tr>    <td><a href="http://www.w3school.com.cn/jsref/met_win_scrollto.asp" target="_blank" rel="noopener">scrollTo()</a></td>    <td>把内容滚动到指定的坐标。</td>  </tr>  <tr>    <td><a href="http://www.w3school.com.cn/jsref/met_win_setinterval.asp" target="_blank" rel="noopener">setInterval()</a></td>    <td>按照指定的周期（以毫秒计）来调用函数或计算表达式。<b>setInterval() 方法会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭。由 setInterval() 返回的 ID 值可用作 clearInterval() 方法的参数。<b></td>  </tr>  <tr>    <td><a href="http://www.w3school.com.cn/jsref/met_win_settimeout.asp" target="_blank" rel="noopener">setTimeout()</a></td>    <td>在指定的毫秒数后调用函数或计算表达式。setTimeout() 只执行 code 一次</td>  </tr><tr>    <td><a href="http://www.w3school.com.cn/jsref/met_win_clearinterval.asp" target="_blank" rel="noopener">clearInterval()</a></td>    <td>取消由 setInterval() 设置的 timeout。</td>  </tr>  <tr>    <td><a href="http://www.w3school.com.cn/jsref/met_win_cleartimeout.asp" target="_blank" rel="noopener">clearTimeout()</a></td>    <td>取消由 setTimeout() 方法设置的 timeout。</td>  </tr> </table><h2 id="框架之间引用"><a href="#框架之间引用" class="headerlink" title="框架之间引用"></a>框架之间引用</h2><p>要引用窗口中的一个框架，可以使用如下语法：</p><pre><code class="js">frame[i]        //当前窗口的框架self.frame[i]    //当前窗口的框架w.frame[i]    //窗口 w 的框架</code></pre><p>要引用一个框架的父窗口（或父框架），可以使用下面的语法：</p><pre><code class="js">parent        //当前窗口的父窗口self.parent    //当前窗口的父窗口w.parent         //窗口 w 的父窗口</code></pre><p>要从顶层窗口含有的任何一个框架中引用它，可以使用如下语法：</p><pre><code class="js">top        //当前框架的顶层窗口self.top        //当前框架的顶层窗口f.top        //框架 f 的顶层窗口</code></pre><p>新的顶层浏览器窗口由方法 <code>Window.open()</code> 创建。当调用该方法时，应把 <code>open()</code> 调用的返回值存储在一个变量中，然后使用那个变量来引用新窗口。新窗口的 <code>opener</code> 属性反过来引用了打开它的那个窗口。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><blockquote><p><a href="http://www.w3school.com.cn/jsref/dom_obj_window.asp" target="_blank" rel="noopener">http://www.w3school.com.cn/jsref/dom_obj_window.asp</a><br><a href="http://javascript.ruanyifeng.com/bom/window.html" target="_blank" rel="noopener">http://javascript.ruanyifeng.com/bom/window.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js框架间的互相引用</title>
      <link href="/2016/03/16/js%E6%93%8D%E4%BD%9Cframeset/"/>
      <url>/2016/03/16/js%E6%93%8D%E4%BD%9Cframeset/</url>
      
        <content type="html"><![CDATA[<h2 id="frameset页面"><a href="#frameset页面" class="headerlink" title="frameset页面"></a>frameset页面</h2><pre><code class="html">&lt;frameset rows=&quot;150,*&quot;   id=&quot;x&quot; frameborder=&quot;NO&quot; border=&quot;0&quot; framespacing=&quot;0&quot;&gt;&lt;frame src=&quot;http://www.163.com&quot; name=&quot;dj-play&quot; scrolling=&quot;no&quot; noresize &gt;&lt;frame src=&quot;xiamian.htm&quot; name=&quot;mainFrame&quot; scrolling=&quot;auto&quot;&gt;&lt;/frameset&gt;</code></pre><a id="more"></a><h2 id="xiamian-htm"><a href="#xiamian-htm" class="headerlink" title="xiamian.htm"></a>xiamian.htm</h2><pre><code class="html">&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.0 Transitional//EN&quot;&gt;&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt; New Document &lt;/TITLE&gt;&lt;META NAME=&quot;Generator&quot; CONTENT=&quot;EditPlus&quot;&gt;&lt;META NAME=&quot;Author&quot; CONTENT=&quot;&quot;&gt;&lt;META NAME=&quot;Keywords&quot; CONTENT=&quot;&quot;&gt;&lt;META NAME=&quot;Description&quot; CONTENT=&quot;&quot;&gt;&lt;/HEAD&gt;&lt;BODY&gt;&lt;input  onclick=&quot;parent.document.getElementById(&#39;x&#39;).cols=&#39;0,*&#39;;&quot;type=button&gt;&lt;/BODY&gt;&lt;/HTML&gt;</code></pre><p>IE6、Firefox3下通过测试。。。。<br><strong>chrome测试不通过</strong>(部署到项目可以访问)<br>使用本地文件查看<br>Uncaught SecurityError: Blocked a frame with origin &quot;null&quot; from accessing a frame with origin &quot;null&quot;. Protocols, domains, and ports must match.<br><a href="http://www.cnblogs.com/lightsong/p/3920935.html" target="_blank" rel="noopener">跨域访问实践</a></p><h2 id="框架编程概述"><a href="#框架编程概述" class="headerlink" title="框架编程概述"></a>框架编程概述</h2><p>一个<code>HTML</code>页面可以有一个或多个子框架，这些子框架以<code>&lt;iframe&gt;</code>来标记，用来显示一个独立的<code>HTML</code>页面。这里所讲的框架编程包括框架的自我控制以及框架之间的互相访问，例如从一个框架中引用另一个框架中的<code>JavaScript</code>变量、调用其他框架内的函数、控制另一个框架中表单的行为等。</p><h2 id="框架间的互相引用"><a href="#框架间的互相引用" class="headerlink" title="框架间的互相引用"></a>框架间的互相引用</h2><p>一个页面中的所有框架以集合的形式作为<code>window</code>对象的属性提供，例如：window.frames就表示该页面内所有框架的集合，这和表单对象、链接对象、图片对象等是类似的，不同的是，这些集合是<code>document</code>的属性。因此，要引用一个子框架，可以使用如下语法：</p><pre><code class="js">window.frames[&quot;frameName&quot;];window.frames.frameNamewindow.frames[index]//其中，window字样也可以用self代替或省略，假设frameName为页面中第一个框架，则以下的写法是等价的：self.frames[&quot;frameName&quot;]self.frames[0]frames[0]frameName</code></pre><p>每个框架都对应一个<code>HTML</code>页面，所以这个框架也是一个独立的浏览器窗口，它具有窗口的所有性质，所谓对框架的引用也就是对<code>window</code>对象的引用。有了这个<code>window</code>对象，就可以很方便地对其中的页面进行操作，例如使用<code>window.document</code>对象向页面写入数据、使用<code>window.location</code>属性来改变框架内的页面等。<br>下面分别介绍不同层次框架间的互相引用：</p><h3 id="1-父框架到子框架的引用"><a href="#1-父框架到子框架的引用" class="headerlink" title="1. 父框架到子框架的引用"></a>1. 父框架到子框架的引用</h3><p>知道了上述原理，从父框架引用子框架变的非常容易，即：</p><pre><code class="js">window.frames[&quot;frameName&quot;];</code></pre><p>这样就引用了页面内名为<code>frameName</code>的子框架。如果要引用子框架内的子框架，根据引用的框架实际就是<code>window</code>对象的性质，可以这样实现：</p><pre><code class="js">window.frames[&quot;frameName&quot;].frames[&quot;frameName2&quot;];</code></pre><p>这样就引用到了二级子框架，以此类推，可以实现多层框架的引用。</p><h3 id="2-子框架到父框架的引用"><a href="#2-子框架到父框架的引用" class="headerlink" title="2. 子框架到父框架的引用"></a>2. 子框架到父框架的引用</h3><p>每个<code>window</code>对象都有一个<code>parent</code>属性，<strong>表示它的父框架</strong>。如果该框架已经是顶层框架，则<code>window.parent</code>还表示该框架本身。</p><h3 id="3-兄弟框架间的引用"><a href="#3-兄弟框架间的引用" class="headerlink" title="3. 兄弟框架间的引用"></a>3. 兄弟框架间的引用</h3><p>如果两个框架同为一个框架的子框架，它们称为兄弟框架，可以通过父框架来实现互相引用，例如一个页面包括2个子框架：</p><pre><code class="html">&lt;frameset rows=&quot;50%,50%&quot;&gt;    &lt;frame src=&quot;1.html&quot; name=&quot;frame1&quot; /&gt;    &lt;frame src=&quot;2.html&quot; name=&quot;frame2&quot; /&gt;&lt;/frameset&gt;</code></pre><p>在<code>frame1</code>中可以使用如下语句来引用<code>frame2</code>：</p><pre><code class="js">self.parent.frames[&quot;frame2&quot;];</code></pre><h3 id="4-不同层次框架间的互相引用"><a href="#4-不同层次框架间的互相引用" class="headerlink" title="4. 不同层次框架间的互相引用"></a>4. 不同层次框架间的互相引用</h3><p>框架的层次是针对顶层框架而言的。当层次不同时，只要知道自己所在的层次以及另一个框架所在的层次和名字，利用框架引用的<code>window</code>对象性质，可以很容易地实现互相访问，例如：</p><pre><code class="js">self.parent.frames[&quot;childName&quot;].frames[&quot;targetFrameName&quot;];</code></pre><h3 id="5-对顶层框架的引用"><a href="#5-对顶层框架的引用" class="headerlink" title="5. 对顶层框架的引用"></a>5. 对顶层框架的引用</h3><p>和<code>parent</code>属性类似，<code>window</code>对象还有一个<code>top</code>属性。它表示对顶层框架的引用，这可以用来判断一个框架自身是否为顶层框架，例如：</p><pre><code class="js">//判断本框架是否为顶层框架if(self==top){    //dosomething}</code></pre><h2 id="改变框架的载入页面"><a href="#改变框架的载入页面" class="headerlink" title="改变框架的载入页面"></a>改变框架的载入页面</h2><p>对框架的引用就是对<code>window</code>对象的引用，利用<code>window</code>对象的<code>location</code>属性，可以改变框架的导航，例如：</p><pre><code class="js">window.frames[0].location=&quot;1.html&quot;;</code></pre><p>这就将页面中第一个框架的页面重定向到<code>1.html</code>，利用这个性质，甚至可以使用一条链接来更新多个框架。</p><pre><code class="html">&lt;frameset rows=&quot;50%,50%&quot;&gt;    &lt;frame src=&quot;1.html&quot; name=&quot;frame1&quot; /&gt;    &lt;frame src=&quot;2.html&quot; name=&quot;frame2&quot; /&gt;&lt;/frameset&gt;&lt;!--somecode--&gt;&lt;a href=&quot;frame1.location=&#39;3.html;frame2.location=&#39;4.html&#39;&quot;&gt;link&lt;/a&gt;&lt;!--somecode--&gt;</code></pre><h3 id="引用其他框架内的JavaScript变量和函数"><a href="#引用其他框架内的JavaScript变量和函数" class="headerlink" title="引用其他框架内的JavaScript变量和函数"></a>引用其他框架内的JavaScript变量和函数</h3><p>在介绍引用其他框架内JavaScript变量和函数的技术之前，先来看以下代码：</p><pre><code class="html">&lt;script language=&quot;JavaScript&quot; type=&quot;text/javascript&quot;&gt;function hello(){    alert(&quot;hello,ajax!&quot;);}window.hello();&lt;/script&gt;</code></pre><p>如果运行了这段代码，会弹出<code>“hello,ajax!”</code>的窗口，这正是执行<code>hello()</code>函数的结果。那为什么<code>hello()</code>变成了<code>window</code>对象的方法呢？因为<strong>在一个页面内定义的所有全局变量和全局函数都是作为<code>window</code>对象的成员</strong>。例如：</p><pre><code class="js">var a=1;alert(window.a);</code></pre><p>就会弹出对话框显示为<code>1</code>。同样的原理，在不同框架之间共享变量和函数，就是要通过<code>window</code>对象来调用。</p><p>框架可以使一个页面划分为功能独立的多个模块，每个模块之间彼此独立，但又可以通过<code>window</code>对象的引用来建立联系，是<code>Web</code>开发中的一个重要机制。</p><h2 id="参见"><a href="#参见" class="headerlink" title="参见"></a>参见</h2><blockquote><p><a href="http://blog.csdn.net/lushuaiyin/article/details/8003257" target="_blank" rel="noopener">http://blog.csdn.net/lushuaiyin/article/details/8003257</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在frameset，frame，iframe中如何操作其他框架中的页面以及如何刷新框架中的页面</title>
      <link href="/2016/03/16/%E5%9C%A8frameset%EF%BC%8Cframe%EF%BC%8Ciframe%E4%B8%AD%E5%A6%82%E4%BD%95%E6%93%8D%E4%BD%9C%E5%85%B6%E4%BB%96%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E9%A1%B5%E9%9D%A2%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%88%B7%E6%96%B0%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E9%A1%B5%E9%9D%A2/"/>
      <url>/2016/03/16/%E5%9C%A8frameset%EF%BC%8Cframe%EF%BC%8Ciframe%E4%B8%AD%E5%A6%82%E4%BD%95%E6%93%8D%E4%BD%9C%E5%85%B6%E4%BB%96%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E9%A1%B5%E9%9D%A2%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%88%B7%E6%96%B0%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E9%A1%B5%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<p><code>frameset</code>，<code>frame</code>，<code>iframe</code>可以让我们很好的布局整个<code>web</code>页面。<br>每个web工程没有不用到这些的，那在<code>frameset</code>，<code>frame</code>，<code>iframe</code>中如何操作其他框架中的页面以及如何刷新框架中的页面？</p><a id="more"></a><p>整体的布局可以用一张图来看，这样更清楚：</p><p><img src="/demo/photo/2016316155008.jpg" alt="整体的布局"></p><p>上面的<code>MAINCONTENT</code>中嵌入<code>listphonebook.jsp</code><br>我们想在<code>listphonebook.jsp</code>中调用其他页面的方法或者刷新某个<code>frame</code>中的页面应该怎么做呢？</p><p>比如<code>homeleft.jsp</code>中有个方法：</p><pre><code class="js">function gg(){ alert(&quot;gg&quot;);}</code></pre><h2 id="方法1：使用parent跳出本框架再找其他框架。"><a href="#方法1：使用parent跳出本框架再找其他框架。" class="headerlink" title="方法1：使用parent跳出本框架再找其他框架。"></a>方法1：使用<code>parent</code>跳出本框架再找其他框架。</h2><p>一，刷新<code>listphonebook.jsp</code></p><p>当然也可以<code>window.location.reload();</code><br>不过这个刷新会有IE的提示框弹出，效果不是很好。<br>所以<strong>把右面所有页面刷新</strong></p><pre><code class="js">parent.window.parent.window.frames[1].window.location.reload();</code></pre><p><strong>刷新左面</strong><code>homeleft.jsp</code></p><pre><code class="js">parent.window.parent.window.frames[0].window.location=&quot;xxx.jsp&quot;;parent.window.parent.window.frames[0].window.location.reload();</code></pre><p>二，调用<code>homeleft.jsp</code>中的方法</p><pre><code class="js">parent.window.parent.window.frames[0].gg();parent.window是homerightparent.window.parent.window是mainFrameparent.window.parent.window.frames[0]是homeleft.jsp</code></pre><p>这样就可以调用这个页面的方法<code>gg()</code>；</p><h2 id="方法2：使用top跳到本页面的顶层框架"><a href="#方法2：使用top跳到本页面的顶层框架" class="headerlink" title="方法2：使用top跳到本页面的顶层框架"></a>方法2：使用<code>top</code>跳到本页面的顶层框架</h2><p>然后一层层按从外向里的顺序找到你要的页面。<br>一，刷新<code>listphonebook.jsp</code></p><pre><code class="js">//那在此页面可以top.mainFrame.homeright.location=&quot;&lt;%=path%&gt;/jsp/layout/module.jsp?parentMenuId=hd_phonebook&quot;;//或者top.mainFrame.homeright.location.reload();//刷新左面homeleft.jsptop.mainFrame.homeleft.location=&quot;xxx.jsp&quot;;//或者top.mainFrame.homeleft.location.reload();</code></pre><p>二，调用<code>homeleft.jsp</code>中的方法</p><pre><code class="js">top.mainFrame.homeleft.window.gg();</code></pre><h2 id="参见"><a href="#参见" class="headerlink" title="参见"></a>参见</h2><blockquote><p><a href="http://blog.csdn.net/lushuaiyin/article/details/7999073" target="_blank" rel="noopener">在frameset，frame，iframe中如何操作其他框架中的页面以及如何刷新框架中的页面</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript判断变量是否为undefined两种方式差异</title>
      <link href="/2016/03/16/JavaScript%E5%88%A4%E6%96%AD%E5%8F%98%E9%87%8F%E6%98%AF%E5%90%A6%E4%B8%BAundefined%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%B7%AE%E5%BC%82/"/>
      <url>/2016/03/16/JavaScript%E5%88%A4%E6%96%AD%E5%8F%98%E9%87%8F%E6%98%AF%E5%90%A6%E4%B8%BAundefined%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%B7%AE%E5%BC%82/</url>
      
        <content type="html"><![CDATA[<p>我们经常需要判断某个变量/属性是否为<code>undefined</code>。通常有两种写法</p><pre><code class="js">// 方式1typeof age === &#39;undefined&#39;;// 方式2age === undefined</code></pre><a id="more"></a><p>这两种写法有什么区别吗? 应该使用哪一种呢？看看下面的例子</p><pre><code class="js">typeof age === &#39;undefined&#39;; // true</code></pre><p>标识符 <code>age</code> 没有声明过，输出<code>true</code>。</p><p>再看另一个例子</p><pre><code class="js">age === undefined; // 报错</code></pre><p>chrome提示 <code>Uncaught ReferenceError: age is not defined</code>，<br>这就是两者的区别， 即<strong>不确定age是否声明或定义时用方式1</strong>，<strong>确定的则可以用方式2</strong>。<strong><em>使用方式1如果变量没有声明，代码也不会报错，但方式2会报错</em></strong>。</p><p>看似方式1容错性更好，实际会是潜伏了的Bug。变量先声明再使用永远是个好习惯。</p><pre><code class="js">var a;&lt; undefineda === undefined;//如果a已经声明了,就不报错&lt; truetypeof age === &#39;undefined&#39;;&lt; true</code></pre><blockquote><p><a href="http://www.cnblogs.com/snandy/archive/2011/06/17/2083481.html" target="_blank" rel="noopener">JavaScript判断变量是否为undefined两种方式差异</a></p></blockquote><p>此外，方式1是两次运算，方式2是一次。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图标闪动提醒，并加载内容到弹出框jQuery插件</title>
      <link href="/2016/03/16/%E5%9B%BE%E6%A0%87%E9%97%AA%E5%8A%A8%E6%8F%90%E9%86%92%EF%BC%8C%E5%B9%B6%E5%8A%A0%E8%BD%BD%E5%86%85%E5%AE%B9%E5%88%B0%E5%BC%B9%E5%87%BA%E6%A1%86Jquery%E6%8F%92%E4%BB%B6/"/>
      <url>/2016/03/16/%E5%9B%BE%E6%A0%87%E9%97%AA%E5%8A%A8%E6%8F%90%E9%86%92%EF%BC%8C%E5%B9%B6%E5%8A%A0%E8%BD%BD%E5%86%85%E5%AE%B9%E5%88%B0%E5%BC%B9%E5%87%BA%E6%A1%86Jquery%E6%8F%92%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><a href="/demo\加载内容到弹出框jQuery插件/demo.html">加载内容到弹出框jQuery插件</a></p><h2 id="界面小图标"><a href="#界面小图标" class="headerlink" title="界面小图标"></a>界面小图标</h2><pre><code class="html">&lt;div class=&quot;right&quot; ID=&quot;soccer&quot;&gt;&lt;a href=&quot;javascript:void(0);&quot; title=&quot;消息&quot; &gt;    &lt;img src=&quot;css/images/ic_notifications.png&quot;&gt;&lt;/a&gt;&lt;/div&gt;</code></pre><a id="more"></a><h2 id="图标闪动js"><a href="#图标闪动js" class="headerlink" title="图标闪动js"></a>图标闪动js</h2><pre><code class="js">var msecs = 750; //改变时间得到不同的闪烁间隔,毫秒；var counter = 0;var whetherFlashing = false;//是否闪动setInterval(&quot;blink()&quot;, msecs);function blink() {//闪动    if(whetherFlashing){        soccer.style.visibility = (soccer.style.visibility == &quot;hidden&quot;) ? &quot;visible&quot; : &quot;hidden&quot;;        counter +=1;    }else{        soccer.style.visibility = &quot;visible&quot;;    }}</code></pre><h2 id="从后台获取信息，判断是否闪动"><a href="#从后台获取信息，判断是否闪动" class="headerlink" title="从后台获取信息，判断是否闪动"></a>从后台获取信息，判断是否闪动</h2><pre><code class="js">var topInfoSize = 0;//待信息量var topWorkReceiveSize = 0;//工作未处理信息量var topthreshold = 0;//提醒阀值setInterval(&quot;Push()&quot;,300000);//5分钟，刷新一次//后台返回结果示例：{InfoSize: &quot;57&quot;, WorkReceiveSize: &quot;0&quot;, threshold: &quot;50&quot;}function Push() {       $.ajax({           type: &quot;POST&quot;,           url:&quot;remind/getRemind.do?type=refresh&quot;,        success: function(data) {               var obj = eval (&quot;(&quot; + data + &quot;)&quot;);               topInfoSize = parseInt(obj.InfoSize);               topthreshold = parseInt(obj.threshold);               topWorkReceiveSize = parseInt(obj.WorkReceiveSize);               if((parseInt(obj.InfoSize)&lt;parseInt(obj.threshold)) &amp;&amp; obj.WorkReceiveSize == 0 ){                   //同时满足 小于阀值，没有工作信息，停止闪动                   whetherFlashing = false;               }               if(parseInt(obj.InfoSize)&gt;=parseInt(obj.threshold)){                   whetherFlashing = true;               }               if(parseInt(obj.WorkReceiveSize) &gt; 0){                   whetherFlashing = true;            }           }     });}</code></pre><h2 id="页面加载进来，调用方法"><a href="#页面加载进来，调用方法" class="headerlink" title="页面加载进来，调用方法"></a>页面加载进来，调用方法</h2><pre><code class="js">$(function(){    $(&#39;#soccer&#39;).mousemove(function(){//鼠标移动上去触发        $(this).skyLayer({id:&#39;img&#39;,        title:&#39;我的消息&#39;,url:&quot;./page/office/remind/topremind.html&quot;});    })    $(&#39;#soccer&#39;).click(function(){//点击触发        $(this).skyLayer({id:&#39;img&#39;,        title:&#39;我的消息&#39;,url:&quot;./page/office/remind/topremind.html&quot;});    })    window.onresize=function(){        $.fn.skyLayer.Sclose()//关闭提醒框    }    Push();//首次进入界面，获得提醒信息});</code></pre><h2 id="topremind-html"><a href="#topremind-html" class="headerlink" title="topremind.html"></a>topremind.html</h2><pre><code class="html">&lt;html&gt;&lt;head&gt;&lt;script type=&quot;text/javascript&quot;&gt;    $(function(){        $(&#39;#context&#39;).text(topInfoSize);//待处理信息量        if(topInfoSize&gt;=topthreshold){               $(&#39;#contextInfo&#39;).css(&quot;color&quot;,&quot;red&quot;);           }else {               $(&#39;#contextInfo&#39;).css(&quot;color&quot;,&quot;&quot;);           }           $(&#39;#WorkReceiveSize&#39;).text(topWorkReceiveSize);//工作未处理信息量           if(topWorkReceiveSize &gt; 0){               $(&#39;#contextInfo2&#39;).css(&quot;color&quot;,&quot;red&quot;);        }else {               $(&#39;#contextInfo2&#39;).css(&quot;color&quot;,&quot;&quot;);           }    });&lt;/script&gt;&lt;/head&gt;&lt;body &gt;&lt;div &gt;&lt;table width=&quot;100%&quot; border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;    &lt;tr  style=&quot;cursor:pointer;&quot; onclick=&quot;&quot;&gt;        &lt;td height=&quot;30&quot;&gt;            &lt;img src=&quot;./images/blue3.png&quot; /&gt;        &lt;/td&gt;        &lt;td height=&quot;30&quot; &gt;        &lt;label id=&quot;contextInfo&quot; style=&quot;cursor:pointer;&quot; &gt;            待处理信息量：&lt;label id=&quot;context&quot; style=&quot;cursor:pointer;&quot;&gt;&lt;/label&gt;&lt;/label&gt;        &lt;/td&gt;    &lt;/tr&gt;    &lt;tr style=&quot;cursor:pointer;&quot; onclick=&quot;&quot;&gt;        &lt;td height=&quot;30&quot;&gt;            &lt;img src=&quot;./images/blue8.png&quot;&gt;        &lt;/td&gt;        &lt;td height=&quot;30&quot;&gt;            &lt;label id=&quot;contextInfo2&quot; style=&quot;cursor:pointer;&quot;&gt;工作未处理信息量：&lt;label style=&quot;cursor:pointer;&quot; id=&quot;WorkReceiveSize&quot; &gt;&lt;/label&gt;&lt;/label&gt;        &lt;/td&gt;    &lt;/tr&gt;    &lt;/table&gt;  &lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="jquery-skyLayer-js"><a href="#jquery-skyLayer-js" class="headerlink" title="jquery-skyLayer.js"></a>jquery-skyLayer.js</h2><pre><code class="js">/** * 功能： 加载内容到弹出框 * 作者： SKY * email：lavi_sky@163.com */(function($){    $.fn.skyLayer = function(options){        var defaults={            id:&quot;id&quot;,//id必须防止重复            title:&quot;标题&quot; , //显示在弹出层的标题            url:&quot;&quot;//要加载的内容地址        }        var opts = $.extend(defaults, options);        var position = this.position();        var left = position.left - this.width() - 5;        var top = position.top + this.height() + 5;        var html = &#39;&lt;div id=&quot;layer_&#39;+opts.id+&#39;&quot; class=&quot;sky-layer&quot; style=&quot;display:block;left:&#39;+left+&#39;px;top:&#39;+top+&#39;px;&quot;&gt;&lt;div class=&quot;holder&quot;&gt;&lt;div class=&quot;content&quot;&gt;&lt;div class=&quot;sky-tab clearfix&quot;&gt;&lt;a href=&quot;javascript:;&quot;&gt;&#39;+opts.title+&#39;&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;sky-sub-tab clearfix&quot;&gt;&#39;;        html += &#39;&lt;div id=&quot;loadurl&quot;&gt;&lt;div class=&quot;voloading&quot;&gt;&lt;/div&gt;&lt;/div&gt;&#39;;        html +=&#39;&lt;/div&gt;&lt;ul class=&quot;sky-detail clearfix&quot;&gt;&lt;/ul&gt;&lt;/div&gt;&lt;a class=&quot;sky-close&quot; href=&quot;javascript:;&quot;&gt;&lt;/a&gt;&lt;/div&gt;&lt;a class=&quot;sky-tri&quot; href=&quot;javascript:;&quot;&gt;&lt;/a&gt;&lt;/div&gt;&#39;;        if($(&#39;#layer_&#39;+opts.id).css(&#39;display&#39;)!=&#39;block&#39;){            if($(&#39;.sky-layer&#39;).attr(&#39;id&#39;)!=&#39;&#39; &amp;&amp; $(&#39;.sky-layer&#39;).attr(&#39;id&#39;)!=opts.id){                $(&#39;.sky-layer&#39;).remove();            }            this.after(html);            $(&#39;#loadurl&#39;).load(opts.url)        }else{            $.fn.skyLayer.Sclose()        }        $(&#39;.sky-close&#39;).click(function(){            $.fn.skyLayer.Sclose()        })        $.fn.skyLayer.Sclose=function(){            $(&#39;#layer_&#39;+opts.id).remove();        }    };})(jQuery)</code></pre><h2 id="style-css"><a href="#style-css" class="headerlink" title="style.css"></a>style.css</h2><pre><code class="css">/** 清除内外边距 **/body,h1,h2,h3,h4,h5,h6,hr,p,blockquote,/* structural elements 结构元素 */dl,dt,dd,ul,ol,li,/* list elements 列表元素 */pre,/* text formatting elements 文本格式元素 */form,fieldset,legend,button,input,textarea,/* form elements 表单元素 */th,td /* table elements 表格元素 */{margin:0;padding:0;}/** 设置默认字体 **/body,button,input,select,textarea /* for ie */{font:12px/1.5 tahoma,arial,\5b8b\4f53,sans-serif;}h1,h2,h3,h4,h5,h6{font-size:100%;}address,cite,dfn,em,var{font-style:normal;} /* 将斜体扶正 */code,kbd,pre,samp{font-family:courier new,courier,monospace;} /* 统一等宽字体 */small{font-size:12px;} /* 小于 12px 的中文很难阅读，让 small 正常化 *//** 重置列表元素 **/ul,ol{list-style:none;}/** 重置文本格式元素 **/a{text-decoration:none;}a:hover{text-decoration:underline;}sup{vertical-align:text-top;} /* 重置，减少对行高的影响 */sub{vertical-align:text-bottom;}.sky-layer{display:none;position:absolute;left:200px;top:200px;z-index:10;width:394px;border-radius:4px;padding:4px;background:url(&quot;../img/layer_bg.png&quot;);}.sky-layer .holder{position:relative;z-index:30;border:1px solid #c3c3c3;border-radius:4px;background:#fff;}.sky-layer .sky-tri{position:absolute;margin:0;left:30px;top:-7px;z-index:40;width:16px;height:12px;background:url(&quot;../img/layer_arrow.png&quot;);}.sky-layer .sky-close{display:block;margin:0;position:absolute;right:14px;top:5px;z-index:20;width:20px;height:20px;background:url(&quot;../img/ico.png&quot;) 5px -250px no-repeat;}.sky-layer .sky-close:hover{background-position:0 -1954px;}.sky-layer .sky-tab{padding:4px 4px 0 6px;background:#F0F0F0;}.sky-layer .sky-tab a{width:auto;display:block;float:left;height:25px;margin:0 3px;padding:0 10px;border:1px solid #E8E8E8;border-bottom:0;border-radius:4px 4px 0 0;background:#fff;font-size:12px;font-weight:400;text-overflow:clip;color:#666;text-decoration:none;line-height:25px;}.sky-layer .sky-sub-tab{position:relative;margin:10px 16px;overflow:hidden;}.sky-layer .sky-sub-tab .sky-close,.sky-layer .sky-sub-tab .sky-tri{display:block;float:left;height:23px;padding:0 7px;color:#9ABBC8;font-size:12px;font-weight:400;text-decoration:none;line-height:23px;}.sky-layer .sky-sub-tab a.slct{background:none repeat scroll 0 0 #F0F0F0;border-radius:3px 3px 3px 3px;cursor:default;position:relative;text-decoration:none;z-index:2;}.sky-layer .sky-sub-tab span{float: left; margin: 0 5px; color:#9ABBC8;}.sky-layer .sub-tab-pagination{position:absolute;right:10px;top:0px;height:100%;}.sky-layer .sub-tab-pagination a{display:none;width:17px;height:17px;margin:0 2px;padding:0;background:url(&quot;../img/ico.png&quot;) no-repeat;cursor:pointer;display:inline;line-height:17px;}.sky-layer .sub-tab-pagination .pre{background-position:0 -1290px;}.sky-layer .sub-tab-pagination .next{background-position:0 -1176px;}.sky-layer .sub-tab-pagination a.pre-disable{background-position:0 -1367px;cursor:default;}.sky-layer .sub-tab-pagination a.next-disalbe{background-position:0 -1253px;cursor:default;}.sky-layer .sky-detail{margin:10px;}.sky-detail li{display:block;float:left;width:26px;height:22px;margin:-1px 0 0 -1px;border:1px solid #e8e8e8;padding:4px 2px;text-align:center;cursor:pointer;}.sky-detail li:hover{position:relative;border:1px solid #0095cd;background:#fff9ec;z-index:50;}.clearfix:after {visibility: hidden;display: block;font-size: 0;content: &quot; &quot;;clear: both;height: 0;}* html .clearfix             { zoom: 1; } /* IE6 */*:first-child+html .clearfix { zoom: 1; } /* IE7 */</code></pre><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><blockquote><p><a href="http://www.jq-school.com/Detail.aspx?id=71" target="_blank" rel="noopener">网友SKY分享原创加载内容到弹出框Jquery插件</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> jQuery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 3整合Quartz实现定时任务</title>
      <link href="/2016/03/10/Spring-3%E6%95%B4%E5%90%88Quartz%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
      <url>/2016/03/10/Spring-3%E6%95%B4%E5%90%88Quartz%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="Quartz介绍"><a href="#Quartz介绍" class="headerlink" title="Quartz介绍"></a>Quartz介绍</h1><p>在企业应用中，我们经常会碰到时间任务调度的需求，比如每天凌晨生成前天报表，每小时生成一次汇总数据等等。<code>Quartz</code> 是出了名的任务调度框架，它可以与 <code>J2SE</code> 和 <code>J2EE</code> 应用程序相结合，功能灰常强大，轻轻松松就能与 <code>Spring</code> 集成，使用方便。</p><p>spring3.1 以下的版本必须使用 quartz1.x 系列，3.1 以上的版本才支持 quartz 2.x，不然会出错。</p><h1 id="Quartz中的概念"><a href="#Quartz中的概念" class="headerlink" title="Quartz中的概念"></a>Quartz中的概念</h1><p>主要有三个核心概念：调度器、任务和触发器。三者关系简单来说就是，调度器负责调度各个任务，到了某个时刻或者过了一定时间，触发器触动了，特定任务便启动执行。概念相对应的类和接口有：</p><a id="more"></a><ol><li><p><code>JobDetail</code>：望文生义就是描述任务的相关情况；</p></li><li><p><code>Trigger</code>：描述出发Job执行的时间触发规则。有 <code>SimpleTrigger</code> 和 <code>CronTrigger</code> 两个子类代表两种方式，一种是每隔多少分钟小时执行，则用 <code>SimpleTrigger</code>；另一种是日历相关的重复时间间隔，如每天凌晨，每周星期一运行的话，通过 <code>Cron</code> 表达式便可定义出复杂的调度方案。</p></li><li><p><code>Scheduler</code>：代表一个 <code>Quartz</code> 的独立运行容器，<code>Trigger</code> 和 <code>JobDetail</code> 要注册到 <code>Scheduler</code> 中才会生效，也就是让调度器知道有哪些触发器和任务，才能进行按规则进行调度任务。</p></li></ol><h1 id="Spring-中使用-Quartz"><a href="#Spring-中使用-Quartz" class="headerlink" title="Spring 中使用 Quartz"></a>Spring 中使用 Quartz</h1><h2 id="所需-jar-包"><a href="#所需-jar-包" class="headerlink" title="所需 jar 包"></a>所需 jar 包</h2><p>quartz.jar，spring-context-support.jar，commons-collections-3.2.jar；</p><h2 id="添加业务逻辑类"><a href="#添加业务逻辑类" class="headerlink" title="添加业务逻辑类"></a>添加业务逻辑类</h2><p>简单示例：</p><pre><code class="java">public class QuartzTest {    //到了某个时刻就会被调用    public void autoRun(){        System.out.println(&quot;It&#39;s time to run :&quot; + new Date().toString());        //TODO 执行任务逻辑        //........    }}</code></pre><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><h3 id="SimpleTrigger-方式"><a href="#SimpleTrigger-方式" class="headerlink" title="SimpleTrigger 方式"></a>SimpleTrigger 方式</h3><pre><code class="xml">    &lt;!-- Quartz --&gt;    &lt;bean name=&quot;quartzTest&quot; class=&quot;com.jz.schedual.QuartzTest&quot; /&gt;    &lt;bean id=&quot;quartzTestJob&quot; class=&quot;org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean&quot;&gt;        &lt;property name=&quot;targetObject&quot; ref=&quot;quartzTest&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;targetMethod&quot; value=&quot;autoRun&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;concurrent&quot; value=&quot;false&quot;&gt;&lt;/property&gt;&lt;!-- 作业不并发调度,表示等上一个任务执行完后再开启新的任务 --&gt;    &lt;/bean&gt;    &lt;bean id=&quot;quartzTestTrigger&quot; class=&quot;org.springframework.scheduling.quartz.SimpleTriggerBean&quot;&gt;        &lt;property name=&quot;jobDetail&quot; ref=&quot;quartzTestJob&quot;/&gt;        &lt;!-- 调度工厂实例化后，经过20秒开始执行调度(即tomcat启动后多久启动定时器) --&gt;        &lt;property name=&quot;startDelay&quot; value=&quot;20000&quot; /&gt;        &lt;!-- 每隔多长时间（毫秒）执行一次 ,30秒--&gt;        &lt;property name=&quot;repeatInterval&quot; value=&quot;30000&quot; /&gt;    &lt;/bean&gt;    &lt;bean name=&quot;quartzScheduler&quot; class=&quot;org.springframework.scheduling.quartz.SchedulerFactoryBean&quot;&gt;        &lt;property name=&quot;triggers&quot;&gt;            &lt;list&gt;                &lt;ref local=&quot;quartzTestTrigger&quot; /&gt;            &lt;/list&gt;        &lt;/property&gt;    &lt;/bean&gt;</code></pre><h3 id="CronTrigger-方式"><a href="#CronTrigger-方式" class="headerlink" title="CronTrigger 方式"></a>CronTrigger 方式</h3><pre><code class="xml">    &lt;!-- Quartz --&gt;    &lt;bean name=&quot;quartzTest&quot; class=&quot;com.jz.schedual.QuartzTest&quot; /&gt;    &lt;bean id=&quot;quartzTestJob&quot; class=&quot;org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean&quot;&gt;        &lt;property name=&quot;targetObject&quot; ref=&quot;quartzTest&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;targetMethod&quot; value=&quot;autoRun&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;concurrent&quot; value=&quot;false&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;bean id=&quot;quartzTestTrigger&quot; class=&quot;org.springframework.scheduling.quartz.CronTriggerBean&quot;&gt;        &lt;property name=&quot;jobDetail&quot; ref=&quot;quartzTestJob&quot;/&gt;        &lt;!-- 每天十点 --&gt;        &lt;property name=&quot;cronExpression&quot; value=&quot;0 0 10 * * ?&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;bean name=&quot;quartzScheduler&quot; class=&quot;org.springframework.scheduling.quartz.SchedulerFactoryBean&quot;&gt;        &lt;property name=&quot;triggers&quot;&gt;            &lt;list&gt;                &lt;ref local=&quot;quartzTestTrigger&quot; /&gt;            &lt;/list&gt;        &lt;/property&gt;    &lt;/bean&gt;</code></pre><h1 id="Cron表达式"><a href="#Cron表达式" class="headerlink" title="Cron表达式"></a>Cron表达式</h1><p><code>cronExpression</code> 定义时间规则，<code>Cron</code> 表达式由6或7个空格分隔的时间字段组成：<code>秒</code> <code>分钟</code> <code>小时</code> <code>日期</code> <code>月份</code> <code>星期</code> <code>年</code>（可选）；</p><table><thead><tr><th align="center">字段</th><th align="center">允许值</th><th align="center">允许的特殊字符</th></tr></thead><tbody><tr><td align="center">秒</td><td align="center">0-59</td><td align="center">, - * /</td></tr><tr><td align="center">分</td><td align="center">0-59</td><td align="center">, - * /</td></tr><tr><td align="center">小时</td><td align="center">0-23</td><td align="center">, - * /</td></tr><tr><td align="center">日期</td><td align="center">1-31</td><td align="center">, - * ? / L W C</td></tr><tr><td align="center">月份</td><td align="center">1-12</td><td align="center">, - * /</td></tr><tr><td align="center">星期</td><td align="center">1-7</td><td align="center">, - * ? / L C #</td></tr><tr><td align="center">年</td><td align="center">1970-2099</td><td align="center">, - * /</td></tr></tbody></table><p><strong>解析：</strong> 每 5 秒执行一次</p><pre><code class="cron">0/5 * * * * ?</code></pre><ol><li><p>“<code>*</code>”字符被用来<strong>指定所有的值</strong>。<br>如：&quot;<code>*</code>&quot;在分钟的字段域里表示“每分钟”。</p></li><li><p>“<code>?</code>”字符只在<strong>日期域</strong>和<strong>星期域</strong>中使用。它被用来指定“<strong>非明确的值</strong>”。当你需要通过在这两个域中的一个来指定一些东西的时候，它是有用的。看下面的例子你就会明白。<em>月份中的日期和星期中的日期这两个元素时互斥的一起应该通过设置一个问号来表明不想设置那个字段</em>。</p></li><li><p>“<code>-</code>”字符被用来指定<strong>一个范围</strong>。<br>如：“<code>10-12</code>”在小时域意味着“<code>10点、11点、12点</code>”。</p></li><li><p>“<code>,</code>”字符被用来指定<strong>另外的值</strong>。<br>如：“<code>MON,WED,FRI</code>”在星期域里表示”<code>星期一、星期三、星期五</code>”。</p></li><li><p>“<code>/</code>”字符用于指定<strong>增量</strong>。<br>如：“<code>0/15</code>”在秒域意思是每分钟的<strong>0，15，30和45秒</strong>。<br>“<code>5/15</code>”在分钟域表示每小时的<strong>5，20，35和50</strong>。<br>符号“<code>*</code>”在“<code>/</code>”前面（如：<code>*/10</code>）等价于<code>0</code>在“<code>/</code>”前面（如：<code>0/10</code>）。<br>记住一条本质：<em>表达式的每个数值域都是一个有最大值和最小值的集合</em>，如： <strong>秒域和分钟域的集合是 0-59，日期域是 1-31，月份域是 1-12</strong>。字符“<code>/</code>”可以帮助你<strong>在每个字符域中取相应的数值</strong>。<br>如：“<code>7/6</code>”在月份域的时候只 有当7月的时候才会触发，并不是表示每个6月。</p></li><li><p><code>L</code> 是“last”的省略写法可以表示 <code>day-of-month</code> 和 <code>day-of-week</code> 域，但在两个字段中的意思不同，例如 <code>day-of- month</code> 域中表示一个月的最后一天。如果在 <code>day-of-week</code> 域表示“<code>7</code>”或者“<code>SAT</code>”<br>如果在 <code>day-of-week</code> 域中前面加上数字，它表示一个月的最后几天，例如“6L”就表示一个月的最后一个星期五。</p></li><li><p>字符“<code>W</code>”只允许日期域出现。这个字符用于<strong>指定日期的最近工作日</strong>。<br>例如：如果你在日期域中写 “<code>15W</code>”，表示：<strong>这个月15号最近的工作日</strong>。所以，如果15号是周六，则任务会在14号触发。如果15好是周日，则任务会在周一也就是16号触发。如果 是在日期域填写“<code>1W</code>”即使1号是周六，那么任务也只会在下周一，也就是3号触发，“<code>W</code>”字符指定的最近工作日是<strong>不能够跨月份的</strong>。字符“<code>W</code>”只能配合一个 单独的数值使用，不能够是一个数字段，如：1-15W是错误的。</p></li><li><p>“<code>L</code>”和“<code>W</code>”可以在日期域中联合使用，<strong>LW表示这个月最后一周的工作日</strong>。</p></li><li><p>字符“<code>#</code>”只允许在星期域中出现。这个字符用于<strong>指定本月的某某天</strong>。<br>例如：</p><ul><li>“<code>6#3</code>”表示<strong>本月第三周的星期五</strong>（6表示星期五，3表示第三周）。</li><li>“<code>2#1</code>”表示<strong>本月第一周的星期一</strong>。</li><li>“<code>4#5</code>”表示<strong>第五周的星期三</strong>。</li></ul></li><li><p>字符“<code>C</code>”允许在<code>日期域</code>和<code>星期域</code>出现。这个字符依靠一个指定的“<code>日历</code>”。也就是说这个表达式的值依赖于相关的“日历”的计算结果，如果没有“日历” 关联，则等价于所有包含的“日历”。<br>如：日期域是“<code>5C</code>”表示关联“日历”中第一天，或者这个月开始的第一天的后5天。星期域是“<code>1C</code>”表示关联“日历” 中第一天，或者星期的第一天的后1天，也就是周日的后一天（周一）。</p></li></ol><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><table><thead><tr><th align="center">字段</th><th align="center">允许值</th></tr></thead><tbody><tr><td align="center">0 0 10,14,16 * * ?</td><td align="center">每天上午10点，下午2点，4点</td></tr><tr><td align="center">0 0/30 9-17 * * ?</td><td align="center">朝九晚五工作时间内每半小时</td></tr><tr><td align="center">0 0 12 ? *</td><td align="center">WED 表示每个星期三中午12点</td></tr><tr><td align="center">&quot;0 0 12 * * ?&quot;</td><td align="center">每天中午12点触发</td></tr><tr><td align="center">&quot;0 15 10 ? * *&quot;</td><td align="center">每天上午10:15触发</td></tr><tr><td align="center">&quot;0 15 10 * * ?&quot;</td><td align="center">每天上午10:15触发</td></tr><tr><td align="center">&quot;0 15 10 * * ? *&quot;</td><td align="center">每天上午10:15触发</td></tr><tr><td align="center">&quot;0 15 10 * * ? 2005&quot;</td><td align="center">2005年的每天上午10:15触发</td></tr><tr><td align="center">&quot;0 * 14 * * ?&quot;</td><td align="center">在每天下午2点到下午2:59期间的每1分钟触发</td></tr><tr><td align="center">&quot;0 0/5 14 * * ?&quot;</td><td align="center">在每天下午2点到下午2:55期间的每5分钟触发</td></tr><tr><td align="center">&quot;0 0/5 14,18 * * ?&quot;</td><td align="center">在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发</td></tr><tr><td align="center">&quot;0 0-5 14 * * ?&quot;</td><td align="center">在每天下午2点到下午2:05期间的每1分钟触发</td></tr><tr><td align="center">&quot;0 10,44 14 ? 3 WED&quot;</td><td align="center">每年三月的星期三的下午2:10和2:44触发</td></tr><tr><td align="center">&quot;0 15 10 ? * MON-FRI&quot;</td><td align="center">周一至周五的上午10:15触发</td></tr><tr><td align="center">&quot;0 15 10 15 * ?&quot;</td><td align="center">每月15日上午10:15触发</td></tr><tr><td align="center">&quot;0 15 10 L * ?&quot;</td><td align="center">每月最后一日的上午10:15触发</td></tr><tr><td align="center">&quot;0 15 10 ? * 6L&quot;</td><td align="center">每月的最后一个星期五上午10:15触发</td></tr><tr><td align="center">&quot;0 15 10 ? * 6L 2002-2005&quot;</td><td align="center">2002年至2005年的每月的最后一个星期五上午10:15触发</td></tr><tr><td align="center">&quot;0 15 10 ? * 6#3&quot;</td><td align="center">每月的第三个星期五上午10:15触发</td></tr><tr><td align="center">&quot;30 * * * * ?&quot;</td><td align="center">每半分钟触发任务</td></tr><tr><td align="center">&quot;30 10 1 20 * ?&quot;</td><td align="center">每月20号1点10分30秒触发任务</td></tr><tr><td align="center">&quot;30 10 1 20 10 ? *&quot;</td><td align="center">每年10月20号1点10分30秒触发任务</td></tr><tr><td align="center">&quot;30 10 1 20 10 ? 2011&quot;</td><td align="center">2011年10月20号1点10分30秒触发任务</td></tr><tr><td align="center">&quot;30 10 1 ? 10 * 2011&quot;</td><td align="center">2011年10月每天1点10分30秒触发任务</td></tr><tr><td align="center">&quot;30 10 1 ? 10 SUN 2011&quot;</td><td align="center">2011年10月每周日1点10分30秒触发任务</td></tr><tr><td align="center">&quot;15,30,45 * * * * ?&quot;</td><td align="center">每15秒，30秒，45秒时触发任务</td></tr><tr><td align="center">&quot;15-45 * * * * ?&quot;</td><td align="center">15到45秒内，每秒都触发任务</td></tr><tr><td align="center">0 * * * * ? *</td><td align="center">每分钟触发一次</td></tr><tr><td align="center">&quot;15/5 * * * * ?&quot;</td><td align="center">每分钟的每15秒开始触发，每隔5秒触发一次</td></tr><tr><td align="center">&quot;15-30/5 * * * * ?&quot;</td><td align="center">每分钟的15秒到30秒之间开始触发，每隔5秒触发一次</td></tr><tr><td align="center">&quot;0 0/3 * * * ?&quot;</td><td align="center">每小时的第0分0秒开始，每三分钟触发一次</td></tr><tr><td align="center">&quot;0 15 10 ? * MON-FRI&quot;</td><td align="center">星期一到星期五的10点15分0秒触发任务</td></tr><tr><td align="center">&quot;0 15 10 L * ?&quot;</td><td align="center">每个月最后一天的10点15分0秒触发任务</td></tr><tr><td align="center">&quot;0 15 10 LW * ?&quot;</td><td align="center">每个月最后一个工作日的10点15分0秒触发任务</td></tr><tr><td align="center">&quot;0 15 10 ? * 5L&quot;</td><td align="center">每个月最后一个星期四的10点15分0秒触发任务</td></tr><tr><td align="center">&quot;0 15 10 ? * 5#3&quot;</td><td align="center">每个月第三周的星期四的10点15分0秒触发任务</td></tr></tbody></table><h1 id="动态配置定时任务"><a href="#动态配置定时任务" class="headerlink" title="动态配置定时任务"></a>动态配置定时任务</h1><p>有时，我们会碰到这样的问题：需要修改触发器的触发时间，那么就要修改spring配置文件，再重启服务器，但是有很多时候我们没有条件去重启服务器；或者，有特定的需求，需要前台直接修改调度时间。这时候我们就要动态设置触发时间。详细配置请参考文章：<a href="http://ithead.iteye.com/blog/1460748" target="_blank" rel="noopener">http://ithead.iteye.com/blog/1460748</a></p><p>最后说一下，我们可以通过Quartz完整下载包中的Examples来快速学习使用掌握Quartz。</p><blockquote><ol><li><a href="http://www.cnblogs.com/jianzhi/p/3384436.html" target="_blank" rel="noopener">http://www.cnblogs.com/jianzhi/p/3384436.html</a></li><li><a href="http://www.dexcoder.com/selfly/article/297" target="_blank" rel="noopener">http://www.dexcoder.com/selfly/article/297</a></li><li>本文是系列<a href="http://www.dexcoder.com/selfly/series/20" target="_blank" rel="noopener">《Spring Quartz 定时任务系列》</a>中的其中一篇，点此<a href="http://www.dexcoder.com/selfly/series/20" target="_blank" rel="noopener">查看本系列全部文章</a>。</li><li><a href="http://quartz-scheduler.org/documentation/quartz-2.1.x/tutorials/crontrigger" target="_blank" rel="noopener">http://quartz-scheduler.org/documentation/quartz-2.1.x/tutorials/crontrigger</a></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
            <tag> Quartz </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL:一个分组取最大值并且去重</title>
      <link href="/2016/03/08/SQL-%E4%B8%80%E4%B8%AA%E5%88%86%E7%BB%84%E5%8F%96%E6%9C%80%E5%A4%A7%E5%80%BC%E5%B9%B6%E4%B8%94%E5%8E%BB%E9%87%8D/"/>
      <url>/2016/03/08/SQL-%E4%B8%80%E4%B8%AA%E5%88%86%E7%BB%84%E5%8F%96%E6%9C%80%E5%A4%A7%E5%80%BC%E5%B9%B6%E4%B8%94%E5%8E%BB%E9%87%8D/</url>
      
        <content type="html"><![CDATA[<p>处理分组获取最大值后去重的问题。</p><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><p>有一张表，字段和内容如下，</p><pre><code>id category   name   click  download--------------------------------------1     1         A      11     1082     1         B      12     1083     2         C      33     344     2         D      22     1085     3         E      21     516     3         F      32     68</code></pre><p>现在需要按category分组，每个类别只要一个结果，取download最大的那个，并且如果download<br>最大值有重复的，只取一个。如上表，我想要取出来的结果是：</p><pre><code>id category   name   click  download--------------------------------------1     1         A      11     1084     2         D      22     1086     3         F      32     68</code></pre><p>遇到的问题：现在卡在了如果一个类别的download最大值有重复的情况下，会把最大值重复的行一起取出来。</p><a id="more"></a><h2 id="创建表和数据"><a href="#创建表和数据" class="headerlink" title="创建表和数据"></a>创建表和数据</h2><pre><code class="sql">-- 创建表和数据startSET FOREIGN_KEY_CHECKS=0;-- ------------------------------ Table structure for groupbytoheavy-- ----------------------------DROP TABLE IF EXISTS `groupbytoheavy`;CREATE TABLE `groupbytoheavy` (  `id` int(128) NOT NULL auto_increment,  `category` int(128) default NULL,  `name` varchar(255) default NULL,  `click` int(128) default NULL,  `download` int(128) default NULL,  PRIMARY KEY  (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;-- ------------------------------ Records of groupbytoheavy-- ----------------------------INSERT INTO `groupbytoheavy` VALUES (&#39;1&#39;, &#39;1&#39;, &#39;A&#39;, &#39;11&#39;, &#39;108&#39;);INSERT INTO `groupbytoheavy` VALUES (&#39;2&#39;, &#39;1&#39;, &#39;B&#39;, &#39;12&#39;, &#39;108&#39;);INSERT INTO `groupbytoheavy` VALUES (&#39;3&#39;, &#39;2&#39;, &#39;C&#39;, &#39;33&#39;, &#39;34&#39;);INSERT INTO `groupbytoheavy` VALUES (&#39;4&#39;, &#39;2&#39;, &#39;D&#39;, &#39;22&#39;, &#39;108&#39;);INSERT INTO `groupbytoheavy` VALUES (&#39;5&#39;, &#39;3&#39;, &#39;E&#39;, &#39;21&#39;, &#39;51&#39;);INSERT INTO `groupbytoheavy` VALUES (&#39;6&#39;, &#39;3&#39;, &#39;F&#39;, &#39;32&#39;, &#39;68&#39;);-- 创建表和数据end</code></pre><h2 id="查询SQL"><a href="#查询SQL" class="headerlink" title="查询SQL"></a>查询SQL</h2><pre><code class="sql">--主要是2次，一次获取排名，一次排重，排重算法取最大或者最小id都可以SELECT    t.*FROM    groupbytoheavy t,    (        SELECT            MAX(t1.id) AS id,            t1.category        FROM            groupbytoheavy t1,            (                SELECT                    MAX(download) AS download,                    category                FROM                    groupbytoheavy                GROUP BY                    category            ) t2        WHERE            t1.category = t2.category        AND t1.download = t2.download        GROUP BY        t1.category    ) ttWHERE    t.id = tt.id</code></pre><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><pre><code>id    category    name   click    download---------------- ------ ------- -----------2        1          B      12        1084        2          D      22        1086        3          F      32        68</code></pre><h2 id="错误情景"><a href="#错误情景" class="headerlink" title="错误情景"></a>错误情景</h2><pre><code class="sql">SELECT    id,category,name,click,    MAX(download) AS download    FROM        groupbytoheavy    GROUP BY        category-- 没有遵循SQL标准，数据出现差行id    category    name   click    download---------------- ------ ------- -----------1        1          A      11       1083        2          C      33       108  --数据完全错误5        3          E      21       68   --数据完全错误</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jQuery全选反选</title>
      <link href="/2016/03/02/jQuery%E5%85%A8%E9%80%89%E5%8F%8D%E9%80%89/"/>
      <url>/2016/03/02/jQuery%E5%85%A8%E9%80%89%E5%8F%8D%E9%80%89/</url>
      
        <content type="html"><![CDATA[<p>项目使用freemarker<br>checkbox复选框的个数是依据从数据库中取出值的条数决定的，是list循环遍历出来的。</p><h2 id="界面"><a href="#界面" class="headerlink" title="界面"></a>界面</h2><pre><code class="html">&lt;table width=&quot;100%&quot; border=&quot;0&quot; align=&quot;center&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; &gt;    &lt;tr&gt;        &lt;td colspan=&quot;3&quot; align=&quot;center&quot; &gt;            &lt;strong&gt;                &lt;input type=&quot;checkbox&quot; name=&quot;checkAll&quot; id=&quot;checkAll&quot; onclick=&quot;checkAll23();&quot;/&gt;全选/反选            &lt;/strong&gt;        &lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td colspan=&quot;3&quot; style=&quot;border-top:1px solid #fff;&quot; &gt;&lt;/td&gt;    &lt;/tr&gt;&lt;#list page.list as item&gt;    &lt;tr&gt;        &lt;td&gt;            &lt;input type=&quot;checkbox&quot; id=&quot;check&quot; name=&quot;check&quot;  value=&quot;&lt;#if item.id?exists&gt;${item.id}&lt;/#if&gt;&quot;/&gt;        &lt;/td&gt;    &lt;/tr&gt;&lt;/#list&gt;&lt;/table&gt;</code></pre><a id="more"></a><h2 id="实现全选"><a href="#实现全选" class="headerlink" title="实现全选"></a>实现全选</h2><pre><code class="js">$(document).ready(function(){    //全选    $(&quot;#checkAll&quot;).click(function() {//全选框        if($(this).is(&quot;:checked&quot;)) {//选中，全选            $(&quot;input[name=&#39;check&#39;]&quot;).each(function() {                this.checked = true;            });        } else {//未选中，全不选            $(&quot;input[name=&#39;check&#39;]&quot;).each(function() {                this.checked = false;            });        }    });    $(&quot;input[name=&#39;check&#39;]&quot;).click(function() {//其他选择框        if($(this).is(&quot;:checked&quot;)) {            var flag = true;            $(&quot;input[name=&#39;check&#39;]&quot;).each(function() {                if(this.checked==false) {                    flag = false;                }            });            if(flag==true) {//全部选中，全选框选中                document.getElementById(&quot;checkAll&quot;).checked = true;            }        } else {//取消选中，全选框不选中            $(&quot;#checkAll&quot;).attr(&quot;checked&quot;, false);        }    });});</code></pre><h2 id="全选和反选"><a href="#全选和反选" class="headerlink" title="全选和反选"></a>全选和反选</h2><p>在全部选择状态下，选中全选/反选框，有一个未选中则不选中全选/反选框，同时实现反选的功能。<br>更好的选择是：将全选和反选分别提供一个按钮。</p><pre><code class="js">$(document).ready(function(){    //加载进来就是全选的情况 --start    var flag1 = true;    $(&quot;input[name=&#39;check&#39;]&quot;).each(function() {        if(this.checked==false) {            flag1 = false;        }    });    if(flag1==true) {        document.getElementById(&quot;checkAll&quot;).checked = true;    }//--end    $(&quot;input[name=&#39;check&#39;]&quot;).click(function() {        if($(this).is(&quot;:checked&quot;)) {            var flag = true;            $(&quot;input[name=&#39;check&#39;]&quot;).each(function() {                if(this.checked==false) {                    flag = false;                }            });            if(flag==true) {                document.getElementById(&quot;checkAll&quot;).checked = true;            }        } else {            $(&quot;#checkAll&quot;).attr(&quot;checked&quot;, false);        }    });});//全选反选function checkAll23(){    //反选    $(&quot;#checkAll&quot;).prop(&quot;disabled&quot;,&#39;true&#39;);    $(&quot;input[name=&#39;check&#39;]&quot;).each(function(){        if($(this).is(&quot;:checked&quot;)){            $(this).removeProp(&quot;checked&quot;);        }else{            $(this).prop(&quot;checked&quot;,&#39;true&#39;);        }    });    $(&quot;#checkAll&quot;).removeProp(&quot;disabled&quot;);    //上面的在 遨游浏览器中出现问题    //--可换用下方代码--start    var names=document.getElementsByName(&quot;check&quot;);    var len=names.length;    if(len&gt;0){        var i=0;        for(i=0;i&lt;len;i++){            if(names[i].checked)                 names[i].checked=false;             else                 names[i].checked=true;        }    }    //----end    //检查全选/反选框是否应该被选中    var flag = true;    $(&quot;input[name=&#39;check&#39;]&quot;).each(function() {        if(this.checked==false) {            flag = false;        }    });    if(flag==true) {        document.getElementById(&quot;checkAll&quot;).checked = true;    } else {        $(&quot;#checkAll&quot;).attr(&quot;checked&quot;, false);    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> jQuery </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
