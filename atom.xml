<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="https://www.w3.org/2005/Atom">
  <title>Gradatim&#39;s blog</title>
  
  <subtitle>Walk steps step by step</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://coolview.github.io/"/>
  <updated>2020-08-13T15:04:33.171Z</updated>
  <id>http://coolview.github.io/</id>
  
  <author>
    <name>Bin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL 事件</title>
    <link href="http://coolview.github.io/2020/08/13/MySQL/MySQL%20%E4%BA%8B%E4%BB%B6/"/>
    <id>http://coolview.github.io/2020/08/13/MySQL/MySQL%20%E4%BA%8B%E4%BB%B6/</id>
    <published>2020-08-13T15:04:29.000Z</published>
    <updated>2020-08-13T15:04:33.171Z</updated>
    
    <content type="html"><![CDATA[<h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><blockquote><p><a href="https://www.jianshu.com/p/8faa7dadd073" target="_blank" rel="noopener">https://www.jianshu.com/p/8faa7dadd073</a><br><a href="https://www.cnblogs.com/geaozhang/p/6821692.html" target="_blank" rel="noopener">https://www.cnblogs.com/geaozhang/p/6821692.html</a></p></blockquote><p>可以将数据库按自定义的时间周期触发某种操作，可以理解为时间触发器，类似于 linux 系统下面的任务调度器 crontab，或者类似与 window 下面的计划任务。</p><h2 id="查看事件功能是否开启"><a href="#查看事件功能是否开启" class="headerlink" title="查看事件功能是否开启"></a>查看事件功能是否开启</h2><pre><code class="sql">-- 方式一SHOW VARIABLES LIKE &#39;event_scheduler&#39;;-- 方式二SELECT @@event_scheduler;-- 方式三SHOW PROCESSLIST;-- 查看事件状态SHOW EVENTS;</code></pre><p>如果看到 <code>event_scheduler</code> 为 <code>on</code> 或者 <code>PROCESSLIST</code> 中显示有 <code>event_scheduler</code> 的信息说明就已经开启了事件。</p><h2 id="开启事件功能"><a href="#开启事件功能" class="headerlink" title="开启事件功能"></a>开启事件功能</h2><pre><code class="sql">-- 方式一、通过动态参数修改，更改完这个参数就立刻生效了，但是重启mysql又还原了，即设置不能跨重启。SET GLOBAL event_scheduler = ON;-- 方式二、更改配置文件然后重启，在my.cnf中的[mysqld]部分添加如下内容，然后重启mysql。event_scheduler=ON;-- 方式三、直接在启动命令加上 &quot;–event_scheduler=1&quot;mysqld ... --event_scheduler=ON</code></pre><h2 id="创建事件"><a href="#创建事件" class="headerlink" title="创建事件"></a>创建事件</h2><pre><code class="sql">CREATE    [DEFINER = { user | CURRENT_USER }]    EVENT    [IF NOT EXISTS]    event_name    ON SCHEDULE schedule    [ON COMPLETION [NOT] PRESERVE]    [ENABLE | DISABLE | DISABLE ON SLAVE]    [COMMENT &#39;comment&#39;]    DO event_body;schedule:    AT timestamp [+ INTERVAL interval] ...     | EVERY interval    [STARTS timestamp [+ INTERVAL interval] ...]    [ENDS timestamp [+ INTERVAL interval] ...]interval:  quantity {YEAR | QUARTER | MONTH | DAY | HOUR | MINUTE |              WEEK | SECOND | YEAR_MONTH | DAY_HOUR |DAY_MINUTE |DAY_SECOND | HOUR_MINUTE |HOUR_SECOND | MINUTE_SECOND}</code></pre><ol><li><p><code>definer</code>：指明该 event 的用户，服务器在执行该事件时，使用该用户来检查权限。默认用户为当前用户。</p></li><li><p><code>if not exists</code>：如果事件已经存在，则不会创建，也不会报错。</p></li><li><p><code>on schedule</code> 子句：指定何时执行该事件，以及如何执行该事件　　</p><ul><li><p><code>at timestamp</code> 用于<strong>创建单次执行的事件</strong>，timestamp 执行事件执行的时间(如果指定的时间是过去的时间，则会产生一个 warning)，时间可以是具体的时间字符串或者是一个 datetime 类型的表达式(如 current_timestamp)：</p><ul><li>如果要指定将来某个时间，直接使用 <code>at timestamp</code>，例：at &#39;2017-08-08 08:08:08&#39;；</li><li>如果要指定将来某个时间间隔，可利用 <code>interval</code> 关键字(interval 关键字可以进行组合，<code>at timestamp + INTERVAL 2 HOUR</code>、 <code>+ INTERVAL 30 MINUTE</code>)</li></ul></li><li><p><code>every</code> 子句用于<strong>创建重复执行的事件</strong>，如果每分钟执行一次，则可以：<code>EVERY 1 MINUTE</code>。当然，<code>every</code> 子句可以指定一个开始事件和结束时间，通过 <code>STARTS</code> 和 <code>ENDS</code> 关键字来表示，具体语法与前面类似，例如：<code>EVERY 12 HOUR STARTS CURRENT_TIMESTAMP + INTERVAL 30 MINUTE ENDS CURRENT_TIMESTAMP + INTERVAL 4 WEEK</code>。</p></li></ul></li><li><p>通常情况下，如果一个事件过期已过期，则会被立即删除。但是，create event 定义中通过 <code>on completion preserve</code> 子句可以保留已过期的事件。默认：<code>ON COMPLETION NOT PRESERVE</code>，也就是不保存。</p></li><li><p><code>[ENABLE | DISABLE | DISABLE ON SLAVE]</code> 默认为 ENABLE，即创建后立即启用。</p></li><li><p><code>comment</code> 子句用于给事件添加注释。</p></li><li><p><code>do</code> 子句用于指示事件需要执行的操作，可以是一条 SQL 语句，也可以是被 begin...end 包括的语句块，也可以在语句块中调用存储过程。</p></li></ol><h2 id="修改事件"><a href="#修改事件" class="headerlink" title="修改事件"></a>修改事件</h2><pre><code class="sql">ALTER    [DEFINER = { user | CURRENT_USER }]    EVENT event_name    [ON SCHEDULE schedule]    [ON COMPLETION [NOT] PRESERVE]    [RENAME TO new_event_name]    [ENABLE | DISABLE | DISABLE ON SLAVE]    [COMMENT &#39;comment&#39;]    [DO event_body]</code></pre><h2 id="删除事件"><a href="#删除事件" class="headerlink" title="删除事件"></a>删除事件</h2><pre><code class="sql">DROP EVENT [IF EXISTS] event_name;</code></pre><h2 id="事件使用举例"><a href="#事件使用举例" class="headerlink" title="事件使用举例"></a>事件使用举例</h2><h3 id="定时每隔-3-秒向表-test2-中插入数据"><a href="#定时每隔-3-秒向表-test2-中插入数据" class="headerlink" title="定时每隔 3 秒向表 test2 中插入数据"></a>定时每隔 3 秒向表 test2 中插入数据</h3><pre><code class="sql">create event event_insert_t2on schedule every 3 secondon completion preservedo insert into test2(department,time_v) value(&#39;1&#39;,now());</code></pre><h3 id="创建一个-10-分钟后清空-test-表数据的事件"><a href="#创建一个-10-分钟后清空-test-表数据的事件" class="headerlink" title="创建一个 10 分钟后清空 test 表数据的事件"></a>创建一个 10 分钟后清空 test 表数据的事件</h3><pre><code class="sql">CREATE EVENT IF NOT EXISTS event_truncate_test2ON SCHEDULEAT CURRENT_TIMESTAMP + INTERVAL 10 MINUTE-- AT TIMESTAMP &#39;2020-8-13 22:40:21&#39;  -- 指定时间删除DO TRUNCATE TABLE test2;</code></pre><h3 id="每年定时执行函数"><a href="#每年定时执行函数" class="headerlink" title="每年定时执行函数"></a>每年定时执行函数</h3><pre><code class="sql">CREATE EVENT `creat_t_table_event`ON SCHEDULE EVERY 1 YEAR STARTS &#39;2020-12-31 00:00:00&#39;ON COMPLETION NOT PRESERVEENABLECOMMENT &#39;每年最后一天执行函数&#39;DO call creat_t_table(date_format(DATE_ADD(now(), INTERVAL 1 YEAR), &#39;%Y&#39;))</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;事件&quot;&gt;&lt;a href=&quot;#事件&quot; class=&quot;headerlink&quot; title=&quot;事件&quot;&gt;&lt;/a&gt;事件&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/8faa7dadd073&quot; target=&quot;
      
    
    </summary>
    
    
      <category term="数据库" scheme="http://coolview.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="http://coolview.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Docker 简介与安装</title>
    <link href="http://coolview.github.io/2020/05/02/Docker%20%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%AE%89%E8%A3%85/"/>
    <id>http://coolview.github.io/2020/05/02/Docker%20%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%AE%89%E8%A3%85/</id>
    <published>2020-05-02T13:06:22.000Z</published>
    <updated>2020-08-13T15:06:13.310Z</updated>
    
    <content type="html"><![CDATA[<p>官方文档：<a href="https://docs.docker.com/" target="_blank" rel="noopener">https://docs.docker.com/</a></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。它是目前最流行的 Linux 容器解决方案。</p><p>Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。</p><p>总体来说，Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。</p><h1 id="Docker-的用途"><a href="#Docker-的用途" class="headerlink" title="Docker 的用途"></a>Docker 的用途</h1><p>Docker 的主要用途，目前有三大类。</p><ol><li><strong>提供一次性的环境</strong>。比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。</li><li><strong>提供弹性的云服务</strong>。因为 Docker 容器可以随开随关，很适合动态扩容和缩容。</li><li><strong>组建微服务架构</strong>。通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。</li></ol><h1 id="Docker-vs-VM"><a href="#Docker-vs-VM" class="headerlink" title="Docker vs VM"></a>Docker vs VM</h1><p>从下图可以看出，VM 是一个运行在宿主机之上的完整的操作系统，VM 运行自身操作系统会占用较多的 CPU、内存、硬盘资源。Docker 不同于 VM，只包含应用程序以及依赖库，基于 libcontainer 运行在宿主机上，并处于一个隔离的环境中，这使得 Docker 更加轻量高效，启动容器只需几秒钟之内完成。由于 Docker 轻量、资源占用少，使得 Docker 可以轻易的应用到构建标准化的应用中。但 Docker 目前还不够完善，比如隔离效果不如 VM，共享宿主机操作系统的一些基础库等；网络配置功能相对简单，主要以桥接方式为主；查看日志也不够方便灵活。</p><p>Container 和虚拟机在 IO 密集的应用中都需要调整优化以更好的支持 IO 操作，两者在 IO 密集型的应用中都应该谨慎使用。</p><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/2020504155527.png" alt="Docker vs VM"></p><p>具体来说与虚拟机技术对比，Docker 容器存在以下几个特点：</p><ul><li><strong>更快的启动速度</strong>：因为 Docker 直接运行于宿主内核，无需启动完整的操作系统，因此启动速度属于秒级别，而虚拟机通常需要几分钟去启动。</li><li><strong>更高效的资源利用率</strong>：由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用率更高。</li><li><strong>更高的系统支持量</strong>：Docker 的架构可以共用一个内核与共享应用程序库，所占内存极小。同样的硬件环境，Docker 运行的镜像数远多于虚拟机数量，对系统的利用率非常高。</li><li><strong>持续交付与部署</strong>：对开发和运维人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 Dockerfile 来进行镜像构建，并进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至进行自动部署。</li><li><strong>更轻松的迁移</strong>：由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。</li><li><strong>更轻松的维护与扩展</strong>：Docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，Docker 团队同各个开源项目团队一起维护了一大批高质量的 官方镜像，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。</li><li><strong>更弱的隔离性</strong>：Docker 属于进程之间的隔离，虚拟机可实现系统级别隔离。</li><li><strong>更弱的安全性</strong>：Docker 的租户 root 和宿主机 root 等同，一旦容器内的用户从普通用户权限提升为 root 权限，它就直接具备了宿主机的 root 权限，进而可进行无限制的操作。虚拟机租户 root 权限和宿主机的 root 虚拟机权限是分离的，并且利用硬件隔离技术可以防止虚拟机突破和彼此交互，而容器至今还没有任何形式的硬件隔离，这使得容器容易受到攻击。</li></ul><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/docker-architecture.svg" alt="docker 体系结构"></p><h2 id="Docker-daemon"><a href="#Docker-daemon" class="headerlink" title="Docker daemon"></a>Docker daemon</h2><p>Docker守护程序（dockerd）侦听 Docker API 请求并管理 Docker 对象，例如 images, containers, networks, and volumes。守护程序还可以与其他守护程序通信以管理Docker服务。</p><h2 id="Docker-client"><a href="#Docker-client" class="headerlink" title="Docker client"></a>Docker client</h2><p>Docker 命令行工具（docker）是用户与 Docker 交互的主要方式。当您使用诸如之类的命令时 docker run，client 会将这些命令发送到 dockerd，以执行这些命令。该 docker 命令使用 Docker API。Docker client 可以与多个 daemon 通信。</p><h2 id="Docker-objects"><a href="#Docker-objects" class="headerlink" title="Docker objects"></a>Docker objects</h2><h3 id="镜像-Image"><a href="#镜像-Image" class="headerlink" title="镜像(Image)"></a>镜像(Image)</h3><p>Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p><h3 id="容器-Container"><a href="#容器-Container" class="headerlink" title="容器(Container)"></a>容器(Container)</h3><p>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。</p><p>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</p><p>按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 <a href="https://vuepress.mirror.docker-practice.com/data_management/volume.html" target="_blank" rel="noopener">数据卷（Volume）</a>、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。</p><h3 id="Docker-Registry"><a href="#Docker-Registry" class="headerlink" title="Docker Registry"></a>Docker Registry</h3><p>镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry 就是这样的服务。</p><p>一个 Docker Registry 中可以包含多个 <strong>仓库</strong>（Repository）；每个仓库可以包含多个 <strong>标签</strong>（Tag）；每个标签对应一个镜像。</p><p>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 &lt;仓库名&gt;:&lt;标签&gt; 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。</p><h2 id="示例-docker-run-命令"><a href="#示例-docker-run-命令" class="headerlink" title="示例 docker run 命令"></a>示例 docker run 命令</h2><p>以下命令运行一个 ubuntu 容器，以交互方式附加到本地命令行会话，然后运行 <code>/bin/bash</code>。</p><pre><code class="shell">$ docker run -i -t ubuntu /bin/bash</code></pre><p>当您运行此命令时，会发生以下情况（假设使用的是默认 Registry 配置）：</p><ol><li><p>如果 ubuntu 本地没有该映像，则 Docker 会将其从已配置的 Registry 中拉出，相当于 <code>docker pull ubuntu</code>。</p></li><li><p>Docker 会创建一个新容器，相当于 <code>docker container create</code>。</p></li><li><p>Docker 将一个读写文件系统分配给容器，作为其最后一层。这允许运行中的容器在其本地文件系统中创建或修改文件和目录。</p></li><li><p>Docker 创建了一个网络接口以将容器连接到默认网络，因为未指定任何网络选项。这包括为容器分配 IP 地址。默认情况下，容器可以使用主机的网络连接连接到外部网络。</p></li><li><p>Docker 启动容器并执行 <code>/bin/bash</code>。</p><ul><li><code>-t</code>: 在新容器内指定一个伪终端或终端。</li><li><code>-i</code>: 允许你对容器内的标准输入 (STDIN) 进行交互。</li></ul></li><li><p>输入 <code>exit</code> 可终止 <code>/bin/bash</code> 命令时，容器将停止但不会被删除。可以重新启动或删除它。</p></li></ol><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="CentOS"><a href="#CentOS" class="headerlink" title="CentOS"></a>CentOS</h2><blockquote><p><a href="https://docs.docker.com/engine/install/centos/" target="_blank" rel="noopener">https://docs.docker.com/engine/install/centos/</a></p></blockquote><h3 id="卸载旧版本"><a href="#卸载旧版本" class="headerlink" title="卸载旧版本"></a>卸载旧版本</h3><pre><code class="shell">sudo yum remove docker \                  docker-client \                  docker-client-latest \                  docker-common \                  docker-latest \                  docker-latest-logrotate \                  docker-logrotate \                  docker-engine</code></pre><h3 id="设置存储库"><a href="#设置存储库" class="headerlink" title="设置存储库"></a>设置存储库</h3><pre><code class="shell">$ sudo yum install -y yum-utils# 使用国内源$ sudo yum-config-manager \    --add-repo \    https://mirrors.ustc.edu.cn/docker-ce/linux/centos/docker-ce.repo</code></pre><h3 id="安装-docker-ce"><a href="#安装-docker-ce" class="headerlink" title="安装 docker-ce"></a>安装 docker-ce</h3><pre><code class="shell">$ sudo yum install docker-ce上次元数据过期检查：0:00:57 前，执行于 2020年05月04日 星期一 21时47分13秒。错误： 问题: package docker-ce-3:19.03.8-3.el7.x86_64 requires containerd.io &gt;= 1.2.2-3, but none of the providers can be installed  - cannot install the best candidate for the job  - package containerd.io-1.2.10-3.2.el7.x86_64 is excluded  - package containerd.io-1.2.13-3.1.el7.x86_64 is excluded  - package containerd.io-1.2.2-3.3.el7.x86_64 is excluded  - package containerd.io-1.2.2-3.el7.x86_64 is excluded  - package containerd.io-1.2.4-3.1.el7.x86_64 is excluded  - package containerd.io-1.2.5-3.1.el7.x86_64 is excluded  - package containerd.io-1.2.6-3.3.el7.x86_64 is excluded(尝试添加 &#39;--skip-broken&#39; 来跳过无法安装的软件包 或 &#39;--nobest&#39; 来不只使用最佳选择的软件包)</code></pre><p>此时需要安装新版 <code>containerd.io</code></p><pre><code class="shell">$ sudo dnf install https://download.docker.com/linux/centos/7/x86_64/stable/Packages/containerd.io-1.2.6-3.3.el7.x86_64.rpm# 再次安装$ sudo yum install docker-ce</code></pre><h2 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h2><p>Docker CE 支持以下版本的 Ubuntu 操作系统：</p><ul><li>Eoan 19.10</li><li>Bionic 18.04 (LTS)</li><li>Xenial 16.04 (LTS)</li></ul><h3 id="卸载旧版本-1"><a href="#卸载旧版本-1" class="headerlink" title="卸载旧版本"></a>卸载旧版本</h3><pre><code class="shell">$ sudo apt-get remove docker docker-engine docker.io containerd runc</code></pre><h3 id="使用-APT-安装"><a href="#使用-APT-安装" class="headerlink" title="使用 APT 安装"></a>使用 APT 安装</h3><p>由于 apt 源使用 HTTPS 以确保软件下载过程中不被篡改。因此，我们首先需要添加使用 HTTPS 传输的软件包以及 CA 证书。</p><pre><code class="shell">$ sudo apt-get update$ sudo apt-get install \    apt-transport-https \    ca-certificates \    curl \    software-properties-common# 添加软件源的 GPG 密钥$ curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add -$ sudo add-apt-repository \    &quot;deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu \    $(lsb_release -cs) \    stable&quot;</code></pre><h3 id="安装-Docker-CE"><a href="#安装-Docker-CE" class="headerlink" title="安装 Docker CE"></a>安装 Docker CE</h3><p>更新 apt 软件包缓存，并安装 docker-ce：</p><pre><code class="shell">$ sudo apt-get update$ sudo apt-get install docker-ce</code></pre><h1 id="其他可选操作"><a href="#其他可选操作" class="headerlink" title="其他可选操作"></a>其他可选操作</h1><p><a href="https://docs.docker.com/engine/install/linux-postinstall/" target="_blank" rel="noopener">https://docs.docker.com/engine/install/linux-postinstall/</a></p><h2 id="设置启动"><a href="#设置启动" class="headerlink" title="设置启动"></a>设置启动</h2><pre><code class="shell"># 开机自启动$ sudo systemctl enable docker$ sudo systemctl start docker</code></pre><h2 id="以非-root-用户身份管理-docker"><a href="#以非-root-用户身份管理-docker" class="headerlink" title="以非 root 用户身份管理 docker"></a>以非 root 用户身份管理 docker</h2><p>默认情况下，docker 命令会使用 Unix socket 与 Docker 引擎通讯。而只有 root 用户和 docker 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 root 用户。因此，更好地做法是将需要使用 docker 的用户加入 docker 用户组。</p><p>建立 docker 组：</p><pre><code class="shell">$ sudo groupadd docker</code></pre><p>将当前用户加入 docker 组：</p><pre><code class="shell">$ sudo usermod -aG docker $USER</code></pre><h2 id="修改-docker-镜像源"><a href="#修改-docker-镜像源" class="headerlink" title="修改 docker 镜像源"></a>修改 docker 镜像源</h2><pre><code class="shell">$ cd /etc/docker$ sudo vim daemon.json# 添加以下内容{  &quot;registry-mirrors&quot;: [&quot;http://hub-mirror.c.163.com&quot;]}# 重新载入 systemd，扫描新的或有变动的单元$ sudo systemctl daemon-reload# 重新启动 docker 服务$ sudo systemctl restart docker</code></pre><h2 id="测试-hello-world"><a href="#测试-hello-world" class="headerlink" title="测试 hello-world"></a>测试 hello-world</h2><pre><code class="shell">$ docker run hello-worldUnable to find image &#39;hello-world:latest&#39; locallylatest: Pulling from library/hello-world0e03bdcc26d7: Pull completeDigest: sha256:8e3114318a995a1ee497790535e7b88365222a21771ae7e53687ad76563e8e76Status: Downloaded newer image for hello-world:latestHello from Docker!This message shows that your installation appears to be working correctly.To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.    (amd64) 3. The Docker daemon created a new container from that image which runs the    executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it    to your terminal.To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bashShare images, automate workflows, and more with a free Docker ID: https://hub.docker.com/For more examples and ideas, visit: https://docs.docker.com/get-started/</code></pre><h1 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h1><pre><code class="shell">$ sudo yum remove docker-ce docker-ce-cli containerd.io# 主机上的映像，容器，volumes 或自定义配置文件不会自动删除。$ sudo rm -rf /var/lib/docker</code></pre><h1 id="重命名-docker-容器名"><a href="#重命名-docker-容器名" class="headerlink" title="重命名 docker 容器名"></a>重命名 docker 容器名</h1><p><code>docker rename 原容器名  新容器名</code></p><h1 id="安装-docker-compose"><a href="#安装-docker-compose" class="headerlink" title="安装 docker-compose"></a>安装 docker-compose</h1><blockquote><p><a href="https://docs.docker.com/compose/install/" target="_blank" rel="noopener">https://docs.docker.com/compose/install/</a></p></blockquote><pre><code class="cmd">sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.26.2/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-composesudo chmod +x /usr/local/bin/docker-compose</code></pre><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote><p><a href="https://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html" target="_blank" rel="noopener">https://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html</a><br><a href="https://hijiangtao.github.io/2018/04/17/Docker-in-Action/" target="_blank" rel="noopener">https://hijiangtao.github.io/2018/04/17/Docker-in-Action/</a><br><a href="https://yeasy.gitbooks.io/docker_practice/" target="_blank" rel="noopener">https://yeasy.gitbooks.io/docker_practice/</a><br><a href="https://lisongyang.club/2020/04/16/docker/" target="_blank" rel="noopener">https://lisongyang.club/2020/04/16/docker/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;官方文档：&lt;a href=&quot;https://docs.docker.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.docker.com/&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="Docker" scheme="http://coolview.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://coolview.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis 10-缓存配置</title>
    <link href="http://coolview.github.io/2019/12/01/MyBatis/MyBatis%2010-%E7%BC%93%E5%AD%98%E9%85%8D%E7%BD%AE/"/>
    <id>http://coolview.github.io/2019/12/01/MyBatis/MyBatis%2010-%E7%BC%93%E5%AD%98%E9%85%8D%E7%BD%AE/</id>
    <published>2019-12-01T07:53:26.000Z</published>
    <updated>2019-12-03T07:54:10.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="http://www.broadview.com.cn/book/3643" target="_blank" rel="noopener">http://www.broadview.com.cn/book/3643</a><br><a href="https://github.com/mybatis-book/book" target="_blank" rel="noopener">https://github.com/mybatis-book/book</a></p></blockquote><p>一般提到 MyBatis 缓存时都是指二级缓存。一级缓存默认会启用，且不能控制。</p><h1 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h1><pre><code class="java">@Testpublic void testL1Cache(){    // 获取 sqlSession    SqlSession sqlSession = getSqlSession();    SysUser user1 = null;    try {        // 获取 UserMapper 接口        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);        // 调用 selectById 方法，查询 id = 1 的用户        user1 = userMapper.selectById(1l);        // 对当前获取的对象重新赋值        user1.setUserName(&quot;New Name&quot;);        // 再次查询获取 id 相同的用户        SysUser user2 = userMapper.selectById(1l);        // 虽然我们没有更新数据库，但是这个用户名和我们 user1 重新赋值的名字相同了        Assert.assertEquals(&quot;New Name&quot;, user2.getUserName());        // 不仅如何，user2 和 user1 完全就是同一个实例        Assert.assertEquals(user1, user2);    } finally {        // 关闭当前的 sqlSession        sqlSession.close();    }    System.out.println(&quot;开启新的 sqlSession&quot;);    // 开始另一个新的 session    sqlSession = getSqlSession();    try {        // 获取 UserMapper 接口        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);        // 调用 selectById 方法，查询 id = 1 的用户        SysUser user2 = userMapper.selectById(1l);        // 第二个 session 获取的用户名仍然是 admin        Assert.assertNotEquals(&quot;New Name&quot;, user2.getUserName());        // 这里的 user2 和 前一个 session 查询的结果是两个不同的实例        Assert.assertNotEquals(user1, user2);        // 执行删除操作        userMapper.deleteById(2L);        // 获取 user3        SysUser user3 = userMapper.selectById(1l);        // 这里的 user2 和 user3 是两个不同的实例        Assert.assertNotEquals(user2, user3);    } finally {        // 关闭 sqlSession        sqlSession.close();    }}</code></pre><p>MyBatis 的一级缓存存在于 SqlSession 的生命周期中，在同一个 SqlSession 中查询时，MyBatis会把执行的方法和参数通过算法生成缓存的键值，将键值和查询结果存入一个 Map 对象中。如果同一个 SqlSession 中执行的方法和参数完全一致，那么通过算法会生成相同的键值，当 Map 缓存对象中已经存在该键值时，则会返回缓存中的对象。</p><p>如果不想让 selectById 方法使用一级缓存，可以加上 <code>flushCach=&quot;true&quot;</code>，会在查询数据前清空当前的一级缓存。</p><pre><code class="xml">&lt;!-- useCache=&quot;false&quot; 可以禁止使用缓存 --&gt;&lt;select id=&quot;selectById&quot; flushCache=&quot;true&quot; resultMap=&quot;userMap&quot;&gt;    select * from sys_user where id=#{id}&lt;/select&gt;</code></pre><p>另外所有的 insert，update、delete 操作都会清空一级缓存。</p><h1 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h1><p>一级缓存只存在于 SqlSession 的生命周期中，而二级缓存可以理解为存在于 SqlSessionFactory 的生命周期中。</p><h2 id="配置二级缓存"><a href="#配置二级缓存" class="headerlink" title="配置二级缓存"></a>配置二级缓存</h2><p>mybatis-config.xml 文件中可以配置二级缓存的全局开关，默认是 true</p><pre><code class="xml">&lt;settings&gt;    &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;&gt;&lt;/settings&gt;</code></pre><p>二级缓存是和命名空间绑定的，所以需要配置在 Mapper.xml 映射文件中（命名空间是 xml 根节点 mapper 的 namespace 属性），或者配置在 Mapper.java 接口中（命令空间就是接口的全限定名称）。</p><h3 id="Mapper-xml-中配置二级缓存"><a href="#Mapper-xml-中配置二级缓存" class="headerlink" title="Mapper.xml 中配置二级缓存"></a>Mapper.xml 中配置二级缓存</h3><p>只需要在你的 SQL 映射文件中添加一行 <code>&lt;cache/&gt;</code></p><p>默认效果：</p><ul><li>映射语句文件中的所有 select 语句的结果将会被缓存。</li><li>映射语句文件中的所有 insert、update 和 delete 语句会刷新缓存。</li><li>缓存会使用最近最少使用算法（LRU, Least Recently Used）算法来清除不需要的缓存。</li><li>缓存不会定时进行刷新（也就是说，没有刷新间隔）。</li><li>缓存会保存列表或对象（无论查询方法返回哪种）的 1024 个引用。</li><li>缓存会被视为读/写缓存，这意味着获取到的对象并不是共享的，可以安全地被调用者修改，而不干扰其他调用者或线程所做的潜在修改。</li></ul><p>这些属性可以通过 cache 元素的属性来修改。比如：</p><pre><code class="xml">&lt;cache    eviction=&quot;FIFO&quot;    flushInterval=&quot;60000&quot;    size=&quot;512&quot;    readOnly=&quot;true&quot;/&gt;</code></pre><p>这个更高级的配置创建了一个 FIFO 缓存，每隔 60 秒刷新，最多可以存储结果对象或列表的 512 个引用，而且返回的对象被认为是只读的，因此对它们进行修改可能会在不同线程中的调用者产生冲突。</p><ol><li><code>eviction</code>（回收策略）：<ul><li>LRU – 最近最少使用：移除最长时间不被使用的对象。默认策略</li><li>FIFO – 先进先出：按对象进入缓存的顺序来移除它们。</li><li>SOFT – 软引用：基于垃圾回收器状态和软引用规则移除对象。</li><li>WEAK – 弱引用：更积极地基于垃圾收集器状态和弱引用规则移除对象。</li></ul></li><li><code>flushInterval</code>（刷新间隔）属性可以被设置为任意的正整数，设置的值应该是一个以毫秒为单位的合理时间量。 默认情况是不设置，也就是没有刷新间隔，缓存仅仅会在调用语句时刷新。</li><li><code>size</code>（引用数目）属性可以被设置为任意正整数，要注意欲缓存对象的大小和运行环境中可用的内存资源。默认值是 1024。</li><li><code>readOnly</code>（只读）属性可以被设置为 true 或 false。只读的缓存会给所有调用者返回缓存对象的相同实例。 因此这些对象不能被修改。这就提供了可观的性能提升。而可读写的缓存会（通过序列化）返回缓存对象的拷贝。 速度上会慢一些，但是更安全，因此默认值是 false。</li></ol><h3 id="Mapper-接口中配置二级缓存"><a href="#Mapper-接口中配置二级缓存" class="headerlink" title="Mapper 接口中配置二级缓存"></a>Mapper 接口中配置二级缓存</h3><pre><code class="java">@CacheNamespace(    eviction=FifoCache.class,    flushInterval=60000,    size=512,    readWrite=true  // true 为读写（默认），false 为只读)public interface RoleMapper {}</code></pre><p>当同时使用注解方式和 xml 映射文件时，如果同时配置了二级缓存，会抛出异常 Caches collection already contains value for tk.mybatis.simple.mapper.RoleMapper</p><p>因为这时是相同的命名空间，这时应该使用<strong>参照缓存</strong></p><pre><code class="java">// 这样就会使用命名空间为 tk.mybatis.simple.mapper.RoleMapper 的缓存配置，即 RoleMapper.xml 中配置的缓存@CacheNamespaceRef(RoleMapper.class)public interface RoleMapper {}</code></pre><p>也可以在 xml 中配置参照缓存</p><pre><code class="xml">&lt;cache-ref namespace=&quot;tk.mybatis.simple.mapper.RoleMapper&quot;/&gt;</code></pre><p>不会同时使用 Mapper 接口注解方式和 xml 映射文件，所以参照缓存不是为解决这个问题设计的，主要作用是解决脏读</p><h2 id="使用二级缓存"><a href="#使用二级缓存" class="headerlink" title="使用二级缓存"></a>使用二级缓存</h2><p>由于配置的是可读写的缓存，而 MyBatis 使用 SerializedCache 序列化缓存来实现可读写缓存类，并通过序列化和反序列化来保证通过缓存获取数据时，得到的是一个新的实例。如果配置为只读缓存，MyBatis 会使用 Map 来存储缓存值。</p><p>使用 SerializedCache 序列化缓存，要求所有被序列化的对象必须实现 Serializable 接口。</p><pre><code class="java">public class SysRole implements Serializable {    private static final long serialVersionUID = 6320941908222932112L;}</code></pre><p>测试</p><pre><code class="java">@Testpublic void testL2Cache(){    SqlSession sqlSession = getSqlSession();    SysRole role1 = null;    try {        // 获取 RoleMapper 接口        RoleMapper roleMapper = sqlSession.getMapper(RoleMapper.class);        // 调用 selectById 方法，查询 id = 1 的用户        role1 = roleMapper.selectById(1l);        // 对当前获取的对象重新赋值        role1.setRoleName(&quot;New Name&quot;);        // 再次查询获取 id 相同的用户        SysRole role2 = roleMapper.selectById(1l);        // 虽然我们没有更新数据库，但是这个用户名和我们 role1 重新赋值的名字相同了        Assert.assertEquals(&quot;New Name&quot;, role2.getRoleName());        // 不仅如何，role2 和 role1 完全就是同一个实例        Assert.assertEquals(role1, role2);    } finally {        sqlSession.close();    }    System.out.println(&quot;开启新的 sqlSession&quot;);    // 开始另一个新的 session    sqlSession = getSqlSession();    try {        // 获取 RoleMapper 接口        RoleMapper roleMapper = sqlSession.getMapper(RoleMapper.class);        // 调用 selectById 方法，查询 id = 1 的用户        SysRole role2 = roleMapper.selectById(1l);        // 第二个 session 获取的用户名仍然是 admin        Assert.assertEquals(&quot;New Name&quot;, role2.getRoleName());        // 这里的 role2 和 前一个 session 查询的结果是两个不同的实例        Assert.assertNotEquals(role1, role2);        // 获取 role3        SysRole role3 = roleMapper.selectById(1l);        // 这里的 role2 和 role3 是两个不同的实例        Assert.assertNotEquals(role2, role3);    } finally {        sqlSession.close();    }}</code></pre><pre><code class="java">// 第一次没有缓存，命中率 0DEBUG [main] - Cache Hit Ratio [tk.mybatis.simple.mapper.RoleMapper]: 0.0DEBUG [main] - ==&gt;  Preparing: select id,role_name roleName, enabled, create_by createBy, create_time createTime from sys_role where id = ?DEBUG [main] - ==&gt; Parameters: 1(Long)TRACE [main] - &lt;==    Columns: id, roleName, enabled, createBy, createTimeTRACE [main] - &lt;==        Row: 1, 管理员, 1, 1, 2016-04-01 17:02:14DEBUG [main] - &lt;==      Total: 1// 使用的一级缓存，所以命中率还是 0DEBUG [main] - Cache Hit Ratio [tk.mybatis.simple.mapper.RoleMapper]: 0.0开启新的 sqlSession// 第三次查询，命中率 1/3DEBUG [main] - Cache Hit Ratio [tk.mybatis.simple.mapper.RoleMapper]: 0.3333333333333333DEBUG [main] - Cache Hit Ratio [tk.mybatis.simple.mapper.RoleMapper]: 0.5</code></pre><p>这个例子中没有真正的读写安全，<code>role1.setRoleName(&quot;New Name&quot;);</code>，第二部分的代码中查询结果 roleName 都是 &quot;New Name&quot;。所以想要安全使用，需要避免无意义的修改。</p><h1 id="集成-EhCache"><a href="#集成-EhCache" class="headerlink" title="集成 EhCache"></a>集成 EhCache</h1><p>EhCache 是一个纯粹的 Java 进程内的缓存框架，具有快速、精干等特点。具体来说，EhCache 主要的特性如下。</p><ul><li>快速。</li><li>简单。</li><li>多种缓存策略。</li><li>缓存数据有内存和磁盘两级，无须担心容量问题。</li><li>存数据会在虚拟机重启的过程中写入磁盘。</li><li>可以通过RMI、可插入 AP I等方式进行分布式缓存。</li><li>具有缓存和缓存管理器的侦昕接口。</li><li>支持多缓存管理器实例以及一个实例的多个缓存区域。</li></ul><h2 id="添加项目依赖"><a href="#添加项目依赖" class="headerlink" title="添加项目依赖"></a>添加项目依赖</h2><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.mybatis.caches&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt;    &lt;version&gt;1.0.3&lt;/version&gt;&lt;/dependency&gt;</code></pre><h2 id="配置-EhCache"><a href="#配置-EhCache" class="headerlink" title="配置 EhCache"></a>配置 EhCache</h2><p>在 src/main/resources 目录下新增 ehcache.xml 文件</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:noNamespaceSchemaLocation=&quot;ehcache.xsd&quot;    updateCheck=&quot;false&quot; monitoring=&quot;autodetect&quot;    dynamicConfig=&quot;true&quot;&gt;    &lt;diskStore path=&quot;D:/cache&quot; /&gt;    &lt;defaultCache        maxElementsInMemory=&quot;3000&quot;        eternal=&quot;false&quot;        copyOnRead=&quot;true&quot;        copyOnWrite=&quot;true&quot;        timeToIdleSeconds=&quot;3600&quot;        timeToLiveSeconds=&quot;3600&quot;        overflowToDisk=&quot;true&quot;        diskPersistent=&quot;true&quot;/&gt;&lt;/ehcache&gt;</code></pre><ul><li><p>maxElementsInMemory：设置基于内存的缓存中可存放的对象最大数目</p></li><li><p>eternal：设置对象是否为永久的，true 表示永不过期，此时将忽略</p></li><li><p>timeToIdleSeconds：设置对象空闲最长时间，以秒为单位，超过这个时间对象过期。当对象过期时，ehCache 会把它从缓存中清除。如果此值为 0，表示对象可以无限期地处于空闲状态。</p></li><li><p>timeToLiveSeconds：设置对象生存最长时间，超过这个时间，对象过期。如果此值为 0，表示对象可以无限期地存在于缓存中，该属性值必须大于或等于 timeToIdleSeconds 属性值</p></li><li><p>overflowToDisk：设置基于内在的缓存中的对象数目达到上限后，是否把溢出的对象写到基于硬盘的缓存中</p></li><li><p>diskPersistent：当 jvm 结束时是否持久化对象 true false 默认是false</p></li><li><p>diskExpiryThreadIntervalSeconds：指定专门用于清除过期对象的监听线程的轮询时间</p></li><li><p>memoryStoreEvictionPolicy：当内存缓存达到最大，有新的 element 加入的时候，移除缓存中 element 的策略，默认是LRU（最近最少使用），可选的有LFU（最不常使用）和 FIFO（先进先出）</p></li><li><p><code>copyOnRead</code> ：判断从缓存中读取数据时是返回对象的引用还是复制一个对象返回。默认情况下是 false，即返回数据的引用，这种情况下返回的都是相同的对象，和 MyBatis 默认缓存中的只读对象是相同的。如果设置为 true，那就是可读写缓存，每次读取缓存时都会复制一个新的实例。</p></li><li><p><code>copyOnWrite</code> ：判断写入缓存时是直接缓存对象的引用还是复制一个对象然后缓存，默认也是 false。如果想使用可读写缓存，就需要将这两个属性配置为 true，如果使用只读缓存，可以不配置这两个属性，使用默认值 false 即可。</p></li></ul><h2 id="修改-RoleMapper-xml-中的缓存配置"><a href="#修改-RoleMapper-xml-中的缓存配置" class="headerlink" title="修改 RoleMapper.xml 中的缓存配置"></a>修改 RoleMapper.xml 中的缓存配置</h2><p>修改 RoleMapper.xml 中的配置如下。</p><pre><code class="xml">&lt;mapper namespace＝&quot;tk.mybatis.simple.mapper.RoleMapper&quot;&gt;    &lt;!-- cache 其他属性不会起到任何作用 --&gt;    &lt;cache type＝&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;/&gt;&lt;/mapper&gt;</code></pre><p>ehcache.xml 只有一个默认的缓存配置，如果想针对某一个命名空间进行配置，需添加</p><pre><code class="xml">&lt;cache    name=&quot;tk.mybatis.simple.mapper.RoleMapper&quot;    maxElementsInMemory=&quot;3000&quot;    eternal=&quot;false&quot;    copyOnRead=&quot;true&quot;    copyOnWrite=&quot;true&quot;    timeToIdleSeconds=&quot;3600&quot;    timeToLiveSeconds=&quot;3600&quot;    overflowToDisk=&quot;true&quot;    diskPersistent=&quot;true&quot;/&gt;</code></pre><h1 id="集成-Redis-缓存"><a href="#集成-Redis-缓存" class="headerlink" title="集成 Redis 缓存"></a>集成 Redis 缓存</h1><h2 id="添加项目依赖-1"><a href="#添加项目依赖-1" class="headerlink" title="添加项目依赖"></a>添加项目依赖</h2><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.mybatis.caches&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-redis&lt;/artifactId&gt;    &lt;version&gt;1.0.0-beta2&lt;/version&gt;&lt;/dependency&gt;</code></pre><h2 id="配置-Redis"><a href="#配置-Redis" class="headerlink" title="配置 Redis"></a>配置 Redis</h2><p>在 src/main/resources 目录下新增 redis.properties 文件</p><pre><code class="ini">host=127.0.0.1port=6379connectionTimeout=5000soTimeout=5000password=database=0clientName=</code></pre><h2 id="修改-RoleMapper-xml-中的缓存配置-1"><a href="#修改-RoleMapper-xml-中的缓存配置-1" class="headerlink" title="修改 RoleMapper.xml 中的缓存配置"></a>修改 RoleMapper.xml 中的缓存配置</h2><pre><code class="xml">&lt;mapper namespace＝&quot;tk.mybatis.simple.mapper.RoleMapper&quot;&gt;    &lt;cache type＝&quot;org.mybatis.caches.redis.RedisCache&quot;/&gt;&lt;/mapper&gt;</code></pre><h1 id="脏数据的产生和避免"><a href="#脏数据的产生和避免" class="headerlink" title="脏数据的产生和避免"></a>脏数据的产生和避免</h1><p>一个多表的查询就会缓存在某命名空间的二级缓存中。涉及这些表的增、删、改操作通常不在一个映射文件中，它们的命名空间不同，因此当有数据变化时，多表查询的缓存未必会被清空，这种情况下就会产生脏数据。</p><p>在 UserMapper.xml 添加二级缓存配置，增加 <code>&lt;cache/&gt;</code> 元素，SysUser 对象实现 Serializable 接口。</p><pre><code class="java">@Testpublic void testDirtyData(){    SqlSession sqlSession = getSqlSession();    try {        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);        SysUser user = userMapper.selectUserAndRoleById(1001L);        Assert.assertEquals(&quot;普通用户&quot;, user.getRole().getRoleName());        System.out.println(&quot;角色名：&quot; + user.getRole().getRoleName());    } finally {        sqlSession.close();    }    // 开始另一个新的 session    sqlSession = getSqlSession();    try {        RoleMapper roleMapper = sqlSession.getMapper(RoleMapper.class);        SysRole role = roleMapper.selectById(2L);        role.setRoleName(&quot;脏数据&quot;);        roleMapper.updateById(role);        sqlSession.commit();    } finally {        sqlSession.close();    }    System.out.println(&quot;开启新的 sqlSession&quot;);    sqlSession = getSqlSession();    try {        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);        RoleMapper roleMapper = sqlSession.getMapper(RoleMapper.class);        SysUser user = userMapper.selectUserAndRoleById(1001L);        SysRole role = roleMapper.selectById(2L);        Assert.assertEquals(&quot;普通用户&quot;, user.getRole().getRoleName());        Assert.assertEquals(&quot;脏数据&quot;, role.getRoleName());        System.out.println(&quot;角色名：&quot; + user.getRole().getRoleName());        // 还原数据        role.setRoleName(&quot;普通用户&quot;);        roleMapper.updateById(role);        sqlSession.commit();    } finally {        sqlSession.close();    }}</code></pre><p>第一个 SqlSession 中获取了用户和关联的角色信息，第二个 SqlSession 中查询角色并修改了角色的信息，第三个 SqlSession 查询用户和关联的角色信息。这时从缓存中直接取出数据，就出现了脏数据，因为角色名称己经修改，但是这里读取到的角色名称仍然是修改前的名字，因此出现了脏读。</p><p>如何避免脏数据的出现？就需要用到参照缓存了。可以让几个会关联的表同时使用同一个二级缓存。修改 UserMapper.xml 的缓存配置。</p><pre><code class="xml">&lt;cache-ref namespace=&quot;tk.mybatis.simple.mapper.RoleMapper&quot;&gt;</code></pre><h1 id="二级缓存适用场景"><a href="#二级缓存适用场景" class="headerlink" title="二级缓存适用场景"></a>二级缓存适用场景</h1><ul><li>查询为主的应用中，只有尽可能少的增、删、改操作。</li><li>绝大多数以单表操作存在时，由于很少存在互相关联的情况，因此不会出现脏数据。</li><li>可以按业务划分对表进行分组时，如关联的表比较少，可以通过参照缓存进行配置。</li></ul><p>除了推荐使用的情况，如果脏读对系统没有影响，也可以考虑使用。在无法保证数据不出现脏读的情况下，建议在业务层使用可控制的缓存代替二级缓存。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://www.broadview.com.cn/book/3643&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.broadview.com.cn/book/3643&lt;/a&gt;&lt;br&gt;
      
    
    </summary>
    
    
      <category term="Java" scheme="http://coolview.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="http://coolview.github.io/tags/Java/"/>
    
      <category term="MyBatis" scheme="http://coolview.github.io/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis 09-使用枚举或其他对象</title>
    <link href="http://coolview.github.io/2019/12/01/MyBatis/MyBatis%2009-%E4%BD%BF%E7%94%A8%E6%9E%9A%E4%B8%BE%E6%88%96%E5%85%B6%E4%BB%96%E5%AF%B9%E8%B1%A1/"/>
    <id>http://coolview.github.io/2019/12/01/MyBatis/MyBatis%2009-%E4%BD%BF%E7%94%A8%E6%9E%9A%E4%B8%BE%E6%88%96%E5%85%B6%E4%BB%96%E5%AF%B9%E8%B1%A1/</id>
    <published>2019-12-01T06:33:25.000Z</published>
    <updated>2019-12-01T07:13:20.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="http://www.broadview.com.cn/book/3643" target="_blank" rel="noopener">http://www.broadview.com.cn/book/3643</a><br><a href="https://github.com/mybatis-book/book" target="_blank" rel="noopener">https://github.com/mybatis-book/book</a></p></blockquote><h1 id="使用-MyBatis-提供的枚举处理器"><a href="#使用-MyBatis-提供的枚举处理器" class="headerlink" title="使用 MyBatis 提供的枚举处理器"></a>使用 MyBatis 提供的枚举处理器</h1><pre><code class="java">public enum Enabled {    enabled,  // 启用    disabled; // 禁用}</code></pre><p>修改 SysRole 中 enabled 的类型</p><pre><code class="java">private Enabled enabled；</code></pre><p>MyBatis 处理枚举类型时默认使用 org.apache.ibatis.type.EnumTypeHandler 处理器，这个处理器会将枚举类型转换为字符串类型的字面值并使用。对于 Enabled 而言便是 &quot;enabled&quot;，&quot;disabled&quot; 字符串。由于数据库中使用的是 int 类型，所以转换时肯定会报错。</p><p>MyBatis 还提供了另一个 org.apache.ibatis.type.EnumOrdinalTypeHandler 处理器，这个处理器使用枚举的索引进行处理，可以解决遇到的问题，在 mybatis-config.xml 中添加配置：</p><pre><code class="xml">&lt;typeHandlers&gt;    &lt;typeHandler        javaType=&quot;tk.mybatis.simple.type.Enabled&quot;        handler=&quot;org.apache.ibatis.type.EnumOrdinalTypeHandler&quot;/&gt;&lt;/typeHandlers&gt;</code></pre><h1 id="使用自定义的类型处理器"><a href="#使用自定义的类型处理器" class="headerlink" title="使用自定义的类型处理器"></a>使用自定义的类型处理器</h1><p>有时候，值既不是枚举的字面值，也不是枚举的索引值，这样就需要自己来实现类型处理器了。</p><pre><code class="java">public enum Enabled {    enabled(1), //启用    disabled(0);//禁用    private final int value;    private Enabled(int value) {        this.value = value;    }    public int getValue() {        return value;    }}</code></pre><pre><code class="java">/** * Enabled 类型处理器 */public class EnabledTypeHandler implements TypeHandler&lt;Enabled&gt; {    private final Map&lt;Integer, Enabled&gt; enabledMap = new HashMap&lt;Integer, Enabled&gt;();    public EnabledTypeHandler() {        for(Enabled enabled : Enabled.values()){            enabledMap.put(enabled.getValue(), enabled);        }    }    public EnabledTypeHandler(Class&lt;?&gt; type) {        this();    }    @Override    public void setParameter(PreparedStatement ps, int i, Enabled parameter, JdbcType jdbcType) throws SQLException {        ps.setInt(i, parameter.getValue());    }    @Override    public Enabled getResult(ResultSet rs, String columnName) throws SQLException {        Integer value = rs.getInt(columnName);        return enabledMap.get(value);    }    @Override    public Enabled getResult(ResultSet rs, int columnIndex) throws SQLException {        Integer value = rs.getInt(columnIndex);        return enabledMap.get(value);    }    @Override    public Enabled getResult(CallableStatement cs, int columnIndex) throws SQLException {        Integer value = cs.getInt(columnIndex);        return enabledMap.get(value);    }}</code></pre><p>在 mybatis-config.xml 中修改配置：</p><pre><code class="xml">&lt;typeHandlers&gt;    &lt;typeHandler        javaType=&quot;tk.mybatis.simple.type.Enabled&quot;        handler=&quot;tk.mybatis.simple.type.EnabledTypeHandler&quot;/&gt;&lt;/typeHandlers&gt;</code></pre><h1 id="对-Java8-日期的支持"><a href="#对-Java8-日期的支持" class="headerlink" title="对 Java8 日期的支持"></a>对 Java8 日期的支持</h1><p><a href="https://github.com/mybatis/typehandlers-jsr310" target="_blank" rel="noopener">https://github.com/mybatis/typehandlers-jsr310</a></p><p>MyBatis 从 3.4.0 版本开始增加对 Java8 日期的支持。如果使用 3.4.0 及以上版本时，只需添加依赖即可。</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-typehandlers-jsr310&lt;/artifactId&gt;    &lt;version&gt;l.0.2&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>如果使用更早的版本，还需要在 mybatis-config.xml 中添加如下配置。</p><pre><code class="xml">&lt;typeHandlers&gt;    &lt;!-- ... --&gt;    &lt;typeHandler handler=&quot;org.apache.ibatis.type.InstantTypeHandler&quot; /&gt;    &lt;typeHandler handler=&quot;org.apache.ibatis.type.LocalDateTimeTypeHandler&quot; /&gt;    &lt;typeHandler handler=&quot;org.apache.ibatis.type.LocalDateTypeHandler&quot; /&gt;    &lt;typeHandler handler=&quot;org.apache.ibatis.type.LocalTimeTypeHandler&quot; /&gt;    &lt;typeHandler handler=&quot;org.apache.ibatis.type.OffsetDateTimeTypeHandler&quot; /&gt;    &lt;typeHandler handler=&quot;org.apache.ibatis.type.OffsetTimeTypeHandler&quot; /&gt;    &lt;typeHandler handler=&quot;org.apache.ibatis.type.ZonedDateTimeTypeHandler&quot; /&gt;    &lt;typeHandler handler=&quot;org.apache.ibatis.type.YearTypeHandler&quot; /&gt;    &lt;typeHandler handler=&quot;org.apache.ibatis.type.MonthTypeHandler&quot; /&gt;    &lt;typeHandler handler=&quot;org.apache.ibatis.type.YearMonthTypeHandler&quot; /&gt;    &lt;typeHandler handler=&quot;org.apache.ibatis.type.JapaneseDateTypeHandler&quot; /&gt;&lt;/typeHandlers&gt;</code></pre><p>为什么这些 typeHandler 都没有配置 javaType 呢？看看 InstantTypeHandler 的源码</p><pre><code class="java">public class InstantTypeHandler extends BaseTypeHandler&lt;Instant&gt; {    // ...}</code></pre><p>InstantTypeHandler 继承了 <code>BaseTypeHandler&lt;T&gt;</code> 类，而 <code>BaseTypeHandler&lt;T&gt;</code> 又继承了 <code>TypeReference&lt;T&gt;</code> 类。MyBatis 会获取这里指定的泛型类型作为 javaType 属性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://www.broadview.com.cn/book/3643&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.broadview.com.cn/book/3643&lt;/a&gt;&lt;br&gt;
      
    
    </summary>
    
    
      <category term="Java" scheme="http://coolview.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="http://coolview.github.io/tags/Java/"/>
    
      <category term="MyBatis" scheme="http://coolview.github.io/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis 08-存储过程</title>
    <link href="http://coolview.github.io/2019/12/01/MyBatis/MyBatis%2008-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/"/>
    <id>http://coolview.github.io/2019/12/01/MyBatis/MyBatis%2008-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/</id>
    <published>2019-12-01T05:54:52.000Z</published>
    <updated>2019-12-01T06:31:58.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="http://www.broadview.com.cn/book/3643" target="_blank" rel="noopener">http://www.broadview.com.cn/book/3643</a><br><a href="https://github.com/mybatis-book/book" target="_blank" rel="noopener">https://github.com/mybatis-book/book</a></p></blockquote><h1 id="根据用户-id-查询用户其他信息"><a href="#根据用户-id-查询用户其他信息" class="headerlink" title="根据用户 id 查询用户其他信息"></a>根据用户 id 查询用户其他信息</h1><pre><code class="sql"># 根据用户 id 查询用户其他信息# 方法看着很奇葩，但是展示了多个输出参数DROP PROCEDURE IF EXISTS `select_user_by_id`;DELIMITER ;;CREATE PROCEDURE `select_user_by_id`(IN userId BIGINT,OUT userName VARCHAR(50),OUT userPassword VARCHAR(50),OUT userEmail VARCHAR(50),OUT userInfo TEXT,OUT headImg BLOB,OUT createTime DATETIME)BEGIN# 根据用户 id 查询其他数据select user_name,user_password,user_email,user_info,head_img,create_timeINTO userName,userPassword,userEmail,userInfo,headImg,createTimefrom sys_userWHERE id = userId;END;;DELIMITER ;</code></pre><pre><code class="xml">&lt;select id=&quot;selectUserById&quot; statementType=&quot;CALLABLE&quot; useCache=&quot;false&quot;&gt;    {call select_user_by_id(        #{id, mode=IN},        #{userName, mode=OUT, jdbcType=VARCHAR},        #{userPassword, mode=OUT, jdbcType=VARCHAR},        #{userEmail, mode=OUT, jdbcType=VARCHAR},        #{userInfo, mode=OUT, jdbcType=VARCHAR},        #{headImg, mode=OUT, jdbcType=BLOB, javaType=_byte[]},        #{createTime, mode=OUT, jdbcType=TIMESTAMP}    )}&lt;/select&gt;</code></pre><p>在调用存储过程的方法中，需要把 statementType 设置为 CALLABLE，在使用 select 标签调用存储过程时，由于存储过程不支持二级缓存，因此避免出错将 useCache 设置为 false。</p><p>在存储过程中使用参数时，除了写上必要的属性名，还必须指定参数的 mode，可选值 IN（入参），OUT（出参），INOUT（输入输出）。OUT 模式必须指定 jdbcType。在使用 Oracle 时，如果入参存在 null 的情况，那么入参也必须指定 jdbcType。</p><pre><code class="java">void selectUserById(SysUser user);</code></pre><p>这个存储过程没有返回值（不要和出参混淆）。</p><p>使用出参方式时，使用 JavaBean 对象接收出参时，必须保证所有出参在 JavaBean 中都有对应的属性存在，否则会抛出类似 “Could not set property &#39;xxx&#39;” 这样的错误。使用 Map 类型接收出参时不需要保证所有出参都有对应的属性。</p><h1 id="简单的根据用户名和分页参数进行查询，返回总数和分页数据"><a href="#简单的根据用户名和分页参数进行查询，返回总数和分页数据" class="headerlink" title="简单的根据用户名和分页参数进行查询，返回总数和分页数据"></a>简单的根据用户名和分页参数进行查询，返回总数和分页数据</h1><pre><code class="sql"># 简单的根据用户名和分页参数进行查询，返回总数和分页数据DROP PROCEDURE IF EXISTS `select_user_page`;DELIMITER ;;CREATE PROCEDURE `select_user_page`(IN userName VARCHAR(50),IN _offset BIGINT,IN _limit BIGINT,OUT total BIGINT)BEGIN# 查询数据总数select count(*) INTO totalfrom sys_userwhere user_name like concat(&#39;%&#39;, userName, &#39;%&#39;);# 分页查询数据select *from sys_userwhere user_name like concat(&#39;%&#39;, userName, &#39;%&#39;)limit _offset, _limit;END;;DELIMITER ;</code></pre><pre><code class="xml">&lt;select id=&quot;selectUserPage&quot; statementType=&quot;CALLABLE&quot; useCache=&quot;false&quot; resultMap=&quot;userMap&quot;&gt;    {call select_user_page(        #{userName, mode=IN},        #{offset, mode=IN},        #{limit, mode=IN},        #{total, mode=OUT, jdbcType=BIGINT}    )}&lt;/select&gt;</code></pre><p>select 标签设置了 resultMap，因为该方法通过 total 出参得到了查询的总数，通过存储过程返回了最后的结果集，所以需要设置返回值信息。</p><pre><code class="java">/*** 使用存储过程分页查询** @param userName* @param pageNum* @param pageSize* @param total* @return*/List&lt;SysUser&gt; selectUserPage(Map&lt;String, Object&gt; params);</code></pre><pre><code class="java">@Testpublic void testSelectUserPage(){    // 获取 sqlSession    SqlSession sqlSession = getSqlSession();    try {        // 获取 UserMapper 接口        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);        Map&lt;String, Object&gt; params = new HashMap&lt;String, Object&gt;();        params.put(&quot;userName&quot;, &quot;ad&quot;);        params.put(&quot;offset&quot;, 0);        params.put(&quot;limit&quot;, 10);        List&lt;SysUser&gt; userList = userMapper.selectUserPage(params);  // 也可以使用 JavaBean        Long total = (Long) params.get(&quot;total&quot;);        System.out.println(&quot;总数:&quot; + total);        for(SysUser user : userList){            System.out.println(&quot;用户名：&quot; + user.getUserName());        }    } finally {        // 不要忘记关闭 sqlSession        sqlSession.close();    }}</code></pre><h1 id="添加删除用户"><a href="#添加删除用户" class="headerlink" title="添加删除用户"></a>添加删除用户</h1><pre><code class="sql"># 保存用户信息和角色关联信息DROP PROCEDURE IF EXISTS `insert_user_and_roles`;DELIMITER ;;CREATE PROCEDURE `insert_user_and_roles`(OUT userId BIGINT,IN userName VARCHAR(50),IN userPassword VARCHAR(50),IN userEmail VARCHAR(50),IN userInfo TEXT,IN headImg BLOB,OUT createTime DATETIME,IN roleIds VARCHAR(200))BEGIN# 设置当前时间SET createTime = NOW();# 插入数据INSERT INTO sys_user(user_name, user_password, user_email, user_info, head_img, create_time)VALUES (userName, userPassword, userEmail, userInfo, headImg, createTime);# 获取自增主键SELECT LAST_INSERT_ID() INTO userId;# 保存用户和角色关系数据SET roleIds = CONCAT(&#39;,&#39;,roleIds,&#39;,&#39;);INSERT INTO sys_user_role(user_id, role_id)select userId, id from sys_rolewhere INSTR(roleIds, CONCAT(&#39;,&#39;,id,&#39;,&#39;)) &gt; 0;END;;DELIMITER ;</code></pre><pre><code class="sql"># 删除用户信息和角色关联信息DROP PROCEDURE IF EXISTS `delete_user_by_id`;DELIMITER ;;CREATE PROCEDURE `delete_user_by_id`(IN userId BIGINT)BEGINDELETE FROM sys_user_role where user_id = userId;DELETE FROM sys_user where id = userId;END;;DELIMITER ;</code></pre><pre><code class="xml">&lt;insert id=&quot;insertUserAndRoles&quot; statementType=&quot;CALLABLE&quot;&gt;    {call insert_user_and_roles(        #{user.id, mode=OUT, jdbcType=BIGINT},        #{user.userName, mode=IN},        #{user.userPassword, mode=IN},        #{user.userEmail, mode=IN},        #{user.userInfo, mode=IN},        #{user.headImg, mode=IN, jdbcType=BLOB},        #{user.createTime, mode=OUT, jdbcType=TIMESTAMP},        #{roleIds, mode=IN}    )}&lt;/insert&gt;&lt;delete id=&quot;deleteUserById&quot; statementType=&quot;CALLABLE&quot;&gt;    {call delete_user_by_id(#{id, mode=IN})}&lt;/delete&gt;</code></pre><pre><code class="java">/*** 保存用户信息和角色关联信息*/int insertUserAndRoles(@Param(&quot;user&quot;)SysUser user, @Param(&quot;roleIds&quot;)String roleIds);/*** 根据用户 id 删除用户和用户的角色信息*/int deleteUserById(Long id);</code></pre><h1 id="在-Oracle-中使用游标参数的存储过程"><a href="#在-Oracle-中使用游标参数的存储过程" class="headerlink" title="在 Oracle 中使用游标参数的存储过程"></a>在 Oracle 中使用游标参数的存储过程</h1><pre><code class="sql">create or replace procedure SELECT_COUNTRIES(    ref_cur1 out sys_refcursor,    ref_cur2 out sys_refcursor) isbegin  open ref_cur1 for select * from country where id &lt; 3;  open ref_cur2 for select * from country where id &gt;= 3;end SELECT_COUNTRIES;</code></pre><p>这个存储过程只有两个游标类型的出参，游标对应的值就是两个简单的 SQL。</p><pre><code class="xml">&lt;select id=&quot;selectCountries&quot; statementType=&quot;CALLABLE&quot; useCache=&quot;false&quot;&gt;    {call SELECT_COUNTRIES(        #{list1, mode=OUT, jdbcType=CURSOR, javaType=ResultSet, resultMap=BaseResultMap},        #{list2, mode=OUT, jdbcType=CURSOR, javaType=ResultSet, resultMap=BaseResultMap}    )}&lt;/select&gt;</code></pre><p>使用游标类型时，注意设置 <code>jdbcType=CURSOR</code>, <code>javaType=ResultSet</code></p><pre><code class="java">/*** 执行 Oracle 中的存储过程*/Object selectCountries(Map&lt;String, Object&gt; params);</code></pre><pre><code class="java">@Testpublic void testMapperWithStartPage3() {    SqlSession sqlSession = getSqlSession();    CountryMapper countryMapper = sqlSession.getMapper(CountryMapper.class);    try {        // 获取第1页，10条内容，默认查询总数count        Map&lt;String, Object&gt; params = new HashMap&lt;String, Object&gt;();        countryMapper.selectCountries(params);        List&lt;Country&gt; list1 = (List&lt;Country&gt;) params.get(&quot;list1&quot;);        List&lt;Country&gt; list2 = (List&lt;Country&gt;) params.get(&quot;list2&quot;);        Assert.assertNotNull(list1);        Assert.assertNotNull(list2);    } finally {        sqlSession.close();    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://www.broadview.com.cn/book/3643&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.broadview.com.cn/book/3643&lt;/a&gt;&lt;br&gt;
      
    
    </summary>
    
    
      <category term="Java" scheme="http://coolview.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="http://coolview.github.io/tags/Java/"/>
    
      <category term="MyBatis" scheme="http://coolview.github.io/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>《Java 开发手册》记录</title>
    <link href="http://coolview.github.io/2019/11/30/Java/Java%20%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/"/>
    <id>http://coolview.github.io/2019/11/30/Java/Java%20%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/</id>
    <published>2019-11-30T08:55:52.000Z</published>
    <updated>2019-11-30T12:19:03.998Z</updated>
    
    <content type="html"><![CDATA[<h1 id="编程规范"><a href="#编程规范" class="headerlink" title="编程规范"></a>编程规范</h1><h2 id="命名风格"><a href="#命名风格" class="headerlink" title="命名风格"></a>命名风格</h2><p>6，抽象类使用 <code>Abstract</code> 或 <code>Base</code> 开头；异常类命名使用 <code>Exception</code> 结尾；测试类命名以他要测试的类名称开始，以 <code>Test</code> 结尾。</p><p>7，类型与中括号紧挨相连来表示数组。<br><strong>正例</strong>：<code>int[] arratDemo</code><br><strong>反例</strong>：<code>String args[]</code></p><p>8，<code>POJO</code> 类中布尔类型变量都不要加 <code>is</code> 前缀</p><p>10，避免在子父类的成员变量之间、或者不同代码块的局部变量之间采用完全相同的命名，使可读性降低。</p><pre><code class="java">// 反例public class ConfusingName {    public int age;    // 非 setter/getter 的参数名称，不允许与本类成员变量同名    public void getData(String alibaba) {        if(true) {            final int money = 531;        // ...        }        for (int i = 0; i &lt; 10; i++) {            // 在同一方法体中，不允许与其它代码块中的 taobao 命名相同            final int money = 615;            // ...        }    }}class Son extends ConfusingName {    // 不允许与父类的成员变量名称相同    public int age;}</code></pre><p>13，在常量与变量的命名时，表示类型的名词放在词尾，以提升辨识度。<br><strong>正例</strong>：<code>startTime</code> / <code>workQueue</code> / <code>nameList</code> / <code>TERMINATED_THREAD_COUNT</code><br><strong>反例</strong>：<code>startedAt</code> / <code>QueueOfWork</code> / <code>listName</code> / <code>COUNT_TERMINATED_THREAD</code></p><p>14，如果模块、接口、类、方法使用了设计模式，在命名时需体现出具体模式。</p><pre><code class="java">// 正例：public class OrderFactory;public class LoginProxy;public class ResourceObserver;</code></pre><p>16，对于 <code>Service</code> 和 <code>DAO</code> 类，基于 <code>SOA</code> 的理念，暴露出来的服务一定是接口，内部的实现类用 <code>Impl</code> 的后缀与接口区别。<br><strong>正例</strong>：<code>CacheServiceImpl</code> 实现 <code>CacheService</code> 接口。</p><p>17，枚举类名带上 <code>Enum</code> 后缀，枚举成员名称需要全大写，单词间用下划线隔开。</p><p>18，各层命名规约：</p><ul><li><code>Service</code>/<code>DAO</code> 层方法命名规约<ul><li>获取单个对象的方法用 <code>get</code> 做前缀。</li><li>获取多个对象的方法用 <code>list</code> 做前缀，复数形式结尾如：<code>listObjects</code>。</li><li>获取统计值的方法用 <code>count</code> 做前缀。</li><li>插入的方法用 <code>save</code>/<code>insert</code> 做前缀。</li><li>删除的方法用 <code>remove</code>/<code>delete</code> 做前缀。</li><li>修改的方法用 <code>update</code> 做前缀。</li></ul></li><li>领域模型命名规约<ul><li>数据对象：<code>xxxDO</code>，xxx 即为数据表名。</li><li>数据传输对象：<code>xxxDTO</code>，xxx 为业务领域相关的名称。</li><li>展示对象：<code>xxxVO</code>，xxx 一般为网页名称。</li><li>POJO 是 <code>DO</code>/<code>DTO</code>/<code>BO</code>/<code>VO</code> 的统称，禁止命名成 xxxPOJO。</li></ul></li></ul><h2 id="常量定义"><a href="#常量定义" class="headerlink" title="常量定义"></a>常量定义</h2><p>1，不允许任何魔法值（即未经预先定义的常量）直接出现在代码中。</p><pre><code class="java">// 反例：String key = &quot;Id#taobao_&quot; + tradeId;cache.put(key, value);// 缓存 get 时，由于在代码复制时，漏掉下划线，导致缓存击穿而出现问题</code></pre><p>3，不要使用一个常量类维护所有常量，要按常量功能进行归类，分开维护。</p><p>4，常量的复用层次有五层：跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量。</p><ul><li>跨应用共享常量：放置在二方库中，通常是 client.jar 中的 <code>constant</code> 目录下。</li><li>应用内共享常量：放置在一方库中，通常是子模块中的 <code>constant</code> 目录下。</li><li>子工程内部共享常量：即在当前子工程的 <code>constant</code> 目录下。</li><li>包内共享常量：即在当前包下单独的 <code>constant</code> 目录下。</li><li>类内共享常量：直接在类内部 <code>private static final</code> 定义。</li></ul><p>5，如果变量值仅在一个固定范围内变化用 <code>enum</code> 类型来定义。<br><strong>说明</strong>：如果存在名称之外的延伸属性应使用 <code>enum</code> 类型，下面正例中的数字就是延伸信息，表示一年中的第几个季节。</p><pre><code class="java">// 正例：public enum SeasonEnum {    SPRING(1), SUMMER(2), AUTUMN(3), WINTER(4);    private int seq;    SeasonEnum(int seq) {        this.seq = seq;    }    public int getSeq() {        return seq;    }}</code></pre><h2 id="代码格式"><a href="#代码格式" class="headerlink" title="代码格式"></a>代码格式</h2><p>8，单行字符数限制不超过 120 个，超出需要换行，换行时遵循如下原则：</p><ul><li>第二行相对第一行缩进 4 个空格，从第三行开始，不再继续缩进，参考示例。</li><li>运算符与下文一起换行。</li><li>方法调用的点符号与下文一起换行。</li><li>方法调用中的多个参数需要换行时，在逗号后进行。</li><li>在括号前不要换行。</li></ul><pre><code class="java">// 正例：StringBuilder sb = new StringBuilder();// 超过 120 个字符的情况下，换行缩进 4 个空格，点号和方法名称一起换行sb.append(&quot;Jack&quot;).append(&quot;Ma&quot;)    .append(&quot;alibaba&quot;)    .append(&quot;alibaba&quot;);</code></pre><h2 id="OOP-规约"><a href="#OOP-规约" class="headerlink" title="OOP 规约"></a>OOP 规约</h2><p>1，避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成本，<strong>直接用类名来访问即可</strong>。</p><p>3，相同参数类型，相同业务含义，才可以使用 Java 的可变参数，避免使用 <code>Object</code>。<br><strong>说明</strong>：可变参数必须放置在参数列表的最后。（提倡同学们尽量不用可变参数编程）<br><strong>正例</strong>：<code>public List&lt;User&gt; listUsers(String type, Long... ids) {...}</code></p><p>6，<code>Object</code> 的 <code>equals</code> 方法容易抛空指针异常，应使用常量或确定有值的对象来调用 <code>equals</code>。<br><strong>正例</strong>：<code>&quot;test&quot;.equals(object);</code><br><strong>反例</strong>：<code>object.equals(&quot;test&quot;);</code><br><strong>说明</strong>：推荐使用 <code>java.util.Objects#equals</code>（JDK7 引入的工具类）。</p><p>7，所有整型包装类对象之间值的比较，全部使用 <code>equals</code> 方法比较。<br><strong>说明</strong>：对于 <code>Integer var = ?</code> 在 <code>-128 至 127</code> 范围内的赋值，<code>Integer</code> 对象是在 <code>IntegerCache.cache</code> 产生，会复用已有对象，这个区间内的 <code>Integer</code> 值可以直接使用 <code>==</code> 进行判断，但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象，这是一个大坑，推荐使用 <code>equals</code> 方法进行判断。</p><p>8，浮点数之间的等值判断，基本数据类型不能用 <code>==</code> 来比较，包装数据类型不能用 <code>equals</code> 来判断。<br><strong>说明</strong>：浮点数采用“尾数+阶码”的编码方式，类似于科学计数法的“有效数字+指数”的表示方式。二进制无法精确表示大部分的十进制小数</p><pre><code class="java">// 反例：float a = 1.0f - 0.9f;float b = 0.9f - 0.8f;if (a == b) {// 预期进入此代码快，执行其它业务逻辑// 但事实上 a==b 的结果为 false}Float x = Float.valueOf(a);Float y = Float.valueOf(b);if (x.equals(y)) {// 预期进入此代码快，执行其它业务逻辑// 但事实上 equals 的结果为 false}// 正例：// (1) 指定一个误差范围，两个浮点数的差值在此范围之内，则认为是相等的。float a = 1.0f - 0.9f;float b = 0.9f - 0.8f;float diff = 1e-6f;if (Math.abs(a - b) &lt; diff) {    System.out.println(&quot;true&quot;);}// (2) 使用 BigDecimal 来定义值，再进行浮点数的运算操作。BigDecimal a = new BigDecimal(&quot;1.0&quot;);BigDecimal b = new BigDecimal(&quot;0.9&quot;);BigDecimal c = new BigDecimal(&quot;0.8&quot;);BigDecimal x = a.subtract(b);BigDecimal y = b.subtract(c);if (x.equals(y)) {    System.out.println(&quot;true&quot;);}</code></pre><p>10，为了防止精度损失，禁止使用构造方法 <code>BigDecimal(double)</code> 的方式把 <code>double</code> 值转化为 <code>BigDecimal</code> 对象。<br><strong>说明</strong>：<code>BigDecimal(double)</code>存在精度损失风险，在精确计算或值比较的场景中可能会导致业务逻辑异常。如：<code>BigDecimal g = new BigDecimal(0.1f);</code> 实际的存储值为：<code>0.10000000149</code><br><strong>正例</strong>：优先推荐入参为 <code>String</code> 的构造方法，或使用 <code>BigDecimal</code> 的 <code>valueOf</code> 方法，此方法内部其实执行了 <code>Double</code> 的 <code>toString</code>，而 <code>Double</code> 的 <code>toString</code> 按 <code>double</code> 的实际能表达的精度对尾数进行了截断。</p><pre><code class="java">BigDecimal recommend1 = new BigDecimal(&quot;0.1&quot;);BigDecimal recommend2 = BigDecimal.valueOf(0.1);</code></pre><p>11，关于基本数据类型与包装数据类型的使用标准如下：</p><ul><li>所有的 POJO 类属性必须使用包装数据类型。</li><li>RPC 方法的返回值和参数必须使用包装数据类型。</li><li>【推荐】所有的局部变量使用基本数据类型。</li></ul><p>12，定义 <code>DO</code>/<code>DTO</code>/<code>VO</code> 等 <code>POJO</code> 类时，<strong>不要设定任何属性默认值</strong>。</p><p>13，序列化类新增属性时，请不要修改 <code>serialVersionUID</code> 字段，避免反序列失败；如果完全不兼容升级，避免反序列化混乱，那么请修改 <code>serialVersionUID</code> 值。</p><p>14，构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在 <code>init</code> 方法中。</p><p>15，<code>POJO</code> 类必须写 <code>toString</code> 方法。使用 IDE 中的工具：<code>source&gt; generate toString</code> 时，如果继承了另一个 <code>POJO</code> 类，注意在前面加一下 <code>super.toString</code>。<br><strong>说明</strong>：在方法执行抛出异常时，可以直接调用 <code>POJO</code> 的 <code>toString()</code> 方法打印其属性值，便于排查问题。</p><p>16，禁止在 POJO 类中，同时存在对应属性 xxx 的 <code>isXxx()</code> 和 <code>getXxx()</code> 方法。<br><strong>说明</strong>：框架在调用属性 xxx 的提取方法时，并不能确定哪个方法一定是被优先调用到。</p><p>20，<code>setter</code> 方法中，参数名称与类成员变量名称一致，<code>this.成员名 = 参数名</code>。在 <code>getter/setter</code> 方法中，不要增加业务逻辑，增加排查问题的难度。</p><pre><code class="java">// 反例：public Integer getData() {    if (condition) {        return this.data + 100;    } else {        return this.data - 100;    }}</code></pre><p>21，循环体内，字符串的连接方式，使用 <code>StringBuilder</code> 的 <code>append</code> 方法进行扩展。<br><strong>说明</strong>：下例中，反编译出的字节码文件显示每次循环都会 <code>new</code> 出一个 <code>StringBuilder</code> 对象，然后进行 <code>append</code> 操作，最后通过 <code>toString</code> 方法返回 <code>String</code> 对象，造成内存资源浪费。</p><pre><code class="java">// 反例：String str = &quot;start&quot;;for (int i = 0; i &lt; 100; i++) {    str = str + &quot;hello&quot;;}</code></pre><p>22，<code>final</code> 可以声明类、成员变量、方法、以及本地变量，下列情况使用 <code>final</code> 关键字：</p><ul><li>不允许被继承的类，如：<code>String</code> 类。</li><li>不允许修改引用的域对象。</li><li>不允许被覆写的方法，如：POJO 类的 <code>setter</code> 方法。</li><li>不允许运行过程中重新赋值的局部变量。</li><li>避免上下文重复使用一个变量，使用 <code>final</code> 可以强制重新定义一个变量，方便更好地进行重构。</li></ul><p>23，慎用 <code>Object</code> 的 <code>clone</code> 方法来拷贝对象。<br><strong>说明</strong>：对象 <code>clone</code> 方法默认是浅拷贝，若想实现深拷贝需覆写 <code>clone</code> 方法实现域对象的深度遍历式拷贝。</p><p>24，类成员与方法访问控制从严：</p><ul><li>如果不允许外部直接通过 <code>new</code> 来创建对象，那么构造方法必须是 <code>private</code>。</li><li>工具类不允许有 <code>public</code> 或 <code>default</code> 构造方法。</li><li>类非 <code>static</code> 成员变量并且与子类共享，必须是 <code>protected</code>。</li><li>类非 <code>static</code> 成员变量并且仅在本类使用，必须是 <code>private</code>。</li><li>类 <code>static</code> 成员变量如果仅在本类使用，必须是 <code>private</code>。</li><li>若是 <code>static</code> 成员变量，考虑是否为 <code>final</code>。</li><li>类成员方法只供类内部调用，必须是 <code>private</code>。</li><li>类成员方法只对继承类公开，那么限制为 <code>protected</code>。</li></ul><h2 id="集合处理"><a href="#集合处理" class="headerlink" title="集合处理"></a>集合处理</h2><p>1，关于 <code>hashCode</code> 和 <code>equals</code> 的处理，遵循如下规则：</p><ul><li>只要覆写 <code>equals</code>，就必须覆写 <code>hashCode</code>。</li><li>因为 <code>Set</code> 存储的是不重复的对象，依据 <code>hashCode</code> 和 <code>equals</code> 进行判断，所以 <code>Set</code> 存储的对象必须覆写这两个方法。</li><li>如果自定义对象作为 <code>Map</code> 的键，那么必须覆写 <code>hashCode</code> 和 <code>equals</code>。</li></ul><p><strong>说明</strong>：<code>String</code> 已覆写 <code>hashCode</code> 和 <code>equals</code> 方法，所以我们可以愉快地使用 <code>String</code> 对象作为 <code>key</code> 来使用。</p><p>2，<code>ArrayList</code> 的 <code>subList</code> 结果不可强转成 <code>ArrayList</code>，否则会抛出 <code>ClassCastException</code> 异常，即 java.util.RandomAccessSubList cannot be cast to java.util.ArrayList。<br><strong>说明</strong>：<code>subLis</code>t 返回的是 <code>ArrayList</code> 的内部类 <code>SubList</code>，并不是 <code>ArrayList</code> 而是 <code>ArrayList</code> 的一个视图，对于 <code>SubList</code> 子列表的所有操作最终会反映到原列表上。</p><p>3，使用 <code>Map</code> 的方法 <code>keySet()</code> / <code>values()</code> / <code>entrySet()</code> 返回集合对象时，不可以对其进行添加元素操作，否则会抛出 <code>UnsupportedOperationException</code> 异常。</p><p>4，<code>Collections</code> 类返回的对象，如：<code>emptyList()</code> / <code>singletonList()</code> 等都是 immutable list，不可对其进行添加或者删除元素的操作。<br><strong>反例</strong>：如果查询无结果，返回 <code>Collections.emptyList()</code> 空集合对象，调用方一旦进行了添加元素的操作，就会触发 <code>UnsupportedOperationException</code> 异常。</p><p>5，在 <code>subList</code> 场景中，高度注意对原集合元素的增加或删除，均会导致子列表的遍历、增加、删除产生 <code>ConcurrentModificationException</code> 异常。</p><p>6，使用集合转数组的方法，必须使用集合的 <code>toArray(T[] array)</code>，传入的是类型完全一致、长度为 0 的空数组。<br><strong>反例</strong>：直接使用 <code>toArray</code> 无参方法存在问题，此方法返回值只能是 <code>Object[]</code> 类，若强转其它类型数组将出现 <code>ClassCastException</code> 错误。</p><pre><code class="java">// 正例：List&lt;String&gt; list = new ArrayList&lt;&gt;(2);list.add(&quot;guan&quot;);list.add(&quot;bao&quot;);String[] array = list.toArray(new String[0]);</code></pre><p>7，在使用 <code>Collection</code> 接口任何实现类的 <code>addAll()</code> 方法时，都要对输入的集合参数进行 <code>NPE</code> 判断。<br><strong>说明</strong>：在 <code>ArrayList#addAll</code> 方法的第一行代码即 <code>Object[] a = c.toArray();</code> 其中 c 为输入集合参数，如果为 null，则直接抛出异常。</p><p>8，使用工具类 <code>Arrays.asList()</code> 把数组转换成集合时，不能使用其修改集合相关的方法，它的 <code>add</code>/<code>remove</code>/<code>clear</code> 方法会抛出 <code>UnsupportedOperationException</code> 异常。<br><strong>说明</strong>：<code>asList</code> 的返回对象是一个 <code>Arrays</code> 内部类，并没有实现集合的修改方法。<code>Arrays.asList</code> 体现的是适配器模式，只是转换接口，后台的数据仍是数组。</p><pre><code class="java">String[] str = new String[] { &quot;yang&quot;, &quot;hao&quot; };List list = Arrays.asList(str);</code></pre><p>第一种情况：<code>list.add(&quot;yangguanbao&quot;);</code> 运行时异常。<br>第二种情况：<code>str[0] = &quot;changed&quot;;</code> 也会随之修改，反之亦然。</p><p>9，泛型通配符 <code>&lt;? extends T&gt;</code> 来接收返回的数据，此写法的泛型集合不能使用 <code>add</code> 方法，而 <code>&lt;? super T&gt;</code> 不能使用 <code>get</code> 方法，作为接口调用赋值时易出错。<br><strong>说明</strong>：扩展说一下 <code>PECS(Producer Extends Consumer Super)</code> 原则：第一、频繁往外读取内容的，适合用<code>&lt;? extends T&gt;</code>。第二、经常往里插入的，适合用<code>&lt;? super T&gt;</code></p><p>10，在无泛型限制定义的集合赋值给泛型限制的集合时，在使用集合元素时，需要进行 <code>instanceof</code> 判断，避免抛出 <code>ClassCastException</code> 异常。</p><p>11，不要在 <code>foreach</code> 循环里进行元素的 <code>remove</code>/<code>add</code> 操作。<code>remove</code> 元素请使用 <code>Iterator</code> 方式，如果并发操作，需要对 <code>Iterator</code> 对象加锁。</p><pre><code class="java">// 正例：List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;1&quot;);list.add(&quot;2&quot;);Iterator&lt;String&gt; iterator = list.iterator();while (iterator.hasNext()) {    String item = iterator.next();    if (删除元素的条件) {        iterator.remove();    }}</code></pre><p>12，在 JDK 7 版本及以上， <code>Comparator</code> 实现类要满足如下三个条件，不然 <code>Arrays.sort</code> ，<code>Collections.sort</code> 会抛 <code>IllegalArgumentException</code> 异常。<br><strong>说明</strong>：三个条件如下</p><ul><li><code>x</code>，<code>y</code> 的比较结果和 <code>y</code>，<code>x</code> 的比较结果相反。</li><li><code>x&gt;y</code>，<code>y&gt;z</code>，则 <code>x&gt;z</code>。</li><li><code>x=y</code>，则 <code>x</code>，<code>z</code> 比较结果和 <code>y</code>，<code>z</code> 比较结果相同。</li></ul><p>14，集合初始化时，指定集合初始值大小。<strong>说明</strong>：HashMap 使用 <code>HashMap(int initialCapacity)</code> 初始化。</p><p>15，使用 <code>entrySet</code> 遍历 <code>Map</code> 类集合 <code>KV</code> ，而不是 <code>keySet</code> 方式进行遍历。<br><strong>说明</strong>：<code>keySet</code> 其实是遍历了 2 次，一次是转为 <code>Iterator</code> 对象，另一次是从 <code>hashMap</code> 中取出 <code>key</code> 所对应的 <code>value</code>。而 <code>entrySet</code> 只是遍历了一次就把 <code>key</code> 和 <code>value</code> 都放到了 <code>entry</code> 中，效率更高。如果是 <code>JDK8</code>，使用 <code>Map.forEach</code> 方法。</p><p>16，高度注意 <code>Map</code> 类集合 <code>K/V</code> 能不能存储 <code>null</code> 值的情况，如下表格：</p><table><thead><tr><th>集合类</th><th>Key</th><th>Value</th><th>Super</th><th>说明</th></tr></thead><tbody><tr><td>Hashtable</td><td>不允许为 null</td><td>不允许为 null</td><td>Dictionary</td><td>线程安全</td></tr><tr><td>ConcurrentHashMap</td><td>不允许为 null</td><td>不允许为 null</td><td>AbstractMap</td><td>锁分段技术（JDK8:CAS）</td></tr><tr><td>TreeMap</td><td>不允许为 null</td><td>允许为 null</td><td>AbstractMap</td><td>线程不安全</td></tr><tr><td>HashMap</td><td>允许为 null</td><td>允许为 null</td><td>AbstractMap</td><td>线程不安全</td></tr></tbody></table><h2 id="并发处理"><a href="#并发处理" class="headerlink" title="并发处理"></a>并发处理</h2><p>1，获取单例对象需要保证线程安全，其中的方法也要保证线程安全。</p><p>2，创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。</p><p>3，线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。</p><p>4，线程池不允许使用 <code>Executors</code> 去创建，而是通过 <code>ThreadPoolExecutor</code> 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</p><p>5，<code>SimpleDateFormat</code> 是线程不安全的类，一般不要定义为 <code>static</code> 变量，如果定义为 <code>static</code>，必须加锁，或者使用 <code>DateUtils</code> 工具类。<br><strong>正例</strong>：注意线程安全，使用 <code>DateUtils</code>。亦推荐如下处理：</p><pre><code class="java">private static final ThreadLocal&lt;DateFormat&gt; df = new ThreadLocal&lt;DateFormat&gt;() {    @Override    protected DateFormat initialValue() {        return new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);    }};</code></pre><p><strong>说明</strong>：如果是 <code>JDK8</code> 的应用，可以使用 <code>Instant</code> 代替 <code>Date</code>，<code>LocalDateTime</code> 代替 <code>Calendar</code>，<code>DateTimeFormatter</code> 代替 <code>SimpleDateFormat</code>，官方给出的解释：simple beautiful strong immutable thread-safe。</p><p>6，必须回收自定义的 <code>ThreadLocal</code> 变量，尤其在线程池场景下，线程经常会被复用，如果不清理自定义的 <code>ThreadLocal</code> 变量，可能会影响后续业务逻辑和造成内存泄露等问题。尽量在代理中使用 <code>try-finally</code> 块进行回收。</p><pre><code class="java">// 正例：objectThreadLocal.set(userInfo);try {// ...} finally {    objectThreadLocal.remove();}</code></pre><p>7，高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。</p><p>8，对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁。<br><strong>说明</strong>：线程一需要对表 A、B、C 依次全部加锁后才可以进行更新操作，那么线程二的加锁顺序也必须是A、B、C，否则可能出现死锁。</p><p>9，在使用阻塞等待获取锁的方式中，必须在 <code>try</code> 代码块之外，并且在加锁方法与 <code>try</code> 代码块之间没有任何可能抛出异常的方法调用，避免加锁成功后，在 <code>finally</code> 中无法解锁。<br><strong>说明一</strong>：如果在 <code>lock</code> 方法与 <code>try</code> 代码块之间的方法调用抛出异常，那么无法解锁，造成其它线程无法成功获取锁。<br><strong>说明二</strong>：如果 <code>lock</code> 方法在 <code>try</code> 代码块之内，可能由于其它方法抛出异常，导致在 <code>finally</code> 代码块中，<code>unlock</code> 对未加锁的对象解锁，它会调用 <code>AQS</code> 的 <code>tryRelease</code> 方法（取决于具体实现类），抛出 <code>IllegalMonitorStateException</code> 异常。<br><strong>说明三</strong>：在 <code>Lock</code> 对象的 <code>lock</code> 方法实现中可能抛出 <code>unchecked</code> 异常，产生的后果与说明二相同。</p><pre><code class="java">// 正例：Lock lock = new XxxLock();// ...lock.lock();try {    doSomething();    doOthers();} finally {    lock.unlock();}</code></pre><p>10，在使用尝试机制来获取锁的方式中，进入业务代码块之前，必须先判断当前线程是否持有锁。锁的释放规则与锁的阻塞等待方式相同。<br><strong>说明</strong>：<code>Lock</code> 对象的 <code>unlock</code> 方法在执行时，它会调用 <code>AQS</code> 的 <code>tryRelease</code> 方法（取决于具体实现类），如果当前线程不持有锁，则抛出 <code>IllegalMonitorStateException</code> 异常。</p><pre><code class="java">// 正例：Lock lock = new XxxLock();// ...boolean isLocked = lock.tryLock();if (isLocked) {    try {        doSomething();        doOthers();    } finally {        lock.unlock();    }}</code></pre><p>11，并发修改同一记录时，避免更新丢失，需要加锁。要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用 <code>version</code> 作为更新依据。<br><strong>说明</strong>：如果每次访问冲突概率小于 20%，推荐使用乐观锁，否则使用悲观锁。乐观锁的重试次数不得小于 3 次。</p><p>12，多线程并行处理定时任务时，<code>Timer</code> 运行多个 <code>TimeTask</code> 时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，如果在处理定时任务时使用 <code>ScheduledExecutorService</code> 则没有这个问题。</p><p>13，资金相关的金融敏感信息，使用<strong>悲观锁策略</strong>。</p><p>14，使用 <code>CountDownLatch</code> 进行异步转同步操作，每个线程退出前必须调用 <code>countDown</code> 方法，线程执行代码注意 <code>catch</code> 异常，确保 <code>countDown</code> 方法被执行到，避免主线程无法执行至 <code>await</code> 方法，直到超时才返回结果。<br><strong>说明</strong>：注意，子线程抛出异常堆栈，不能在主线程 <code>try-catch</code> 到。</p><p>15，避免 <code>Random</code> 实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一 <code>seed</code> 导致的性能下降。<br><strong>说明</strong>：<code>Random</code> 实例包括 <code>java.util.Random</code> 的实例或者 <code>Math.random()</code> 的方式。<br><strong>正例</strong>：在 <code>JDK7</code> 之后，可以直接使用 API <code>ThreadLocalRandom</code>，而在 <code>JDK7</code> 之前，需要编码保证每个线程持有一个实例。</p><p>16，在并发场景下，通过双重检查锁（double checked locking）实现延迟初始化的优化问题隐患，将目标属性声明为 <code>volatile</code> 型 。</p><h2 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h2><p>1，在一个 <code>switch</code> 块内，每个 <code>case</code> 要么通过 <code>continue</code>/<code>break</code>/<code>return</code> 等来终止，要么注释说明程序将继续执行到哪一个 <code>case</code> 为止；在一个 <code>switch</code> 块内，都必须包含一个 <code>default</code> 语句并且放在最后，即使它什么代码也没有。</p><p>2，当 <code>switch</code> 括号内的变量类型为 <code>String</code> 并且此变量为外部参数时，必须先进行 <code>null</code> 判断。</p><p>4，在高并发场景中，避免使用“等于”判断作为中断或退出的条件。反例：判断剩余奖品数量等于 0 时，终止发放奖品，但因为并发处理错误导致奖品数量瞬间变成了负数，这样的话，活动无法终止。</p><p>8，循环体中的语句要考量性能，以下操作尽量移至循环体外处理，如定义对象、变量、获取数据库连接，进行不必要的 <code>try-catch</code> 操作（这个 <code>try-catch</code> 是否可以移至循环体外）。</p><p>11，下列情形，<strong>需要进行参数校验</strong>：</p><ul><li>调用频次低的方法。</li><li>执行时间开销很大的方法。此情形中，参数校验时间几乎可以忽略不计，但如果因为参数错误导致中间执行回退，或者错误，那得不偿失。</li><li>需要极高稳定性和可用性的方法。</li><li>对外提供的开放接口，不管是 RPC/API/HTTP 接口。</li><li>敏感权限入口。</li></ul><p>12，下列情形，<strong>不需要进行参数校验</strong>：</p><ul><li>极有可能被循环调用的方法。但在方法说明里必须注明外部参数检查要求。</li><li>底层调用频度比较高的方法。毕竟是像纯净水过滤的最后一道，参数错误不太可能到底层才会暴露问题。一般 DAO 层与 Service 层都在同一个应用中，部署在同一台服务器中，所以 DAO 的参数校验，可以省略。</li><li>被声明成 private 只会被自己代码所调用的方法，如果能够确定调用方法的代码传入参数已经做过检查或者肯定不会有问题，此时可以不校验参数。</li></ul><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>1，在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度。</p><p>4，注意 <code>Math.random()</code> 这个方法返回是 <code>double</code> 类型，注意取值的范围 <code>0≤x&lt;1</code> （能够取到零值，注意除零异常），如果想获取整数类型的随机数，不要将 x 放大 10 的若干倍然后取整，直接使用 <code>Random</code> 对象的 <code>nextInt</code> 或者 <code>nextLong</code> 方法。</p><p>5，获取当前毫秒数 <code>System.currentTimeMillis();</code> 而不是 <code>new Date().getTime();</code><br><strong>说明</strong>：如果想获取更加精确的纳秒级时间值，使用 <code>System.nanoTime()</code> 的方式。在 <code>JDK8</code> 中，针对统计时间等场景，推荐使用 <code>Instant</code> 类。</p><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>2，异常不要用来做流程控制，条件控制。<strong>说明</strong>：异常设计的初衷是解决程序运行中的各种意外情况，且异常的处理效率比条件判断方式要低很多。</p><p>5，有 <code>try</code> 块放到了事务代码中，<code>catch</code> 异常后，如果需要回滚事务，一定要注意手动回滚事务。</p><p>7，不要在 <code>finally</code> 块中使用 <code>return</code>。<br><strong>说明</strong>：<code>try</code> 块中的 <code>return</code> 语句执行成功后，并不马上返回，而是继续执行 <code>finally</code> 块中的语句，如果此处存在 <code>return</code> 语句，则在此直接返回，无情丢弃掉 <code>try</code> 块中的返回点。</p><p>9，在调用 RPC、二方包、或动态生成类的相关方法时，捕捉异常必须使用 <code>Throwable</code> 类来进行拦截。<br><strong>说明</strong>：通过反射机制来调用方法，如果找不到方法，抛出 <code>NoSuchMethodException</code>。什么情况会抛出 <code>NoSuchMethodError</code> 呢？二方包在类冲突时，仲裁机制可能导致引入非预期的版本使类的方法签名不匹配，或者在字节码修改框架（比如：ASM）动态创建或修改类时，修改了相应的方法签名。这些情况，即使代码编译期是正确的，但在代码运行期时，会抛出 <code>NoSuchMethodError</code>。</p><p>10，方法的返回值可以为 <code>null</code>，不强制返回空集合，或者空对象等，必须添加注释充分说明什么情况下会返回 <code>null</code> 值。</p><p>11，防止 <code>NPE</code> ，是程序员的基本修养，注意 <code>NPE</code> 产生的场景：</p><ul><li>返回类型为基本数据类型，<code>return</code> 包装数据类型的对象时，自动拆箱有可能产生 <code>NPE</code>。</li></ul><p><strong>反例</strong>：<code>public int f() { return Integer 对象}</code>， 如果为 <code>null</code>，自动解箱抛 <code>NPE</code>。</p><ul><li>数据库的查询结果可能为 <code>null</code>。</li><li>集合里的元素即使 <code>isNotEmpty</code>，取出的数据元素也可能为 <code>null</code>。</li><li>远程调用返回对象时，一律要求进行空指针判断，防止 <code>NPE</code>。</li><li>对于 <code>Session</code> 中获取的数据，建议进行 <code>NPE</code> 检查，避免空指针。</li><li>级联调用 <code>obj.getA().getB().getC()；</code>一连串调用，易产生 <code>NPE</code>。</li></ul><p><strong>正例</strong>：使用 <code>JDK8</code> 的 <code>Optional</code> 类来防止 <code>NPE</code> 问题。</p><p>13，对于公司外的 <code>http/api</code> 开放接口必须使用“错误码”；而应用内部推荐异常抛出；跨应用间 <code>RPC</code> 调用优先考虑使用 <code>Result</code> 方式，封装 <code>isSuccess()</code> 方法、“错误码”、“错误简短信息”。<br><strong>说明</strong>：关于 <code>RPC</code> 方法返回方式使用 <code>Result</code> 方式的理由：<br>    1）使用抛异常返回方式，调用方如果没有捕获到就会产生运行时错误。<br>    2）如果不加栈信息，只是 new 自定义异常，加入自己的理解的 error message，对于调用端解决问题的帮助不会太多。如果加了栈信息，在频繁调用出错的情况下，数据序列化和传输的性能损耗也是问题。</p><h1 id="日志规约"><a href="#日志规约" class="headerlink" title="日志规约"></a>日志规约</h1><p>1，应用中不可直接使用日志系统（Log4j、Logback）中的 API ，而应依赖使用日志框架 SLF4J 中的 API ，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。</p><pre><code class="java">import org.slf4j.Logger;import org.slf4j.LoggerFactory;private static final Logger logger = LoggerFactory.getLogger(Test.class);</code></pre><p>2，所有日志文件至少保存 15 天，因为有些异常具备以“周”为频次发生的特点。网络运行状态、安全相关信息、系统监测、管理后台操作、用户敏感操作需要留存相关的网络日志不少于 6 个月。</p><p>3，应用中的扩展日志（如打点、临时监控、访问日志等）命名方式：appName_logType_logName.log。logType：日志类型，如 stats/monitor/access 等；logName：日志描述。这种命名的好处：通过文件名就可知道日志文件属于什么应用，什么类型，什么目的，也有利于归类查找。<br><strong>说明</strong>：推荐对日志进行分类，如将错误日志和业务日志分开存放，便于开发人员查看，也便于通过日志对系统进行及时监控。<br><strong>正例</strong>：force-web 应用中单独监控时区转换异常，如：force_web_timeZoneConvert.log</p><p>4，在日志输出时，字符串变量之间的拼接使用占位符的方式。<br><strong>说明</strong>：因为 String 字符串的拼接会使用 StringBuilder 的 append() 方式，有一定的性能损耗。使用占位符仅是替换动作，可以有效提升性能。<br><strong>正例</strong>： <code>logger.debug(&quot;Processing trade with id: {} and symbol: {}&quot;, id, symbol);</code></p><p>5，对于 trace/debug/info 级别的日志输出，必须进行日志级别的开关判断。<br><strong>说明</strong>：虽然在 debug(参数)的方法体内第一行代码 <code>isDisabled(Level.DEBUG_INT)</code> 为真时（Slf4j 的常见实现 Log4j 和 Logback），就直接 return，但是参数可能会进行字符串拼接运算。此外，如果 <code>debug(getName())</code> 这种参数内有 <code>getName()</code> 方法调用，无谓浪费方法调用的开销。</p><pre><code class="java">// 正例：// 如果判断为真，那么可以输出 trace 和 debug 级别的日志if (logger.isDebugEnabled()) {    logger.debug(&quot;Current ID is: {} and name is: {}&quot;, id, getName());}</code></pre><p>6，避免重复打印日志，浪费磁盘空间，务必在 <code>log4j.xml</code> 中设置 <code>additivity=false</code>。<br><strong>正例</strong>：<code>&lt;logger name=&quot;com.taobao.dubbo.config&quot; additivity=&quot;false&quot;&gt;</code></p><p>7，异常信息应该包括两类信息：案发现场信息和异常堆栈信息。如果不处理，那么通过关键字 <code>throws</code> 往上抛出。<br><strong>正例</strong>：<code>logger.error(各类参数或者对象 toString() + &quot;_&quot; + e.getMessage(), e);</code></p><p>9，可以使用 <code>warn</code> 日志级别来<strong>记录用户输入参数错误的情况</strong>，避免用户投诉时，无所适从。</p><h1 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h1><p>1，好的单元测试必须遵守 <code>AIR</code> 原则。<br><strong>说明</strong>：单元测试在线上运行时，感觉像空气（AIR）一样并不存在，但在测试质量的保障上，却是非常关键的。好的单元测试宏观上来说，具有自动化、独立性、可重复执行的特点。</p><ul><li>A：Automatic（自动化）</li><li>I：Independent（独立性）</li><li>R：Repeatable（可重复）</li></ul><p>2，单元测试应该是全自动执行的，并且非交互式的。测试用例通常是被定期执行的，执行过程必须完全自动化才有意义。输出结果需要人工检查的测试不是一个好的单元测试。单元测试中不准使用 <code>System.out</code> 来进行人肉验证，必须使用 <code>assert</code> 来验证。</p><p>3，保持单元测试的独立性。为了保证单元测试稳定可靠且便于维护，单元测试用例之间决不能互相调用，也不能依赖执行的先后次序。<br><strong>反例</strong>：method2 需要依赖 method1 的执行，将执行结果作为 method2 的输入。</p><p>4，单元测试是可以重复执行的，不能受到外界环境的影响。<br><strong>说明</strong>：单元测试通常会被放到持续集成中，每次有代码 check in 时单元测试都会被执行。如果单测对外部环境（网络、服务、中间件等）有依赖，容易导致持续集成机制的不可用。<br><strong>正例</strong>：为了不受外界环境影响，要求设计代码时就把 SUT 的依赖改成注入，在测试时用 spring 这样的 DI 框架注入一个本地（内存）实现或者 Mock 实现。</p><p>5，对于单元测试，要保证测试粒度足够小，有助于精确定位问题。单测粒度至多是类级别，一般是方法级别。<br><strong>说明</strong>：只有测试粒度小才能在出错时尽快定位到出错位置。单测不负责检查跨类或者跨系统的交互逻辑，那是集成测试的领域。</p><p>9，编写单元测试代码遵守 <code>BCDE</code> 原则，以保证被测试模块的交付质量。</p><ul><li>B：Border，边界值测试，包括循环边界、特殊取值、特殊时间点、数据顺序等。</li><li>C：Correct，正确的输入，并得到预期的结果。</li><li>D：Design，与设计文档相结合，来编写单元测试。</li><li>E：Error，强制错误信息输入（如：非法数据、异常流程、业务允许外等），并得到预期的结果。</li></ul><p>10，对于数据库相关的查询，更新，删除等操作，不能假设数据库里的数据是存在的，或者直接操作数据库把数据插入进去，请使用程序插入或者导入数据的方式来准备数据。</p><p>11，和数据库相关的单元测试，可以设定自动回滚机制，不给数据库造成脏数据。或者对单元测试产生的数据有明确的前后缀标识。</p><p>14，单元测试作为一种质量保障手段，在项目提测前完成单元测试，不建议项目发布后补充单元测试用例。</p><p>15，为了更方便地进行单元测试，业务代码应避免以下情况：</p><ul><li>构造方法中做的事情过多。</li><li>存在过多的全局变量和静态方法。</li><li>存在过多的外部依赖。</li><li>存在过多的条件语句。</li></ul><p>16，不要对单元测试存在如下误解：</p><ul><li>那是测试同学干的事情。本文是开发手册，凡是本文内容都是与开发同学强相关的。</li><li>单元测试代码是多余的。系统的整体功能与各单元部件的测试正常与否是强相关的。</li><li>单元测试代码不需要维护。一年半载后，那么单元测试几乎处于废弃状态。</li><li>单元测试与线上故障没有辩证关系。好的单元测试能够最大限度地规避线上故障。</li></ul><h1 id="安全规约"><a href="#安全规约" class="headerlink" title="安全规约"></a>安全规约</h1><p>1，隶属于用户个人的页面或者功能必须进行权限控制校验。</p><p>2，用户敏感数据禁止直接展示，必须对展示数据进行脱敏。<br><strong>说明</strong>：中国大陆个人手机号码显示为: 137****0969，隐藏中间 4 位，防止隐私泄露。</p><p>3，用户输入的 SQL 参数严格使用参数绑定或者 METADATA 字段值限定，防止 SQL 注入，禁止字符串拼接 SQL 访问数据库。</p><p>4，用户请求传入的任何参数必须做有效性验证。<br><strong>说明</strong>：忽略参数校验可能导致：</p><ul><li>page size 过大导致内存溢出</li><li>恶意 order by 导致数据库慢查询</li><li>任意重定向</li><li>SQL 注入</li><li>反序列化注入</li><li>正则输入源串拒绝服务 ReDoS</li></ul><p><strong>说明</strong>：Java 代码用正则来验证客户端的输入，有些正则写法验证普通用户输入没有问题，但是如果攻击人员使用的是特殊构造的字符串来验证，有可能导致死循环的结果。</p><p>5，禁止向 HTML 页面输出未经安全过滤或未正确转义的用户数据。</p><p>6，表单、 AJAX 提交必须执行 CSRF 安全验证。</p><p>7，在使用平台资源，譬如短信、邮件、电话、下单、支付，必须实现正确的防重放的机制，如数量限制、疲劳度控制、验证码校验，避免被滥刷而导致资损。</p><h1 id="MySQL-数据库"><a href="#MySQL-数据库" class="headerlink" title="MySQL 数据库"></a>MySQL 数据库</h1><h2 id="建表规约"><a href="#建表规约" class="headerlink" title="建表规约"></a>建表规约</h2><p>1，表达是与否概念的字段，必须使用 <code>is_xxx</code> 的方式命名，数据类型是 <code>unsigned tinyint</code>（1 表示是，0 表示否）。<br><strong>说明</strong>：任何字段如果为非负数，必须是 <code>unsigned</code>。<br>注意：POJO 类中的任何布尔类型的变量，都不要加 is 前缀，所以，需要在 <code>&lt;resultMap&gt;</code> 设置从 <code>is_xxx</code> 到 <code>Xxx</code> 的映射关系。数据库表示是与否的值，使用 <code>tinyint</code> 类型，坚持 <code>is_xxx</code> 的命名方式是为了明确其取值含义与取值范围。</p><p>2，表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只出现数字。</p><p>3，表名不使用复数名词。<strong>说明</strong>：表名应该仅仅表示表里面的实体内容，不应该表示实体数量，对应于 DO 类名也是单数形式，符合表达习惯。</p><p>4，禁用保留字，如 desc、range、match、delayed 等，请参考 MySQL 官方保留字。</p><p>5，主键索引名为 <code>pk_字段名</code>；唯一索引名为 <code>uk_字段名</code>；普通索引名则为 <code>idx_字段名</code>。<strong>说明</strong>：<code>pk_</code> 即 primary key；<code>uk_</code> 即 unique key；<code>idx_</code> 即 index 的简称。</p><p>6，小数类型为 <code>decimal</code>，禁止使用 <code>float</code> 和 <code>double</code> 。</p><p>7，如果存储的字符串长度几乎相等，使用 <code>char</code> 定长字符串类型。</p><p>8，<code>varchar</code> 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长度大于此值，定义字段类型为 <code>text</code>，独立出来一张表，用主键来对应，避免影响其它字段索引效率。</p><p>9，表必备三字段：<code>id</code>, <code>create_time</code>, <code>update_time</code>。<br><strong>说明</strong>：其中 <code>id</code> 必为主键，类型为 <code>bigint unsigned</code>、单表时自增、步长为 1。create_time, update_time 的类型均为 datetime 类型。</p><p>13，字段允许适当冗余，以提高查询性能，但必须考虑数据一致。冗余字段应遵循：</p><ul><li>不是频繁修改的字段。</li><li>不是 <code>varchar</code> 超长字段，更不能是 <code>text</code> 字段。</li><li>不是唯一索引的字段。<br>正例：商品类目名称使用频率高，字段长度短，名称基本一不变，可在相关联的表中冗余存储类目名称，避免关联查询。</li></ul><p>14，单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。</p><p>15，合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。<br>正例：如下表，其中无符号值可以避免误存负数，且扩大了表示范围。</p><table><thead><tr><th>对象</th><th>年龄区间</th><th>类型</th><th>字节</th><th>表示范围</th></tr></thead><tbody><tr><td>人</td><td>150 岁之内</td><td>tinyint unsigned</td><td>1</td><td>无符号值：0 到 255</td></tr><tr><td>龟</td><td>数百岁</td><td>smallint unsigned</td><td>2</td><td>无符号值：0 到 65535</td></tr><tr><td>恐龙化石</td><td>数千万年</td><td>int unsigned</td><td>4</td><td>无符号值：0 到约 42.9 亿</td></tr><tr><td>太阳</td><td>约 50 亿年</td><td>bigint unsigned</td><td>8</td><td>无符号值：0 到约 10 的 19 次方</td></tr></tbody></table><h2 id="索引规约"><a href="#索引规约" class="headerlink" title="索引规约"></a>索引规约</h2><p>1，业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。<br><strong>说明</strong>：不要以为唯一索引影响了 <code>insert</code> 速度，这个速度损耗可以忽略，但提高查找速度是明显的；另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生。</p><p>2，超过三个表禁止 <code>join</code> 。需要 <code>join</code> 的字段，数据类型必须绝对一致；多表关联查询时，保证被关联的字段需要有索引。<br><strong>说明</strong>：即使双表 <code>join</code> 也要注意表索引、SQL 性能。</p><p>3，在 <code>varchar</code> 字段上建立索引时，必须指定<strong><em>索引长度</em></strong>，没必要对全字段建立索引，根据实际文本区分度决定索引长度即可。<br><strong>说明</strong>：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会高达 90% 以上，可以使用 <code>count(distinct left(列名, 索引长度))/count(*)</code> 的区分度来确定。<br>Innodb 默认单列索引最大长度 767bytes，一般我们认为是 255 字符。</p><p>4，页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。<br><strong>说明</strong>：索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。</p><p>5，如果有 order by 的场景，请注意利用索引的有序性。order by 最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现 file_sort 的情况，影响查询性能。<br><strong>正例</strong>：<code>where a=? and b=? order by c;</code> 索引：<code>a_b_c</code><br><strong>反例</strong>：索引如果存在范围查询，那么索引有序性无法利用，如：<code>WHERE a&gt;10 ORDER BY b;</code> 索引 <code>a_b</code> 无法排序。</p><p>6，利用<strong><em>覆盖索引</em></strong>来进行查询操作，避免回表。<br><strong>说明</strong>：如果一本书需要知道第 11 章是什么标题，会翻开第 11 章对应的那一页吗？目录浏览一下就好，这个目录就是起到覆盖索引的作用。<br><strong>正例</strong>：能够建立索引的种类分为主键索引、唯一索引、普通索引三种，而覆盖索引只是一种查询的一种效果，用 <code>explain</code> 的结果，<code>extra</code> 列会出现：<code>using index</code>。</p><p>如果一个索引包含所有需要查询的字段的值，称之为“覆盖索引”。</p><p>由于覆盖索引必须要存储索引列的值，哈希索引、空间索引和全文索引都不存储列的值，MySQL 只有 B-Tree 索引可以做覆盖索引。如：对 id,name,title 三个字段建立索引，在索引中会存储这三个列的值，如果查询：<code>select id,name,title from table where id &lt; 10;</code> 通过 explain 会看到 extra 为 using index。<br>如果查询 <code>select * from table where id &lt; 10;</code> 就不会使用覆盖索引，因为索引中没有包含所有的列值。</p><p>7，利用延迟关联或者子查询优化超多分页场景。<br><strong>说明</strong>：MySQL 并不是跳过 <code>offset</code> 行，而是取 <code>offset+N</code> 行，然后返回放弃前 <code>offset</code> 行，返回 N 行，那当 <code>offset</code> 特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行 SQL 改写。<br><strong>正例</strong>：先快速定位需要获取的 id 段，然后再关联：</p><pre><code class="sql">SELECT a.* FROM 表 1 a, (select id from 表 1 where 条件 LIMIT 100000,20 ) b where a.id=b.id</code></pre><p>8，SQL 性能优化的目标：至少要达到 <code>range</code> 级别，要求是 <code>ref</code> 级别，如果可以是 <code>consts</code> 最好。<br><strong>说明</strong>：</p><ul><li><code>consts</code> 单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。</li><li><code>ref</code> 指的是使用普通的索引（normal index）。</li><li><code>range</code> 对索引进行范围检索。</li></ul><p><strong>反例</strong>：<code>explain</code> 表的结果，<code>type=index</code>，索引物理文件全扫描，速度非常慢，这个 <code>index</code> 级别比较 <code>range</code> 还低，与全表扫描是小巫见大巫。</p><p>9，建组合索引的时候，区分度最高的在最左边。<br><strong>正例</strong>：如果 <code>where a=? and b=?</code> ，如果 a 列的几乎接近于唯一值，那么只需要单建 <code>idx_a</code> 索引即可。<br><strong>说明</strong>：存在非等号和等号混合时，在建索引时，请把等号条件的列前置。如：<code>where c&gt;? and d=?</code> 那么即使 c 的区分度更高，也必须把 d 放在索引的最前列，即索引 <code>idx_d_c</code>。</p><p>10，防止因字段类型不同造成的<strong><em>隐式转换</em></strong>，导致索引失效。例如：varchar 条件需要加上 &#39;&#39; ，如果没加就有可能导致索引失效，<code>SELECT code FROM t WHERE code=86</code>，加上 &#39;&#39; 即可使用索引 <code>SELECT code FROM t WHERE code=&#39;86&#39;</code></p><p>11，创建索引时避免有如下极端误解：</p><ul><li>宁滥勿缺。认为一个查询就需要建一个索引。</li><li>宁缺勿滥。认为索引会消耗空间、严重拖慢记录的更新以及行的新增速度。</li><li>抵制惟一索引。认为业务的惟一性一律需要在应用层通过“先查后插”方式解决。</li></ul><h2 id="SQL-语句"><a href="#SQL-语句" class="headerlink" title="SQL 语句"></a>SQL 语句</h2><p>1，不要使用 <code>count(列名)</code> 或 <code>count(常量)</code> 来替代 <code>count(*)</code>，<code>count(*)</code> 是 SQL92 定义的标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。<br><strong>说明</strong>：<code>count(*)</code> 会统计值为 NULL 的行，<strong>而 <code>count(列名)</code> 不会统计此列为 NULL 值的行</strong>。</p><p>2，<code>count(distinct col)</code> 计算该列除 NULL 之外的不重复行数，注意 <code>count(distinct col1, col2)</code> 如果其中一列全为 NULL，那么即使另一列有不同的值，也返回为 0。</p><p>3，当某一列的值全是 NULL 时，<code>count(col)</code> 的返回结果为 0，但 <code>sum(col)</code> 的返回结果为 <code>NULL</code>，因此<strong>使用 <code>sum()</code> 时需注意 <code>NPE</code> 问题</strong>。<br><strong>正例</strong>：使用如下方式来避免 sum 的 NPE 问题：<code>SELECT IFNULL(SUM(column), 0) FROM table;</code></p><p>4，使用 <code>ISNULL()</code> 来判断是否为 <code>NULL</code> 值。<br><strong>说明</strong><code>：NULL</code> 与任何值的直接比较都为 <code>NULL</code>。</p><ul><li><code>NULL&lt;&gt;NULL</code> 的返回结果是 NULL，而不是 false。</li><li><code>NULL=NULL</code> 的返回结果是 NULL，而不是 true。</li><li><code>NULL&lt;&gt;1</code> 的返回结果是 NULL，而不是 true。</li></ul><p>5，代码中写分页查询逻辑时，若 <code>count</code> 为 <code>0</code> 应直接返回，避免执行后面的分页语句。</p><p>6，不得使用外键与级联，一切外键概念必须在应用层解决。<br><strong>说明</strong>：以学生和成绩的关系为例，学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，即为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。</p><p>7，禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。</p><p>8，数据订正（特别是删除、修改记录操作）时，要先 <code>select</code>，避免出现误删除，确认无误才能执行更新语句。</p><p>9，in 操作能避免则避免，若实在避免不了，需要仔细评估 in 后边的集合元素数量，控制在 1000 个之内。</p><p>10，如果有国际化需要，所有的字符存储与表示，均以 utf-8 编码，注意字符统计函数的区别。</p><pre><code class="sql">-- 说明SELECT LENGTH(&quot;轻松工作&quot;)； -- 返回为 12SELECT CHARACTER_LENGTH(&quot;轻松工作&quot;)； -- 返回为 4</code></pre><h2 id="ORM-映射"><a href="#ORM-映射" class="headerlink" title="ORM 映射"></a>ORM 映射</h2><p>1，在表查询中，一律不要使用 * 作为查询的字段列表，需要哪些字段必须明确写明。<br><strong>说明</strong>：</p><ul><li>增加查询分析器解析成本。</li><li>增减字段容易与 <code>resultMap</code> 配置不一致。</li><li>无用字段增加网络消耗，尤其是 text 类型的字段。</li></ul><p>2，POJO 类的布尔属性不能加 is，而数据库字段必须加 <code>is_</code>，要求在 <code>resultMap</code> 中进行字段与属性之间的映射。<br><strong>说明</strong>：参见定义 POJO 类以及数据库字段定义规定，在 <code>&lt;resultMap&gt;</code> 中增加映射，是必须的。在 MyBatis Generator 生成的代码中，需要进行对应的修改。</p><p>3，不要用 <code>resultClass</code> 当返回参数，即使所有类属性名与数据库字段一一对应，也需要定义；反过来，每一个表也必然有一个 POJO 类与之对应。<br><strong>说明</strong>：配置映射关系，使字段与 <code>DO</code> 类解耦，方便维护。</p><p>4，<code>sql.xml</code> 配置参数使用：<code>#{}</code>，<code>#param#</code> 不要使用 <code>${}</code> 此种方式容易出现 SQL 注入。</p><p>6，不允许直接拿 <code>HashMap</code> 与 <code>Hashtable</code> 作为查询结果集的输出。<br><strong>说明</strong>：<code>resultClass=&quot;Hashtable&quot;</code>，会置入字段名和属性值，但是值的类型不可控。</p><p>7，更新数据表记录时，必须同时更新记录对应的 <code>gmt_modified</code> 字段值为当前时间。</p><p>8，不要写一个大而全的数据更新接口。传入为 POJO 类，不管是不是自己的目标更新字段，都进行 <code>update table set c1=value1,c2=value2,c3=value3;</code> 这是不对的。执行 SQL 时，不要更新无改动的字段，一是易出错；二是效率低；三是增加 binlog 存储。</p><p>9，<code>@Transactional</code> 事务不要滥用。事务会影响数据库的 QPS，另外使用事务的地方需要考虑各方面的回滚方案，包括缓存回滚、搜索引擎回滚、消息补偿、统计修正等。</p><h1 id="工程结构"><a href="#工程结构" class="headerlink" title="工程结构"></a>工程结构</h1><h2 id="应用分层"><a href="#应用分层" class="headerlink" title="应用分层"></a>应用分层</h2><p>1，图中默认上层依赖于下层，箭头关系表示可直接依赖，如：开放接口层可以依赖于 Web 层，也可以直接依赖于 Service 层，依此类推：</p><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20191130162652.png" alt=""></p><ul><li>开放接口层：可直接封装 Service 方法暴露成 RPC 接口；通过 Web 封装成 http 接口；进行网关安全控制、流量控制等。</li><li>终端显示层：各个端的模板渲染并执行显示的层。当前主要是 velocity 渲染，JS 渲染，JSP 渲染，移动端展示等。</li><li>Web 层：主要是对访问控制进行转发，各类基本参数校验，或者不复用的业务简单处理等。</li><li>Service 层：相对具体的业务逻辑服务层。</li><li>Manager 层：通用业务处理层，它有如下特征：<br>  1） 对第三方平台封装的层，预处理返回结果及转化异常信息。<br>  2） 对 Service 层通用能力的下沉，如缓存方案、中间件通用处理。<br>  3） 与 DAO 层交互，对多个 DAO 的组合复用。</li><li>DAO 层：数据访问层，与底层 MySQL、Oracle、Hbase 等进行数据交互。</li><li>外部接口或第三方平台：包括其它部门 RPC 开放接口，基础平台，其它公司的 HTTP 接口。</li></ul><p>2，（分层异常处理规约） 在 DAO 层，产生的异常类型有很多，无法用细粒度的异常进行 catch ，使用 catch(Exception e) 方式，并 throw new DAOException(e) ，不需要打印日志，因为日志在 Manager / Service 层一定需要捕获并打印到日志文件中去，如果同台服务器再打日志，浪费性能和存储。在 Service 层出现异常时，必须记录出错日志到磁盘，尽可能带上参数信息，相当于保护案发现场。如果 Manager 层与 Service 同机部署，日志方式与 DAO 层处理一致，如果是单独部署，则采用与 Service 一致的处理方式。 Web 层绝不应该继续往上抛异常，因为已经处于顶层，如果意识到这个异常将导致页面无法正常渲染，那么就应该直接跳转到友好错误页面，加上用户容易理解的错误提示信息。开放接口层要将异常处理成错误码和错误信息方式返回。</p><p>3，分层领域模型规约：</p><ul><li><code>DO</code>（Data Object）：此对象与数据库表结构一一对应，通过 DAO 层向上传输数据源对象。</li><li><code>DTO</code>（Data Transfer Object）：数据传输对象，Service 或 Manager 向外传输的对象。</li><li><code>BO</code>（Business Object）：业务对象，由 Service 层输出的封装业务逻辑的对象。</li><li><code>AO</code>（Application Object）：应用对象，在 Web 层与 Service 层之间抽象的复用对象模型，极为贴近展示层，复用度不高。</li><li><code>VO</code>（View Object）：显示层对象，通常是 Web 向模板渲染引擎层传输的对象。</li><li><code>Query</code>：数据查询对象，各层接收上层的查询请求。注意超过 2 个参数的查询封装，禁止使用 Map 类来传输。</li></ul><h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><p>1，高并发服务器建议调小 TCP 协议的 <code>time_wait</code> 超时时间。<br><strong>说明</strong>：操作系统默认 240 秒后，才会关闭处于 <code>time_wait</code> 状态的连接，在高并发访问下，服务器端会因为处于 <code>time_wait</code> 的连接数太多，可能无法建立新的连接，所以需要在服务器上调小此等待值。<br><strong>正例</strong>：在 linux 服务器上请通过变更 <code>/etc/sysctl.conf</code> 文件去修改该缺省值（秒）：<br><code>net.ipv4.tcp_fin_timeout = 30</code></p><p>2，调大服务器所支持的<code>最大文件句柄数</code>（File Descriptor，简写为 fd）。<br><strong>说明</strong>：主流操作系统的设计是将 TCP/UDP 连接采用与文件一样的方式去管理，即一个连接对应于一个 fd。主流的 linux 服务器默认所支持最大 fd 数量为 <code>1024</code>，当并发连接数很大时很容易因为 fd 不足而出现“open too many files”错误，导致新的连接无法建立。建议将 linux 服务器所支持的最大句柄数调高数倍（与服务器的内存数量相关）。</p><p>3，给 JVM 环境参数设置 <code>-XX:+HeapDumpOnOutOfMemoryError</code> 参数，让 JVM 碰到 OOM 场景时输出 dump 信息。<br><strong>说明</strong>：OOM 的发生是有概率的，甚至相隔数月才出现一例，出错时的堆内信息对解决问题非常有帮助。</p><p>4，在线上生产环境， JVM 的 <code>Xms</code> 和 <code>Xmx</code> 设置一样大小的内存容量，避免在 GC 后调整堆大小带来的压力。</p><p>5，服务器内部重定向使用 <code>forward</code>；外部重定向地址使用 URL 拼装工具类来生成，否则会带来 URL 维护不一致的问题和潜在的安全风险。</p><h1 id="设计规约"><a href="#设计规约" class="headerlink" title="设计规约"></a>设计规约</h1><p>3，如果某个业务对象的状态超过 3 个，使用状态图来表达并且明确状态变化的各个触发条件。<br><strong>说明</strong>：状态图的核心是对象状态，首先明确对象有多少种状态，然后明确两两状态之间是否存在直接转换关系，再明确触发状态转换的条件是什么。<br><strong>正例</strong>：淘宝订单状态有已下单、待付款、已付款、待发货、已发货、已收货等。比如已下单与已收货这两种状态之间是不可能有直接转换关系的。</p><p>4，如果系统中某个功能的调用链路上的涉及对象超过 3 个，使用时序图来表达并且明确各调用环节的输入与输出。<br><strong>说明</strong>：时序图反映了一系列对象间的交互与协作关系，清晰立体地反映系统的调用纵深链路。</p><p>5，如果系统中模型类超过 5 个，并且存在复杂的依赖关系，使用类图来表达并且明确类之间的关系。<br><strong>说明</strong>：类图像建筑领域的施工图，如果搭平房，可能不需要，但如果建造蚂蚁 Z 空间大楼，肯定需要详细的施工图。</p><p>6，如果系统中超过 2 个对象之间存在协作关系，并且需要表示复杂的处理流程，使用活动图来表示。<br><strong>说明</strong>：活动图是流程图的扩展，增加了能够体现协作关系的对象泳道，支持表示并发等。</p><p>7，需求分析与系统设计在考虑主干功能的同时，需要充分评估异常流程与业务边界。<br><strong>反例</strong>：用户在淘宝付款过程中，银行扣款成功，发送给用户扣款成功短信，但是支付宝入款时由于断网演练产生异常，淘宝订单页面依然显示未付款，导致用户投诉。</p><p>8，类在设计与实现时要符合单一原则。<br><strong>说明</strong>：单一原则最易理解却是最难实现的一条规则，随着系统演进，很多时候，忘记了类设计的初衷。</p><p>9，谨慎使用继承的方式来进行扩展，优先使用聚合/组合的方式来实现。<br><strong>说明</strong>：不得已使用继承的话，必须符合里氏代换原则，此原则说父类能够出现的地方子类一定能够出现，比如，“把钱交出来”，钱的子类美元、欧元、人民币等都可以出现。</p><p>10，系统设计时，根据依赖倒置原则，尽量依赖抽象类与接口，有利于扩展与维护。<br><strong>说明</strong>：低层次模块依赖于高层次模块的抽象，方便系统间的解耦。</p><p>11，系统设计时，注意对扩展开放，对修改闭合。<br><strong>说明</strong>：极端情况下，交付线上生产环境的代码都是不可修改的，同一业务域内的需求变化，通过模块或类的扩展来实现。</p><p>12，系统设计阶段，共性业务或公共行为抽取出来公共模块、公共配置、公共类、公共方法等，避免出现重复代码或重复配置的情况。<br><strong>说明</strong>：随着代码的重复次数不断增加，维护成本指数级上升。</p><p>14，系统设计主要目的是明确需求、理顺逻辑、后期维护，次要目的用于指导编码。<br><strong>说明</strong>：避免为了设计而设计，系统设计文档有助于后期的系统维护和重构，所以设计结果需要进行分类归档保存。</p><p>15，设计的本质就是识别和表达系统难点，找到系统的变化点，并隔离变化点。<br><strong>说明</strong>：世间众多设计模式目的是相同的，即隔离系统变化点。</p><p>16，系统架构设计的目的：</p><ul><li>确定系统边界。确定系统在技术层面上的做与不做。</li><li>确定系统内模块之间的关系。确定模块之间的依赖关系及模块的宏观输入与输出。</li><li>确定指导后续设计与演化的原则。使后续的子系统或模块设计在规定的框架内继续演化。</li><li>确定非功能性需求。非功能性需求是指安全性、可用性、可扩展性等。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;编程规范&quot;&gt;&lt;a href=&quot;#编程规范&quot; class=&quot;headerlink&quot; title=&quot;编程规范&quot;&gt;&lt;/a&gt;编程规范&lt;/h1&gt;&lt;h2 id=&quot;命名风格&quot;&gt;&lt;a href=&quot;#命名风格&quot; class=&quot;headerlink&quot; title=&quot;命名风格&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="Java" scheme="http://coolview.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="http://coolview.github.io/tags/Java/"/>
    
      <category term="MyBatis" scheme="http://coolview.github.io/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis 07-高级查询</title>
    <link href="http://coolview.github.io/2019/11/17/MyBatis/MyBatis%2007-%E9%AB%98%E7%BA%A7%E6%9F%A5%E8%AF%A2/"/>
    <id>http://coolview.github.io/2019/11/17/MyBatis/MyBatis%2007-%E9%AB%98%E7%BA%A7%E6%9F%A5%E8%AF%A2/</id>
    <published>2019-11-17T13:04:43.000Z</published>
    <updated>2019-12-03T12:27:57.340Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="http://www.broadview.com.cn/book/3643" target="_blank" rel="noopener">http://www.broadview.com.cn/book/3643</a><br><a href="https://github.com/mybatis-book/book" target="_blank" rel="noopener">https://github.com/mybatis-book/book</a></p></blockquote><h2 id="一对一映射"><a href="#一对一映射" class="headerlink" title="一对一映射"></a>一对一映射</h2><h3 id="使用自动映射处理一对一关系"><a href="#使用自动映射处理一对一关系" class="headerlink" title="使用自动映射处理一对一关系"></a>使用自动映射处理一对一关系</h3><p>假设<strong>一个用户只有一个角色</strong></p><pre><code class="java">public class SysUser {    private Long id;    private String userName;    private String userPassword;    private String userEmail;    /**     * 用户角色     */    private SysRole role;    // ...}</code></pre><p>MyBatis 支持多层嵌套，role.roleName 将会绑定到 role 对象的 roleName 属性上。</p><pre><code class="xml">&lt;select id=&quot;selectUserAndRoleById&quot; resultType=&quot;tk.mybatis.simple.model.SysUser&quot;&gt;    select        u.id,        u.user_name userName,        u.user_password userPassword,        u.user_email userEmail,        r.id &quot;role.id&quot;,        r.role_name &quot;role.roleName&quot;,        r.enabled &quot;role.enabled&quot;,        r.create_by &quot;role.createBy&quot;,        r.create_time &quot;role.createTime&quot;    from sys_user u    inner join sys_user_role ur on u.id = ur.user_id    inner join sys_role r on ur.role_id = r.id    where u.id = #{id}&lt;/select&gt;</code></pre><h3 id="使用-resultMap-配置一对一映射"><a href="#使用-resultMap-配置一对一映射" class="headerlink" title="使用 resultMap 配置一对一映射"></a>使用 resultMap 配置一对一映射</h3><pre><code class="xml">&lt;resultMap id=&quot;userMap&quot; type=&quot;tk.mybatis.simple.model.SysUser&quot;&gt;    &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;    &lt;result property=&quot;userName&quot; column=&quot;user_name&quot;/&gt;    &lt;result property=&quot;userPassword&quot; column=&quot;user_password&quot;/&gt;    &lt;result property=&quot;userEmail&quot; column=&quot;user_email&quot;/&gt;    &lt;!-- role 部分，避免列名重复，可能重复的列名增加了 &quot;role_&quot; 前缀，并在 SQL 中设置别名 --&gt;    &lt;result property=&quot;role.id&quot; column=&quot;role_id&quot;/&gt;    &lt;result property=&quot;role.roleName&quot; column=&quot;role_name&quot;/&gt;    &lt;result property=&quot;role.enabled&quot; column=&quot;enabled&quot;/&gt;    &lt;result property=&quot;role.createBy&quot; column=&quot;create_by&quot;/&gt;    &lt;result property=&quot;role.createTime&quot; column=&quot;role_create_time&quot; jdbcType=&quot;TIMESTAMP&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;selectUserAndRoleById2&quot; resultMap=&quot;userRoleMap&quot;&gt;    select        u.id,        u.user_name,        u.user_password,        u.user_email,        r.id role_id,        r.role_name role_name,        r.enabled enabled,        r.create_by create_by,        r.create_time role_create_time    from sys_user u    inner join sys_user_role ur on u.id = ur.user_id    inner join sys_role r on ur.role_id = r.id    where u.id = #{id}&lt;/select&gt;</code></pre><p>相比自动映射，这样会更麻烦。<br>可简单的部分，MyBatis 支持 resultMap 映射继承的。</p><pre><code class="xml">&lt;resultMap id=&quot;userMap&quot; type=&quot;tk.mybatis.simple.model.SysUser&quot;&gt;    &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;    &lt;result property=&quot;userName&quot; column=&quot;user_name&quot;/&gt;    &lt;result property=&quot;userPassword&quot; column=&quot;user_password&quot;/&gt;    &lt;result property=&quot;userEmail&quot; column=&quot;user_email&quot;/&gt;    &lt;result property=&quot;userInfo&quot; column=&quot;user_info&quot;/&gt;    &lt;result property=&quot;headImg&quot; column=&quot;head_img&quot; jdbcType=&quot;BLOB&quot;/&gt;    &lt;result property=&quot;createTime&quot; column=&quot;create_time&quot; jdbcType=&quot;TIMESTAMP&quot;/&gt;&lt;/resultMap&gt;&lt;resultMap id=&quot;userRoleMap&quot; extends=&quot;userMap&quot; type=&quot;tk.mybatis.simple.model.SysUser&quot;&gt;    &lt;result property=&quot;role.id&quot; column=&quot;role_id&quot;/&gt;    &lt;result property=&quot;role.roleName&quot; column=&quot;role_name&quot;/&gt;    &lt;result property=&quot;role.enabled&quot; column=&quot;enabled&quot;/&gt;    &lt;result property=&quot;role.createBy&quot; column=&quot;create_by&quot;/&gt;    &lt;result property=&quot;role.createTime&quot; column=&quot;role_create_time&quot; jdbcType=&quot;TIMESTAMP&quot;/&gt;&lt;/resultMap&gt;</code></pre><h3 id="使用-resultMap-的-association-标签配置一对一映射"><a href="#使用-resultMap-的-association-标签配置一对一映射" class="headerlink" title="使用 resultMap 的 association 标签配置一对一映射"></a>使用 resultMap 的 association 标签配置一对一映射</h3><p>修改上面的配置</p><pre><code class="xml">&lt;resultMap id=&quot;userRoleMap&quot; extends=&quot;userMap&quot; type=&quot;tk.mybatis.simple.model.SysUser&quot;&gt;    &lt;association property=&quot;role&quot; columnPrefix=&quot;role_&quot; javaType=&quot;tk.mybatis.simple.model.SysRole&quot;/&gt;    &lt;result property=&quot;id&quot; column=&quot;id&quot;/&gt;    &lt;result property=&quot;roleName&quot; column=&quot;role_name&quot;/&gt;    &lt;result property=&quot;enabled&quot; column=&quot;enabled&quot;/&gt;    &lt;result property=&quot;createBy&quot; column=&quot;create_by&quot;/&gt;    &lt;result property=&quot;createTime&quot; column=&quot;create_time&quot; jdbcType=&quot;TIMESTAMP&quot;/&gt;&lt;/resultMap&gt;</code></pre><p>association 标签包含以下属性：</p><ul><li>property：对应实体类中的属性名</li><li>javaType：属性对应的 Java 类型</li><li>resultMap：可以直接使用现有的 resultMap，而不需要在这里配置</li><li>columnPrefix：查询列的前缀，配置前缀后，在子标签配置 result 的 column 时可以省略前缀</li></ul><pre><code class="xml">&lt;!-- 将 sys_role 相关所有列的别名修改为 &quot;role_&quot; 前缀 --&gt;&lt;select id=&quot;selectUserAndRoleById2&quot; resultMap=&quot;userRoleMap&quot;&gt;    select        u.id,        u.user_name,        u.user_password,        u.user_email,        r.id role_id,        r.role_name role_role_name,        r.enabled role_enabled,        r.create_by role_create_by,        r.create_time role_create_time    from sys_user u    inner join sys_user_role ur on u.id = ur.user_id    inner join sys_role r on ur.role_id = r.id    where u.id = #{id}&lt;/select&gt;</code></pre><p>使用 <code>association</code> 配置 resultMap 属性配置一个已经存在的 resultMap 映射。</p><pre><code class="xml">&lt;!-- 这个应该放到 RoleMapper.xml 更合理 --&gt;&lt;resultMap id=&quot;roleMap&quot; type=&quot;tk.mybatis.simple.model.SysRole&quot;&gt;    &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;    &lt;result property=&quot;roleName&quot; column=&quot;role_name&quot;/&gt;    &lt;result property=&quot;enabled&quot; column=&quot;enabled&quot;/&gt;    &lt;result property=&quot;createBy&quot; column=&quot;create_by&quot;/&gt;    &lt;result property=&quot;createTime&quot; column=&quot;create_time&quot; jdbcType=&quot;TIMESTAMP&quot;/&gt;&lt;/resultMap&gt;&lt;!-- 这里还是在 UserMapper.xml 中，所有需要加上 roleMap 的命名空间 --&gt;&lt;resultMap id=&quot;userRoleMap&quot; extends=&quot;userMap&quot; type=&quot;tk.mybatis.simple.model.SysUser&quot;&gt;    &lt;association property=&quot;role&quot; columnPrefix=&quot;role_&quot; resultMap=&quot;tk.mybatis.simple.mapper.RoleMapper.roleMap&quot;/&gt;&lt;/resultMap&gt;</code></pre><h3 id="association-标签的嵌套查询"><a href="#association-标签的嵌套查询" class="headerlink" title="association 标签的嵌套查询"></a>association 标签的嵌套查询</h3><p>association 标签的嵌套查询常用的属性如下：</p><ul><li><code>select</code>：另一个映射查询的 id，MyBatis 会额外执行这个查询获取嵌套对象的结果</li><li><code>column</code>：列名，将主查询中列的结果作为嵌套查询的参数，配置方式：<code>column={prop1=col1, prop2=col2}</code>，prop1，prop2 将作为嵌套查询的参数</li><li><code>fetchType</code>：数据加载方式，可选值为 <code>lazy</code> 和 <code>eager</code>，分别为延迟加载和积极加载，将覆盖全局配置 <code>lazyLoadingEnabled</code></li></ul><pre><code class="xml">&lt;resultMap id=&quot;userRoleMapSelect&quot; extends=&quot;userMap&quot; type=&quot;tk.mybatis.simple.model.SysUser&quot;&gt;    &lt;association property=&quot;role&quot; fetchType=&quot;lazy&quot;                    select=&quot;tk.mybatis.simple.mapper.RoleMapper.selectRoleById&quot;                    column=&quot;{id=role_id}&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;selectUserAndRoleByIdSelect&quot; resultMap=&quot;userRoleMapSelect&quot;&gt;    select        u.id,        u.user_name,        u.user_password,        u.user_email,        u.user_info,        u.head_img,        u.create_time,        ur.role_id    from sys_user u    inner join sys_user_role ur on u.id = ur.user_id    where u.id = #{id}&lt;/select&gt;&lt;!-- RoleMapper.xml --&gt;&lt;select id=&quot;selectRoleById&quot; resultMap=&quot;roleMap&quot;&gt;    select * from sys_role where id = #{id}&lt;/select&gt;</code></pre><p>嵌套查询会多执行 SQL，查询出来的 N 条数据，就会执行 N+1 次查询，设置 <code>fetchType=&quot;lazy&quot;</code>，这样只有调用 getRole() 方法时，才会去执行嵌套查询。</p><p>另外还需设置 <code>aggressiveLazyLoading</code> 才会生效，在 mybatis-config.xml 中添加配置：</p><pre><code class="xml">&lt;settings&gt;    &lt;!-- 当开启时，任何方法的调用都会加载该对象的所有属性。否则，每个属性会按需加载 --&gt;    &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt;&lt;/settings&gt;</code></pre><p>在和 spring 集成时，要确保只能在 Service 层调用延迟加载的属性，因为在 Control 层获取延迟加载的属性值，会因为 SqlSession 已经关闭而报错。</p><p>另外 MyBatis 还提供了 <code>lazyLoadTriggerMethods</code> 参数，指定哪个对象的方法触发一次延迟加载，默认值：<code>equals,clone,hashCode,toString</code>。如执行了 equals 方法就会加载数据。</p><h2 id="一对多映射"><a href="#一对多映射" class="headerlink" title="一对多映射"></a>一对多映射</h2><h3 id="collection-集合的嵌套结果映射"><a href="#collection-集合的嵌套结果映射" class="headerlink" title="collection 集合的嵌套结果映射"></a>collection 集合的嵌套结果映射</h3><p>和 association 类似，集合的嵌套结果映射就是指通过一次 SQL 查询将所有的结果查询出来，然后通过配置的结果映射，将数据映射到不同的对象中去。</p><pre><code class="java">public class SysUser {    // 原有属性    private List&lt;SysRole&gt; roleList;    // setter getter}</code></pre><pre><code class="xml">&lt;resultMap id=&quot;userRoleListMap&quot; extends=&quot;userMap&quot; type=&quot;tk.mybatis.simple.model.SysUser&quot;&gt;    &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;    &lt;result property=&quot;userName&quot; column=&quot;user_name&quot;/&gt;    &lt;result property=&quot;userPassword&quot; column=&quot;user_password&quot;/&gt;    &lt;result property=&quot;userEmail&quot; column=&quot;user_email&quot;/&gt;    &lt;result property=&quot;userInfo&quot; column=&quot;user_info&quot;/&gt;    &lt;result property=&quot;headImg&quot; column=&quot;head_img&quot; jdbcType=&quot;BLOB&quot;/&gt;    &lt;result property=&quot;createTime&quot; column=&quot;create_time&quot; jdbcType=&quot;TIMESTAMP&quot;/&gt;    &lt;collection property=&quot;roleList&quot; columnPrefix=&quot;role_&quot; javaType=&quot;tk.mybatis.simple.model.SysRole&quot;&gt;        &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;        &lt;result property=&quot;roleName&quot; column=&quot;role_name&quot;/&gt;        &lt;result property=&quot;enabled&quot; column=&quot;enabled&quot;/&gt;        &lt;result property=&quot;createBy&quot; column=&quot;create_by&quot;/&gt;        &lt;result property=&quot;createTime&quot; column=&quot;create_time&quot; jdbcType=&quot;TIMESTAMP&quot;/&gt;    &lt;/collection&gt;&lt;/resultMap&gt;</code></pre><p>只是把上文 [使用 resultMap 的 association 标签配置一对一映射] 中 <code>association</code> 改成 <code>collection</code>。</p><p>collection 支持的属性以及属性的作用和 association 完全相同。</p><pre><code class="xml">&lt;!-- 使用 extends，简化 resultMap --&gt;&lt;resultMap id=&quot;userRoleListMap&quot; extends=&quot;userMap&quot; type=&quot;tk.mybatis.simple.model.SysUser&quot;&gt;    &lt;collection property=&quot;roleList&quot; columnPrefix=&quot;role_&quot;                resultMap=&quot;tk.mybatis.simple.mapper.RoleMapper.roleMap&quot;/&gt;&lt;/resultMap&gt;</code></pre><p>仿照 selectUserAndRoleById2 方法，创建 selectAllUserAndRoles</p><pre><code class="xml">&lt;select id=&quot;selectAllUserAndRoles&quot; resultMap=&quot;userRoleListMap&quot;&gt;    select        u.id, u.user_name,        u.user_password, u.user_email,        u.user_info, u.head_img, u.create_time,        r.id role_id,        r.role_name role_role_name,        r.enabled role_enabled,        r.create_by role_create_by,        r.create_time role_create_time    from sys_user u    inner join sys_user_role ur on u.id = ur.user_id    inner join sys_role r on ur.role_id = r.id&lt;/select&gt;</code></pre><p>admin 用户，对应角色：管理员，普通用户<br>test 用户，对应角色：普通用户</p><p>SQL 执行结果数有 3 条，通过 selectAllUserAndRoles 查询出来用户数是 2。</p><p>MyBatis 在处理结果的时候，会判断结果是否相同，如果是相同的结果，则只会保留第一个结果。MyBatis 判断结果是否相同时，最简单的情况就是在映射配置中至少有一个 id 标签，在 userMap 中配置如下：</p><pre><code class="xml">&lt;id property=&#39;id&#39; column=&#39;id&#39;&gt;</code></pre><p>当配置 id 标签时，MyBatis 只需要逐条比较所以数据中 id 标签配置的字段值是否相同即可。在配置嵌套结果查询时，配置 id 标签可以提高处理效率。</p><p>在嵌套结果配置 id 属性时，如果查询语句中没有查询 id 属性配置的列，会导致 id 对应的值未 null，所有值 id 都相同，会使嵌套集合中只有一条数据。所以查询语句中必须包含该列。</p><p>如果将 id 标签改为 result，MyBatis 会对所有字段进行比较，当字段数为 M，查询结果为 N 条时，需要进行 M*N 次比较。</p><p>如果要配置一个相当复杂的映射，一定要从基础映射开始配置，每增加一些配置就进行对应的测试，在循序渐进的过程中更容易发现和解决问题。</p><h3 id="collection-集合的嵌套查询"><a href="#collection-集合的嵌套查询" class="headerlink" title="collection 集合的嵌套查询"></a>collection 集合的嵌套查询</h3><p>和 association 相似</p><p>有一个新的 <code>ofType</code> 属性。这个属性非常重要，它用来将 JavaBean（或字段）属性的类型和集合存储的类型区分开来。</p><pre><code class="xml">&lt;!-- PrivilegeMapper.xml --&gt;&lt;resultMap id=&quot;privilegeMap&quot; type=&quot;tk.mybatis.simple.model.SysPrivilege&quot;&gt;    &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;    &lt;result property=&quot;privilegeName&quot; column=&quot;privilege_name&quot;/&gt;    &lt;result property=&quot;privilegeUrl&quot; column=&quot;privilege_url&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;selectPrivilegeByRoleId&quot; resultMap=&quot;privilegeMap&quot;&gt;    select p.*    from sys_privilege p    inner join sys_role_privilege rp on rp.privilege_id = p.id    where role_id = #{roleId}&lt;/select&gt;</code></pre><pre><code class="xml">&lt;!-- RoleMapper.xml collection 中的 javaType 和 ofType 可以省略--&gt;&lt;resultMap id=&quot;rolePrivilegeListMapSelect&quot; extends=&quot;roleMap&quot; type=&quot;tk.mybatis.simple.model.SysRole&quot;&gt;    &lt;collection property=&quot;privilegeList&quot;                fetchType=&quot;lazy&quot;                ofType=&quot;tk.mybatis.simple.model.SysPrivilege&quot;                javaType=&quot;ArrayList&quot;                select=&quot;tk.mybatis.simple.mapper.PrivilegeMapper.selectPrivilegeByRoleId&quot;                column=&quot;{roleId=id}&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;selectRoleByUserId&quot; resultMap=&quot;rolePrivilegeListMapSelect&quot;&gt;    select        r.id, r.role_name, r.enabled,        r.create_by, r.create_time    from sys_role r    inner join sys_user_role ur on ur.role_id = r.id    where ur.user_id = #{userId}&lt;/select&gt;</code></pre><pre><code class="xml">&lt;!-- UserMapper.xml --&gt;&lt;resultMap id=&quot;userRoleListMapSelect&quot; extends=&quot;userMap&quot; type=&quot;tk.mybatis.simple.model.SysUser&quot;&gt;    &lt;collection property=&quot;roleList&quot;                fetchType=&quot;lazy&quot;                ofType=&quot;tk.mybatis.simple.model.SysRole&quot;                select=&quot;tk.mybatis.simple.mapper.RoleMapper.selectRoleByUserId&quot;                column=&quot;{userId=id}&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;selectAllUserAndRolesSelect&quot; resultMap=&quot;userRoleListMapSelect&quot;&gt;    select        u.id, u.user_name, u.user_password,        u.user_email, u.user_info,        u.head_img, u.create_time    from sys_user u    where u.id = #{id}&lt;/select&gt;</code></pre><h2 id="鉴别器映射"><a href="#鉴别器映射" class="headerlink" title="鉴别器映射"></a>鉴别器映射</h2><p>鉴别器很像 Java 中的 switch 语句</p><p>discriminator 标签常用的两个属性：</p><ul><li>column：该属性用于设置要进行鉴别比较值的列</li><li>javaType：该属性用于指定列的类型，保证使用相同的 Java 类型来比较值。</li></ul><p>discriminator 标签可以有 1 个或者多个 case 标签，case 标签包含以下三个属性：</p><ul><li>value：该值未 discriminator 指定 column 用来匹配的值。</li><li>resultMap：当 column 的值和 value 的值匹配时，可以配置使用 resultMap 指定的映射，resultMap 优先级 高于 resultType。</li><li>resultType：当 column 的值和 value 的值匹配时，用于配置使用 resultType 指定的映射。</li></ul><pre><code class="xml">&lt;resultMap id=&quot;rolePrivilegeListMapChoose&quot; type=&quot;tk.mybatis.simple.model.SysRole&quot;&gt;    &lt;discriminator column=&quot;enabled&quot; javaType=&quot;int&quot;&gt;        &lt;case value=&quot;1&quot; resultMap=&quot;rolePrivilegeListMapSelect&quot;/&gt;        &lt;case value=&quot;0&quot; resultMap=&quot;roleMap&quot;/&gt;    &lt;/discriminator&gt;&lt;/resultMap&gt;</code></pre><p>角色的属性 enable 值为 1 的时候表示状态可用，为 0 不可用。当不可用时，只能获取角色的基本信息，不能获得角色的权限信息。</p><pre><code class="xml">&lt;select id=&quot;selectRoleByUserIdChoose&quot; resultMap=&quot;rolePrivilegeListMapChoose&quot;&gt;    select        r.id, r.role_name, r.enabled,        r.create_by, r.create_time    from sys_role r    inner join sys_user_role ur on ur.role_id = r.id    where ur.user_id = #{userId}&lt;/select&gt;</code></pre><p>鉴别器特殊的地方</p><pre><code class="xml">&lt;resultMap id=&quot;rolePrivilegeListMapChoose&quot; type=&quot;tk.mybatis.simple.model.SysRole&quot;&gt;    &lt;discriminator column=&quot;enabled&quot; javaType=&quot;int&quot;&gt;        &lt;case value=&quot;1&quot; resultMap=&quot;rolePrivilegeListMapSelect&quot;/&gt;        &lt;case value=&quot;0&quot; resultType=&quot;SysRole&quot;&gt;            &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;            &lt;result property=&quot;roleName&quot; column=&quot;role_name&quot;/&gt;        &lt;/case&gt;    &lt;/discriminator&gt;&lt;/resultMap&gt;</code></pre><p>使用 resultType，并在 case 中配置了两个属性的映射，这时 MyBatis 只会对列举出来的配置进行映射，不像使用 resultMap 配置时会自动映射其他的字段。</p><p>鉴别器很少使用，尽可能避免使用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://www.broadview.com.cn/book/3643&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.broadview.com.cn/book/3643&lt;/a&gt;&lt;br&gt;
      
    
    </summary>
    
    
      <category term="Java" scheme="http://coolview.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="http://coolview.github.io/tags/Java/"/>
    
      <category term="MyBatis" scheme="http://coolview.github.io/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis 06-代码生成器</title>
    <link href="http://coolview.github.io/2019/11/17/MyBatis/MyBatis%2006-%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/"/>
    <id>http://coolview.github.io/2019/11/17/MyBatis/MyBatis%2006-%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/</id>
    <published>2019-11-17T07:11:16.000Z</published>
    <updated>2019-11-17T13:03:55.922Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="http://www.broadview.com.cn/book/3643" target="_blank" rel="noopener">http://www.broadview.com.cn/book/3643</a></p></blockquote><p>Mybatis Generator 文档：<a href="http://mybatis.org/generator/" target="_blank" rel="noopener">http://mybatis.org/generator/</a></p><p>这里只讨论 <code>MyBatis3Simple</code></p><h1 id="maven-配置"><a href="#maven-配置" class="headerlink" title="maven 配置"></a>maven 配置</h1><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt;    &lt;version&gt;1.3.3&lt;/version&gt;&lt;/dependency&gt;</code></pre><h1 id="generatorConfig-xml"><a href="#generatorConfig-xml" class="headerlink" title="generatorConfig.xml"></a>generatorConfig.xml</h1><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration        PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt;    &lt;!-- properties 标签用于指定一个需要在配置中解析使用的外部属性文件，之后可以在配置中使用 ${property} 的方式引用，最多配置一个，包含 resource 和 url 两个属性，    resource：指定 classpath 下的属性文件    url：指定文件系统上的特定位置 --&gt;    &lt;!-- &lt;properties resource=&quot;&quot;/&gt; --&gt;    &lt;!-- &lt;classPathEntry location=&quot;F:\.m2\repository\mysql\mysql-connector-java\5.1.38\mysql-connector-java-5.1.38.jar&quot;/&gt; --&gt;    &lt;!-- targetRuntime：MyBatis3Simple 不会生成与 Example 相关的方法；MyBatis3 默认值 --&gt;    &lt;!-- defaultModelType：为每一张表生成一个实体类，包含所有字段 --&gt;    &lt;context id=&quot;MySqlContext&quot; targetRuntime=&quot;MyBatis3Simple&quot; defaultModelType=&quot;flat&quot;&gt;        &lt;!-- 分隔符，MySQL ``，SQLServer []，postgresql &quot;&quot; --&gt;        &lt;!-- &lt;property name=&quot;autoDelimitKeywords&quot; value=&quot;true&quot; /&gt; --&gt;        &lt;property name=&quot;beginningDelimiter&quot; value=&quot;`&quot;/&gt;        &lt;property name=&quot;endingDelimiter&quot; value=&quot;`&quot;/&gt;        &lt;!-- Java 文件编码 --&gt;        &lt;property name=&quot;javaFileEncoding&quot; value=&quot;UTF-8&quot;/&gt;        &lt;commentGenerator&gt;  &lt;!-- 可以自定义实现注释形式， type=&quot;tk.mybatis.generator.MyCommentGenerator&quot; --&gt;            &lt;!-- suppressAllComments：是否阻止生成注释，默认 false --&gt;            &lt;property name=&quot;suppressDate&quot; value=&quot;true&quot;/&gt;  &lt;!-- 注释中是否不生成时间戳，默认 false --&gt;            &lt;property name=&quot;addRemarkComments&quot; value=&quot;true&quot;/&gt;  &lt;!-- 注释是否添加表的备注信息，默认 false --&gt;        &lt;/commentGenerator&gt;        &lt;jdbcConnection driverClass=&quot;com.mysql.cj.jdbc.Driver&quot;                        connectionURL=&quot;jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;amp;characterEncoding=utf8&amp;amp;useSSL=false&amp;amp;serverTimezone=GMT%2B8&quot;                        userId=&quot;root&quot;                        password=&quot;123456&quot;&gt;            &lt;!-- MySQL8 会把所有库中的表都生成出来，添加下面一行即可 http://mybatis.org/generator/usage/mysql.html --&gt;            &lt;property name=&quot;nullCatalogMeansCurrent&quot; value=&quot;true&quot;/&gt;            &lt;!-- Oracle 需添加如下配置，使能够获取到列的注释 --&gt;            &lt;!-- &lt;property name=&quot;remarksReporting&quot; value=&quot;true&quot;/&gt; --&gt;        &lt;/jdbcConnection&gt;        &lt;!-- targetPackage：生成实体类存放的包名             targetProject：指定目标项目路径 --&gt;        &lt;javaModelGenerator targetPackage=&quot;test.model&quot; targetProject=&quot;src\main\java&quot;&gt;            &lt;!-- 是否对数据库查询结果进行 trim 操作 --&gt;            &lt;property name=&quot;trimStrings&quot; value=&quot;false&quot; /&gt;            &lt;!-- 设置所有实体类的基类 --&gt;            &lt;!--&lt;property name=&quot;rootClass&quot; value=&quot;tk.mybatis.simple.model.BaseEntity&quot; /&gt;--&gt;        &lt;/javaModelGenerator&gt;        &lt;!-- 如果未指定该标签，则不生成 xml 的 SQL 映射文件             targetPackage：生成的 xml 文件存放的包名             targetProject：指定目标项目路径 --&gt;        &lt;sqlMapGenerator targetPackage=&quot;test.xml&quot;  targetProject=&quot;src\main\resources&quot;/&gt;        &lt;!-- XMLMAPPER：接口调用依赖 xml 文件 --&gt;        &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;test.dao&quot;  targetProject=&quot;src\main\java&quot;/&gt;        &lt;!-- % 表示全部，要指定多个，可以配置多个 table 标签 --&gt;        &lt;table tableName=&quot;%&quot;&gt;            &lt;!-- 指定自动生成主键的属性 --&gt;            &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;MySql&quot;/&gt;            &lt;!-- Oracle 配置如下 --&gt;            &lt;!-- &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;select SEQ_ID.nextval from dual&quot;/&gt; --&gt;        &lt;/table&gt;    &lt;/context&gt;&lt;/generatorConfiguration&gt;</code></pre><h1 id="自定义实现注释形式"><a href="#自定义实现注释形式" class="headerlink" title="自定义实现注释形式"></a>自定义实现注释形式</h1><pre><code class="java">/** * 自己实现的注释生成器 */public class MyCommentGenerator extends DefaultCommentGenerator {    /**     * 由于默认实现类中的可配参数都没有提供给子类可以访问的方法，这里要定义一遍     */    private boolean suppressAllComments;    private boolean addRemarkComments;    /**     * 设置用户配置的参数     */    @Override    public void addConfigurationProperties(Properties properties) {        // 先调用父类方法保证父类方法可以正常使用        super.addConfigurationProperties(properties);        // 获取 suppressAllComments 参数值        suppressAllComments = isTrue(properties.getProperty(PropertyRegistry.COMMENT_GENERATOR_SUPPRESS_ALL_COMMENTS));        // 获取 addRemarkComments 参数值        addRemarkComments = isTrue(properties.getProperty(PropertyRegistry.COMMENT_GENERATOR_ADD_REMARK_COMMENTS));    }    /**     * 给字段添加注释信息     */    @Override    public void addFieldComment(Field field, IntrospectedTable introspectedTable,            IntrospectedColumn introspectedColumn) {        // 如果阻止生成所有注释，直接返回        if (suppressAllComments) {            return;        }        // 文档注释开始        field.addJavaDocLine(&quot;/**&quot;);        // 获取数据库字段的备注信息        String remarks = introspectedColumn.getRemarks();        // 根据参数和备注信息判断是否添加备注信息        if (addRemarkComments &amp;&amp; StringUtility.stringHasValue(remarks)) {            String[] remarkLines = remarks.split(System.getProperty(&quot;line.separator&quot;));            for (String remarkLine : remarkLines) {                field.addJavaDocLine(&quot; * &quot; + remarkLine);            }        }        // 由于 Java 对象名和数据库字段名可能不一样，注释中保留数据库字段名        field.addJavaDocLine(&quot; * &quot; + introspectedColumn.getActualColumnName());        field.addJavaDocLine(&quot; */&quot;);    }}// 生成的代码中注释如下：/** * 用户名 * user_name */private String userName;</code></pre><h1 id="生成代码"><a href="#生成代码" class="headerlink" title="生成代码"></a>生成代码</h1><pre><code class="java">/** * 读取 MBG 配置生成代码 */public class Generator {    public static void main(String[] args) throws Exception {        // MBG 执行过程中的警告信息        List&lt;String&gt; warnings = new ArrayList&lt;String&gt;();        // 当生成的代码重复时，覆盖原代码        boolean overwrite = true;        // 读取我们的 MBG 配置文件        InputStream is = Generator.class.getResourceAsStream(&quot;/generator/generatorConfig.xml&quot;);        ConfigurationParser cp = new ConfigurationParser(warnings);        Configuration config = cp.parseConfiguration(is);        is.close();        DefaultShellCallback callback = new DefaultShellCallback(overwrite);        // 创建 MBG        MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings);        // 执行生成代码        myBatisGenerator.generate(null);        // 输出警告信息        for(String warning : warnings){            System.out.println(warning);        }    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://www.broadview.com.cn/book/3643&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.broadview.com.cn/book/3643&lt;/a&gt;&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="Java" scheme="http://coolview.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="http://coolview.github.io/tags/Java/"/>
    
      <category term="MyBatis" scheme="http://coolview.github.io/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>aiohttp 简单记录</title>
    <link href="http://coolview.github.io/2019/10/11/Python/aiohttp%20%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/"/>
    <id>http://coolview.github.io/2019/10/11/Python/aiohttp%20%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/</id>
    <published>2019-10-11T09:05:03.000Z</published>
    <updated>2019-10-11T09:27:15.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>aiohttp 中文文档：<a href="https://hubertroy.gitbooks.io/aiohttp-chinese-documentation/content/" target="_blank" rel="noopener">https://hubertroy.gitbooks.io/aiohttp-chinese-documentation/content/</a></p></blockquote><pre><code class="py">loop = asyncio.get_event_loop()app = web.Application()app[&#39;websockets&#39;] = []app.router.add_route(&#39;GET&#39;, &#39;/ws&#39;, websocket_handler)  # WebSockets 控制器app.router.add_route(&#39;POST&#39;, &#39;/sync&#39;, sync)app.router.add_route(&#39;POST&#39;, &#39;/subscribe&#39;, subscribe)  # 需要 POST 和 GET 方法，可以定义两个控制器app.router.add_route(&#39;GET&#39;, &#39;/subscribe&#39;, subscribe)srv = loop.create_server(app.make_handler(), &#39;&#39;, 8080)print(&quot;Server start at at 8080&quot;)loop.run_until_complete(srv)loop.run_forever()</code></pre><h1 id="使用-WebSockets"><a href="#使用-WebSockets" class="headerlink" title="使用 WebSockets"></a>使用 WebSockets</h1><pre><code class="py">async def websocket_handler(request):    ws = web.WebSocketResponse()    await ws.prepare(request)    SerialNo = request.query.get(&#39;SerialNo&#39;)  # 从 url 中获得参数    wsInfo = (ws, cameraid, cameraname)    request.app[&#39;websockets&#39;].append(wsInfo)  # 将连接信息存入 app[&#39;websockets&#39;]    try:        async for msg in ws:            if msg.type == WSMsgType.TEXT:                print(msg.data)                if msg.data == &#39;ping&#39;:                    await ws.send_bytes(&#39;pong&#39;.encode(&#39;utf-8&#39;))  # 向客户端发送数据             elif msg.type == WSMsgType.CLOSE:                await ws.close()                logging.warning(&#39;websocket connection closed, SerialNo: {}&#39;.format(SerialNo))    finally:        request.app[&#39;websockets&#39;].remove(wsInfo)    return ws</code></pre><p>从另一个线程中向客户端发送 <code>WebSocket</code> 数据，注意需要 <code>asyncio.new_event_loop()</code></p><blockquote><p><a href="https://stackoverflow.com/questions/46727787/runtimeerror-there-is-no-current-event-loop-in-thread-in-async-apscheduler/46750562#46750562" target="_blank" rel="noopener">https://stackoverflow.com/questions/46727787/runtimeerror-there-is-no-current-event-loop-in-thread-in-async-apscheduler/46750562#46750562</a></p></blockquote><pre><code class="py">async def employeeSync(ws, cameraid):    await ws.send_bytes(&#39;pong&#39;.encode(&#39;utf-8&#39;))class employeeSyncThread (threading.Thread):    def __init__(self):        threading.Thread.__init__(self)    def run(self):        syncList = []        for webs in app[&#39;websockets&#39;]:            ws, cameraid, cameraname = webs            syncList.append(employeeSync(ws, cameraid))        if syncList:            syncLoop = asyncio.new_event_loop()            asyncio.set_event_loop(syncLoop)            # syncLoop = asyncio.get_event_loop()            syncRes = syncLoop.run_until_complete(asyncio.wait(syncList))            syncLoop.close()</code></pre><h1 id="http-控制器"><a href="#http-控制器" class="headerlink" title="http 控制器"></a>http 控制器</h1><pre><code class="py">async def subscribe(request):    if request.method == &#39;POST&#39;:  # 判断请求方法        data = await request.post()  # 接收表单提交数据        data = await request.json()  # 接收 json 数据        syntype = data.get(&quot;syntype&quot;)        SerialNo = request.query[&#39;SerialNo&#39;]  # url 参数，?SerialNo=111    return web.json_response({&#39;msg&#39;: &#39;ok&#39;})  # 返回 json    text = &#39;测试&#39;    return web.Response(text=text)  # 返回文本</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;aiohttp 中文文档：&lt;a href=&quot;https://hubertroy.gitbooks.io/aiohttp-chinese-documentation/content/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;h
      
    
    </summary>
    
    
      <category term="Python" scheme="http://coolview.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="http://coolview.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 记录</title>
    <link href="http://coolview.github.io/2019/10/11/Nginx%20%E8%AE%B0%E5%BD%95/"/>
    <id>http://coolview.github.io/2019/10/11/Nginx%20%E8%AE%B0%E5%BD%95/</id>
    <published>2019-10-11T07:46:01.000Z</published>
    <updated>2019-10-11T07:50:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Nginx-WebSocket-配置"><a href="#Nginx-WebSocket-配置" class="headerlink" title="Nginx WebSocket 配置"></a>Nginx WebSocket 配置</h1><pre><code class="conf">location /ws {    proxy_pass http://127.0.0.1:7270;  // 代理转发地址    proxy_http_version 1.1;  // 使用http版本为1.1    proxy_set_header   Host             $host:$server_port;    proxy_set_header   X-Real-IP        $remote_addr;    proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;    proxy_read_timeout 120s;  // 超时设置，如果 120 秒内没有通讯，会断开    // 启用支持websocket连接    proxy_set_header Upgrade $http_upgrade;    proxy_set_header Connection &quot;upgrade&quot;;}</code></pre><blockquote><p><a href="https://www.cnblogs.com/kevingrace/p/9512287.html" target="_blank" rel="noopener">https://www.cnblogs.com/kevingrace/p/9512287.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Nginx-WebSocket-配置&quot;&gt;&lt;a href=&quot;#Nginx-WebSocket-配置&quot; class=&quot;headerlink&quot; title=&quot;Nginx WebSocket 配置&quot;&gt;&lt;/a&gt;Nginx WebSocket 配置&lt;/h1&gt;&lt;pre&gt;&lt;cod
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://coolview.github.io/categories/Linux/"/>
    
    
      <category term="Nginx" scheme="http://coolview.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis 05-动态 SQL</title>
    <link href="http://coolview.github.io/2019/10/09/MyBatis/MyBatis%2005-%E5%8A%A8%E6%80%81%20SQL/"/>
    <id>http://coolview.github.io/2019/10/09/MyBatis/MyBatis%2005-%E5%8A%A8%E6%80%81%20SQL/</id>
    <published>2019-10-09T13:19:25.000Z</published>
    <updated>2019-10-11T11:12:27.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="http://www.broadview.com.cn/book/3643" target="_blank" rel="noopener">http://www.broadview.com.cn/book/3643</a><br><a href="https://mybatis.org/mybatis-3/zh/dynamic-sql.html" target="_blank" rel="noopener">https://mybatis.org/mybatis-3/zh/dynamic-sql.html</a></p></blockquote><h1 id="if"><a href="#if" class="headerlink" title="if"></a>if</h1><pre><code class="xml">&lt;if test=&quot;title != null and title != &#39;&#39;&quot;&gt;    AND title like #{title}&lt;/if&gt;</code></pre><p><code>test</code> 属性值是一个符合 <code>OGNL</code> 要求的判断表达式，表达式的结果可以是 <code>true</code> 或 <code>false</code>，所有非 0 的值都为 true，只有 0 为 false。</p><ul><li>判断条件 <code>property != null</code> 或 <code>property == null</code>，适用于任何类型的字段，用于判断属性值是否为空。</li><li>判断条件 <code>property != &#39;&#39;</code> 或 <code>property == &#39;&#39;</code>，仅适用于 <code>String</code> 类型。</li><li><code>and</code> 和 <code>or</code>，嵌套的判断可以使用小括号分组。</li></ul><h1 id="choose-when-otherwise"><a href="#choose-when-otherwise" class="headerlink" title="choose, when, otherwise"></a>choose, when, otherwise</h1><p>有点像 Java 中的 switch 语句。</p><p>如果提供了 title 就按 title 查找，提供了 author 就按 author 查找的情形，若两者都没有提供，就返回 featured=1 的。</p><pre><code class="xml">&lt;select id=&quot;findActiveBlogLike&quot; resultType=&quot;Blog&quot;&gt;    SELECT * FROM BLOG WHERE state = &#39;ACTIVE&#39;    &lt;choose&gt;        &lt;when test=&quot;title != null&quot;&gt;            AND title like #{title}        &lt;/when&gt;        &lt;when test=&quot;author != null and author.name != null&quot;&gt;            AND author_name like #{author.name}        &lt;/when&gt;        &lt;otherwise&gt;            AND featured = 1        &lt;/otherwise&gt;    &lt;/choose&gt;&lt;/select&gt;</code></pre><h1 id="trim-where-set"><a href="#trim-where-set" class="headerlink" title="trim, where, set"></a>trim, where, set</h1><p><code>where</code> 元素只会在至少有一个子元素的条件返回 SQL 子句的情况下才去插入 <code>WHERE</code> 子句。而且，若语句的开头为 AND 或 OR ，<code>where</code> 元素也会将它们去除。</p><p>我们可以通过自定义 <code>trim</code> 元素来定制 <code>where</code> 元素的功能。比如，和 <code>where</code> 元素等价的自定义 <code>trim</code> 元素为：</p><pre><code class="xml">&lt;!-- 这里的 AND 和 OR 后面的空格不能省略 --&gt;&lt;trim prefix=&quot;WHERE&quot; prefixOverrides=&quot;AND |OR &quot;&gt;    ...&lt;/trim&gt;</code></pre><p><code>set</code> 元素会动态前置 <code>SET</code> 关键字，同时也会删掉无关的逗号，因为用了条件语句之后很可能就会在生成的 SQL 语句的后面留下这些逗号。</p><p>set 元素等价的自定义 trim 元素：</p><pre><code class="xml">&lt;trim prefix=&quot;SET&quot; suffixOverrides=&quot;,&quot;&gt;  ...&lt;/trim&gt;</code></pre><p><code>trim</code> 标签有如下属性：</p><ul><li><code>prefix</code>：当 trim 元素内包含内容时，会给内容增加 <code>prefix</code> 指定的前缀。</li><li><code>prefixOverrides</code>：当 trim 元素内包含内容时，会把内容中匹配的前缀字符串去掉。</li><li><code>suffix</code>：当 trim 元素内包含内容时，会给内容增加 <code>suffix</code> 指定的后缀。</li><li><code>suffixOverrides</code>：当 trim 元素内包含内容时，会把内容中匹配的后缀字符串去掉。</li></ul><h1 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h1><pre><code class="xml">&lt;foreach item=&quot;item&quot; index=&quot;index&quot; collection=&quot;list&quot;    open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt;        #{item}&lt;/foreach&gt;</code></pre><p>foreach 包含以下属性：</p><ul><li><code>collection</code>：必填，为要迭代循环的属性名。</li><li><code>item</code>：变量名，为从迭代对象中取出的每一个值。</li><li><code>index</code>：索引的属性名，在集合数组情况下值为当前索引值，Map 类型时为 Map 的 key。</li><li><code>open</code>：整个循环内容开头的字符串。</li><li><code>close</code>：整个循环内容结尾的字符串。</li><li><code>separator</code>：每次循环的分隔符。</li></ul><p><strong>批量新增并回写主键值</strong>，3.3.1 版本开始，只支持 MySQL。</p><pre><code class="xml">&lt;insert id=&quot;insertList&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;    insert into sys user(        user_name, user_password, user_email,        user_info , head_img , create_time)    values    &lt;foreach collection=&quot;list&quot; item=&quot;user&quot; separator=&quot;,&quot;&gt;        (        #{user.userName}, #{user.userPassword}, #{user.userEmail},        #{user.userlnfo}, #{user.headlmg, jdbcType=BLOB},        #{user.createTime, jdbcType=TIMESTAMP})    &lt;/foreach&gt;&lt;/insert&gt;</code></pre><h1 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h1><p><code>bind</code> 元素可以从 <code>OGNL</code> 表达式中创建一个变量并将其绑定到上下文。比如：</p><pre><code class="xml">&lt;select id=&quot;selectBlogsLike&quot; resultType=&quot;Blog&quot;&gt;    &lt;bind name=&quot;pattern&quot; value=&quot;&#39;%&#39; + _parameter.getTitle() + &#39;%&#39;&quot; /&gt;    SELECT * FROM BLOG    WHERE title LIKE #{pattern}&lt;/select&gt;</code></pre><h1 id="多数据库支持"><a href="#多数据库支持" class="headerlink" title="多数据库支持"></a>多数据库支持</h1><p>一个配置了 <code>_databaseId</code> 变量的 <code>databaseIdProvider</code> 可用于动态代码中，这样就可以根据不同的数据库厂商构建特定的语句。比如下面的例子：</p><pre><code class="xml">&lt;insert id=&quot;insert&quot;&gt;    &lt;selectKey keyProperty=&quot;id&quot; resultType=&quot;int&quot; order=&quot;BEFORE&quot;&gt;        &lt;if test=&quot;_databaseId == &#39;oracle&#39;&quot;&gt;            select seq_users.nextval from dual        &lt;/if&gt;        &lt;if test=&quot;_databaseId == &#39;db2&#39;&quot;&gt;            select nextval for seq_users from sysibm.sysdummy1&quot;        &lt;/if&gt;    &lt;/selectKey&gt;    insert into users values (#{id}, #{name})&lt;/insert&gt;</code></pre><h1 id="OGNL"><a href="#OGNL" class="headerlink" title="OGNL"></a>OGNL</h1><p>MyBatis 的动态 SQL 和 <code>${}</code> 形式的参数中都用到了 OGNL 表达式，常用的表达式如下：</p><ol><li>e1 or e2</li><li>e1 and e2</li><li>e1 == e2 或 e1 eq e2</li><li>e1 != e2 或 e1 neq e2</li><li>e1 lt e2：小于</li><li>e1 lte e2：小于等于，gt（大于），gte（大于等于）</li><li>e1 + e2：+-*/%</li><li>!e 或 not e：非、取反</li><li><code>e.method(args)</code>：调用对象方法，<code>list.size() &gt; 0</code></li><li><code>e.property</code>：对象属性值</li><li><code>e1[e2]</code>：按索引取值（List、数组和 Map）</li><li><code>@class@method(args)</code>：调用类的静态方法</li><li><code>@class@field</code>：调用类的静态字段值</li></ol><p>表达式 12 通常用于简化一些校验，如：</p><pre><code class="xml">&lt;if test=&quot;@tk.mybatis.util.StringUtil@isNotEmpty(userName)&quot;&gt;    and user_name like concat(&#39;%&#39;, #{userName}, &#39;%&#39;)&lt;/if&gt;</code></pre><p>StringUtil 类如下：</p><pre><code class="java">public class StringUtil {    public static boolean isEmpty(String str) {        return str == null || str.length() == 0;    }    public static boolean isNotEmpty(String str) {        return !isEmpty(str);    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://www.broadview.com.cn/book/3643&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.broadview.com.cn/book/3643&lt;/a&gt;&lt;br&gt;
      
    
    </summary>
    
    
      <category term="Java" scheme="http://coolview.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="http://coolview.github.io/tags/Java/"/>
    
      <category term="MyBatis" scheme="http://coolview.github.io/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis 04-注解方式的基本用法</title>
    <link href="http://coolview.github.io/2019/09/21/MyBatis/MyBatis%2004-%E6%B3%A8%E8%A7%A3%E6%96%B9%E5%BC%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/"/>
    <id>http://coolview.github.io/2019/09/21/MyBatis/MyBatis%2004-%E6%B3%A8%E8%A7%A3%E6%96%B9%E5%BC%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</id>
    <published>2019-09-21T09:04:10.000Z</published>
    <updated>2019-10-09T13:19:02.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="http://www.broadview.com.cn/book/3643" target="_blank" rel="noopener">http://www.broadview.com.cn/book/3643</a></p></blockquote><p>MyBatis 注解方式就是将 SQL 语句直接写在接口上。优点：对于简单的系统，效率高。缺点：当 SQL 有变化时需重新编译代码。一般不建议使用注解方式。</p><h1 id="Select-注解"><a href="#Select-注解" class="headerlink" title="@Select 注解"></a>@Select 注解</h1><pre><code class="java">@Select({&quot;select id,role_name roleName, enabled, create_by createBy, create_time createTime&quot;,            &quot;from sys_role&quot;,            &quot;where id = #{id}&quot;})SysRole selectById(Long id);</code></pre><h2 id="实现字段映射，使用-resultMap-方式"><a href="#实现字段映射，使用-resultMap-方式" class="headerlink" title="实现字段映射，使用 resultMap 方式"></a>实现字段映射，使用 resultMap 方式</h2><p>可以在配置文件中 <code>&lt;settings&gt;</code> 标签中设置 <code>mapUnderscoreToCamelCase</code> 为 true。MyBatis 会按照“下划线转驼峰”的方式自动映射。</p><p>XML 中的 <code>resultMap</code> 元素对应的 Java 注解 <code>@Results</code></p><pre><code class="java">// 3.3.1 版本，增加了 id 属性，可以通过 id 属性引用同一个 @Results 配置@Results(id = &quot;roleResultMap&quot;, value = {    @Result(property = &quot;id&quot;, column = &quot;id&quot;, id = true),    @Result(property = &quot;roleName&quot;, column = &quot;role_name&quot;),    @Result(property = &quot;enabled&quot;, column = &quot;enabled&quot;),    @Result(property = &quot;createBy&quot;, column = &quot;create_by&quot;),    @Result(property = &quot;createTime&quot;, column = &quot;create_time&quot;)})@Select(&quot;select id,role_name, enabled, create_by, create_time from sys_role where id = #{id}&quot;)SysRole selectById2(Long id);@ResultMap(&quot;roleResultMap&quot;)@Select(&quot;select * from sys_role&quot;)List&lt;SysRole&gt; selectAll();</code></pre><h1 id="Insert-注解"><a href="#Insert-注解" class="headerlink" title="@Insert 注解"></a>@Insert 注解</h1><h2 id="返回自增主键"><a href="#返回自增主键" class="headerlink" title="返回自增主键"></a>返回自增主键</h2><pre><code class="java">@Insert({&quot;insert into sys_role(role_name, enabled, create_by, create_time)&quot;,            &quot;values(#{roleName}, #{enabled}, #{createBy}, #{createTime, jdbcType=TIMESTAMP})&quot;})@Options(useGeneratedKeys = true, keyProperty = &quot;id&quot;)int insert2(SysRole sysRole);</code></pre><h2 id="返回非自增主键"><a href="#返回非自增主键" class="headerlink" title="返回非自增主键"></a>返回非自增主键</h2><pre><code class="java">@Insert({&quot;insert into sys_role(role_name, enabled, create_by, create_time)&quot;,             &quot;values(#{roleName}, #{enabled}, #{createBy}, #{createTime, jdbcType=TIMESTAMP})&quot;})@SelectKey(statement = &quot;SELECT LAST_INSERT_ID()&quot;, keyProperty = &quot;id&quot;, resultType = Long.class, before = false)int insert3(SysRole sysRole);</code></pre><p>使用了 <code>@SelectKey</code> 主键，如果是 XML 中配置的 selectKey</p><pre><code class="xml">&lt;selectKey keyColumn=&quot;id&quot; resultType=&quot;long&quot; keyProperty=&quot;id&quot; order=&quot;AFTER&quot;&gt;    SELECT LAST_INSERT_ID {)&lt;/selectKey&gt;</code></pre><p>before 为 false 时，等同于 <code>order=&quot;AFTER&quot;</code>，before 为 true 时，等同于 <code>order=&quot;BEFORE&quot;</code>，</p><h1 id="Update-和-Delete"><a href="#Update-和-Delete" class="headerlink" title="@Update 和 @Delete"></a>@Update 和 @Delete</h1><h1 id="Provider-注解"><a href="#Provider-注解" class="headerlink" title="Provider 注解"></a>Provider 注解</h1><p>MyBatis 提供了 4 中 Provider 注解，分别是 @SelectProvider、@InsertProvider、@UpdateProvider 和 @DeleteProvider。</p><p>创建 PrivilegeMapper 接口：</p><pre><code class="java">public interface PrivilegeMapper {    // method=&quot;selectById&quot; 方法的参数应该和这个方法一样    @SelectProvider(type=PrivilegeProvider.class, method=&quot;selectById&quot;)    SysPrivilege selectById(Long id);}</code></pre><p>PrivilegeProvider 类：</p><pre><code class="java">public class PrivilegeProvider {    // 必须要有空的构造方法    public String selectById(final Long id){        // 可以直接返回 SQL 字符串        return new SQL(){            {                SELECT(&quot;id, privilege_name, privilege_url&quot;);                FROM(&quot;sys_privilege&quot;);                WHERE(&quot;id = #{id}&quot;);            }        }.toString();    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://www.broadview.com.cn/book/3643&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.broadview.com.cn/book/3643&lt;/a&gt;&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="Java" scheme="http://coolview.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="http://coolview.github.io/tags/Java/"/>
    
      <category term="MyBatis" scheme="http://coolview.github.io/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis 03-XML 映射文件</title>
    <link href="http://coolview.github.io/2019/09/21/MyBatis/MyBatis%2003-XML%20%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6/"/>
    <id>http://coolview.github.io/2019/09/21/MyBatis/MyBatis%2003-XML%20%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6/</id>
    <published>2019-09-21T06:32:21.000Z</published>
    <updated>2019-10-09T13:19:09.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://mybatis.org/mybatis-3/zh/sqlmap-xml.html" target="_blank" rel="noopener">https://mybatis.org/mybatis-3/zh/sqlmap-xml.html</a><br><a href="http://www.broadview.com.cn/book/3643" target="_blank" rel="noopener">http://www.broadview.com.cn/book/3643</a></p></blockquote><p>SQL 映射文件只有很少的几个顶级元素（按照应被定义的顺序列出）：</p><ul><li><code>cache</code> – 对给定命名空间的缓存配置。</li><li><code>cache-ref</code> – 对其他命名空间缓存配置的引用。</li><li><code>resultMap</code> – 是最复杂也是最强大的元素，用来描述如何从数据库结果集中来加载对象。</li><li><code>sql</code> – 可被其他语句引用的可重用语句块。</li><li><code>insert</code> – 映射插入语句</li><li><code>update</code> – 映射更新语句</li><li><code>delete</code> – 映射删除语句</li><li><code>select</code> – 映射查询语句</li></ul><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.bin.mapper.CountryMapper&quot;&gt;&lt;/mapper&gt;</code></pre><p><strong>命名空间</strong>的作用有两个，一个是利用更长的完全限定名来将不同的语句隔离开来，同时也实现了你上面见到的接口绑定。就算你觉得暂时用不到接口绑定，你也应该遵循这里的规定，以防哪天你改变了主意。 长远来看，只要将命名空间置于合适的 Java 包命名空间之中，你的代码会变得更加整洁，也有利于你更方便地使用 MyBatis。</p><h1 id="select"><a href="#select" class="headerlink" title="select"></a>select</h1><p>简单查询的 select 元素是非常简单的。比如：</p><pre><code class="xml">&lt;select id=&quot;selectPerson&quot; parameterType=&quot;int&quot; resultType=&quot;hashmap&quot;&gt;    SELECT * FROM PERSON WHERE ID = #{id}&lt;/select&gt;</code></pre><p>这个语句被称作 selectPerson，接受一个 int（或 Integer）类型的参数，并返回一个 HashMap 类型的对象，其中的键是列名，值便是结果行中的对应值。</p><p>如果查询一个 country 下的所有 user，resultType 的类型必须包含 country 和 user 的全部属性。这样不利于扩展，所以可以在 country 中加入 user 属性：<code>private SysUser user; private Integer userid;</code></p><pre><code class="xml">&lt;select id=&quot;selectPerson2&quot; parameterType=&quot;int&quot; resultType=&quot;country&quot;&gt;    select u.id, c.countryname, c.countrycode, u.username as &quot;user.userName&quot;    from sys_user u left join country c on u.id=c.userid    WHERE u.id = #{id}&lt;/select&gt;</code></pre><p>这里设置别名的时候，使用的是 “user.属性名”，可以通过这种方式直接赋值给 country 中的 user 字段的属性。</p><p>select 元素允许你配置很多属性来配置每条语句的作用细节。</p><pre><code class="xml">&lt;select    id=&quot;selectPerson&quot;    parameterType=&quot;int&quot;    parameterMap=&quot;deprecated&quot;    resultType=&quot;hashmap&quot;    resultMap=&quot;personResultMap&quot;    flushCache=&quot;false&quot;    useCache=&quot;true&quot;    timeout=&quot;10&quot;    fetchSize=&quot;256&quot;    statementType=&quot;PREPARED&quot;    resultSetType=&quot;FORWARD_ONLY&quot;&gt;</code></pre><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td><code>id</code></td><td>在命名空间中唯一的标识符，可以被用来引用这条语句。</td></tr><tr><td><code>parameterType</code></td><td>将会传入这条语句的参数类的完全限定名或别名。这个属性是可选的，因为 MyBatis 可以通过类型处理器（TypeHandler） 推断出具体传入语句的参数，默认值为未设置（unset）。</td></tr><tr><td><code>resultType</code></td><td>从这条语句中返回的期望类型的类的完全限定名或别名。 注意如果返回的是集合，那应该设置为集合包含的类型，而不是集合本身。可以使用 resultType 或 resultMap，但不能同时使用。</td></tr><tr><td><code>resultMap</code></td><td>外部 resultMap 的命名引用。结果集的映射是 MyBatis 最强大的特性，如果你对其理解透彻，许多复杂映射的情形都能迎刃而解。可以使用 resultMap 或 resultType，但不能同时使用。</td></tr><tr><td><code>flushCache</code></td><td>将其设置为 true 后，只要语句被调用，都会导致本地缓存和二级缓存被清空，默认值：对 select 元素为 false，对于 insert、update 和 delete 语句为 true。</td></tr><tr><td><code>useCache</code></td><td>将其设置为 true 后，将会导致本条语句的结果被二级缓存缓存起来，默认值：对 select 元素为 true。</td></tr><tr><td><code>timeout</code></td><td>这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为未设置（unset）（依赖驱动）。</td></tr><tr><td><code>fetchSize</code></td><td>这是一个给驱动的提示，尝试让驱动程序每次批量返回的结果行数和这个设置值相等。 默认值为未设置（unset）（依赖驱动）。</td></tr><tr><td><code>statementType</code></td><td>STATEMENT，PREPARED 或 CALLABLE 中的一个。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。</td></tr><tr><td><code>resultSetType</code></td><td>FORWARD_ONLY，SCROLL_SENSITIVE, SCROLL_INSENSITIVE 或 DEFAULT（等价于 unset） 中的一个，默认值为 unset （依赖驱动）。</td></tr><tr><td><code>databaseId</code></td><td>如果配置了数据库厂商标识（databaseIdProvider），MyBatis 会加载所有的不带 databaseId 或匹配当前 databaseId 的语句；如果带或者不带的语句都有，则不带的会被忽略。</td></tr><tr><td><code>resultOrdered</code></td><td>这个设置仅针对嵌套结果 select 语句适用：如果为 true，就是假设包含了嵌套结果集或是分组，这样的话当返回一个主结果行的时候，就不会发生有对前面结果集的引用的情况。 这就使得在获取嵌套的结果集的时候不至于导致内存不够用。默认值：false。</td></tr><tr><td><code>resultSets</code></td><td>这个设置仅对多结果集的情况适用。它将列出语句执行后返回的结果集并给每个结果集一个名称，名称是逗号分隔的。</td></tr></tbody></table><h2 id="多个接口参数的用法"><a href="#多个接口参数的用法" class="headerlink" title="多个接口参数的用法"></a>多个接口参数的用法</h2><ul><li>将多个参数合并到一个 JavaBean 中</li><li>使用 Map 类型</li><li>使用 <code>@Param</code> 注解</li></ul><pre><code class="java">List&lt;SysRole&gt; selectUserAndEnabled(@Param(&quot;userId&quot;)Long userid , @Param(&quot;enabled&quot;)Integer enabled);</code></pre><pre><code class="xml">&lt;select id=&quot;selectUserAndEnabled&quot; resultType =&quot;SysUser&quot;&gt;    select * from sys_user where id = #{userld) and enabled = #{enabled)&lt;/select&gt;</code></pre><p>当只有一个参数时，MyBatis 会不关心参数叫什么名字就直接把这个唯一的参数值拿来使用。</p><pre><code class="java">// @Param 注解，可以将方法的参数换成 JavaBean 类型List&lt;SysRole&gt; selectRolesByUserAndRole(@Param(&quot;user&quot;) SysUser user, @Param(&quot;role&quot;) SysRole role);// 这时，XML 中需要通过点取值方式，#{user.id}</code></pre><h1 id="insert-update-和-delete"><a href="#insert-update-和-delete" class="headerlink" title="insert, update 和 delete"></a>insert, update 和 delete</h1><pre><code class="xml">&lt;insert    id=&quot;insertAuthor&quot;    parameterType=&quot;domain.blog.Author&quot;    flushCache=&quot;true&quot;    statementType=&quot;PREPARED&quot;    keyProperty=&quot;&quot;    keyColumn=&quot;&quot;    useGeneratedKeys=&quot;&quot;    timeout=&quot;20&quot;&gt;&lt;update    id=&quot;updateAuthor&quot;    parameterType=&quot;domain.blog.Author&quot;    flushCache=&quot;true&quot;    statementType=&quot;PREPARED&quot;    timeout=&quot;20&quot;&gt;&lt;delete    id=&quot;deleteAuthor&quot;    parameterType=&quot;domain.blog.Author&quot;    flushCache=&quot;true&quot;    statementType=&quot;PREPARED&quot;    timeout=&quot;20&quot;&gt;</code></pre><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td><code>useGeneratedKeys</code></td><td>（仅对 insert 和 update 有用）这会令 MyBatis 使用 JDBC 的 getGeneratedKeys 方法来取出由数据库内部生成的主键（比如：像 MySQL 和 SQL Server 这样的关系数据库管理系统的自动递增字段），默认值：false。</td></tr><tr><td><code>keyProperty</code></td><td>（仅对 insert 和 update 有用）唯一标记一个属性，MyBatis 会通过 getGeneratedKeys 的返回值或者通过 insert 语句的 selectKey 子元素设置它的键值，默认值：未设置（unset）。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。</td></tr><tr><td><code>keyColumn</code></td><td>（仅对 insert 和 update 有用）通过生成的键值设置表中的列名，这个设置仅在某些数据库（像 PostgreSQL）是必须的，当主键列不是表中的第一列的时候需要设置。如果希望使用多个生成的列，也可以设置为逗号分隔的属性名称列表。</td></tr></tbody></table><pre><code class="xml">&lt;!-- MySQL --&gt;&lt;insert id=&quot;addShop&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot; &gt;    INSERT INTO t_shop(shopname) VALUES(#{shopname})&lt;/insert&gt;&lt;!-- 批量 --&gt;&lt;insert id=&quot;addShops&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;    insert into t_shop (shopname) values    &lt;foreach item=&quot;item&quot; collection=&quot;list&quot; separator=&quot;,&quot;&gt;        (#{item.shopname})    &lt;/foreach&gt;&lt;/insert&gt;</code></pre><h2 id="selectKey"><a href="#selectKey" class="headerlink" title="selectKey"></a>selectKey</h2><p>selectKey 元素描述如下：</p><pre><code class="xml">&lt;selectKey    keyProperty=&quot;id&quot;    resultType=&quot;int&quot;    order=&quot;BEFORE&quot;    statementType=&quot;PREPARED&quot;&gt;</code></pre><p>selectKey 元素的属性</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>keyProperty</td><td>selectKey 语句结果应该被设置的目标属性。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。</td></tr><tr><td>keyColumn</td><td>匹配属性的返回结果集中的列名称。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。</td></tr><tr><td>resultType</td><td>结果的类型。MyBatis 通常可以推断出来，但是为了更加精确，写上也不会有什么问题。MyBatis 允许将任何简单类型用作主键的类型，包括字符串。如果希望作用于多个生成的列，则可以使用一个包含期望属性的 Object 或一个 Map。</td></tr><tr><td>order</td><td>这可以被设置为 BEFORE 或 AFTER。如果设置为 BEFORE，那么它会首先生成主键，设置 keyProperty 然后执行插入语句。如果设置为 AFTER，那么先执行插入语句，然后是 selectKey 中的语句 - 这和 Oracle 数据库的行为相似，在插入语句内部可能有嵌入索引调用。</td></tr><tr><td>statementType</td><td>与前面相同，MyBatis 支持 STATEMENT，PREPARED 和 CALLABLE 语句的映射类型，分别代表 PreparedStatement 和 CallableStatement 类型。</td></tr></tbody></table><pre><code class="xml">&lt;!-- MySQL --&gt;&lt;insert id=&quot;addShop&quot;&gt;    INSERT INTO t_shop(shopname) VALUES(#{shopname})    &lt;selectKey keyColumn=&quot;id&quot; resultType=&quot;long&quot; keyProperty=&quot;id&quot; order=&quot;AFTER&quot;&gt;        SELECT LAST_INSERT_ID()    &lt;/selectKey&gt;&lt;/insert&gt;&lt;!-- Oracle --&gt;&lt;insert id=&quot;insert&quot; &gt;    &lt;selectKey resultType=&quot;int&quot; keyProperty=&quot;id&quot; order=&quot;BEFORE&quot;&gt;        &lt;![CDATA[SELECT T_SHOP_SEQ.NEXTVAL FROM DUAL]]&gt;    &lt;/selectKey&gt;    insert into T_SHOP (id, shopname) values (#{id}, #{shopname})&lt;/insert&gt;</code></pre><h1 id="sql"><a href="#sql" class="headerlink" title="sql"></a>sql</h1><p>这个元素可以被用来定义<strong>可重用的 SQL 代码段</strong>，这些 SQL 代码可以被包含在其他语句中。它可以（在加载的时候）被静态地设置参数。 在不同的包含语句中<strong>可以设置不同的值到参数占位符上</strong>。比如：</p><pre><code class="xml">&lt;sql id=&quot;userColumns&quot;&gt; ${alias}.id,${alias}.username,${alias}.password &lt;/sql&gt;</code></pre><p>这个 SQL 片段可以被包含在其他语句中，例如：</p><pre><code class="xml">&lt;select id=&quot;selectUsers&quot; resultType=&quot;map&quot;&gt;    select        &lt;include refid=&quot;userColumns&quot;&gt;&lt;property name=&quot;alias&quot; value=&quot;t1&quot;/&gt;&lt;/include&gt;,        &lt;include refid=&quot;userColumns&quot;&gt;&lt;property name=&quot;alias&quot; value=&quot;t2&quot;/&gt;&lt;/include&gt;    from some_table t1        cross join some_table t2&lt;/select&gt;</code></pre><p>属性值也可以被用在 include 元素的 refid 属性里或 include 元素的内部语句中，例如：</p><pre><code class="xml">&lt;sql id=&quot;sometable&quot;&gt;    ${prefix}Table&lt;/sql&gt;&lt;sql id=&quot;someinclude&quot;&gt;    from        &lt;include refid=&quot;${include_target}&quot;/&gt;&lt;/sql&gt;&lt;select id=&quot;select&quot; resultType=&quot;map&quot;&gt;    select        field1, field2, field3    &lt;include refid=&quot;someinclude&quot;&gt;        &lt;property name=&quot;prefix&quot; value=&quot;Some&quot;/&gt;        &lt;property name=&quot;include_target&quot; value=&quot;sometable&quot;/&gt;    &lt;/include&gt;&lt;/select&gt;</code></pre><h1 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h1><p>参数也可以指定一个特殊的数据类型。</p><pre><code class="xml">#{property, javaType=int, jdbcType=NUMERIC}</code></pre><p><strong>JDBC 要求，如果一个列允许 null 值，并且会传递值 null 的参数，就必须要指定 JDBC Type。</strong></p><p>数据库中区分 date、time、datetime，但 Java 中一般都使用 java.util.Date 类型。所以需要指定类型，分别对应的 JDBC 类型为 DATE、TIME、TIMESTAMP。</p><h2 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h2><p>默认情况下,使用 #{} 格式的语法会导致 MyBatis 创建 PreparedStatement 参数占位符并安全地设置参数（就像使用 ? 一样）。 这样做更安全，更迅速，通常也是首选做法。不过有时你就是想直接在 SQL 语句中插入一个不转义的字符串。 比如，像 ORDER BY，你可以这样来使用：<code>ORDER BY ${columnName}</code></p><pre><code class="java">@Select(&quot;select * from user where ${column} = #{value}&quot;)User findByColumn(@Param(&quot;column&quot;) String column, @Param(&quot;value&quot;) String value);</code></pre><p>其中 <code>${column}</code> 会被直接替换，而 <code>#{value}</code> 会被使用 <code>?</code> 预处理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://mybatis.org/mybatis-3/zh/sqlmap-xml.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://mybatis.org/mybatis-3/zh/s
      
    
    </summary>
    
    
      <category term="Java" scheme="http://coolview.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="http://coolview.github.io/tags/Java/"/>
    
      <category term="MyBatis" scheme="http://coolview.github.io/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis 01-入门</title>
    <link href="http://coolview.github.io/2019/09/18/MyBatis/MyBatis%2001-%E5%85%A5%E9%97%A8/"/>
    <id>http://coolview.github.io/2019/09/18/MyBatis/MyBatis%2001-%E5%85%A5%E9%97%A8/</id>
    <published>2019-09-18T15:08:44.000Z</published>
    <updated>2019-10-09T13:18:56.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://mybatis.org/mybatis-3/zh/getting-started.html" target="_blank" rel="noopener">https://mybatis.org/mybatis-3/zh/getting-started.html</a><br><a href="http://www.broadview.com.cn/book/3643" target="_blank" rel="noopener">http://www.broadview.com.cn/book/3643</a></p></blockquote><h1 id="引用-jar-包"><a href="#引用-jar-包" class="headerlink" title="引用 jar 包"></a>引用 jar 包</h1><p>可在 <a href="https://github.com/mybatis/mybatis-3/releases" target="_blank" rel="noopener">https://github.com/mybatis/mybatis-3/releases</a> 下载</p><p>或者使用 Maven 来构建项目</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;    &lt;version&gt;3.5.2&lt;/version&gt;&lt;/dependency&gt;</code></pre><h1 id="从-XML-中构建-SqlSessionFactory"><a href="#从-XML-中构建-SqlSessionFactory" class="headerlink" title="从 XML 中构建 SqlSessionFactory"></a>从 XML 中构建 SqlSessionFactory</h1><p>每个基于 <code>MyBatis</code> 的应用都是以一个 <code>SqlSessionFactory</code> 的实例为核心的。<code>SqlSessionFactory</code> 的实例可以通过 <code>SqlSessionFactoryBuilder</code> 获得。而 <code>SqlSessionFactoryBuilder</code> 则可以从 <code>XML</code> 配置文件或一个预先定制的 <code>Configuration</code> 的实例构建出 <code>SqlSessionFactory</code> 的实例。</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;settings&gt;        &lt;!-- logImpl 属性配置指定使用 LOG4J 输出日志 --&gt;        &lt;setting name=&quot;logImpl&quot; value=&quot;LOG4J&quot;/&gt;    &lt;/settings&gt;    &lt;typeAliases&gt;        &lt;!-- 配置了一个包的别名，如：com.bin.model.Country，在使用类时可以使用 Country 即可，或采用如下方式 --&gt;        &lt;!-- &lt;typeAlias alias=&quot;Country&quot; type=&quot;com.bin.model.Country&quot;/&gt; --&gt;        &lt;package name=&quot;com.bin.model&quot;/&gt;    &lt;/typeAliases&gt;    &lt;environments default=&quot;development&quot;&gt;        &lt;environment id=&quot;development&quot;&gt;            &lt;!-- 配置数据库连接  --&gt;            &lt;transactionManager type=&quot;JDBC&quot;/&gt;            &lt;dataSource type=&quot;UNPOOLED&quot;&gt;                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?serverTimezone=Asia/Shanghai&amp;amp;characterEncoding=utf8&quot;/&gt;                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;                &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;    &lt;mappers&gt;        &lt;!-- MyBatis 的 SQL 语句和映射配置文件 --&gt;        &lt;mapper resource=&quot;com/bin/mapper/CountryMapper.xml&quot;/&gt;    &lt;/mappers&gt;&lt;/configuration&gt;</code></pre><p>MyBatis 包含一个名叫 Resources 的工具类，它包含一些实用方法，可使从 classpath 或其他位置加载资源文件更加容易。</p><pre><code class="java">String resource = &quot;mybatis-config.xml&quot;;InputStream inputStream = Resources.getResourceAsStream(resource);SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);</code></pre><h1 id="不使用-XML-构建-SqlSessionFactory"><a href="#不使用-XML-构建-SqlSessionFactory" class="headerlink" title="不使用 XML 构建 SqlSessionFactory"></a>不使用 XML 构建 SqlSessionFactory</h1><p>如果你更愿意直接从 Java 代码而不是 XML 文件中创建配置，或者想要创建你自己的配置构建器，MyBatis 也提供了完整的配置类，提供所有和 XML 文件相同功能的配置项。</p><pre><code class="java">// https://stackoverflow.com/questions/22517318/cant-find-some-mybatis-classes-to-import-in-getting-started-guide/42051489#42051489public interface CountryMapper {    @Select(&quot;select id, countryname, countrycode from country&quot;)  // xml 示例中这行注释    public List&lt;Country&gt; selectAll();}class MyDataSourceFactory implements DataSourceFactory {    private Properties prop;    @Override    public DataSource getDataSource() {        PooledDataSource ds = new PooledDataSource();        ds.setDriver(prop.getProperty(&quot;driver&quot;));        ds.setUrl(prop.getProperty(&quot;url&quot;));        ds.setUsername(prop.getProperty(&quot;user&quot;));        ds.setPassword(prop.getProperty(&quot;password&quot;));        return ds;    }    @Override    public void setProperties(Properties prprts) {        prop = prprts;    }}public class MyBatisJavaConfClient {    private static SqlSessionFactory sesFact = null;    public static void main(String[] args) throws IOException {        Properties prop = new Properties();        prop.setProperty(&quot;driver&quot;, &quot;com.mysql.cj.jdbc.Driver&quot;);        prop.setProperty(&quot;url&quot;, &quot;jdbc:mysql://localhost:3306/mybatis?serverTimezone=Asia/Shanghai&amp;characterEncoding=utf8&quot;);        prop.setProperty(&quot;user&quot;, &quot;root&quot;);        prop.setProperty(&quot;password&quot;, &quot;root&quot;);        MyDataSourceFactory mdsf = new MyDataSourceFactory();        mdsf.setProperties(prop);        DataSource ds = mdsf.getDataSource();        TransactionFactory trFact = new JdbcTransactionFactory();        Environment environment = new Environment(&quot;development&quot;, trFact, ds);        Configuration configuration = new Configuration(environment);        configuration.addMapper(CountryMapper.class);        sesFact = new SqlSessionFactoryBuilder().build(configuration);        try (SqlSession session = sesFact.openSession()) {            List&lt;Country&gt; countryList = session.selectList(&quot;selectAll&quot;);            System.out.println(countryList);        }    }}</code></pre><p>注意该例中，<code>configuration</code> 添加了一个映射器类（mapper class）。映射器类是 Java 类，它们包含 SQL 映射语句的注解从而避免依赖 XML 文件。不过，由于 Java 注解的一些限制以及某些 MyBatis 映射的复杂性，要使用大多数高级映射（比如：嵌套联合映射），仍然需要使用 XML 配置。有鉴于此，如果存在一个同名 XML 配置文件，MyBatis 会自动查找并加载它（在这个例子中，基于类路径和 <code>CountryMapper.class</code> 的类名，会加载 <code>CountryMapper.xml</code>）。</p><h1 id="从-SqlSessionFactory-中获取-SqlSession"><a href="#从-SqlSessionFactory-中获取-SqlSession" class="headerlink" title="从 SqlSessionFactory 中获取 SqlSession"></a>从 SqlSessionFactory 中获取 SqlSession</h1><p>既然有了 SqlSessionFactory，顾名思义，我们就可以从中获得 SqlSession 的实例了。SqlSession 完全包含了面向数据库执行 SQL 命令所需的所有方法。你可以通过 SqlSession 实例来直接执行已映射的 SQL 语句。例如：</p><pre><code class="java">try (SqlSession session = sqlSessionFactory.openSession()) {    List&lt;Country&gt; countryList = sqlSession.selectList(&quot;selectAll&quot;);}</code></pre><p>诚然，这种方式能够正常工作，并且对于使用旧版本 MyBatis 的用户来说也比较熟悉。不过现在有了一种更简洁的方式 ——使用正确描述每个语句的参数和返回值的接口（比如 BlogMapper.class），你现在不仅可以执行更清晰和类型安全的代码，而且还不用担心易错的字符串字面值以及强制类型转换。</p><p>例如：</p><pre><code class="java">try (SqlSession session = sqlSessionFactory.openSession()) {    CountryMapper mapper = sqlSession.getMapper(CountryMapper.class);    List&lt;Country&gt; countryList = mapper.selectAll();}</code></pre><h1 id="CountryMapper-xml"><a href="#CountryMapper-xml" class="headerlink" title="CountryMapper.xml"></a>CountryMapper.xml</h1><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.bin.mapper.CountryMapper&quot;&gt;    &lt;!-- 不能和 接口中的注解同时使用 --&gt;    &lt;select id=&quot;selectAll&quot; resultType=&quot;Country&quot;&gt;        select id, countryname, countrycode from country    &lt;/select&gt;&lt;/mapper&gt;</code></pre><p><strong>命名空间</strong>的作用有两个，一个是利用更长的完全限定名来将不同的语句隔离开来，同时也实现了你上面见到的接口绑定。就算你觉得暂时用不到接口绑定，你也应该遵循这里的规定，以防哪天你改变了主意。 长远来看，只要将命名空间置于合适的 Java 包命名空间之中，你的代码会变得更加整洁，也有利于你更方便地使用 MyBatis。</p><h1 id="作用域（Scope）和生命周期"><a href="#作用域（Scope）和生命周期" class="headerlink" title="作用域（Scope）和生命周期"></a>作用域（Scope）和生命周期</h1><h2 id="SqlSessionFactoryBuilder"><a href="#SqlSessionFactoryBuilder" class="headerlink" title="SqlSessionFactoryBuilder"></a>SqlSessionFactoryBuilder</h2><p>这个类可以被实例化、使用和丢弃，一旦创建了 <code>SqlSessionFactory</code>，就不再需要它了。 因此 <code>SqlSessionFactoryBuilder</code> 实例的最佳作用域是方法作用域（也就是局部方法变量）。 你可以重用 <code>SqlSessionFactoryBuilder</code> 来创建多个 <code>SqlSessionFactory</code> 实例，但是最好还是不要让其一直存在，以保证所有的 XML 解析资源可以被释放给更重要的事情。</p><h2 id="SqlSessionFactory"><a href="#SqlSessionFactory" class="headerlink" title="SqlSessionFactory"></a>SqlSessionFactory</h2><p><code>SqlSessionFactory</code> 一旦被创建就应该在应用的运行期间一直存在，<strong>没有任何理由丢弃它或重新创建另一个实例</strong>。 使用 <code>SqlSessionFactory</code> 的最佳实践是在应用运行期间不要重复创建多次，多次重建 <code>SqlSessionFactory</code> 被视为一种代码“坏味道（bad smell）”。因此 <code>SqlSessionFactory</code> 的最佳作用域是应用作用域。 有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式。</p><h2 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h2><p><strong>每个线程都应该有它自己的 <code>SqlSession</code> 实例</strong>。<code>SqlSession</code> 的实例不是线程安全的，因此是不能被共享的，所以它的<strong>最佳的作用域是请求或方法作用域</strong>。 绝对不能将 <code>SqlSession</code> 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。 也绝不能将 <code>SqlSession</code> 实例的引用放在任何类型的托管作用域中，比如 <code>Servlet</code> 框架中的 <code>HttpSession</code>。 如果你现在正在使用一种 <code>Web</code> 框架，要考虑 <code>SqlSession</code> 放在一个和 <code>HTTP</code> 请求对象相似的作用域中。 换句话说，每次收到的 <code>HTTP</code> 请求，就可以打开一个 <code>SqlSession</code>，返回一个响应，就关闭它。 这个关闭操作是很重要的，你应该把这个关闭操作放到 <code>finally</code> 块中以确保每次都能执行关闭。 下面的示例就是一个确保 <code>SqlSession</code> 关闭的标准模式：</p><pre><code class="java">try (SqlSession session = sqlSessionFactory.openSession()) {  // 你的应用逻辑代码}</code></pre><p>在你的所有的代码中一致地使用这种模式来保证所有数据库资源都能被正确地关闭。</p><h2 id="映射器实例"><a href="#映射器实例" class="headerlink" title="映射器实例"></a>映射器实例</h2><p>映射器是一些由你创建的、绑定你映射的语句的接口。映射器接口的实例是从 <code>SqlSession</code> 中获得的。因此从技术层面讲，任何映射器实例的最大作用域是和请求它们的 <code>SqlSession</code> 相同的。尽管如此，映射器实例的最佳作用域是<strong>方法作用域</strong>。 也就是说，映射器实例应该在调用它们的方法中被请求，用过之后即可丢弃。 并不需要显式地关闭映射器实例，尽管在整个请求作用域保持映射器实例也不会有什么问题，但是你很快会发现，像 <code>SqlSession</code> 一样，在这个作用域上管理太多的资源的话会难于控制。 为了避免这种复杂性，最好把映射器放在方法作用域内。下面的示例就展示了这个实践：</p><pre><code class="java">try (SqlSession session = sqlSessionFactory.openSession()) {  BlogMapper mapper = session.getMapper(BlogMapper.class);  // 你的应用逻辑代码}</code></pre><h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><p>Mybatis 的内置日志工厂提供日志功能，内置日志工厂将日志交给以下其中一种工具作代理：</p><ul><li>SLF4J</li><li>Apache Commons Logging</li><li>Log4j 2</li><li>Log4j</li><li>JDK logging</li></ul><p>MyBatis 内置日志工厂基于运行时自省机制选择合适的日志工具。它会使用第一个查找得到的工具（按上文列举的顺序查找）。如果一个都未找到，日志功能就会被禁用。</p><p>可以通过在 MyBatis 配置文件 <code>mybatis-config.xml</code> 里面添加一项 <code>setting</code> 来选择别的日志工具。</p><pre><code class="xml">&lt;configuration&gt;  &lt;settings&gt;    ...    &lt;setting name=&quot;logImpl&quot; value=&quot;LOG4J&quot;/&gt;    ...  &lt;/settings&gt;&lt;/configuration&gt;</code></pre><p>在应用的类路径中创建一个名称为 <code>log4j.properties</code> 的文件，文件的具体内容如下：</p><pre><code class="ini">; Global logging configurationlog4j.rootLogger=ERROR, stdout; MyBatis logging configuration...log4j.logger.com.bin.mapper.CountryMapper=TRACE; 你也可以将日志的记录方式从接口级别切换到语句级别，从而实现更细粒度的控制。如下配置只对 selectAll 语句记录日志：log4j.logger.com.bin.mapper.CountryMapper.selectAll=TRACE; 可以对一组映射器接口记录日志，只要对映射器接口所在的包开启日志功能即可：log4j.logger.com.bin.mapper=TRACE; 如需对 XML 文件记录日志，只要对命名空间增加日志记录功能即可：log4j.logger.com.bin.mapper.CountryMapper=TRACE; Console output...log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n</code></pre><p>MyBatis 日志的最低级别时 TREAC，这个级别下会输出执行 SQL 过程中的详细信息。</p><pre><code class="log">EBUG [main] - ==&gt;  Preparing: select id, countryname, countrycode from countryDEBUG [main] - ==&gt; Parameters:TRACE [main] - &lt;==    Columns: id, countryname, countrycodeTRACE [main] - &lt;==        Row: 1, 中国, CNTRACE [main] - &lt;==        Row: 2, 美国, USTRACE [main] - &lt;==        Row: 3, 俄罗斯, RUTRACE [main] - &lt;==        Row: 4, 英国, GBTRACE [main] - &lt;==        Row: 5, 法国, FRDEBUG [main] - &lt;==      Total: 5</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://mybatis.org/mybatis-3/zh/getting-started.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://mybatis.org/mybatis-3
      
    
    </summary>
    
    
      <category term="Java" scheme="http://coolview.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="http://coolview.github.io/tags/Java/"/>
    
      <category term="MyBatis" scheme="http://coolview.github.io/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis 02-XML 配置文件</title>
    <link href="http://coolview.github.io/2019/09/18/MyBatis/MyBatis%2002-XML%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    <id>http://coolview.github.io/2019/09/18/MyBatis/MyBatis%2002-XML%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</id>
    <published>2019-09-18T15:08:44.000Z</published>
    <updated>2019-10-23T07:15:39.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://mybatis.org/mybatis-3/zh/configuration.html" target="_blank" rel="noopener">https://mybatis.org/mybatis-3/zh/configuration.html</a></p></blockquote><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;!-- 标签顺序必须按以下顺序 --&gt;    &lt;properties&gt;    &lt;settings&gt;    &lt;typeAliases&gt;    &lt;typeHandlers&gt;    &lt;objectFactory&gt;    &lt;objectWrapperFactory&gt;    &lt;reflectorFactory&gt;    &lt;plugins&gt;    &lt;environments&gt;    &lt;databaseIdProvider&gt;    &lt;mappers&gt;&lt;/configuration&gt;</code></pre><p>标签顺序必须符合要求，否则报错：<br>The content of element type &quot;configuration&quot; must match &quot;(properties?,settings?,typeAliases?,typeHandlers?,objectFactory?,objectWrapperFactory?,reflectorFactory?,plugins?,environments?,databaseIdProvider?,mappers?)&quot;.</p><h1 id="属性（properties）"><a href="#属性（properties）" class="headerlink" title="属性（properties）"></a>属性（properties）</h1><p>属性可以在典型的 Java properties 文件中配置，亦可通过 properties 元素的子元素来传递</p><pre><code class="xml">&lt;properties resource=&quot;config.properties&quot;&gt;    &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;    &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;&lt;/properties&gt;</code></pre><p>然后其中的属性就可以在整个配置文件中被用来替换需要动态配置的属性值。比如:</p><pre><code class="xml">&lt;dataSource type=&quot;POOLED&quot;&gt;  &lt;property name=&quot;driver&quot; value=&quot;${driver}&quot;/&gt;  &lt;property name=&quot;url&quot; value=&quot;${url}&quot;/&gt;  &lt;property name=&quot;username&quot; value=&quot;${username}&quot;/&gt;  &lt;property name=&quot;password&quot; value=&quot;${password}&quot;/&gt;&lt;/dataSource&gt;</code></pre><p>属性也可以被传递到 <code>SqlSessionFactoryBuilder.build()</code> 方法中。例如：</p><pre><code class="java">Properties prop = new Properties();prop.setProperty(&quot;driver&quot;, &quot;com.mysql.cj.jdbc.Driver&quot;);prop.setProperty(&quot;url&quot;, &quot;jdbc:mysql://localhost:3306/mybatis?serverTimezone=Asia/Shanghai&amp;characterEncoding=utf8&quot;);prop.setProperty(&quot;username&quot;, &quot;root&quot;);prop.setProperty(&quot;password&quot;, &quot;root&quot;);Reader reader = Resources.getResourceAsReader(&quot;config.xml&quot;);sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader, prop);reader.close();</code></pre><h2 id="加载顺序"><a href="#加载顺序" class="headerlink" title="加载顺序"></a>加载顺序</h2><p>通过方法参数传递的属性具有最高优先级，属性中指定的配置文件次之，最低优先级的是 properties 属性中指定的属性。</p><h2 id="为占位符指定一个默认值"><a href="#为占位符指定一个默认值" class="headerlink" title="为占位符指定一个默认值"></a>为占位符指定一个默认值</h2><p>从 MyBatis 3.4.2 开始</p><pre><code class="xml">&lt;dataSource type=&quot;POOLED&quot;&gt;    &lt;property name=&quot;username&quot; value=&quot;${username:ut_user}&quot;/&gt; &lt;!-- 如果属性 &#39;username&#39; 没有被配置，&#39;username&#39; 属性的值将为 &#39;ut_user&#39; --&gt;&lt;/dataSource&gt;</code></pre><p>需添加一个指定的属性来开启这个特性。例如：</p><pre><code class="xml">&lt;properties resource=&quot;org/mybatis/example/config.properties&quot;&gt;    &lt;property name=&quot;org.apache.ibatis.parsing.PropertyParser.enable-default-value&quot; value=&quot;true&quot;/&gt; &lt;!-- 启用默认值特性 --&gt;&lt;/properties&gt;</code></pre><p>可以修改 <code>value=&quot;?:&quot;</code> 的值，来修改分隔键名和默认值的字符。</p><h1 id="设置（settings）"><a href="#设置（settings）" class="headerlink" title="设置（settings）"></a>设置（settings）</h1><pre><code class="xml">&lt;settings&gt;    &lt;!-- 全局的映射器启用或禁用缓存。 --&gt;    &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;    &lt;!-- 全局启用或禁用延迟加载 --&gt;    &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;    &lt;!-- 允许或不允许多种结果集从一个单独的语句中返回 --&gt;    &lt;setting name=&quot;multipleResultSetsEnabled&quot; value=&quot;true&quot;/&gt;    &lt;setting name=&quot;useColumnLabel&quot; value=&quot;true&quot;/&gt;    &lt;setting name=&quot;useGeneratedKeys&quot; value=&quot;true&quot;/&gt;    &lt;setting name=&quot;defaultExecutorType&quot; value=&quot;SIMPLE&quot;/&gt;    &lt;!-- 设置超时时间（秒） --&gt;    &lt;setting name=&quot;defaultStatementTimeout&quot; value=&quot;200&quot;/&gt;&lt;/settings&gt;</code></pre><table><thead><tr><th>设置名</th><th>描述</th><th>有效值</th><th>默认值</th></tr></thead><tbody><tr><td>cacheEnabled</td><td>全局地开启或关闭配置文件中的所有映射器已经配置的任何缓存。</td><td>true/false</td><td>true</td></tr><tr><td>lazyLoadingEnabled</td><td>延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。特定关联关系中可通过设置 <code>fetchType</code> 属性来覆盖该项的开关状态。</td><td>true/false</td><td>false</td></tr><tr><td>aggressiveLazyLoading</td><td>当开启时，任何方法的调用都会加载该对象的所有属性。否则，每个属性会按需加载（参考 <code>lazyLoadTriggerMethods</code>)。</td><td>true/false</td><td>false （在 3.4.1 及之前的版本默认值为 true）</td></tr><tr><td>lazyLoadTriggerMethods</td><td>指定哪个对象的方法触发一次延迟加载。</td><td>用逗号分隔的方法列表。</td><td>equals,clone,hashCode,toString</td></tr><tr><td>multipleResultSetsEnabled</td><td>是否允许单一语句返回多结果集（需要驱动支持）。</td><td>true/false</td><td>true</td></tr><tr><td>useColumnLabel</td><td>使用列标签代替列名。不同的驱动在这方面会有不同的表现，具体可参考相关驱动文档或通过测试这两种不同的模式来观察所用驱动的结果。</td><td>true/false</td><td>true</td></tr><tr><td>useGeneratedKeys</td><td>允许 JDBC 支持自动生成主键，需要驱动支持。 如果设置为 true 则这个设置强制使用自动生成主键，尽管一些驱动不能支持但仍可正常工作（比如 Derby）。</td><td>true/false</td><td>false</td></tr><tr><td>autoMappingBehavior</td><td>指定 MyBatis 应如何自动映射列到字段或属性。 <code>NONE</code> 表示取消自动映射； <code>PARTIAL</code> 只会自动映射没有定义嵌套结果集映射的结果集。 <code>FULL</code> 会自动映射任意复杂的结果集（无论是否嵌套）。</td><td>NONE, PARTIAL, FULL</td><td>PARTIAL</td></tr><tr><td>autoMappingUnknownColumnBehavior</td><td>指定发现自动映射目标未知列（或者未知属性类型）的行为。 <br/><code>NONE</code>: 不做任何反应 <br/> <code>WARNING</code>: 输出提醒日志 (<code>&#39;org.apache.ibatis.session.AutoMappingUnknownColumnBehavior&#39;</code> 的日志等级必须设置为 <code>WARN</code>)  <br/> <code>FAILING</code>: 映射失败 (抛出 SqlSessionException)</td><td>NONE, WARNING, FAILING</td><td>NONE</td></tr><tr><td>defaultExecutorType</td><td>配置默认的执行器。SIMPLE 就是普通的执行器；REUSE 执行器会重用预处理语句（prepared statements）； BATCH 执行器将重用语句并执行批量更新。</td><td>SIMPLE, REUSE, BATCH</td><td>SIMPLE</td></tr><tr><td>defaultStatementTimeout</td><td>设置超时时间，它决定驱动等待数据库响应的秒数。</td><td>任意正整数</td><td>未设置 (null)</td></tr><tr><td>defaultFetchSize</td><td>为驱动的结果集获取数量（fetchSize）设置一个提示值。此参数只可以在查询设置中被覆盖。</td><td>任意正整数</td><td>未设置 (null)</td></tr><tr><td>safeRowBoundsEnabled</td><td>允许在嵌套语句中使用分页（RowBounds）。如果允许使用则设置为 false。</td><td>true/false</td><td>False</td></tr><tr><td>safeResultHandlerEnabled</td><td>允许在嵌套语句中使用分页（ResultHandler）。如果允许使用则设置为 false。</td><td>true/false</td><td>True</td></tr><tr><td>mapUnderscoreToCamelCase</td><td>是否开启自动驼峰命名规则（camel case）映射，即从经典数据库列名 A_COLUMN 到经典 Java 属性名 aColumn 的类似映射。</td><td>true/false</td><td>False</td></tr><tr><td>localCacheScope</td><td>MyBatis 利用本地缓存机制（Local Cache）防止循环引用（circular references）和加速重复嵌套查询。 默认值为 SESSION，这种情况下会缓存一个会话中执行的所有查询。 若设置值为 STATEMENT，本地会话仅用在语句执行上，对相同 SqlSession 的不同调用将不会共享数据。</td><td>SESSION / STATEMENT</td><td>SESSION</td></tr><tr><td>defaultEnumTypeHandler</td><td>指定 Enum 使用的默认 TypeHandler 。（新增于 3.4.5）</td><td>一个类型别名或完全限定类名。</td><td>org.apache.ibatis.type.EnumTypeHandler</td></tr><tr><td>logPrefix</td><td>指定 MyBatis 增加到日志名称的前缀。</td><td>任何字符串</td><td>未设置</td></tr><tr><td>logImpl</td><td>指定 MyBatis 所用日志的具体实现，未指定时将自动查找。</td><td>SLF4J / LOG4J / LOG4J2 / JDK_LOGGING / COMMONS_LOGGING / STDOUT_LOGGING / NO_LOGGING</td><td>未设置</td></tr></tbody></table><h1 id="类型别名（typeAliases）"><a href="#类型别名（typeAliases）" class="headerlink" title="类型别名（typeAliases）"></a>类型别名（typeAliases）</h1><p>类型别名是为 Java 类型设置一个短的名字。 它只和 XML 配置有关，存在的意义仅在于用来减少类完全限定名的冗余。例如：</p><pre><code class="xml">&lt;typeAliases&gt;    &lt;typeAlias alias=&quot;Country&quot; type=&quot;com.bin.domian.Country&quot;/&gt;&lt;/typeAliases&gt;</code></pre><p>也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean，比如：</p><pre><code class="xml">&lt;typeAliases&gt;    &lt;package name=&quot;com.bin.domian&quot;/&gt;&lt;/typeAliases&gt;</code></pre><p>每一个在包 <code>com.bin.domian</code> 中的 Java Bean，在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名。 比如 <code>com.bin.domian.Country</code> 的别名为 <code>country</code>；若有注解，则别名为其注解值。见下面的例子：</p><pre><code class="java">@Alias(&quot;country&quot;)public class Country {    ...}</code></pre><p>常见的 Java 类型内建的相应的类型别名。它们都是<strong>不区分大小写的</strong>，注意对基本类型名称重复采取的特殊命名风格。</p><table><thead><tr><th>别名</th><th>映射的类型</th></tr></thead><tbody><tr><td>_byte</td><td>byte</td></tr><tr><td>_long</td><td>long</td></tr><tr><td>_short</td><td>short</td></tr><tr><td>_int</td><td>int</td></tr><tr><td>_integer</td><td>int</td></tr><tr><td>_double</td><td>double</td></tr><tr><td>_float</td><td>float</td></tr><tr><td>_boolean</td><td>boolean</td></tr><tr><td>string</td><td>String</td></tr><tr><td>byte</td><td>Byte</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>integer</td><td>Integer</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>boolean</td><td>Boolean</td></tr><tr><td>date</td><td>Date</td></tr><tr><td>decimal</td><td>BigDecimal</td></tr><tr><td>bigdecimal</td><td>BigDecimal</td></tr><tr><td>object</td><td>Object</td></tr><tr><td>map</td><td>Map</td></tr><tr><td>hashmap</td><td>HashMap</td></tr><tr><td>list</td><td>List</td></tr><tr><td>arraylist</td><td>ArrayList</td></tr><tr><td>collection</td><td>Collection</td></tr><tr><td>iterator</td><td>Iterator</td></tr></tbody></table><h1 id="类型处理器（typeHandlers）"><a href="#类型处理器（typeHandlers）" class="headerlink" title="类型处理器（typeHandlers）"></a>类型处理器（typeHandlers）</h1><p>无论是 MyBatis 在预处理语句（PreparedStatement）中设置一个参数时，还是从结果集中取出一个值时， 都会用类型处理器将获取的值以合适的方式转换成 Java 类型。</p><p>可以重写类型处理器或创建你自己的类型处理器来处理不支持的或非标准的类型。 具体做法为：实现 <code>org.apache.ibatis.type.TypeHandler</code> 接口， 或继承一个很便利的类 <code>org.apache.ibatis.type.BaseTypeHandler</code>， 然后可以选择性地将它映射到一个 JDBC 类型。</p><h1 id="处理枚举类型"><a href="#处理枚举类型" class="headerlink" title="处理枚举类型"></a>处理枚举类型</h1><p>若想映射枚举类型 Enum，则需要从 EnumTypeHandler 或者 EnumOrdinalTypeHandler 中选一个来使用。</p><p>默认情况下，MyBatis 会利用 EnumTypeHandler 来把 Enum 值转换成对应的名字。</p><pre><code class="java">public enum CountryCode {    CN(&quot;CN 中国&quot;),    US(&quot;US 美国&quot;),    RU(&quot;RU 俄罗斯&quot;),    GB(&quot;GB 英国&quot;),    FR(&quot;FR 法国&quot;);    private String codename;    private CountryCode(String codename) {        this.codename = codename;    }    public String getCodename() {        return codename;    }}</code></pre><pre><code class="java">// Country 类下 增加属性private CountryCode code;</code></pre><h2 id="EnumTypeHandler"><a href="#EnumTypeHandler" class="headerlink" title="EnumTypeHandler"></a>EnumTypeHandler</h2><pre><code class="xml">&lt;resultMap id=&quot;countryMap&quot; type=&quot;Country&quot;&gt;    &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;    &lt;result column=&quot;countrycode&quot; property=&quot;code&quot; typeHandler=&quot;org.apache.ibatis.type.EnumTypeHandler&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;selectAll2&quot; resultMap=&quot;countryMap&quot;&gt;    select id, countryname, countrycode from country&lt;/select&gt;</code></pre><p>将数据库中 countrycode 映射到 code 字段中。</p><h2 id="EnumOrdinalTypeHandler"><a href="#EnumOrdinalTypeHandler" class="headerlink" title="EnumOrdinalTypeHandler"></a>EnumOrdinalTypeHandler</h2><p>数据库中新增 code 字段，存放整型值</p><pre><code class="xml">&lt;!-- 修改默认的处理器，如果在下方的 resultMap 指定了 typeHandler 这里可以不需要--&gt;&lt;typeHandlers&gt;    &lt;typeHandler handler=&quot;org.apache.ibatis.type.EnumOrdinalTypeHandler&quot; javaType=&quot;com.bin.domian.CountryCode&quot;/&gt;&lt;/typeHandlers&gt;</code></pre><pre><code class="xml">&lt;resultMap id=&quot;countryMap&quot; type=&quot;Country&quot;&gt;    &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;    &lt;!-- 同样如果已经在配置文件中修改了 默认的处理器，这里的 typeHandler 可以不需要 --&gt;    &lt;result column=&quot;code&quot; property=&quot;code&quot; typeHandler=&quot;org.apache.ibatis.type.EnumOrdinalTypeHandler&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;selectAll2&quot; resultMap=&quot;countryMap&quot;&gt;    select id, countryname, countrycode, code from country&lt;/select&gt;</code></pre><h1 id="环境配置（environments）"><a href="#环境配置（environments）" class="headerlink" title="环境配置（environments）"></a>环境配置（environments）</h1><p>可以指定使用哪个环境配置，如果忽略了环境参数，那么默认环境将会被加载</p><pre><code class="java">SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment);SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment, properties);</code></pre><p>环境元素定义了如何配置环境。</p><pre><code class="xml">&lt;environments default=&quot;development&quot;&gt;    &lt;environment id=&quot;development&quot;&gt;        &lt;transactionManager type=&quot;JDBC&quot;&gt;            &lt;property name=&quot;...&quot; value=&quot;...&quot;/&gt;        &lt;/transactionManager&gt;        &lt;dataSource type=&quot;POOLED&quot;&gt;            &lt;property name=&quot;driver&quot; value=&quot;${driver}&quot;/&gt;            &lt;property name=&quot;url&quot; value=&quot;${url}&quot;/&gt;            &lt;property name=&quot;username&quot; value=&quot;${username}&quot;/&gt;            &lt;property name=&quot;password&quot; value=&quot;${password}&quot;/&gt;        &lt;/dataSource&gt;    &lt;/environment&gt;&lt;/environments&gt;</code></pre><ul><li><p>默认使用的环境 ID（比如：default=&quot;development&quot;）。</p></li><li><p>每个 environment 元素定义的环境 ID（比如：id=&quot;development&quot;）。</p></li><li><p>事务管理器的配置（比如：type=&quot;JDBC&quot;）。如果使用 Spring + MyBatis，Spring 模块会使用自带的管理器来覆盖前面的配置。</p></li><li><p>数据源的配置（比如：type=&quot;POOLED&quot;）。</p><pre><code class="xml">  &lt;dataSource type=&quot;POOLED&quot;&gt;      &lt;!-- type=&quot;UNPOOLED&quot;  不使用任何数据库连接池来管理数据库连接 --&gt;      &lt;property name=&quot;driver&quot; value=&quot;${driver}&quot;/&gt;      &lt;property name=&quot;url&quot; value=&quot;${url}&quot;/&gt;      &lt;property name=&quot;username&quot; value=&quot;${username}&quot;/&gt;      &lt;property name=&quot;password&quot; value=&quot;${password}&quot;/&gt;      &lt;!-- defaultTransactionIsolationLevel – 默认的连接事务隔离级别。 --&gt;      &lt;!-- defaultNetworkTimeout 默认网络超时值(以毫秒为单位)，以等待数据库操作完成 --&gt;      &lt;!-- 你也可以传递属性给数据库驱动。只需在属性名加上“driver.”前缀即可，例如： --&gt;          &lt;!-- driver.encoding=UTF8 --&gt;      &lt;!-- type=&quot;POOLED&quot; 使用 Mybatis 自带的数据库连接池来管理数据库连接 --&gt;      &lt;!-- 除了上述提到 UNPOOLED 下的属性外，还有更多属性用来配置 POOLED 的数据源： --&gt;      &lt;!-- 在任意时间可以存在的活动（也就是正在使用）连接数量，默认值：10 --&gt;      &lt;property name=&quot;poolMaximumActiveConnections&quot; value=&quot;10&quot;/&gt;      &lt;!-- 任意时间可能存在的空闲连接数。 --&gt;      &lt;property name=&quot;poolMaximumIdleConnections&quot; value=&quot;10&quot;/&gt;      &lt;!--  在被强制返回之前，池中连接被检出（checked out）时间，默认值：20000 毫秒（即 20 秒） --&gt;      &lt;property name=&quot;poolMaximumCheckoutTime&quot; value=&quot;20000&quot;/&gt;      &lt;!--  这是一个底层设置，如果获取连接花费了相当长的时间，连接池会打印状态日志并重新尝试获取一个连接，默认值：20000 毫秒（即 20 秒）。 --&gt;      &lt;property name=&quot;poolTimeToWait&quot; value=&quot;20000&quot;/&gt;      &lt;!-- 这是一个关于坏连接容忍度的底层设置， 作用于每一个尝试从缓存池获取连接的线程。 如果这个线程获取到的是一个坏的连接，那么这个数据源允许这个线程尝试重新获取一个新的连接，但是这个重新尝试的次数不应该超过 poolMaximumIdleConnections 与 poolMaximumLocalBadConnectionTolerance 之和。 默认值：3 （新增于 3.4.5） --&gt;      &lt;property name=&quot;poolMaximumLocalBadConnectionTolerance&quot; value=&quot;3&quot;/&gt;      &lt;!-- 是否启用侦测查询。若开启，需要设置 poolPingQuery 属性为一个可执行的 SQL 语句（最好是一个速度非常快的 SQL 语句），默认值：false。 --&gt;      &lt;property name=&quot;poolPingEnabled&quot; value=&quot;true&quot;/&gt;      &lt;!-- 发送到数据库的侦测查询，用来检验连接是否正常工作并准备接受请求。默认是“NO PING QUERY SET”，这会导致多数数据库驱动失败时带有一个恰当的错误消息。 --&gt;      &lt;property name=&quot;poolPingQuery&quot; value=&quot;select 1&quot;/&gt;      &lt;!-- 配置 poolPingQuery 的频率。可以被设置为和数据库连接超时时间一样，来避免不必要的侦测，默认值：0（即所有连接每一时刻都被侦测 — 当然仅当 poolPingEnabled 为 true 时适用）。 --&gt;      &lt;property name=&quot;poolPingConnectionsNotUsedFor&quot; value=&quot;20000&quot;/&gt;  &lt;/dataSource&gt;</code></pre></li></ul><h1 id="映射器（mappers）"><a href="#映射器（mappers）" class="headerlink" title="映射器（mappers）"></a>映射器（mappers）</h1><p>可以使用相对于类路径的资源引用， 或完全限定资源定位符（包括 file:/// 的 URL），或类名和包名等。例如：</p><pre><code class="xml">&lt;!-- 使用相对于类路径的资源引用 --&gt;&lt;mappers&gt;    &lt;mapper resource=&quot;org/mybatis/builder/PostMapper.xml&quot;/&gt;&lt;/mappers&gt;&lt;!-- 使用完全限定资源定位符（URL） --&gt;&lt;mappers&gt;    &lt;mapper url=&quot;file:///var/mappers/PostMapper.xml&quot;/&gt;&lt;/mappers&gt;&lt;!-- 使用映射器接口实现类的完全限定类名 --&gt;&lt;mappers&gt;    &lt;mapper class=&quot;org.mybatis.builder.PostMapper&quot;/&gt;&lt;/mappers&gt;&lt;!-- 将包内的映射器接口实现全部注册为映射器 --&gt;&lt;mappers&gt;    &lt;package name=&quot;org.mybatis.builder&quot;/&gt;&lt;/mappers&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://mybatis.org/mybatis-3/zh/configuration.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://mybatis.org/mybatis-3/z
      
    
    </summary>
    
    
      <category term="Java" scheme="http://coolview.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="http://coolview.github.io/tags/Java/"/>
    
      <category term="MyBatis" scheme="http://coolview.github.io/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>Maven 学习</title>
    <link href="http://coolview.github.io/2019/08/26/Java/Maven%20%E5%AD%A6%E4%B9%A0/"/>
    <id>http://coolview.github.io/2019/08/26/Java/Maven%20%E5%AD%A6%E4%B9%A0/</id>
    <published>2019-08-26T13:41:45.000Z</published>
    <updated>2019-09-11T13:42:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>Maven 是一个项目管理工具，它包含了一个 项目对象模<br>型 (POM：Project Object Model)，一组标准集合，一个项目生命周期(Project Lifecycle)，一个依赖管<br>理系统(Dependency Management System)，和用来运行定义在生命周期阶段(phase)中插件(plugin)目标<br>(goal)的逻辑。</p><h1 id="安装-maven"><a href="#安装-maven" class="headerlink" title="安装 maven"></a>安装 maven</h1><ul><li><p>配置 <code>JAVA_HOME</code> 的环境变量</p></li><li><p>下载地址：<a href="https://maven.apache.org/download.cgi" target="_blank" rel="noopener">https://maven.apache.org/download.cgi</a></p></li><li><p>解压到一个没有中文没有空格的路径下</p><ul><li><code>bin</code>: 存放了 maven 的命令，比如 <code>mvn</code></li><li><code>boot</code>: 存放了一些 maven 本身的引导程序，如类加载器等</li><li><code>conf</code>: 存放了 maven 的一些配置文件，如 <code>setting.xml</code> 文件</li><li><code>lib</code>: 存放了 maven 本身运行所需的一些 jar 包</li></ul></li><li><p>在环境变量增加 <code>M2_HOME</code>，路径是 maven 解压后的根目录</p></li><li><p>在环境变量里的 <code>path</code> 中增加 <code>maven/bin</code> 的目录</p></li><li><p><code>mvn -v</code> 查看 maven 版本</p><pre><code class="cmd">  mvn -v  Apache Maven 3.3.9 (bb52d8502b132ec0a5a3f4c09453c07478323dc5; 2015-11-11T00:41:47+08:00)  Maven home: C:\maven\bin\..  Java version: 1.8.0_171, vendor: Oracle Corporation  Java home: C:\Program Files\Java\jdk1.8.0_171\jre  Default locale: zh_CN, platform encoding: GBK  OS name: &quot;windows 10&quot;, version: &quot;10.0&quot;, arch: &quot;amd64&quot;, family: &quot;dos&quot;</code></pre></li></ul><h1 id="Maven-本地仓库的配置"><a href="#Maven-本地仓库的配置" class="headerlink" title="Maven 本地仓库的配置"></a>Maven 本地仓库的配置</h1><p>在 <code>MAVE_HOME/conf/settings.xml</code> 文件中配置本地仓库位置（maven 的安装目录下）：</p><pre><code class="xml">&lt;!-- settings 标签下 --&gt;&lt;!-- 默认值：${user.home}/.m2/repository --&gt;&lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt;</code></pre><h1 id="Maven-工程的目录结构"><a href="#Maven-工程的目录结构" class="headerlink" title="Maven 工程的目录结构"></a>Maven 工程的目录结构</h1><ul><li><code>src/main/java</code> —— 存放项目的.java 文件</li><li><code>src/main/resources</code> —— 存放项目资源文件，如 spring, hibernate 配置文件</li><li><code>src/main/webapp</code> —— 存放项目页面元素，普通 Java 项目没有这个目录</li><li><code>src/test/java</code> —— 存放所有单元测试 .java 文件，如 JUnit 测试类</li><li><code>src/test/resources</code> —— 测试资源文件</li><li><code>target</code> —— 项目输出位置，编译后的 class 文件会输出到此目录</li><li><code>pom.xml</code> —— maven 项目核心配置文件</li></ul><h1 id="Maven-常用命令"><a href="#Maven-常用命令" class="headerlink" title="Maven 常用命令"></a>Maven 常用命令</h1><ul><li><code>compile</code>：编译，<code>mvn compile</code> 将 src/main/java 下的文件编译为 class 文件输出到 target 目录下</li><li><code>test</code>：测试，<code>mvn test</code> 执行 src/test/java 下的单元测试类</li><li><code>clean</code>：清理，<code>mvn clean</code> 删除 target 目录</li><li><code>package</code>：打包，<code>mvn package</code> 将 Java 工程打成 jar 包，对于 web 工程打成 war 包</li><li><code>install</code>：安装，<code>mvn install</code> 将打成 jar 或 war 包发布到本地仓库中</li></ul><h1 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h1><pre><code class="xml">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;!-- 公司或组织域名倒序+项目名 --&gt;    &lt;groupId&gt;com.bin.test&lt;/groupId&gt;    &lt;!-- 模块名 --&gt;    &lt;artifactId&gt;Demo&lt;/artifactId&gt;    &lt;!-- 打包方式 jar 或 war 或 pom ：用于 maven 工程的继承，通常父工程设置为 pom--&gt;    &lt;packaging&gt;war&lt;/packaging&gt;    &lt;!-- 版本 --&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;    &lt;!-- 项目的显示名称，通常用于 maven 产生的文档中 --&gt;    &lt;name&gt;Demo Maven Webapp&lt;/name&gt;    &lt;!-- 指定项目站点，通常用于maven产生的文档中 --&gt;    &lt;url&gt;http://maven.apache.org&lt;/url&gt;    &lt;!-- 描述此项目，通常用于maven产生的文档中 --&gt;    &lt;description&gt;测试&lt;/description&gt;    &lt;properties&gt;        &lt;!-- 占位符 --&gt;        &lt;spring.version&gt;4.2.9.RELEASE&lt;/spring.version&gt;    &lt;/properties&gt;    &lt;dependencies&gt;    &lt;!-- 依赖的项目 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;            &lt;version&gt;${spring.version}&lt;/version&gt;            &lt;scope&gt;compile&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;repositories&gt;    &lt;!-- 默认的中央仓库设置 --&gt;        &lt;repository&gt;            &lt;id&gt;central&lt;/id&gt;            &lt;name&gt;Central Repository&lt;/name&gt;            &lt;url&gt;https://repo.maven.apache.org/maven2&lt;/url&gt;            &lt;layout&gt;default&lt;/layout&gt;            &lt;snapshots&gt;                &lt;enabled&gt;false&lt;/enabled&gt;            &lt;/snapshots&gt;        &lt;/repository&gt;    &lt;/repositories&gt;    &lt;build&gt;        &lt;!-- 项目的名字 --&gt;    　　&lt;finalName&gt;WebMavenDemo&lt;/finalName&gt;    　　&lt;!-- 描述项目中资源的位置 --&gt;    　　&lt;resources&gt;    　　　　&lt;!-- 自定义资源1 --&gt;    　　　　&lt;resource&gt;    　　　　　　&lt;!-- 资源目录 --&gt;    　　　　　　&lt;directory&gt;src/main/java&lt;/directory&gt;    　　　　　　&lt;!-- 包括哪些文件参与打包 --&gt;    　　　　　　&lt;includes&gt;    　　　　　　　　&lt;include&gt;**/*.xml&lt;/include&gt;    　　　　　　&lt;/includes&gt;    　　　　　　&lt;!-- 排除哪些文件不参与打包 --&gt;    　　　　　　&lt;excludes&gt;    　　　　　　　　&lt;exclude&gt;**/*.txt&lt;/exclude&gt;    　　　　　　　　　　&lt;exclude&gt;**/*.doc&lt;/exclude&gt;    　　　　　　&lt;/excludes&gt;    　　　　&lt;/resource&gt;    　　&lt;/resources&gt;        &lt;plugins&gt;            &lt;!-- 设置 jdk 编译版本 --&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;                &lt;configuration&gt;                    &lt;source&gt;1.8&lt;/source&gt;                    &lt;target&gt;1.8&lt;/target&gt;                    &lt;encoding&gt;UTF-8&lt;/encoding&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;            &lt;!-- 添加 tomcat7 插件，自带 tomcat6， 就算加上 7 了，执行 mvn tomcat:run 也还是 6 --&gt;            &lt;!-- 启动命令：mvn tomcat7:run --&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;                &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;                &lt;version&gt;2.2&lt;/version&gt;                &lt;configuration&gt;                    &lt;uriEncoding&gt;utf-8&lt;/uriEncoding&gt;                    &lt;port&gt;8070&lt;/port&gt;                    &lt;path&gt;/&lt;/path&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;            &lt;!-- 此时点击 idea 最右侧 Maven Projects，就可以看到我们新添加的 tomcat7 插件，双击 tomcat7 插件下 tomcat7:run 命令直接运行项目 --&gt;        &lt;/plugins&gt;    &lt;/build&gt;</code></pre><p>maven坐标和仓库对应的映射关系：<code>[groupId]\[artifactId]\[version]\[artifactId]-[version].jar</code></p><p>去本地仓库看一下此目录：org\springframework\spring-core\4.3.4.RELEASE\spring-core-4.3.4.RELEASE.jar</p><h2 id="依赖范围"><a href="#依赖范围" class="headerlink" title="依赖范围"></a>依赖范围</h2><p>scope就是依赖的范围</p><ol><li><code>compile</code>，默认值，适用于所有阶段（开发、测试、部署、运行）</li><li><code>provided</code>，只在开发、测试阶段使用，目的是不让 Servlet 容器和你本地仓库的 jar 包冲突 。如 servlet.jar。</li><li><code>runtime</code>，只在运行时使用，如 JDBC 驱动，适用运行和测试阶段。</li><li><code>test</code>，只在测试时使用，用于编译和运行测试代码。不会随项目发布。</li><li><code>system</code>，类似 provided，需要显式提供包含依赖的 jar 文件的路径，Maven 不会在 Repository 中查找它，不推荐使用。</li></ol><table><thead><tr><th>依赖范围</th><th>对于编译 classpath 有效</th><th>对于测试 classpath 有效</th><th>对于运行时 classpath 有效</th><th>例子</th></tr></thead><tbody><tr><td>compile</td><td>Y</td><td>Y</td><td>Y</td><td>spring-core</td></tr><tr><td>test</td><td>-</td><td>Y</td><td>-</td><td>Junit</td></tr><tr><td>provided</td><td>Y</td><td>Y</td><td>-</td><td>servlet-api</td></tr><tr><td>runtime</td><td>-</td><td>Y</td><td>Y</td><td>JDBC 驱动</td></tr><tr><td>system</td><td>Y</td><td>Y</td><td>-</td><td>本地的</td></tr></tbody></table><h1 id="idea-开发-maven-项目"><a href="#idea-开发-maven-项目" class="headerlink" title="idea 开发 maven 项目"></a>idea 开发 maven 项目</h1><p>idea 的 的 maven 配置：<code>File --&gt; Settings --&gt; Build, Execution, Deployment --&gt; Build Tools --&gt; Maven</code>。</p><h2 id="创建-Maven-项目速度慢问题"><a href="#创建-Maven-项目速度慢问题" class="headerlink" title="创建 Maven 项目速度慢问题"></a>创建 Maven 项目速度慢问题</h2><blockquote><p><a href="https://www.cnblogs.com/del88/p/6286887.html" target="_blank" rel="noopener">https://www.cnblogs.com/del88/p/6286887.html</a></p></blockquote><p>IDEA 根据 <code>maven archetype</code> 的本质，其实是执行 <code>mvn archetype:generate</code> 命令，该命令执行时，需要指定一个 <code>archetype-catalog.xml</code> 文件。</p><p>该命令的参数 <code>-DarchetypeCatalog</code>，可选值为：<code>remote</code>，<code>internal</code>（内置的，即 <code>maven-archetype-plugin</code> 内置的 <code>archetypeCatalog</code> 文件），<code>local</code>（本地的，即本地 <code>~/.m2/</code> 下的 <code>archetypeCatalog</code> 文件）等，用来指定 <code>archetype-catalog.xml</code> 文件从哪里获取。</p><p>默认为 <code>remote</code>，即从 <a href="http://repo1.maven.org/maven2/archetype-catalog.xml" target="_blank" rel="noopener">http://repo1.maven.org/maven2/archetype-catalog.xml</a> 路径下载 <code>archetype-catalog.xml</code> 文件。</p><p>可以在 <code>Maven --&gt; Runner --&gt; VM Options</code>，增加参数：<code>-DarchetypeCatalog=internal</code></p><h2 id="创建-Maven-项目"><a href="#创建-Maven-项目" class="headerlink" title="创建 Maven 项目"></a>创建 Maven 项目</h2><p>普通 Java 项目，勾选 <code>Create from archetype</code>（可选，最后生成的目录结构不一样），选择 <code>maven-archetype-quickstart</code>。</p><p>web 项目，勾选 <code>Create from archetype</code>），选择 <code>maven-archetype-webapp</code>。</p><p>填写 <code>GroupId</code>（公司名称），<code>ArtifactId</code>（项目名），<code>Version</code>（版本），剩下的默认即可。最后生成的目录不完整，需自己手动补上。</p><blockquote><p><a href="http://yun.itheima.com/course/234.html" target="_blank" rel="noopener">http://yun.itheima.com/course/234.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Maven 是一个项目管理工具，它包含了一个 项目对象模&lt;br&gt;型 (POM：Project Object Model)，一组标准集合，一个项目生命周期(Project Lifecycle)，一个依赖管&lt;br&gt;理系统(Dependency Management System
      
    
    </summary>
    
    
      <category term="Java" scheme="http://coolview.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="http://coolview.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>《Spring 实战》笔记7：Spring MVC 的高级技术</title>
    <link href="http://coolview.github.io/2019/08/10/Spring/%E3%80%8ASpring%20%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B07%EF%BC%9ASpring%20MVC%20%E7%9A%84%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/"/>
    <id>http://coolview.github.io/2019/08/10/Spring/%E3%80%8ASpring%20%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B07%EF%BC%9ASpring%20MVC%20%E7%9A%84%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/</id>
    <published>2019-08-10T01:37:27.000Z</published>
    <updated>2019-08-28T12:32:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-MVC-配置的替代方案"><a href="#Spring-MVC-配置的替代方案" class="headerlink" title="Spring MVC 配置的替代方案"></a>Spring MVC 配置的替代方案</h1><p>在第 5 章中，我们通过扩展 <code>AbstractAnnotationConfigDispatcherServletInitializer</code> 快速搭建了 Spring MVC 环境。在这个便利的基础类中，假设我们需要基本的 <code>DispatcherServlet</code> 和 <code>ContextLoaderListener</code> 环境，并且 Spring 配置是使用 Java 的，而不是 XML。</p><p>尽管对很多 Spring 应用来说，这是一种安全的假设，但是并不一定能满足我们的要求。除了 <code>DispatcherServlet</code> 以外，我们还可能需要额外的 <code>Servlet</code> 和 <code>Filter</code>，我们可能还需要对 <code>DispatcherServlet</code> 本身做一些额外的配置；或者，如果我们需要将应用部署到 Servlet3.0 之前的容器中，那么还需要将 <code>DispatcherServlet</code> 配置到传统的 web.xml 中。</p><h2 id="自定义-DispatcherServlet-配置"><a href="#自定义-DispatcherServlet-配置" class="headerlink" title="自定义 DispatcherServlet 配置"></a>自定义 DispatcherServlet 配置</h2><p>在 <code>SpittrWebAppInitializer</code> （第五章）中继承了 <code>AbstractAnnotationConfigDispatcherServletInitializer</code> ，还有其他可重载的方法 <code>customizeRegistration()</code>。</p><p>在 <code>AbstractAnnotationConfigDispatcherServletInitializer</code> 将 <code>DispatcherServlet</code> 注册到 <code>Servlet</code> 容器中之后，就会调用 <code>customizeRegistration()</code>，并将 <code>Servlet</code> 注册后得到的 <code>Registration.Dynamic</code><br>传递进来。通过重载 <code>customizeRegistration()</code> 方法，我们可以对 <code>DispatcherServlet</code> 进行额外的配置。</p><p>如果计划使用 Servlet 3.0 对 multipart 配置的支持，那么需要使用 <code>DispatcherServlet</code> 的 <code>registration</code> 来启用 <code>multipart</code> 请求。我们可以重载 <code>customizeRegistration()</code> 方法来设置 <code>MultipartConfigElement</code>，如下所示：</p><pre><code class="java">@Overrideprotected void customizeRegistration(ServletRegistration.Dynamic registration) {    registration.setMultipartConfig(new MultipartConfigElement(&quot;/tmp/spittr/uploads&quot;));}</code></pre><p>借助 <code>customizeRegistration()</code> 方法中的 <code>ServletRegistration.Dynamic</code>，我们能够完成多项任务，包括通过调用 <code>setLoadOnStartup()</code> 设置 <code>load-on-startup</code> 优先级，通过 <code>setInitParameter()</code> 设置初始化参数，通过调用 <code>setMultipartConfig()</code> 配置 Servlet3.0 对 <code>multipart</code> 的支持。在前面的样例中，我们设置了对 <code>multipart</code> 的支持，将上传文件的临时存储目录设置在 &quot;tmpspittr/uploads&quot; 中。</p><h2 id="添加其他的-Servlet-和-Filter"><a href="#添加其他的-Servlet-和-Filter" class="headerlink" title="添加其他的 Servlet 和 Filter"></a>添加其他的 Servlet 和 Filter</h2><p>按照 <code>AbstractAnnotationConfigDispatcherServletInitializer</code> 的定义，它会创建 <code>DispatcherServlet</code> 和 <code>ContextLoaderListener</code>。</p><p>如果我们想往 Web 容器中注册其他组件的话，只需创建一个新的初始化器就可以了。最简单的方式就是实现 Spring 的 <code>WebApplicationInitializer</code> 接口。</p><pre><code class="java">// 通过实现 WebApplicationInitializer 来注册 Servletpublic class MyServletInitializer implements WebApplicationInitializer {    @Override    public void onStartup(ServletContext servletContext) throws ServletException {        // 注册 Servlet        ServletRegistration.Dynamic myServlet = servletContext.addServlet(&quot;myServlet&quot;, MyServlet.getClass());        // 映射 Servlet        myServlet.addMapping(&quot;/custom/**&quot;);    }}</code></pre><pre><code class="java">// 注册 Filter 的 WebApplicationInitializer@Overridepublic void onStartup(ServletContext servletContext) throws ServletException {    javax.servlet.FilterRegistration.Dynamic filter = servletContext.addFilter(&quot;myFilter&quot;, MyFilter.class);    filter.addMappingForUrlPatterns(null, false, &quot;/custom/*&quot;);}</code></pre><p>如果你只是注册 <code>Filter</code>，并且该 <code>Filter</code> <strong>只会映射到</strong> <code>DispatcherServlet</code> 上的话，只需重<br>载 <code>AbstractAnnotationConfigDispatcherServletInitializer</code> 的 <code>getServletFilters()</code> 方法。</p><pre><code class="java">@Overrideprotected Filter[] getServletFilters() {    return new Filter[] { new MyFilter() };  // 可以返回任意数量的 Filter}</code></pre><h2 id="在-web-xml-中声明-DispatcherServlet"><a href="#在-web-xml-中声明-DispatcherServlet" class="headerlink" title="在 web.xml 中声明 DispatcherServlet"></a>在 web.xml 中声明 DispatcherServlet</h2><h3 id="在-web-xml-中搭建-Spring-MVC"><a href="#在-web-xml-中搭建-Spring-MVC" class="headerlink" title="在 web.xml 中搭建 Spring MVC"></a>在 web.xml 中搭建 Spring MVC</h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app version=&quot;2.5&quot;    xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee        http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;&gt;    &lt;context-param&gt;        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;        &lt;!-- 指定了一个 XML 文件的地址，这个文件定义了根应用上下文，它会被 ContextLoaderListener 加载。从中加载bean定义 --&gt;        &lt;param-value&gt;/WEB-INF/spring/root-context.xml&lt;/param-value&gt;    &lt;/context-param&gt;    &lt;listener&gt;        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;    &lt;/listener&gt;    &lt;servlet&gt;        &lt;servlet-name&gt;appServlet&lt;/servlet-name&gt;        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;        &lt;!-- DispatcherServlet 会根据 Servlet 的名字找到一个文件，并基于该文件加载应用上下文。 --&gt;        &lt;!-- contextConfigLocation 不是必须的，如果不配置默认在：WEB-INF/servletName -servlet.xml --&gt;        &lt;init-param&gt;            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;            &lt;param-value&gt;/WEB-INF/spring/appServlet/servlet-context.xml&lt;/param-value&gt;        &lt;/init-param&gt;        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;    &lt;/servlet&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;appServlet&lt;/servlet-name&gt;        &lt;url-pattern&gt;/&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;&lt;/web-app&gt;</code></pre><h3 id="设置-web-xml-使用基于-Java-的配置"><a href="#设置-web-xml-使用基于-Java-的配置" class="headerlink" title="设置 web.xml 使用基于 Java 的配置"></a>设置 web.xml 使用基于 Java 的配置</h3><p>在本书中的大部分内容中，我们都更倾向于使用 Java 配置而不是 XML 配置。因此，我们需要让 Spring MVC 在启动的时候，从带有 <code>@Configuration</code> 注解的类上加载配置。</p><p>要在 Spring MVC 中使用基于 Java 的配置，我们需要告诉 <code>DispatcherServlet</code> 和 <code>ContextLoaderListener</code> 使用 <code>AnnotationConfigWebApplicationContext</code>，这是一个 <code>WebApplicationContext</code> 的实现类，</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app version=&quot;2.5&quot;         xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee            http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;&gt;    &lt;context-param&gt;        &lt;param-name&gt;contextClass&lt;/param-name&gt;        &lt;!-- 使用 Java 配置 --&gt;        &lt;param-value&gt;            org.springframework.web.context.support.AnnotationConfigWebApplicationContext        &lt;/param-value&gt;    &lt;/context-param&gt;    &lt;context-param&gt;        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;        &lt;!-- 指定根配置类 --&gt;        &lt;param-value&gt;com.habuma.spitter.config.RootConfig&lt;/param-value&gt;    &lt;/context-param&gt;    &lt;listener&gt;        &lt;listener-class&gt;            org.springframework.web.context.ContextLoaderListener        &lt;/listener-class&gt;    &lt;/listener&gt;    &lt;servlet&gt;        &lt;servlet-name&gt;appServlet&lt;/servlet-name&gt;        &lt;servlet-class&gt;            org.springframework.web.servlet.DispatcherServlet        &lt;/servlet-class&gt;        &lt;init-param&gt;            &lt;param-name&gt;contextClass&lt;/param-name&gt;            &lt;!-- 使用 Java 配置 --&gt;            &lt;param-value&gt;                org.springframework.web.context.support.AnnotationConfigWebApplicationContext            &lt;/param-value&gt;        &lt;/init-param&gt;        &lt;init-param&gt;            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;            &lt;!-- 指定 DispatcherServlet 配置类 --&gt;            &lt;param-value&gt;                com.habuma.spitter.config.WebConfigConfig            &lt;/param-value&gt;        &lt;/init-param&gt;        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;    &lt;/servlet&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;appServlet&lt;/servlet-name&gt;        &lt;url-pattern&gt;/&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;&lt;/web-app&gt;</code></pre><h1 id="处理-multipart-形式的数据"><a href="#处理-multipart-形式的数据" class="headerlink" title="处理 multipart 形式的数据"></a>处理 multipart 形式的数据</h1><h2 id="配置-multipart-解析器"><a href="#配置-multipart-解析器" class="headerlink" title="配置 multipart 解析器"></a>配置 multipart 解析器</h2><p><code>DispatcherServlet</code> 并没有实现任何解析 <code>multipart</code> 请求数据的功能。它将该任务委托给了 Spring 中 <code>MultipartResolver</code> 策略接口的实现，通过这个实现类来解析 <code>multipart</code> 请求中的内容。从 Spring 3.1 开始，Spring 内置了两个 <code>MultipartResolver</code> 的实现供我们选择：</p><ul><li><code>CommonsMultipartResolver</code>：使用 <code>Jakarta Commons FileUpload</code> 解析 <code>multipart</code> 请求；</li><li><code>StandardServletMultipartResolver</code>：依赖于 <code>Servlet 3.0</code> 对 <code>multipart</code> 请求的支持<br>（始于Spring 3.1），优选方案，不需要依赖任何其他的项目。</li></ul><h3 id="使用-Servlet-3-0-解析-multipart-请求"><a href="#使用-Servlet-3-0-解析-multipart-请求" class="headerlink" title="使用 Servlet 3.0 解析 multipart 请求"></a>使用 Servlet 3.0 解析 multipart 请求</h3><p>兼容 Servlet 3.0 的 <code>StandardServletMultipartResolver</code> 没有构造器参数，也没有要设置的属性。这样，在 Spring 应用上下文中，将其声明为 bean 就会非常简单，如下所示：</p><pre><code class="java">@Beanpublic MultipartResolver multipartResolver() throws IOException {    return new StandardServletMultipartResolver();}</code></pre><p>我们必须要在 web.xml 或 Servlet 初始化类中，将 multipart 的具体细节作为 DispatcherServlet 配置的一部分。</p><p>如果我们采用 <code>Servlet</code> 初始化类的方式来配置 <code>DispatcherServlet</code> 的话，这个初始化类应该已经实现了 <code>WebApplicationInitializer</code>，那我们可以在 <code>Servlet</code> <code>registration</code> 上调用 <code>setMultipartConfig()</code> 方法，传入一个 <code>MultipartConfigElement</code> 实例。如下是最基本的 <code>DispatcherServlet</code> <code>multipart</code> 配置，它将临时路径设置为 <code>tmp/spittr/uploads</code>：</p><pre><code class="java">DispatcherServlet ds = new DispatcherServlet();Dynamic registration = context.addServlet(&quot;appServlet&quot;, ds);registration.addMapping(&quot;/&quot;);registration.setMultipartConfig(new MultipartConfigElement(&quot;/tmp/spittr/uploads&quot;));</code></pre><p>如果我们配置 <code>DispatcherServlet</code> 的 Servlet 初始化类继承了 <code>AbstractAnnotationConfigDispatcherServletInitializer</code> 或 <code>AbstractDispatcherServletInitializer</code> 的话，那么我们不会直接创建 <code>DispatcherServlet</code> 实例并将其注册到 Servlet 上下文中。这样的话，将不会有对 <code>Dynamic Servlet registration</code> 的引用供我们使用了。但是，我们可以通过重载 <code>customizeRegistration()</code> 方法（它会得到一个 <code>Dynamic</code> 作为参数）来配置 <code>multipart</code> 的具体细节：</p><pre><code class="java">@Overrideprotected void customizeRegistration(Dynamic registration) {    registration.setMultipartConfig(new MultipartConfigElement(&quot;/tmp/spittr/uploads&quot;));}</code></pre><p>到目前为止，我们所使用是只有一个参数的 <code>MultipartConfigElement</code> 构造器，这个参数指定的是文件系统中的一个绝对目录，上传文件将会临时写入该目录中。但是，我们还可以通过其他的构造器来限制上传文件的大小。除了临时路径的位置，其他的构造器所能接受的参数如下：</p><ul><li>上传文件的最大容量（以字节为单位）。默认是没有限制的。</li><li>整个 multipart 请求的最大容量（以字节为单位），不会关心有多少个 part 以及每个 part 的大小。默认是没有限制的。</li><li>在上传的过程中，如果文件大小达到了一个指定最大容量（以字节为单位），将会写入到临时文件路径中。默认值为 0，也就是所有上传的文件都会写入到磁盘上。</li></ul><pre><code class="java">// 限制文件的大小不超过2MB，整个请求不超过4MB，而且所有的文件都要写到磁盘中@Overrideprotected void customizeRegistration(Dynamic registration) {    registration.setMultipartConfig(new MultipartConfigElement(&quot;/tmp/spittr/uploads&quot;, 2097152, 4194304, 0));}</code></pre><pre><code class="xml">&lt;!-- 使用 web.xml 来配置 MultipartConfigElement --&gt;&lt;servlet&gt;    &lt;servlet-name&gt;appServlet&lt;/servlet-name&gt;    &lt;servlet-class&gt;        org.springframework.web.servlet.DispatcherServlet    &lt;/servlet-class&gt;    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;    &lt;multipart-config&gt;        &lt;location&gt;/tmp/spittr/uploads&lt;/location&gt;        &lt;max-file-size&gt;2097152&lt;/max-file-size&gt;        &lt;max-request-size&gt;4194304&lt;/max-request-size&gt;    &lt;/multipart-config&gt;&lt;/servlet&gt;</code></pre><h3 id="配置-Jakarta-Commons-FileUpload-multipart-解析器"><a href="#配置-Jakarta-Commons-FileUpload-multipart-解析器" class="headerlink" title="配置 Jakarta Commons FileUpload multipart 解析器"></a>配置 Jakarta Commons FileUpload multipart 解析器</h3><p><code>通常来讲，StandardServletMultipartResolver</code> 会是最佳的选择</p><p>Spring 内置了 <code>CommonsMultipartResolver</code>，可以作为 <code>StandardServletMultipartResolver</code> 的替代方案。</p><p>将 <code>CommonsMultipartResolver</code> 声明为 Spring bean 的最简单方式如下：</p><pre><code class="java">@Beanpublic MultipartResolver multipartResolver() {    return new CommonsMultipartResolver();}</code></pre><p><code>CommonsMultipartResolver</code> 不会强制要求设置临时文件路径。默认情况下，这个路径就是 Servlet 容器的临时目录。不过，通过设置 <code>uploadTempDir</code> 属性，我们可以将其指定为一个不同的位置，与<code>MultipartConfigElement</code> 有所不同，我们<strong>无法设定 multipart 请求整体的最大容量</strong>。</p><pre><code class="java">@Beanpublic MultipartResolver multipartResolver() throws IOException {    CommonsMultipartResolver multipartResolver = new CommonsMultipartResolver();    multipartResolver.setUploadTempDir(new FileSystemResource(&quot;/tmp/spittr/uploads&quot;));    multipartResolver.setMaxUploadSize(2097152);  // 最大的文件容量设置为2MB    multipartResolver.setMaxInMemorySize(0);  // 最大的内存大小设置为0字节    return multipartResolver;}</code></pre><h2 id="处理-multipart-请求"><a href="#处理-multipart-请求" class="headerlink" title="处理 multipart 请求"></a>处理 multipart 请求</h2><pre><code class="html">&lt;form method=&quot;POST&quot; th:object=&quot;${spitter}&quot; enctype=&quot;multipart/form-data&quot;&gt;...    &lt;label&gt;Profile Picture&lt;/label&gt;:    &lt;input type=&quot;file&quot; name=&quot;profilePicture&quot; accept=&quot;image/jpeg,image/png,image/gif&quot; /&gt;&lt;br/&gt;...&lt;/form&gt;</code></pre><p>修改 <code>processRegistration()</code> 方法，使其能够接受上传的图片。其中一种方式是添加 byte 数组参数，并为其添加 <code>@RequestPart</code> 注解。如下为示例：</p><pre><code class="java">@RequestMapping(value=&quot;/register&quot;, method=POST)public String processRegistration(        // 如果用户提交表单的时候没有选择文件，那么这个数组会是空（而不是null）。        @RequestPart(&quot;profilePicture&quot;) byte[] profilePicture,        @Valid Spitter spitter, Errors errors) {    ...}</code></pre><h3 id="接受-MultipartFile"><a href="#接受-MultipartFile" class="headerlink" title="接受 MultipartFile"></a>接受 MultipartFile</h3><pre><code class="java">// Spring 所提供的 MultipartFile 接口，用来处理上传的文件public interface MultipartFile {    String getName();    String getOriginalFilename();  // 原始的文件名    String getContentType();  // 内容类型    boolean isEmpty();    long getSize();  // 大小    byte[] getBytes() throws IOException;    InputStream getInputStream() throws IOException;  // 将文件数据以流的方式进行读取    void transferTo(File dest) throws IOException;  // 将上传的文件写入到文件系统中    // file.transferTo(new File(&quot;/data/spittr/&quot; + file.getOriginalFilename()));}</code></pre><h3 id="以-Part-的形式接受上传的文件"><a href="#以-Part-的形式接受上传的文件" class="headerlink" title="以 Part 的形式接受上传的文件"></a>以 Part 的形式接受上传的文件</h3><p>如果你需要将应用部署到 Servlet 3.0 的容器中，那么会有 MultipartFile 的一个替代方案。Spring MVC 也能接受 <code>javax.servlet.http.Part</code> 作为控制器方法的参数。</p><pre><code class="java">@RequestMapping(value=&quot;/register&quot;, method=POST)public String processRegistration(        @RequestPart(&quot;profilePicture&quot;) Part profilePicture,        @Valid Spitter spitter, Errors errors) {    ...}</code></pre><p><code>Part</code> 方法的名称与 <code>MultipartFile</code> 方法的名称是完全相同的。有一些比较类似，但是稍有差异，比如 <code>getSubmittedFileName()</code> 对应于 <code>getOriginalFilename()</code>。类似地，<code>write()</code> 对应于 <code>transferTo()</code></p><pre><code class="java">public interface Part {    public InputStream getInputStream() throws IOException;    public String getContentType();    public String getName();    public String getSubmittedFileName();    public long getSize();    public void write(String fileName) throws IOException;    public void delete() throws IOException;    public String getHeader(String name);    public Collection&lt;String&gt; getHeaders(String name);    public Collection&lt;String&gt; getHeaderNames();}</code></pre><p>如果在编写控制器方法的时候，通过 <code>Part</code> 参数的形式接受文件上传，那么就没有必要配置 <code>MultipartResolver</code> 了。只有使用 <code>MultipartFile</code> 的时候，我们才需要 <code>MultipartResolver</code>。</p><h1 id="处理异常"><a href="#处理异常" class="headerlink" title="处理异常"></a>处理异常</h1><p>Spring 提供了多种方式将异常转换为响应：</p><ul><li>特定的 Spring 异常将会自动映射为指定的 HTTP 状态码；</li><li>异常上可以添加 <code>@ResponseStatus</code> 注解，从而将其映射为某一个 HTTP 状态码；</li><li>在方法上可以添加 <code>@ExceptionHandler</code> 注解，使其用来处理异常。</li></ul><h2 id="将异常映射为-HTTP-状态码"><a href="#将异常映射为-HTTP-状态码" class="headerlink" title="将异常映射为 HTTP 状态码"></a>将异常映射为 HTTP 状态码</h2><table><thead><tr><th>Spring 异常</th><th>HTTP 状态码</th></tr></thead><tbody><tr><td>BindException</td><td>400 - Bad Request</td></tr><tr><td>ConversionNotSupportedException</td><td>500 - Internal Server Error</td></tr><tr><td>HttpMediaTypeNotAcceptableException</td><td>406 - Not Acceptable</td></tr><tr><td>HttpMediaTypeNotSupportedException</td><td>415 - Unsupported Media Type</td></tr><tr><td>HttpMessageNotReadableException</td><td>400 - Bad Request</td></tr><tr><td>HttpMessageNotWritableException</td><td>500 - Internal Server Error</td></tr><tr><td>HttpRequestMethodNotSupportedException</td><td>405 - Method Not Allowed</td></tr><tr><td>MethodArgumentNotValidException</td><td>400 - Bad Request</td></tr><tr><td>MissingServletRequestParameterException</td><td>400 - Bad Request</td></tr><tr><td>MissingServletRequestPartException</td><td>400 - Bad Request</td></tr><tr><td>NoSuchRequestHandlingMethodException</td><td>404 - Not Found</td></tr><tr><td>TypeMismatchException</td><td>400 - Bad Request</td></tr></tbody></table><p><code>@ResponseStatus</code> 注解：将异常映射为特定的状态码</p><pre><code class="java">@ResponseStatus(value=HttpStatus.NOT_FOUND, reason=&quot;Spittle Not Found&quot;)public class SpittleNotFoundException extends RuntimeException {}</code></pre><h2 id="编写异常处理的方法"><a href="#编写异常处理的方法" class="headerlink" title="编写异常处理的方法"></a>编写异常处理的方法</h2><p>如果响应中不仅包含状态码，还要包含所产生的错误信息，需要按照请求的方式来处理异常。</p><pre><code class="java">@RequestMapping(method=RequestMethod.POST)public String saveSpittle(SpittleForm form, Model model) {  try {    spittleRepository.save(new Spittle(null, form.getMessage(), new Date(),        form.getLongitude(), form.getLatitude()));    return &quot;redirect:/spittles&quot;;  } catch (DuplicateSpittleException e) {     //捕获异常    return &quot;error/duplicate&quot;;  }}</code></pre><p>运行起来没什么问题，但是这个方法有些复杂。该方法可以有两个路径，每个路径会有不同的输出。如果能让 saveSpittle() 方法只关注正确的路径，而让其他方法处理异常的话，那么它就能简单一些。</p><pre><code class="java">// 首先将 saveSpittle() 方法中的异常处理方法剥离掉@RequestMapping(method=RequestMethod.POST)public String saveSpittle(SpittleForm form, Model model) {    spittleRepository.save(new Spittle(null, form.getMessage(), new Date(),        form.getLongitude(), form.getLatitude()));    return &quot;redirect:/spittles&quot;;    return &quot;error/duplicate&quot;;}</code></pre><p>它只关注成功保存Spittle的情况，所以只需要一个执行路径，很容易理解和测试。</p><pre><code class="java">// 为 SpittleController 添加一个新的方法，它会处理抛出 DuplicateSpittleException 的情况：@ExceptionHandler(DuplicateSpittleException.class)public String handleNotFound() {  return &quot;error/duplicate&quot;;}</code></pre><p>方法上加上 <code>@ExceptionHandler</code> 注解后，当方法抛出异常的时候，将委托该方法来处理，它能够处理<strong>同一个控制器</strong>中所有的方法抛出的异常。</p><h1 id="为控制器添加通知"><a href="#为控制器添加通知" class="headerlink" title="为控制器添加通知"></a>为控制器添加通知</h1><p>如果多个控制器类中都会抛出某个特定的异常，那么你可能会发现要在所有的控制器方法中重复相同的 <code>@ExceptionHandler</code> 方法。或者，为了避免重复，我们会创建一个基础的控制器类，所有控制器类要扩展这个类，从而继承通用的 <code>@ExceptionHandler</code> 方法。</p><p>Spring 3.2 为这类问题引入了一个新的解决方案：控制器通知。控制器通知（controller advice）是任意带有 <code>@ControllerAdvice</code> 注解的类，这个类会包含一个或多个如下类型的方法：</p><ul><li><code>@ExceptionHandler</code> 注解标注的方法；</li><li><code>@InitBinder</code> 注解标注的方法；</li><li><code>@ModelAttribute</code> 注解标注的方法。</li></ul><p>在带有 <code>@ControllerAdvice</code> 注解的类中，以上所述的这些方法会运用到整个应用程序所有控制器中带有 <code>@RequestMapping</code> 注解的方法上。</p><p><code>@ControllerAdvice</code> 注解本身已经使用了 <code>@Component</code>，因此 <code>@ControllerAdvice</code> 注解所标注的类将会自动被组件扫描获取到，就像带有 <code>@Component</code> 注解的类一样。</p><p><code>@ControllerAdvice</code> 最为实用的一个场景就是将所有的 <code>@ExceptionHandler</code> 方法收集到一个类中，这样所有控制器的异常就能在一个地方进行一致的处理。例如，我们想将 <code>DuplicateSpittleException</code> 的处理方法用到整个应用程序的所有控制器上。如下的程序清单展现的 <code>AppWideExceptionHandler</code> 就能完成这一任务，这是一个带有 <code>@ControllerAdvice</code> 注解的类。</p><pre><code class="java">@ControllerAdvicepublic class AppWideExceptionHandler {    @ExceptionHandler(DuplicateSpittleException.class)    public String duplicateSpittleHandler() {        return &quot;error/duplicate&quot;;    }}</code></pre><p>现在，如果任意的控制器方法抛出了 <code>DuplicateSpittleException</code>，不管这个方法位于哪个控制器中，都会调用这个 <code>duplicateSpittleHandler()</code> 方法来处理异常。</p><h1 id="跨重定向请求传递数据"><a href="#跨重定向请求传递数据" class="headerlink" title="跨重定向请求传递数据"></a>跨重定向请求传递数据</h1><h2 id="通过-URL-模板进行重定向"><a href="#通过-URL-模板进行重定向" class="headerlink" title="通过 URL 模板进行重定向"></a>通过 URL 模板进行重定向</h2><pre><code class="java">@RequestMapping(value=&quot;/register&quot;, method=POST)public String processRegistration(Spitter spitter, Model model) {    spitterRepository.save(spitter);    model.addAttribute(&quot;username&quot;, spitter.getUsername());    model.addAttribute(&quot;spitterId&quot;, spitter.getId());    return &quot;redirect:/spitter/{username}&quot;;}</code></pre><p>因为模型中的 <code>spitterId</code> 属性没有匹配重定向 URL 中的任何占位符，所以它<strong>会自动以查询参数的形式附加到重定向 URL 上</strong>。</p><p>如果 username 属性的值是 habuma 并且 spitterId 属性的值是 42，那么结果得到的重定向 URL 路径将会是 <code>spitter/habuma?spitterId=42</code> 。</p><p><strong>只能用来发送简单的值</strong>，如 String 和数字的值。在 URL 中，并没有办法发送更为复杂的值，但这正是 flash 属性能够提供帮助的领域。</p><h1 id="使用-flash-属性"><a href="#使用-flash-属性" class="headerlink" title="使用 flash 属性"></a>使用 flash 属性</h1><p>假设我们不想在重定向中发送 username 或 ID 了，而是要发送实际的 Spitter 对象。</p><p>有个方案是将 Spitter 放到会话中。会话能够长期存在，并且能够跨多个请求。所以我们可以在重定向发生之前将 Spitter 放到会话中，并在重定向后，从会话中将其取出。当然，我们还要负责在重定向后在会话中将其清理掉。</p><p>实际上，Spring 也认为将跨重定向存活的数据放到会话中是一个很不错的方式。Spring 提供了将数据发送为 flash 属性（flash attribute）的功能。按照定义，flash 属性会一直携带这些数据直到下一次请求，然后才会消失。</p><p>Spring 提供了通过 <code>RedirectAttributes</code> 设置 flash 属性的方法，这是Spring 3.1引入的 <code>Model</code> 的一个子接口。<code>RedirectAttributes</code> 提供了 <code>Model</code> 的所有功能，除此之外，还有几个方法是用来设置 flash 属性的。</p><p>具体来讲，<code>RedirectAttributes</code> 提供了一组 <code>addFlashAttribute()</code> 方法来添加 flash 属性。重新看一下 <code>processRegistration()</code> 方法，我们可以使用 <code>addFlashAttribute()</code> 将 Spitter 对象添加到模型中：</p><pre><code class="java">@RequestMapping(value=&quot;/register&quot;, method=POST)public String processRegistration(Spitter spitter, RedirectAttributes model) {    spitterRepository.save(spitter);    model.addAttribute(&quot;username&quot;, spitter.getUsername());    model.addFlashAttribute(&quot;spitter&quot;, spitter);    return &quot;redirect:/spitter/{username}&quot;;}</code></pre><pre><code class="java">@RequestMapping(value=&quot;/{username}&quot;, method=GET)public String showSpitterProfile(@PathVariable String username, Model model) {    检查是否存有 key 为 spitter 的 model 属性。如果有 spitter 属性，那就什么都不用做了。    if (!model.containsAttribute(&quot;spitter&quot;)) {        model.addAttribute(spitterRepository.findByUsername(username));    }    return &quot;profile&quot;;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Spring-MVC-配置的替代方案&quot;&gt;&lt;a href=&quot;#Spring-MVC-配置的替代方案&quot; class=&quot;headerlink&quot; title=&quot;Spring MVC 配置的替代方案&quot;&gt;&lt;/a&gt;Spring MVC 配置的替代方案&lt;/h1&gt;&lt;p&gt;在第 5 章
      
    
    </summary>
    
    
      <category term="Java" scheme="http://coolview.github.io/categories/Java/"/>
    
    
      <category term="Spring" scheme="http://coolview.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>《Spring 实战》笔记6：渲染 Web 视图</title>
    <link href="http://coolview.github.io/2019/08/06/Spring/%E3%80%8ASpring%20%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B06%EF%BC%9A%E6%B8%B2%E6%9F%93%20Web%20%E8%A7%86%E5%9B%BE/"/>
    <id>http://coolview.github.io/2019/08/06/Spring/%E3%80%8ASpring%20%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B06%EF%BC%9A%E6%B8%B2%E6%9F%93%20Web%20%E8%A7%86%E5%9B%BE/</id>
    <published>2019-08-06T12:31:36.000Z</published>
    <updated>2019-12-11T14:06:46.310Z</updated>
    
    <content type="html"><![CDATA[<h1 id="理解视图解析"><a href="#理解视图解析" class="headerlink" title="理解视图解析"></a>理解视图解析</h1><p>Spring MVC 定义了一个名为 <code>ViewResolver</code> 的接口，它大致如下所示：</p><pre><code class="java">public interface ViewResolver {    View resolveViewName(String viewName, Locale locale) throws Exception;}</code></pre><p>当给 <code>resolveViewName()</code> 方法传入一个视图名和 <code>Locale</code> 对象时，它会返回一个 <code>View</code> 实例。<code>View</code> 是另外一个接口，如下所示：</p><a id="more"></a><pre><code class="java">public interface View {    String getContentType();    void render(Map&lt;String, ?&gt; model,                HttpServletRequest request,                HttpServletResponse response) throws Exception;}</code></pre><p><code>View</code> 接口的任务就是接受模型以及 <code>Servlet</code> 的 <code>request</code> 和 <code>response</code> 对象，并将输出结果渲染到 <code>response</code> 中。</p><p>Spring 自带了 13 个视图解析器，能够将逻辑视图名转换为物理实现</p><ul><li><code>BeanNameViewResolver</code> 将视图解析为 Spring 应用上下文中的 bean，其中 bean 的 ID 与视图的名字相同</li><li><code>ContentNegotiatingViewResolver</code> 通过考虑客户端需要的内容类型来解析视图，委托给另外一个能够产生对应内容类型的视图解析器</li><li><code>FreeMarkerViewResolver</code> 将视图解析为 <code>FreeMarker</code> 模板</li><li><code>InternalResourceViewResolver</code> 将视图解析为 Web 应用的内部资源（一般为 JSP）</li><li><code>JasperReportsViewResolver</code> 将视图解析为 JasperReports 定义</li><li><code>ResourceBundleViewResolver</code> 将视图解析为资源 bundle（一般为属性文件）</li><li><code>TilesViewResolver</code> 将视图解析为 <code>Apache Tile</code> 定义，其中 tile ID 与视图名称相同。注意有两个不同的 <code>TilesViewResolver</code> 实现，分别对应于 Tiles 2.0 和 Tiles 3.0</li><li><code>UrlBasedViewResolver</code> 直接根据视图的名称解析视图，视图的名称会匹配一个物理视图的定义</li><li><code>VelocityLayoutViewResolver</code> 将视图解析为 <code>Velocity</code> 布局，从不同的 <code>Velocity</code> 模板中组合页面</li><li><code>VelocityViewResolver</code> 将视图解析为 <code>Velocity</code> 模板</li><li><code>XmlViewResolver</code> 将视图解析为特定 XML 文件中的 bean 定义。类似于 <code>BeanNameViewResolver</code></li><li><code>XsltViewResolver</code> 将视图解析为 XSLT 转换后的结果</li></ul><h1 id="创建-JSP-视图"><a href="#创建-JSP-视图" class="headerlink" title="创建 JSP 视图"></a>创建 JSP 视图</h1><p>Spring 提供了两种支持 JSP 视图的方式：</p><ul><li>InternalResourceViewResolver 会将视图名解析为 JSP 文件。另外，如果在你的 JSP 页面中使用了 JSP 标准标签库（JavaServer Pages Standard Tag Library，JSTL）的话，InternalResourceViewResolver 能够将视图名解析为 JstlView 形式的 JSP 文件，从而将 JSTL 本地化和资源 bundle 变量暴露给 JSTL 的格式化（formatting）和信息（message）标签。</li><li>Spring 提供了两个 JSP 标签库，一个用于表单到模型的绑定，另一个提供了通用的工具类特性。</li></ul><h2 id="配置适用于-JSP-的视图解析器"><a href="#配置适用于-JSP-的视图解析器" class="headerlink" title="配置适用于 JSP 的视图解析器"></a>配置适用于 JSP 的视图解析器</h2><p>InternalResourceViewResolver 遵循一种约定，会在视图名上添加前缀和后缀，进而确定一个 Web 应用中视图资源的物理路径。</p><pre><code class="java">@Beanpublic ViewResolver viewResolver() {  InternalResourceVIewResolver resolver = new InternalResourceVIewResolver();  resolver.setPrefix(&quot;WEB-INF/view&quot;);  resolver.setSuffix(&quot;.jsp&quot;)  return resolver;}</code></pre><p>作为替代方法，如果你更喜欢基于 XML 的 Spring 配置，那么可以按照如下方式配置 <code>InternalResourceVIewResolver</code></p><pre><code class="xml">&lt;bean id=&quot;viewResolver&quot;  class=&quot;org.springframework.web.servlet.view.InternalResourceVIewResolver&quot;  p:prefix=&quot;/WEB-INF/view&quot;  p:suffix=&quot;.jsp&quot;</code></pre><p>JSTL 的格式化标签需要一个 <code>Locale</code> 对象，以便于恰当地格式化地域相关的值，如日期和货币。信息标签可以借助 Spring 的信息资源和 Locale，从而选择适当的信息渲染到 HTML 之中。通过解析 <code>JstlView</code>，JSTL 能够获得 Locale 对象以及 Spring 中配置的信息资源。</p><p>如果想让 InternalResourceViewResolver 将视图解析为 JstlView，而不是 InternalResourceView 的话，那么我们只需设置它的 viewClass 属性即可：</p><pre><code class="java">@Beanpublic ViewResolver viewResolver() {  InternalResourceVIewResolver resolver = new InternalResourceVIewResolver();  resolver.setPrefix(&quot;WEB-INF/view&quot;);  resolver.setSuffix(&quot;.jsp&quot;)  resolver.setViewClass(&quot;org.springframework.web.servlet.view.JstlView.class&quot;)  return resolver;}</code></pre><p>同样，我们也可以在 XMl 完成这一任务</p><pre><code class="xml">&lt;bean id=&quot;viewResolver&quot;  class=&quot;org.springframework.web.servlet.view.InternalResourceVIewResolver&quot;  p:prefix=&quot;/WEB-INF/view&quot;  p:suffix=&quot;.jsp&quot;  p:viewClass=&quot;org.springframework.web.servlet.view.JstlView.class&quot;</code></pre><h2 id="使用-Spring-的-JSP-库"><a href="#使用-Spring-的-JSP-库" class="headerlink" title="使用 Spring 的 JSP 库"></a>使用 Spring 的 JSP 库</h2><p>用处不多。</p><h3 id="将表单绑定到模型上"><a href="#将表单绑定到模型上" class="headerlink" title="将表单绑定到模型上"></a>将表单绑定到模型上</h3><p>需要在JSP页面中对其进行声明</p><pre><code class="jsp">&lt;%@ taglib uri=&quot;http://www.springframework.org/tags/form&quot; prefix=&quot;sf&quot; %&gt;</code></pre><ul><li><code>&lt;sf:checkbox&gt;</code></li><li><code>&lt;sf:checkboxes&gt;</code></li><li><code>&lt;sf:errors&gt;</code></li><li><code>&lt;sf:form&gt;</code></li><li><code>&lt;sf:hidden&gt;</code></li><li><code>&lt;sf:input&gt;</code></li><li><code>&lt;sf:lable&gt;</code></li><li><code>&lt;sf:option&gt;</code></li><li><code>&lt;sf:password&gt;</code></li><li><code>&lt;sf:radiobutton&gt;</code></li><li><code>&lt;sf:radiobuttons&gt;</code></li><li><code>&lt;sf:select&gt;</code></li><li><code>&lt;sf:textarea&gt;</code></li><li><code>&lt;sf:radilbutton&gt;</code></li></ul><pre><code class="xml">&lt;sf:form method=&quot;POST&quot; comandName=&quot;spitter&quot;&gt;  First Name: &lt;sf:input path=&quot;firstName&quot; /&gt;&lt;br/&gt;  Last Name: &lt;sf:input path=&quot;lastName&quot; /&gt;&lt;br/&gt;  Email: &lt;sf:input path=&quot;email&quot; /&gt;&lt;br/&gt;  Username: &lt;sf:input path=&quot;username&quot; /&gt;&lt;br/&gt;  Password: &lt;sf:password path=&quot;password&quot; /&gt;&lt;br/&gt;  &lt;sf:input type=&quot;submit&quot; value=&quot;Register&quot; /&gt;&lt;/sf:form&gt;</code></pre><p><code>&lt;sf:form&gt;</code> 会渲染一个 HTMl <code>&lt;form&gt;</code> 标签，<strong>但它也会通过 <code>commandName</code> 属性构建针对某个模型对象的上下文信息，在其他的表单绑定标签中，会引用这个模型对象的属性</strong></p><p>我们将 <code>commandName</code> 属性设置为spitter。因此，在模型中必须要有一个 key 为 spitter 的对象，否则的话，表单不能正常渲染（会出现 JSP 错误）</p><p>从 Spring3.1 开始 <code>&lt;sf:input&gt;</code> 标签能够允许我们指定 type 属性，这样的话，除了其他可选的类型外，还能指定 HTML5 特定类型的文本域，如 date、range、email。我们可以按照如下方式指定 email 域：</p><pre><code class="xml">Email: &lt;sf:input path=&quot;email&quot; type=&quot;email&quot;/&gt; &lt;br/&gt;</code></pre><p>使用 <code>&lt;sf:errors&gt;</code></p><pre><code class="xml">&lt;sf:form method=&quot;POST&quot; commandName=&quot;spitter&quot; &gt;    &lt;sf:input path=&quot;firstName&quot; /&gt;&lt;br/&gt;    &lt;sf:errors path=&quot;firstName&quot; cssErrorClass=&quot;error&quot; /&gt;    ......&lt;/sf:form&gt;</code></pre><pre><code class="java">@NotNull@Size(min=5, max=16, message=&quot;{username.size}&quot;)private String username;.......@NotNull@Size(min=2, max=30, message=&quot;{lastName.size}&quot;)private String lastName;</code></pre><p>我们将其 <code>@Size</code> 注解的 message 设置为一个字符串，用大括号括起来的。没有没有大括号的话，message 中的值将会作为展现给用户的错误信息，使用了就用文件中某个一个属性，该属性包含了实际的信息。</p><p>创建一个 <code>ValidationMessages.properties</code> 的文件，并将其放到根路径之下。</p><pre><code class="ini">firstName.size=First name must be between {min} and {max} characters long.lastName.size=Last name must be between {min} and {max} characters long.</code></pre><h3 id="Spring-通用的标签库"><a href="#Spring-通用的标签库" class="headerlink" title="Spring 通用的标签库"></a>Spring 通用的标签库</h3><p>需要在页面首页对其进行声明</p><pre><code class="xml">&lt;%@ taglib uri=&quot;http://www.springframework.org.tags&quot; prefix=&#39;s&#39;%&gt;</code></pre><ul><li><code>&lt;s:escapeBody&gt;</code> 将标签体中的内容进行 HTML 和 / 或 JavaScript 转义，包裹要转义内容，标签属性加上  <code>htmlEscape=&quot;true&quot;</code>   <code>javaScriptEscape=&quot;true</code></li><li><code>&lt;s:hasBindErrors&gt;</code> 根据指定模型对象（在请求属性中）是否有绑定错误，有条件地渲染内容</li><li><code>&lt;s:htmlEscape&gt;</code> 为当前页面设置默认的 HTML 转义值</li><li><code>&lt;s:message&gt;</code> 根据给定的编码获取信息，然后要么进行渲染（默认行为），要么将其设置为页面作用域、请求作用域、会话作用域或应用作用域的变量（通过使用 var 和 scope 属性实现）</li><li><code>&lt;s:theme&gt;</code> 根据给定的编码获取主题信息，然后要么进行渲染（默认行为），要么将其设置为页面作用域、请求作用域、会话作用域或应用作用域的变量（通过使用 var 和 scope 属性实现）</li><li><code>&lt;s:transform&gt;</code> 使用命令对象的属性编辑器转换命令对象中不包含的属性</li><li><code>&lt;s:url&gt;</code> 创建相对于上下文的 URL，支持 URI 模板变量以及 HTML/XML/JavaScript 转义。可以渲染 URL（默认行为），也可以将其设置为页面作用域、请求作用域、会话作用域或应用作用域的变量（通过使用 var 和 scope 属性实现）</li><li><code>&lt;s:eval&gt;</code> 计算符合 Spring 表达式语言（Spring Expression Language，SpEL）语法的某个表达式的值，然后要么进行渲染（默认行为），要么将其设置为页面作用域、请求作用域、会话作用域或应用作用域的变量（通过使用 var 和 scope 属性实现）</li></ul><h1 id="使用-Apache-Tiles-视图定义布局"><a href="#使用-Apache-Tiles-视图定义布局" class="headerlink" title="使用 Apache Tiles 视图定义布局"></a>使用 Apache Tiles 视图定义布局</h1><h1 id="使用-Thymeleaf"><a href="#使用-Thymeleaf" class="headerlink" title="使用 Thymeleaf"></a>使用 Thymeleaf</h1><p><code>Thymeleaf</code> 模板是原生的，不依赖于标签库。它能在接受原始 HTML 的地方进行编辑和渲染。因为它没有与 Servlet 规范耦合，因此 <code>Thymeleaf</code> 模板能够进入 JSP 所无法涉足的领域。</p><h2 id="配置-Thymeleaf-视图解析器"><a href="#配置-Thymeleaf-视图解析器" class="headerlink" title="配置 Thymeleaf 视图解析器"></a>配置 Thymeleaf 视图解析器</h2><ul><li><code>ThymeleafViewResolver</code>：将逻辑视图名称解析为 Thymeleaf 模板视图；</li><li><code>SpringTemplateEngine</code>：处理模板并渲染结果；</li><li><code>TemplateResolver</code>：加载 Thymeleaf 模板。</li></ul><pre><code class="java">// 声明这些 bean 的 Java 配置@Beanpublic ViewResolver viewResolver(SpringTemplateEngine templateEngine) {    // Thymeleaf 视图解析器    ThymeleafViewResolver viewResolver = new ThymeleafViewResolver();    viewResolver.setTemplateEngine(templateEngine);    return viewResolver;}@Beanpublic TemplateEngine templateEngine(TemplateResolver templateResolver) {    // 模板引擎    SpringTemplateEngine templateEngine = new SpringTemplateEngine();    templateEngine.setTemplateResolver(templateResolver);    return templateEngine;}@Beanpublic TemplateResolver templateResolver() {  // 模板解析器    TemplateResolver templateResolver = new ServletContextTemplateResolver();    templateResolver.setPrefix(&quot;/WEB-INF/templates&quot;);    templateResolver.setSuffix(&quot;.html&quot;);    templateResolver.setTemplateMode(&quot;THML5&quot;);    return templateResolver;}</code></pre><pre><code class="xml">&lt;!-- 使用 XML 的方式，配置 Spring 对 Thymeleaf 的支持 --&gt;&lt;bean id=&quot;viewResolver&quot; class=&quot;org.thymeleaf.spring4.view.ThymeleafViewResolver&quot;        p:templateEngine-ref=&quot;templateEngine&quot; /&gt;&lt;bean id=&quot;templateEngine&quot; class=&quot;org.thymeleaf.spring4.SpringTemplateEngine&quot;        P:templateResolver-ref=&quot;templateResolver&quot; /&gt;&lt;bean id=&quot;templateResolver&quot; class=&quot;org.thymeleaf.templateresolver.ServletContextTemplateResolver&quot;        p:prefix=&quot;WEB-INF/templates/&quot;        p:suffix=&quot;.html&quot;        p:templateMode=&quot;HTML5&quot; /&gt; &lt;!-- 预期要解析的模板会渲染成 HTML5 输出 --&gt;</code></pre><h2 id="定义-Thymeleaf-模板"><a href="#定义-Thymeleaf-模板" class="headerlink" title="定义 Thymeleaf 模板"></a>定义 Thymeleaf 模板</h2><p>Thymeleaf 在很大程度上就是 HTML 文件，与 JSP 不同，它没有什么特殊的标签或标签库。Thymeleaf 之所以能够发挥作用，是因为它通过自定义的命名空间，为标准的 HTML 标签集合添加 Thymeleaf 属性。如下的程序清单展现了 home.html，也就是使用 Thymeleaf 命名空间的首页模板。</p><pre><code class="html">&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;      xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;  &lt;!--声明 Thymeleaf 命名空间--&gt;  &lt;head&gt;    &lt;title&gt;Spitter&lt;/title&gt;    &lt;link rel=&quot;stylesheet&quot;          type=&quot;text/css&quot;          th:href=&quot;@{/resources/style.css}&quot;&gt;&lt;/link&gt;  &lt;!--到样式表的 th:href 链接--&gt;  &lt;/head&gt;  &lt;body&gt;      &lt;h1&gt;Welcome to Spitter&lt;/h1&gt;      &lt;a th:href=&quot;@{/spittles}&quot;&gt;Spittles&lt;/a&gt; |      &lt;!--到页面的 th:herf 链接--&gt;      &lt;a th:href=&quot;@{/spitter/register}&quot;&gt;Register&lt;/a&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><p>使用了 <code>th:href</code> 属性，都用到了 <code>@{}</code> 表达式，用来计算相对于 URL 的路径</p><h3 id="借助-Thymeleaf-实现表单绑定"><a href="#借助-Thymeleaf-实现表单绑定" class="headerlink" title="借助 Thymeleaf 实现表单绑定"></a>借助 Thymeleaf 实现表单绑定</h3><pre><code class="xml">&lt;label th:class=&quot;${#fields.hasErrors(&#39;firstName&#39;)}? &#39;error&#39;&quot;&gt;First Name&lt;/label&gt;:&lt;input type=&quot;text&quot; th:field=&quot;*{firstName}&quot;    th:class=&quot;${#fields.hasErrors(&#39;firstName&#39;)}? &#39;error&#39;&quot; /&gt;&lt;br/&gt;</code></pre><p><code>th:class</code> 属性会渲染为一个 class 属性，它的值是根据给定的表达式计算得到的。在上面的这两个 <code>th:class</code> 属性中，它会直接检查 firstName 域有没有校验错误。如果有的话，class 属性在渲染时的值为 error。如果这个域没有错误的话，将不会渲染 class 属性。</p><p><code>&lt;input&gt;</code> 标签使用了 <code>th:field</code> 属性，用来引用后端对象的 firstName 域。这可能与你的预期有点差别。在 Thymeleaf 模板中，我们在很多情况下所使用的属性都对应于标准的 HTML 属性，因此貌似使用 <code>th:value</code> 属性来设置 <code>&lt;input&gt;</code> 标签的 value 属性才是合理的。</p><p>其实不然，因为我们是在将这个输入域绑定到后端对象的 firstName 属性上，因此使用 <code>th:field</code> 属性引用 firstName 域。通过使用 <code>th:field</code>，我们将 value 属性设置为 firstName 的值，同时还会将 name 属性设置为 firstName。</p><p>完整的注册表单模板</p><pre><code class="xml">&lt;form method=&quot;POST&quot; th:object=&quot;${spitter}&quot;&gt;  &lt;div class=&quot;errors&quot; th:if=&quot;${#fields.hasErrors(&#39;*&#39;)}&quot;&gt;    &lt;ul&gt;      &lt;li th:each=&quot;err : ${#fields.errors(&#39;*&#39;)}&quot;          th:text=&quot;${err}&quot;&gt;Input is incorrect&lt;/li&gt;    &lt;/ul&gt;  &lt;/div&gt;  &lt;label th:class=&quot;${#fields.hasErrors(&#39;firstName&#39;)}? &#39;error&#39;&quot;&gt;First Name&lt;/label&gt;:    &lt;input type=&quot;text&quot; th:field=&quot;*{firstName}&quot;           th:class=&quot;${#fields.hasErrors(&#39;firstName&#39;)}? &#39;error&#39;&quot; /&gt;&lt;br/&gt;  &lt;label th:class=&quot;${#fields.hasErrors(&#39;lastName&#39;)}? &#39;error&#39;&quot;&gt;Last Name&lt;/label&gt;:    &lt;input type=&quot;text&quot; th:field=&quot;*{lastName}&quot;           th:class=&quot;${#fields.hasErrors(&#39;lastName&#39;)}? &#39;error&#39;&quot; /&gt;&lt;br/&gt;  &lt;label th:class=&quot;${#fields.hasErrors(&#39;email&#39;)}? &#39;error&#39;&quot;&gt;Email&lt;/label&gt;:    &lt;input type=&quot;text&quot; th:field=&quot;*{email}&quot;           th:class=&quot;${#fields.hasErrors(&#39;email&#39;)}? &#39;error&#39;&quot; /&gt;&lt;br/&gt;  &lt;label th:class=&quot;${#fields.hasErrors(&#39;username&#39;)}? &#39;error&#39;&quot;&gt;Username&lt;/label&gt;:    &lt;input type=&quot;text&quot; th:field=&quot;*{username}&quot;           th:class=&quot;${#fields.hasErrors(&#39;username&#39;)}? &#39;error&#39;&quot; /&gt;&lt;br/&gt;  &lt;label th:class=&quot;${#fields.hasErrors(&#39;password&#39;)}? &#39;error&#39;&quot;&gt;Password&lt;/label&gt;:    &lt;input type=&quot;password&quot; th:field=&quot;*{password}&quot;           th:class=&quot;${#fields.hasErrors(&#39;password&#39;)}? &#39;error&#39;&quot; /&gt;&lt;br/&gt;  &lt;input type=&quot;submit&quot; value=&quot;Register&quot; /&gt;&lt;/form&gt;</code></pre><p>程序清单使用了相同的 Thymeleaf 属性和 <code>*{}</code> 表达式，为所有的表单域绑定后端对象。</p><p><code>&lt;div&gt;</code> 元素使用 <code>th:if</code> 属性来检查是否有校验错误。如果有的话，会渲染 <code>&lt;div&gt;</code>，否则的话，它将不会渲染。</p><p>在 <code>&lt;div&gt;</code> 中，会使用一个无顺序的列表来展现每项错误。<code>&lt;li&gt;</code> 标签上的 <code>th:each</code> 属性将会通知 <code>Thymeleaf</code> 为每项错误都渲染一个 <code>&lt;li&gt;</code>，在每次迭代中会将当前错误设置到一个名为 <code>err</code> 的变量中。</p><p><code>&lt;li&gt;</code> 标签还有一个 <code>th:text</code> 属性。这个命令会通知 <code>Thymeleaf</code> 计算某一个表达式（在本例中，也就是 err 变量）并将它的值渲染为 <code>&lt;li&gt;</code> 标签的内容体。实际上的效果就是每项错误对应一个 <code>&lt;li&gt;</code> 元素，并展现错误的文本。</p><p> <code>${}</code> 和 <code>*{}</code> 括起来的表达式到底有什么区别。 <code>${}</code> 表达式（如 <code>${spitter}</code>）是变量表达式（variable expression）。一般来讲，它们会是对象图导航语言（Object-Graph Navigation Language，<a href="http://commons.apache.org/proper/commons-ognl/" target="_blank" rel="noopener">OGNL</a>）表达式<br>。但在使用 Spring 的时候，它们是 SpEL 表达式。在 <code>${spitter}</code> 这个例子中，它会解析为 key 为 spitter 的 model 属性。</p><p>而对于 <code>*{}</code> 表达式，它们是选择表达式（selection expression）。变量表达式是基于整个 SpEL 上下文计算的，而选择表达式是基于某一个选中对象计算的。在本例的表单中，选中对象就是 <code>&lt;form&gt;</code> 标签中 <code>th:object</code> 属性所设置的对象：模型中的 Spitter 对象。因此，<code>*{firstName}</code> 表达式就会计算为 Spitter 对象的 firstName 属性。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;理解视图解析&quot;&gt;&lt;a href=&quot;#理解视图解析&quot; class=&quot;headerlink&quot; title=&quot;理解视图解析&quot;&gt;&lt;/a&gt;理解视图解析&lt;/h1&gt;&lt;p&gt;Spring MVC 定义了一个名为 &lt;code&gt;ViewResolver&lt;/code&gt; 的接口，它大致如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public interface ViewResolver {
    View resolveViewName(String viewName, Locale locale) throws Exception;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当给 &lt;code&gt;resolveViewName()&lt;/code&gt; 方法传入一个视图名和 &lt;code&gt;Locale&lt;/code&gt; 对象时，它会返回一个 &lt;code&gt;View&lt;/code&gt; 实例。&lt;code&gt;View&lt;/code&gt; 是另外一个接口，如下所示：&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://coolview.github.io/categories/Java/"/>
    
    
      <category term="Spring" scheme="http://coolview.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>《Spring 实战》笔记5：构建 Spring Web 应用程序</title>
    <link href="http://coolview.github.io/2019/07/13/Spring/%E3%80%8ASpring%20%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B05%EF%BC%9A%E6%9E%84%E5%BB%BA%20Spring%20Web%20%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/"/>
    <id>http://coolview.github.io/2019/07/13/Spring/%E3%80%8ASpring%20%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B05%EF%BC%9A%E6%9E%84%E5%BB%BA%20Spring%20Web%20%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/</id>
    <published>2019-07-13T08:35:24.000Z</published>
    <updated>2019-08-06T12:24:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>Spring MVC 基于模型-视图-控制器（Model-View-Controller，MVC）模式实现，它能够帮你构建像Spring框架那样灵活和松耦合的 Web 应用程序。</p><h1 id="Spring-MVC-起步"><a href="#Spring-MVC-起步" class="headerlink" title="Spring MVC 起步"></a>Spring MVC 起步</h1><p>Spring 将请求在调度 Servlet、处理器映射(Handler Mappering)、控制器以及视图解析器(View resolver)之间移动，每一个 Spring MVC 中的组件都有特定的目的，并且也没那么复杂。</p><p>让我们看一下，请求是如何从客户端发起，经过 Spring MVC 中的组件，最终返回到客户端</p><a id="more"></a><h2 id="跟踪-Spring-MVC-的请求"><a href="#跟踪-Spring-MVC-的请求" class="headerlink" title="跟踪 Spring MVC 的请求"></a>跟踪 Spring MVC 的请求</h2><p>每当用户在 Web 浏览器中点击链接或提交表单的时候，请求就开始工作了。请求是一个十分繁忙的家伙，从离开浏览器开始到获取响应返回，它会经历很多站，在每站都会留下一些信息，同时也会带上一些信息。下图展示了请求使用 Spring MVC 所经历的所有站点。</p><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20190713173157.png" alt="一路上请求会将信息带到很多站点，并生产期望的结果"></p><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/1365825529_4693.png" alt="Spring MVC 流程图"><br><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/1365825551_8302.png" alt="Spring MVC 流程图2"></p><blockquote><p><a href="https://blog.csdn.net/zuoluoboy/article/details/19766131" target="_blank" rel="noopener">Spring MVC 流程图</a></p></blockquote><ol><li>用户向服务器发送请求，请求被 Spring 前端控制 Servelt <code>DispatcherServlet</code> 捕获；</li><li><code>DispatcherServlet</code> 对请求 URL 进行解析，得到请求资源标识符（URI）。然后根据该 URI，调用 <code>HandlerMapping</code> 获得该 <code>Handler</code> 配置的所有相关的对象（包括 <code>Handler</code> 对象以及 <code>Handler</code> 对象对应的拦截器），最后以 <code>HandlerExecutionChain</code> 对象的形式返回；</li><li><code>DispatcherServlet</code> 根据获得的 <code>Handler</code>，选择一个合适的 <code>HandlerAdapter</code>。（附注：如果成功获得 <code>HandlerAdapter</code> 后，此时将开始执行拦截器的 <code>preHandler(...)</code> 方法）</li><li>提取 Request 中的模型数据，填充 <code>Handler</code> 入参，开始执行 <code>Handler（Controller)</code>。 在填充 <code>Handler</code> 的入参过程中，根据你的配置，Spring 将帮你做一些额外的工作：<ul><li><code>HttpMessageConveter</code>：将请求消息（如 JSON、XML 等数据）转换成一个对象，将对象转换为指定的响应信息</li><li><code>数据转换</code>：对请求消息进行数据转换。如 String 转换成 Integer、Double 等</li><li><code>数据根式化</code>：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等</li><li><code>数据验证</code>：验证数据的有效性（长度、格式等），验证结果存储到 BindingResult 或 Error 中</li></ul></li><li><code>Handler</code> 执行完成后，向 <code>DispatcherServlet</code> 返回一个 <code>ModelAndView</code> 对象；</li><li>根据返回的 <code>ModelAndView</code>，选择一个适合的 <code>ViewResolver</code>（必须是已经注册到 Spring 容器中的 <code>ViewResolver</code>)返回给 <code>DispatcherServlet</code> ；</li><li><code>ViewResolver</code> 结合 <code>Model</code> 和 <code>View</code>，来渲染视图</li><li>将渲染结果返回给客户端。</li></ol><h2 id="搭建-Spring-MVC"><a href="#搭建-Spring-MVC" class="headerlink" title="搭建 Spring MVC"></a>搭建 Spring MVC</h2><h3 id="配置-DispatcherServlet"><a href="#配置-DispatcherServlet" class="headerlink" title="配置 DispatcherServlet"></a>配置 DispatcherServlet</h3><p><code>DispatcherServlet</code> 是 Spring MVC 的核心。在这里请求会第一次接触到框架，它要负责将请求路由到其他的组件之中。</p><p>按照传统的方式，像 <code>DispatcherServlet</code> 这样的 Servlet 会配置在 <code>web.xml</code> 文件中</p><pre><code class="xml">&lt;servlet&gt;    &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;    &lt;url-pattern&gt;*.form&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;</code></pre><p>Servlet 3 规范和 Spring 3.1 的功能增强，可以使用 Java 将 DispatcherServlet 配置在 Servlet 容器中</p><pre><code class="java">public class SpittrWebAppInitializer            extends AbstractAnnotationConfigDispatcherServletInitializer {    @Override    protected String[] getServletMappings() {  // 将 DispatcherServlet 映射到 &quot;/&quot;        return new String[] { &quot;/&quot; };    }    @Override    protected Class&lt;?&gt;[] getRootConfigClasses() {        return new Class&lt;?&gt;[] { RootConfig.class };    }    @Override    protected Class&lt;?&gt;[] getServletConfigClasses() {        return new Class&lt;?&gt;[] { WebConfig.class };    }}</code></pre><p>要理解程序是如何工作的，我们可能只需要知道扩展 <code>AbstractAnnotationConfigDispatcherServletInitializer</code> 的任意类都会自动地配置 <code>DispatcherServlet</code> 和 Spring 应用上下文，Spring 的应用上下文会位于应用程序的 Servlet 上下文之中。</p><h3 id="AbstractAnnotationConfigDispatcherServletInitializer-剖析"><a href="#AbstractAnnotationConfigDispatcherServletInitializer-剖析" class="headerlink" title="AbstractAnnotationConfigDispatcherServletInitializer 剖析"></a>AbstractAnnotationConfigDispatcherServletInitializer 剖析</h3><p>在 Servlet 3.0 环境中，容器会在类路径中查找实现 <code>javax.servlet.ServletContainerInitializer</code> 接口的类，如果能发现的话，就会用它来配置 Servlet 容器。</p><p>Spring 提供了这个接口的实现，名为 <code>SpringServletContainerInitializer</code> ，这个类反过来又会查找实现 <code>WebApplicationInitializer</code> 的类并将配置的任务交给它们来完成。Spring 3.2 引入了一个便利的 <code>WebApplicationInitializer</code> 基础实现，也就是 <code>AbstractAnnotationConfigDispatcherServletInitializer</code> 。因为我们的 <code>SpittrWebAppInitializer</code> 扩展了 <code>AbstractAnnotationConfigDispatcherServletInitializer</code> （同时也就实现了 <code>WebApplicationInitializer</code> ），因此当部署到 Servlet 3.0 容器中的时候，容器会自动发现它，并用它来配置 Servlet 上下文。</p><p><code>SpittrWebAppInitializer</code> 重写了三个方法。</p><ul><li>第一个方法是 <code>getServletMappings()</code>，它会将一个或多个路径映射到 DispatcherServlet 上。在本例中，它映射的是 &quot;/&quot; ，这表示它会是应用的默认 Servlet。它会处理进入应用的所有请求。</li></ul><p>为了理解其他的两个方法，我们首先要理解 <code>DispatcherServlet</code> 和一个 Servlet 监听器（也就是 <code>ContextLoaderListener</code> ）的关系。</p><h3 id="两个应用上下文之间的故事"><a href="#两个应用上下文之间的故事" class="headerlink" title="两个应用上下文之间的故事"></a>两个应用上下文之间的故事</h3><p>当 <code>DispatcherServlet</code> 启动的时候，它会创建 Spring 应用上下文，并加载配置文件或配置类中所声明的 bean。在上面程序的 <code>getServletConfigClasses()</code> 方法中，我们要求 <code>DispatcherServlet</code> 加载应用上下文时，使用定义在 <code>WebConfig</code> 配置类（使用 Java 配置）中的 bean。</p><p>但是在 Spring Web 应用中，通常还会有另外一个应用上下文。另外的这个应用上下文是由 <code>ContextLoaderListener</code> 创建的。</p><p>我们希望 <code>DispatcherServlet</code> 加载包含 Web 组件的 bean，如控制器、视图解析器以及处理器映射，而 <code>ContextLoaderListener</code> 要加载应用中的其他 bean。这些 bean 通常是驱动应用后端的中间层和数据层组件。</p><p>实际上， <code>AbstractAnnotationConfigDispatcherServletInitializer</code> 会同时创建 <code>DispatcherServlet</code> 和 <code>ContextLoaderListener</code> 。<code>getServletConfigClasses()</code> 方法返回的带有 <code>@Configuration</code> 注解的类将会用来定义 <code>DispatcherServlet</code> 应用上下文中的 bean。<code>getRootConfigClasses()</code> 方法返回的带有 <code>@Configuration</code> 注解的类将会用来配置 <code>ContextLoaderListener</code> 创建的应用上下文中的 bean。</p><p>在本例中，根配置定义在 <code>RootConfig</code> 中， <code>DispatcherServlet</code> 的配置声明在 <code>WebConfig</code> 中。稍后我们将会看到这两个类的内容。</p><p>需要注意的是，通过 <code>AbstractAnnotationConfigDispatcherServletInitializer</code> 来配置 <code>DispatcherServlet</code> 是传统 <code>web.xml</code> 方式的替代方案。</p><h3 id="启用-Spring-MVC"><a href="#启用-Spring-MVC" class="headerlink" title="启用 Spring MVC"></a>启用 Spring MVC</h3><p>以前，Spring 是使用 XML 进行配置的，你可以使用 <code>&lt;mvc:annotation-driven&gt;</code> 启用注解驱动的 Spring MVC。</p><p>基于 Java 进行配置，我们所能创建的最简单的 Spring MVC 配置就是一个带有 <code>@EnableWebMvc</code> 注解的类：</p><pre><code class="java">@Configuration@EnableWebMvc@ComponentScan(&quot;spittr.web&quot;)public class WebConfig extends WebMvcConfigurerAdapter {    @Bean    public ViewResolver viewResolver() {        InternalResourceViewResolver resolver = new InternalResourceViewResolver();        resolver.setPrefix(&quot;/WEB-INF/views/&quot;);        resolver.setSuffix(&quot;.jsp&quot;);        resolver.setExposeContextBeansAsAttributes(true);        return resolver;    }    @Override    public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {        // 要求 DispatcherServlet 将对静态资源的请求转发到 Servlet 容器中默认的 Servlet 上        configurer.enable();    }}</code></pre><pre><code class="java">@Configuration@ComponentScan(basePackages = {&quot;spittr&quot;},        excludeFilters = {                @ComponentScan.Filter(type = FilterType.ANNOTATION, value = EnableWebMvc.class)        })public class RootConfig {}</code></pre><h1 id="编写基本的控制器"><a href="#编写基本的控制器" class="headerlink" title="编写基本的控制器"></a>编写基本的控制器</h1><pre><code class="java">@Controllerpublic class HomeController {    @RequestMapping(value = &quot;/&quot;, method = RequestMethod.GET)   // 处理对 &quot;/&quot; 的 Get 请求    public String home() {        return &quot;home&quot;;  // 视图名为 home        // DispatcherServlet 会要求视图解析器将这个逻辑名称解析为实际的视图。        // 由于配置 InternalResourceViewResolver 的方式，视图名 &quot;home&quot; 将会解析为 &quot;WEB-INF/views/home.jsp&quot; 路径的 JSP。    }}</code></pre><p><code>@Controller</code> 是一个构造型（stereotype）的注解，它基于 <code>@Component</code> 注解。在这里，它的目的就是辅助实现组件扫描。因为 HomeController 带有 @Controller 注解，因此组件扫描器会自动找到 HomeController，并将其声明为 Spring 应用上下文中的一个 bean。</p><p>带有 <code>@RequestMapping</code> 注解的方法，它的 <code>value</code> 属性指定了这个方法所要处理的请求路径，<code>method</code> 属性细化了它所处理的 HTTP 方法。</p><h2 id="测试控制器"><a href="#测试控制器" class="headerlink" title="测试控制器"></a>测试控制器</h2><pre><code class="java">public class HomeControllerTest {    @Test    public void testHomePage() throws Exception {        HomeController controller = new HomeController();        // 搭建 MockMvc        MockMvc mockMvc = MockMvcBuilders.standaloneSetup(controller).build();        mockMvc.perform(MockMvcRequestBuilders.get(&quot;/&quot;)) // 对 “/” 执行 GET 请求，                .andExpect(MockMvcResultMatchers.view().name(&quot;home&quot;));// 预期得到 home 视图    }}</code></pre><p><a href="/2018/04/01/SpringMVC%20Test/">SpringMVC Test</a></p><h2 id="定义类级别的请求处理"><a href="#定义类级别的请求处理" class="headerlink" title="定义类级别的请求处理"></a>定义类级别的请求处理</h2><h2 id="传递模型数据到视图中"><a href="#传递模型数据到视图中" class="headerlink" title="传递模型数据到视图中"></a>传递模型数据到视图中</h2><pre><code class="java">@RequestMapping(method = RequestMethod.GET)public String spittles(Model model) {    model.addAttribute(spittleRepository.findSpittles(Long.MAX_VALUE, 20)); // 将 spittle 添加到视图    // 和上一行等效    // model.put(&quot;spittleList&quot;, spittleRepository.findSpittles(Long.MAX_VALUE, 20));    return &quot;spittles&quot;;  // 返回视图名}</code></pre><p><code>Model</code> 实际上就是一个 Map（也就是key-value对的集合），它会传递给视图，这样数据就能渲染到客户端了。当调用 <code>addAttribute()</code> 方法并且不指定 <code>key</code> 的时候，那么 <code>key</code> 会根据值的对象类型推断确定。在本例中，因为它是一个 <code>List&lt;Spittle&gt;</code>，因此，键将会推断为 <code>spittleList</code>。</p><pre><code class="java">@RequestMapping(method=RequestMethod.GET)public List&lt;Spittle&gt; spittles() {    return spittleRepository.findSpittles(Long.MAX_VALUE, 20));}</code></pre><p>它并没有返回视图名称，也没有显式地设定模型，这个方法返回的是 Spittle 列表。当处理器方法像这样返回对象或集合时，这个值会放到模型中，模型的 key 会根据其类型推断得出（在本例中，也就是 spittleList）。</p><p>而逻辑视图的名称将会根据请求路径推断得出。因为这个方法处理针对 &quot;/spittles&quot; 的 GET 请求，因此视图的名称将会是 <code>spittles</code>（去掉开头的斜线）。</p><h1 id="接受请求的输入"><a href="#接受请求的输入" class="headerlink" title="接受请求的输入"></a>接受请求的输入</h1><p>Spring MVC 允许以多种方式将客户端中的数据传送到控制器的处理器方法中，包括：</p><ul><li>查询参数（Query Parameter）。</li><li>表单参数（Form Parameter）。</li><li>路径变量（Path Variable）。</li></ul><h2 id="处理查询参数"><a href="#处理查询参数" class="headerlink" title="处理查询参数"></a>处理查询参数</h2><pre><code class="java">// 注：原文中所写的这行是错误的，注解那块会提示 Attribute value must be constant// private static final String MAX_LONG_AS_STRING = Long.toString(Long.MAX_VALUE);private static final String MAX_LONG_AS_STRING = Long.MAX_VALUE + &quot;&quot;;@RequestMapping(method=RequestMethod.GET)public List&lt;Spittle&gt; spittles(        @RequestParam(value=&quot;max&quot;, defaultValue=MAX_LONG_AS_STRING) long max,        @RequestParam(value=&quot;count&quot;, defaultValue=&quot;20&quot;) int count) {    return spittleRepository.findSpittles(max, count);}</code></pre><h2 id="通过路径参数接受输入"><a href="#通过路径参数接受输入" class="headerlink" title="通过路径参数接受输入"></a>通过路径参数接受输入</h2><p>Spring MVC 允许我们在 <code>@RequestMapping</code> 路径中添加占位符。占位符的名称要用大括号（“{”和“}”）括起来。如果对 &quot;/spittles/54321&quot; 发送 GET 请求，那么将会把 &quot;54321&quot; 传递进来，作为 spittleId 的值。</p><pre><code class="Java">@RequestMapping(value=&quot;/{spittleId}&quot;, method=RequestMethod.GET)public String spittle(@PathVariable(&quot;spittleId&quot;) long spittleId, Model model) {    model.addAttribute(spittleRepository.findOne(spittleId));    return &quot;spittle&quot;;}</code></pre><p>需要注意的是，如果你想要重命名参数时，<strong>必须要同时修改占位符的名称</strong>，使其互相匹配。</p><h1 id="处理表单"><a href="#处理表单" class="headerlink" title="处理表单"></a>处理表单</h1><h2 id="编写处理表单的控制器"><a href="#编写处理表单的控制器" class="headerlink" title="编写处理表单的控制器"></a>编写处理表单的控制器</h2><h2 id="校验表单"><a href="#校验表单" class="headerlink" title="校验表单"></a>校验表单</h2><p>在 Spring MVC 中要使用 Java 校验 API 的话，并不需要什么额外的配置。只要保证在类路径下包含这个 Java API 的实现即可，比如 <code>Hibernate Validator</code>。</p><p>Java 校验 API 所提供的校验注解</p><ul><li><code>@AssertFalse</code> 所注解的元素必须是 Boolean 类型，并且值为 false</li><li><code>@AssertTrue</code> 所注解的元素必须是 Boolean 类型，并且值为 true</li><li><code>@DecimalMax</code> 所注解的元素必须是数字，并且它的值要小于或等于给定的 BigDecimalString 值</li><li><code>@DecimalMin</code> 所注解的元素必须是数字，并且它的值要大于或等于给定的 BigDecimalString 值</li><li><code>@Digits</code> 所注解的元素必须是数字，并且它的值必须有指定的位数</li><li><code>@Future</code> 所注解的元素的值必须是一个将来的日期</li><li><code>@Max</code> 所注解的元素必须是数字，并且它的值要小于或等于给定的值</li><li><code>@Min</code> 所注解的元素必须是数字，并且它的值要大于或等于给定的值</li><li><code>@NotNul</code>l 所注解元素的值必须不能为 null</li><li><code>@Null</code> 所注解元素的值必须为 null</li><li><code>@Past</code> 所注解的元素的值必须是一个已过去的日期</li><li><code>@Pattern</code> 所注解的元素的值必须匹配给定的正则表达式</li><li><code>@Size</code> 所注解的元素的值必须是 String 、集合或数组，并且它的长度要符合给定的范围</li></ul><pre><code class="java">public class Spitter {    private Long id;    @NotNull    @Size(min=5, max=16)    private String username;  // 非空，5 到 16 个字符    @NotNull    @Size(min=5, max=25)    private String password;    @NotNull    @Size(min=2, max=30)    private String firstName;    @NotNull    @Size(min=2, max=30)    private String lastName;    ...}</code></pre><p>启用校验功能</p><pre><code class="java">@RequestMapping(value=&quot;/register&quot;, method=POST)public String processRegistration(@Valid Spitter spitter, Errors errors) {    if (errors.hasErrors()) {        return &quot;registerForm&quot;;    }    spitterRepository.save(spitter);    return &quot;redirect:/spitter/&quot; + spitter.getUsername();}</code></pre><p><code>Errors</code> 参数要紧跟在带有 <code>@Valid</code> 注解的参数后面，<code>@Valid</code> 注解所标注的就是要检验的参数</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring MVC 基于模型-视图-控制器（Model-View-Controller，MVC）模式实现，它能够帮你构建像Spring框架那样灵活和松耦合的 Web 应用程序。&lt;/p&gt;
&lt;h1 id=&quot;Spring-MVC-起步&quot;&gt;&lt;a href=&quot;#Spring-MVC-起步&quot; class=&quot;headerlink&quot; title=&quot;Spring MVC 起步&quot;&gt;&lt;/a&gt;Spring MVC 起步&lt;/h1&gt;&lt;p&gt;Spring 将请求在调度 Servlet、处理器映射(Handler Mappering)、控制器以及视图解析器(View resolver)之间移动，每一个 Spring MVC 中的组件都有特定的目的，并且也没那么复杂。&lt;/p&gt;
&lt;p&gt;让我们看一下，请求是如何从客户端发起，经过 Spring MVC 中的组件，最终返回到客户端&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://coolview.github.io/categories/Java/"/>
    
    
      <category term="Spring" scheme="http://coolview.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>《Spring 实战》笔记4：面向切面的 Spring</title>
    <link href="http://coolview.github.io/2019/07/04/Spring/%E3%80%8ASpring%20%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B04%EF%BC%9A%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%9A%84%20Spring/"/>
    <id>http://coolview.github.io/2019/07/04/Spring/%E3%80%8ASpring%20%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B04%EF%BC%9A%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%9A%84%20Spring/</id>
    <published>2019-07-04T12:09:37.000Z</published>
    <updated>2019-12-10T14:22:38.160Z</updated>
    
    <content type="html"><![CDATA[<p>在软件开发中，散布于应用中多处的功能被称为<strong>横切关注点</strong>（cross-cutting concern）。通常来讲，这些横切关注点从概念上是与应用的业务逻辑相分离的（但是往往会直接嵌入到应用的业务逻辑之中）。<strong>把这些横切关注点与业务逻辑相分离正是面向切面编程（AOP）所要解决的问题</strong>。</p><p>在第2章，我们介绍了如何使用<strong>依赖注入</strong>（DI）管理和配置我们的应用对象。DI 有助于应用对象之间的解耦，而 AOP 可以实现横切关注点与它们所影响的对象之间的解耦。</p><p>日志是应用切面的常见范例，但它并不是切面适用的唯一场景。通览本书，我们还会看到切面所适用的多个场景，包括声明式事务、安全和缓存。</p><a id="more"></a><h1 id="什么是面向切面编程"><a href="#什么是面向切面编程" class="headerlink" title="什么是面向切面编程"></a>什么是面向切面编程</h1><p>切面能够帮我们模块化横切关注点。简而言之，横切关注点可以被描述为影响应用多处的功能。例如 安全就是一个横切关注点，应用中的许多方法都会涉及到安全规则。</p><p>如果要重用对象的话，最常见的面向对象技术是继承、委托、组合。但是，如果整个应用中都使用相同的基类，继承往往会导致一个脆弱的对象体系。而使用委托可能需要委托对象进行复杂的调用。</p><p>切面提供了取代继承和委托的另一种可选方案。在使用面向切面编程时，我们仍然在一个地方定义通知功能，而无需修改受影响的类。<strong>横切关注点可以被模块化为特殊的类，这些类被称为切面(aspect)</strong>。 这样做带来两个好处：每个关注点都集中到一个地方，而不是分散到多处代码中；其次，服务模块更简洁，因为它只包含了主要关注点（核心功能）的代码。而次要关注的代码被移到切面中了。</p><h2 id="定义-AOP-术语"><a href="#定义-AOP-术语" class="headerlink" title="定义 AOP 术语"></a>定义 AOP 术语</h2><h3 id="通知（advice）"><a href="#通知（advice）" class="headerlink" title="通知（advice）"></a>通知（advice）</h3><p>切面也有目标——它必须要完成的工作。在 AOP 术语中，<strong>切面的工作被称为通知</strong>。</p><p>通知定义了切面是什么以及何时使用。除了描述切面要完成的工作外，通知还解决了何时执行这个工作问题。它应该在某个方法被调用之前？之后？之前和之后都调用？还是只在方法抛出异常时调用？</p><p>Spring 切面可以应用 5 中类型的通知：</p><ul><li><strong>前置通知(Before)</strong>：在目标方法被调用之前调用通知功能。</li><li><strong>后置通知(After)</strong>：在目标方法完成之后调用通知</li><li><strong>返回通知(After-returning)</strong>：在目标方法成功执行之后调用通知</li><li><strong>异常通知(After-throwing)</strong>：在目标方法抛出异常后调用通知</li><li><strong>环绕通知(Around)</strong>：在被通知方法调用之前和调用之后执行自定义的行为</li></ul><h3 id="连接点（Join-point）"><a href="#连接点（Join-point）" class="headerlink" title="连接点（Join point）"></a>连接点（Join point）</h3><p>我们的应用可能有数以千计的时机应用通知，这些时机被称为连接点。连接点是在应用执行过程中能够插入的一个点。这个点可以是调用方法时，抛出异常时，甚至修改一个字段时。切面可以利用这些点插入到应用的正常流程之中，并添加新的行为。</p><h3 id="切点（Pointcut）"><a href="#切点（Pointcut）" class="headerlink" title="切点（Pointcut）"></a>切点（Pointcut）</h3><p>切入点是一个或一组连接点，通知将在这些位置执行。可以通过表达式或匹配的方式指明切入点。</p><h3 id="切面（Aspect）"><a href="#切面（Aspect）" class="headerlink" title="切面（Aspect）"></a>切面（Aspect）</h3><p>切面是通知和切点的结合。通知和切点通过定义了切面的全部内容——它是什么，在什么时候和在哪里完成其功能。</p><h3 id="引入（Introduction）"><a href="#引入（Introduction）" class="headerlink" title="引入（Introduction）"></a>引入（Introduction）</h3><p>引入允许我们向现有的类添加新的方法或者属性。</p><p>例如，我们可以创建一个 Auditable 通知类，该类记录了对象最后一次修改时的状态。这很简单，只需一个方<br>法，setLastModified(Date)，和一个实例变量来保存这个状态。然后，这个新方法和实例变量就可以被引入到现有的类中，从而可以在无需修改这些现有的类的情况下，让它们具有新的行为和状态。</p><h3 id="织入（Weaving）"><a href="#织入（Weaving）" class="headerlink" title="织入（Weaving）"></a>织入（Weaving）</h3><p>织入是把切面应用到目标对象并创建新的代理对象的过程。切面在指定的连接点被织入到目标对象。在目标对象的生命周期里有多个点可以进行织入：</p><ul><li>编译期：切面在目标类编译时被织入。这种方式需要特殊的编译器。<code>AspectJ</code> 的织入编译器就是以这种方式织入切面的。</li><li>类加载期：切面在目标类加载到JVM时被织入。这种方式需要特殊的类加载器（ClassLoader），它可以在目标类被引入应用之前增强该目标类的字节码。<code>AspectJ 5</code> 的加载时织入（load-time weaving，LTW）就支持以这种方式织入切面。</li><li>运行期：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP 容器会为目标对象动态地创建一个代理对象。Spring AOP 就是以这种方式织入切面的。</li></ul><p><strong>通知包含了需要用于多个应用对象的横切行为；连接点是程序执行过程中能够应用通知的所有点；切点定义了通知被应用的具体位置（在哪些连接点）。其中关键的概念是切点定义了哪些连接点会得到通知。</strong></p><h2 id="Spring-对-AOP-的支持"><a href="#Spring-对-AOP-的支持" class="headerlink" title="Spring 对 AOP 的支持"></a>Spring 对 AOP 的支持</h2><p>Spring 提供了 4 种类型的 AOP 支持：</p><ul><li><strong>基于代理的经典 Spring AOP</strong>；非常笨重和过于复杂</li><li><strong>纯 POJO 切面</strong>；需要 XML 配置，但这的确是声明式地将对象转换为切面的简便方式。</li><li><strong><code>@AspectJ</code> 注解驱动的切面</strong>；它依然是 Spring 基于代理的 AOP，但是编程模型几乎与编写成熟的 AspectJ 注解切面完全一致。这种 AOP 风格的好处在于能够不使用 XML 来完成功能。</li><li><strong>注入式 <code>AspectJ</code> 切面</strong>（适用于 Spring 各版本）。如果你的 AOP 需求超过了简单的方法调用（如构造器或属性拦截），那么你需要考虑使用 AspectJ 来实现切面。能够帮助你将值注入到 AspectJ 驱动的切面中。</li></ul><p>前三种都是 Spring AOP 实现的变体，Spring AOP 构建在动态代理基础之上，因此，<strong>Spring 对 AOP 的支持局限于方法拦截</strong>。</p><h3 id="Spring-通知是-Java-编写的"><a href="#Spring-通知是-Java-编写的" class="headerlink" title="Spring 通知是 Java 编写的"></a>Spring 通知是 Java 编写的</h3><p>Spring 所创建的通知都是用标准的 Java 类编写的，定义通知所应用的切点通常会使用注解或在 Spring 配置文件里采用 XML 来编写。</p><p><code>AspectJ</code> 与之相反。虽然 <code>AspectJ</code> 现在支持基于注解的切面，但 <code>AspectJ</code> 最初是以 Java 语言扩展的方式实现的。这种方式有优点也有缺点。通过特有的 AOP 语言，我们可以获得更强大和细粒度的控制，以及更丰富的 AOP 工具集，但是我们需要额外学习新的工具和语法。</p><h3 id="Spring-在运行时通知对象"><a href="#Spring-在运行时通知对象" class="headerlink" title="Spring 在运行时通知对象"></a>Spring 在运行时通知对象</h3><p>通过在代理类中包裹切面，Spring 在运行期把切面织入到 Spring 管理的 bean 中。代理类封装了目标类，并拦截被通知方法的调用，再把调用转发给真正的目标 bean。当代理拦截到方法调用时，在调用目标 bean 方法之前，会执行切面逻辑。</p><p>直到应用需要被代理的 bean 时，Spring 才创建代理对象。如果使用的是 ApplicationContext 的话，在 ApplicationContext 从 BeanFactory 中加载所有 bean 的时候，Spring 才会创建被代理的对象。因为 Spring 运行时才创建代理对象，所以我们不需要特殊的编译器来织入 Spring AOP 的切面。</p><h3 id="Spring-只支持方法级别的连接点"><a href="#Spring-只支持方法级别的连接点" class="headerlink" title="Spring 只支持方法级别的连接点"></a>Spring 只支持方法级别的连接点</h3><p>正如前面所探讨过的，通过使用各种 AOP 方案可以支持多种连接点模型。因为 Spring 基于动态代理，所以 Spring 只支持方法连接点。这与一些其他的 AOP 框架是不同的，例如 <code>AspectJ</code> 和 <code>JBoss</code>，除了方法切点，它们还提供了字段和构造器接入点。Spring 缺少对字段连接点的支持，无法让我们创建细粒度的通知，例如拦截对象字段的修改。而且它不支持构造器连接点，我们就无法在 bean 创建时应用通知。</p><p>但是方法拦截可以满足绝大部分的需求。如果需要方法拦截之外的连接点拦截功能，那么我们可以利用 <code>AspectJ</code> 来补充 Spring AOP 的功能。</p><h1 id="通过切点来选择连接点"><a href="#通过切点来选择连接点" class="headerlink" title="通过切点来选择连接点"></a>通过切点来选择连接点</h1><p>切点用于准确定位应该在什么地方应用切面的通知。通知和切点是切面的最基本元素。</p><p>Spring 仅支持 <code>AspectJ</code> 切点指示器（pointcut designator）的一个子集。Spring 是基于代理的，而某些切点表达式是与基于代理的 AOP 无关的。</p><p>Spring AOP 所支持的 <code>AspectJ</code> 切点指示器</p><table><thead><tr><th>AspectJ指示器</th><th>描　　述</th></tr></thead><tbody><tr><td><code>arg()</code></td><td>限制连接点匹配参数为指定类型的执行方法</td></tr><tr><td><code>@args()</code></td><td>限制连接点匹配参数由指定注解标注的执行方法</td></tr><tr><td><code>execution()</code></td><td>用于匹配是连接点的执行方法</td></tr><tr><td><code>this()</code></td><td>限制连接点匹配 AOP 代理的 bean 引用为指定类型的类</td></tr><tr><td><code>target</code></td><td>限制连接点匹配目标对象为指定类型的类</td></tr><tr><td><code>@target()</code></td><td>限制连接点匹配特定的执行对象，这些对象对应的类要具有指定类型的注解</td></tr><tr><td><code>within()</code></td><td>限制连接点匹配指定的类型</td></tr><tr><td><code>@within()</code></td><td>限制连接点匹配指定注解所标注的类型（当使用 Spring AOP 时，方法定义在由指定的注解所标注的类里）</td></tr><tr><td><code>@annotation</code></td><td>限定匹配带有指定注解的连接点</td></tr></tbody></table><p>注意只有 <code>execution</code> 指示器是实际执行匹配的，而其他的指示器都是用来限制匹配的。这说明 <code>execution</code> 指示器是我们在编写切点定义时最主要使用的指示器。在此基础上，我们使用其他指示器来限制所匹配的切点。</p><h2 id="编写切点"><a href="#编写切点" class="headerlink" title="编写切点"></a>编写切点</h2><p>为了阐述 Spring 中的切面，我们需要有个主题来定义切面的切点。为此，我们定义一个 Performance 接口：</p><pre><code class="java">public interface Performance {    public void perform();}</code></pre><p>下图展现了一个切点表达式，这个表达式能够设置当 perform() 方法执行时触发通知的调用。</p><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20190706151354.png" alt="使用 AspectJ 切点表达式来选择 Performance 的 perform() 方法"></p><p>现在假设我们需要配置的切点仅匹配 concert 包。在此场景下，可以使用 within() 指示器来限制匹配，如图所示。</p><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20190706151943.png" alt="使用 within() 指示器限制切点范围"></p><p>请注意我们使用了 <code>&amp;&amp;</code> 操作符把 <code>execution()</code> 和 <code>within()</code> 指示器连接在一起形成与（and）关系（切点必须匹配所有的指示器）。类似地，我们可以使用 <code>||</code> 操作符来标识或（or）关系，而使用 <code>!</code> 操作符来标识非（not）操作。</p><p>因为 <code>&amp;</code> 在XML中有特殊含义，所以在 Spring 的 XML 配置里面描述切点时，我们可以使用 and<br>来代替 <code>&amp;&amp;</code> 。同样，or 和 not可以分别用来代替 <code>||</code> 和 <code>!</code> 。</p><h2 id="在切点中选择-bean"><a href="#在切点中选择-bean" class="headerlink" title="在切点中选择 bean"></a>在切点中选择 bean</h2><p>Spring 引入了一个新的 <code>bean()</code> 指示器，它允许我们在切点表达式中使用 bean 的ID来标识 bean。<code>bean()</code> 使用 bean ID 或 bean 名称作为参数来限制切点只匹配特定的 bean。</p><pre><code class="java">// 在执行 Performance 的 perform() 方法时应用通知，但限定 bean 的 ID 为 woodstock。execution(* concert.Performance.perform()) and bean(&quot;woodsotck&quot;)</code></pre><pre><code class="java">// 切面的通知会被编织到所有 ID 不为 woodstock 的 bean 中execution(* concert.Performance.perform()) and !bean(&quot;woodsotck&quot;)</code></pre><h1 id="使用注解创建切面"><a href="#使用注解创建切面" class="headerlink" title="使用注解创建切面"></a>使用注解创建切面</h1><p>使用注解来创建切面是 <code>AspectJ 5</code> 所引入的关键特性。</p><p>我们已经定义了 Performance 接口，它是切面中切点的目标对象。现在，让我们使用 AspectJ 注解来定义切面。</p><h2 id="定义切面"><a href="#定义切面" class="headerlink" title="定义切面"></a>定义切面</h2><pre><code class="java">@Aspect  // 使用 @Aspect 注解进行了标注，表明是一个切面public class Audience {    // 表演之前    @Before(&quot;execution(** springaction04.concert.Performance.perform(..))&quot;)    public void silenceCellPhones() {        System.out.println(&quot;Silencing cell phones&quot;);    }    // 表演之前    @Before(&quot;execution(** springaction04.concert.Performance.perform(..))&quot;)    public void takeSeats() {        System.out.println(&quot;Taking seats&quot;);    }    // 表演之后    @AfterReturning(&quot;execution(** springaction04.concert.Performance.perform(..))&quot;)    public void applause() {        System.out.println(&quot;CLAP CLAP CLAP!!!&quot;);    }    // 表演失败之后    @AfterThrowing(&quot;execution(** springaction04.concert.Performance.perform(..))&quot;)    public void demandRefund() {        System.out.println(&quot;Demanding a refund&quot;);    }}</code></pre><p>两个 <code>*</code> 在 IDEA 中会提示 <code>( expected</code>，<a href="https://stackoverflow.com/questions/36717542/why-use-two-stars-in-point-cut-expression-to-match-return-type" target="_blank" rel="noopener">Why use two stars in point cut expression to match return type?</a></p><h3 id="Spring-使用-AspectJ-注解来声明通知方法"><a href="#Spring-使用-AspectJ-注解来声明通知方法" class="headerlink" title="Spring 使用 AspectJ 注解来声明通知方法"></a>Spring 使用 AspectJ 注解来声明通知方法</h3><table><thead><tr><th>注　　解</th><th>通　　知</th></tr></thead><tbody><tr><td><code>@After</code></td><td>通知方法会在目标方法返回或抛出异常后调用</td></tr><tr><td><code>@AfterReturning</code></td><td>通知方法会在目标方法返回后调用</td></tr><tr><td><code>@AfterThrowing</code></td><td>通知方法会在目标方法抛出异常后调用</td></tr><tr><td><code>@Around</code></td><td>通知方法会将目标方法封装起来</td></tr><tr><td><code>@Before</code></td><td>通知方法会在目标方法调用之前执行</td></tr></tbody></table><h3 id="Pointcut"><a href="#Pointcut" class="headerlink" title="@Pointcut"></a>@Pointcut</h3><p><code>@Pointcut</code> 注解能够在一个 <code>@AspectJ</code> 切面内定义可重用的切点。</p><pre><code class="java">@Aspectpublic class Audience {    /**    * 定义命名的切点    * performance() 方法的实际内容并不重要，在这里它实际上应该是空的。    * 其实该方法本身只是一个标识，供 @Pointcut 注解依附。    * 如果方法中存在内容，IDEA 会提示 Pointcut methods should have empty body    */    @Pointcut(&quot;execution(** springaction04.concert.Performance.perform(..))&quot;)    public void performance() {}    @Before(&quot;performance()&quot;)    public void silenceCellPhones() {        System.out.println(&quot;Silencing cell phones&quot;);    }    @Before(&quot;performance()&quot;)    public void takeSeats() {        System.out.println(&quot;Taking seats&quot;);    }    @AfterReturning(&quot;performance()&quot;)    public void applause() {        System.out.println(&quot;CLAP CLAP CLAP!!!&quot;);    }    @AfterThrowing(&quot;performance()&quot;)    public void demandRefund() {        System.out.println(&quot;Demanding a refund&quot;);    }}</code></pre><h3 id="在-JavaConfig-中启用-AspectJ-注解的自动代理"><a href="#在-JavaConfig-中启用-AspectJ-注解的自动代理" class="headerlink" title="在 JavaConfig 中启用 AspectJ 注解的自动代理"></a>在 JavaConfig 中启用 AspectJ 注解的自动代理</h3><pre><code class="java">@Configuration@EnableAspectJAutoProxy  // 启用 AspectJ 自动代理@ComponentScanpublic class ConcertConfig {    @Bean    public Audience audience() {  // 声明 Audience bean        return new Audience();    }}</code></pre><h3 id="在-XML-中启用-AspectJ-自动代理"><a href="#在-XML-中启用-AspectJ-自动代理" class="headerlink" title="在 XML 中启用 AspectJ 自动代理"></a>在 XML 中启用 AspectJ 自动代理</h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop.xsd        http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;context:component-scan base-package=&quot;springaction04.concert&quot; /&gt;    &lt;!-- 启用 AspectJ 自动代理 --&gt;    &lt;aop:aspectj-autoproxy /&gt;    &lt;bean class=&quot;concert.Audience&quot; /&gt;&lt;/beans&gt;</code></pre><p>如果想利用 AspectJ 的所有能力，我们必须在运行时使用 AspectJ 并且不依赖 Spring 来创建基于代理的切面。</p><h2 id="创建环绕通知"><a href="#创建环绕通知" class="headerlink" title="创建环绕通知"></a>创建环绕通知</h2><p>环绕通知是最为强大的通知类型。它能够让你所编写的逻辑将被通知的目标方法完全包装起来。实际上就像在一个通知方法中同时编写前置通知和后置通知。</p><pre><code class="java">// 使用环绕通知重新实现 Audience 切面@Aspectpublic class Audience3 {    @Pointcut(&quot;execution(** concert.Performance.perform(..))&quot;)    public void performance() {}    @Around(&quot;performance()&quot;)    public void watchPerformance(ProceedingJoinPoint jp) {        try {            System.out.println(&quot;Silencing cell phones&quot;);            System.out.println(&quot;Taking seats&quot;);            jp.proceed();            System.out.println(&quot;CLAP CLAP CLAP!!!&quot;);        } catch (Throwable e) {            System.out.println(&quot;Demanding a refund&quot;);        }    }}</code></pre><p>可以看到，这个通知所达到的效果与之前的前置通知和后置通知是一样的。但是，现在它们位于同一个方法中，不像之前那样分散在四个不同的通知方法里面。</p><h2 id="处理通知中的参数"><a href="#处理通知中的参数" class="headerlink" title="处理通知中的参数"></a>处理通知中的参数</h2><pre><code class="java">// 使用参数化的通知来记录磁道播放的次数@Aspectpublic class TrackCounter {    private Map&lt;Integer, Integer&gt; trackCounts = new HashMap&lt;&gt;();    @Pointcut(            &quot;execution(* soundsystem.CompactDisc.playTrack(int)) &quot; +                    &quot;&amp;&amp; args(trackNumber)&quot;)    public void trackPlayed(int trackNumber) {}    // IDEA 提示：argNames attribute isn&#39;t defined，建议修改如下：    // @Before(value = &quot;trackPlayed(trackNumber)&quot;, argNames = &quot;trackNumber&quot;)    @Before(&quot;trackPlayed(trackNumber)&quot;)    public void countTrack(int trackNumber) {        int currentCount = getPlayCount(trackNumber);        trackCounts.put(trackNumber, currentCount + 1);    }    public int getPlayCount(int trackNumber) {        return trackCounts.containsKey(trackNumber)                ? trackCounts.get(trackNumber) : 0;    }}</code></pre><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20190706225055.png" alt="在切点表达式中声明参数，这个参数传入到通知方法中"></p><p>需要关注的是切点表达式中的 <code>args(trackNumber)</code> 限定符。它表明传递给 <code>playTrack()</code> 方法的 int 类型参数也会传递到通知中去。参数的名称 <code>trackNumber</code> 也与切点方法签名中的参数相匹配。</p><h2 id="通过注解引入新功能"><a href="#通过注解引入新功能" class="headerlink" title="通过注解引入新功能"></a>通过注解引入新功能</h2><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20190706234627.png" alt="使用 Spring AOP，我们可以为 bean 引入新的方法。代理拦截调用并委托给实现该方法的其他对象"></p><p>为示例中的所有的 Performance 实现引入下面的 Encoreable 接口：</p><pre><code class="java">public interface Encoreable {    void performEncore();}</code></pre><p>我们需要有一种方式将这个接口应用到 Performance 实现中。我们现在假设你能够访问 Performance 的所有实现，并对其进行修改，让它们都实现 <code>Encoreable</code> 接口。但是，从设计的角度来看，这并不是最好的做法，并不是所有的 Performance 都是具有 Encoreable 特性的。另外一方面，有可能无法修改所有的 Performance 实现，当使用第三方实现并且没有源码的时候更是如此。</p><p>值得庆幸的是，借助于 AOP 的引入功能，我们可以不必在设计上妥协或者侵入性地改变现有的实现。为了实现该功能，我们要创建一个新的切面：</p><pre><code class="java">@Aspectpublic class EncoreableIntroducer {    @DeclareParents(value=&quot;concert.Performance+&quot;, defaultImpl=DefaultEncoreable.class)    public static Encoreable encoreable;}</code></pre><p><code>EncoreableIntroducer</code> 是一个切面。但是，它与我们之前所创建的切面不同，它并没有提供前置、后置或环绕通知，而是通过 <code>@DeclareParents</code> 注解，将 <code>Encoreable</code> 接口引入到 <code>Performance bean</code> 中。</p><p><code>@DeclareParents</code> 注解由三部分组成：</p><ul><li><code>value</code> 属性指定了哪种类型的 bean 要引入该接口。在本例中，也就是所有实现 Performance 的类型。（标记符后面的<code>加号</code>表示是 <code>Performance</code> 的所有子类型，而不是 Performance 本身。）</li><li><code>defaultImpl</code> 属性指定了为引入功能提供实现的类。在这里，我们指定的是 Default`Encoreable 提供实现。</li><li><code>@DeclareParents</code> 注解所标注的静态属性指明了要引入了接口。在这里，我们所引入的是 Encoreable 接口。</li></ul><p>和其他的切面一样，我们需要在 Spring 应用中将 EncoreableIntroducer 声明为一个 bean：</p><pre><code class="xml">&lt;bean class=&quot;concert.EncoreableIntroducer&quot; /&gt;</code></pre><p>在 Spring 中，注解和自动代理提供了一种很便利的方式来创建切面。它非常简单，并且只涉及到最少的Spring配置。但是，面向注解的切面声明有一个明显的劣势：你必须能够为通知类添加注解。为了做到这一点，<strong>必须要有源码</strong>。</p><p>如果你没有源码的话，或者不想将 <code>AspectJ</code> 注解放到你的代码之中，Spring 为切面提供了另外一种可选方案。让我们看一下如何在 Spring XML 配置文件中声明切面。</p><h1 id="在-XML-中声明切面"><a href="#在-XML-中声明切面" class="headerlink" title="在 XML 中声明切面"></a>在 XML 中声明切面</h1><h2 id="Sprin-的-AOP-配置元素能够以非侵入性的方式声明切面"><a href="#Sprin-的-AOP-配置元素能够以非侵入性的方式声明切面" class="headerlink" title="Sprin 的 AOP 配置元素能够以非侵入性的方式声明切面"></a>Sprin 的 AOP 配置元素能够以非侵入性的方式声明切面</h2><table><thead><tr><th>AOP配置元素</th><th>用　　途</th></tr></thead><tbody><tr><td><code>&lt;aop:advisor&gt;</code></td><td>定义 AOP 通知器</td></tr><tr><td><code>&lt;aop:after&gt;</code></td><td>定义 AOP 后置通知（不管被通知的方法是否执行成功）</td></tr><tr><td><code>&lt;aop:after-returning&gt;</code></td><td>定义 AOP 返回通知</td></tr><tr><td><code>&lt;aop:after-throwing&gt;</code></td><td>定义 AOP 异常通知</td></tr><tr><td><code>&lt;aop:around&gt;</code></td><td>定义 AOP 环绕通知</td></tr><tr><td><code>&lt;aop:aspect&gt;</code></td><td>定义一个切面</td></tr><tr><td><code>&lt;aop:aspectj-autoproxy&gt;</code></td><td>启用 <code>@AspectJ</code> 注解驱动的切面</td></tr><tr><td><code>&lt;aop:before&gt;</code></td><td>定义一个 AOP 前置通知</td></tr><tr><td><code>&lt;aop:config&gt;</code></td><td>顶层的 AOP 配置元素。大多数的 <code>&lt;aop:*&gt;</code> 元素必须包含在 <code>&lt;aop:config&gt;</code> 元素内</td></tr><tr><td><code>&lt;aop:declare-parents&gt;</code></td><td>以透明的方式为被通知的对象引入额外的接口</td></tr><tr><td><code>&lt;aop:pointcut&gt;</code></td><td>定义一个切点</td></tr></tbody></table><p>将 Audience 类所有的 <code>AspectJ</code> 注解全部移除掉：</p><pre><code class="java">public class Audience {    public void silenceCellPhones() {        System.out.println(&quot;Silencing cell phones&quot;);    }    public void takeSeats() {        System.out.println(&quot;Taking seats&quot;);    }    public void applause() {        System.out.println(&quot;CLAP CLAP CLAP!!!&quot;);    }    public void demandRefund() {        System.out.println(&quot;Demanding a refund&quot;);    }}</code></pre><h2 id="声明前置和后置通知"><a href="#声明前置和后置通知" class="headerlink" title="声明前置和后置通知"></a>声明前置和后置通知</h2><pre><code class="xml">&lt;aop:config&gt;  &lt;!-- 大多数的 AOP 配置元素必须在 &lt;aop:config&gt; 元素的上下文内使用。 --&gt;    &lt;aop:aspect ref=&quot;audience&quot;&gt;  &lt;!-- 引用 audience bean --&gt;        &lt;aop:before            pointcut=&quot;execution(** concert.Performance.perform(..))&quot;            method=&quot;silenceCellPhones&quot;/&gt;        &lt;aop:before            pointcut=&quot;execution(** concert.Performance.perform(..))&quot;            method=&quot;takeSeats&quot;/&gt;        &lt;aop:after-returning            pointcut=&quot;execution(** concert.Performance.perform(..))&quot;            method=&quot;applause&quot;/&gt;        &lt;aop:after-throwing            pointcut=&quot;execution(** concert.Performance.perform(..))&quot;            method=&quot;demandRefund&quot;/&gt;    &lt;/aop:aspect&gt;&lt;/aop:config&gt;</code></pre><p>使用 <code>&lt;aop:pointcut&gt;</code> 定义命名切点</p><pre><code class="xml">&lt;aop:config&gt;    &lt;aop:aspect ref=&quot;audience&quot;&gt;        &lt;!-- 将通用的切点表达式抽取到一个切点声明中 --&gt;        &lt;aop:pointcut id=&quot;performance&quot;            expression=&quot;execution(** concert.Performance.perform(..))&quot; /&gt;        &lt;aop:before pointcut-ref=&quot;performance&quot; method=&quot;silenceCellPhones&quot;/&gt;        &lt;aop:before pointcut-ref=&quot;performance&quot; method=&quot;takeSeats&quot;/&gt;        &lt;aop:after-returning pointcut-ref=&quot;performance&quot; method=&quot;applause&quot;/&gt;        &lt;aop:after-throwing pointcut-ref=&quot;performance&quot; method=&quot;demandRefund&quot;/&gt;    &lt;/aop:aspect&gt;&lt;/aop:config&gt;</code></pre><p>如果想让定义的切点能够在多个切面使用，我们可以把 <code>&lt;aop:pointcut&gt;</code> 元素放在 <code>&lt;aop:config&gt;</code> 元素的范围内。</p><h2 id="声明环绕通知"><a href="#声明环绕通知" class="headerlink" title="声明环绕通知"></a>声明环绕通知</h2><p>前置通知和后置通知有一些限制。如果不使用成员变量存储信息的话，在前置通知和后置通知之间共享信息非常麻烦。</p><p>使用环绕通知，我们可以完成前置通知和后置通知所实现的相同功能，而且只需要在一个方法中实现。因为整个通知逻辑是在一个方法内实现的，所以不需要使用成员变量保存状态。</p><pre><code class="java">// 新 Audience 类的 watchPerformance() 方法，没有使用任何的注解。public class Audience {    public void watchPerformance(ProceedingJoinPoint jp) {        try {            System.out.println(&quot;Silencing cell phones&quot;);            System.out.println(&quot;Taking seats&quot;);            jp.proceed();            System.out.println(&quot;CLAP CLAP CLAP!!!&quot;);        } catch (Throwable e) {            System.out.println(&quot;Demanding a refund&quot;);        }    }}</code></pre><p>在 XML 中使用 <code>&lt;aop:around&gt;</code> 元素声明环绕通知</p><pre><code class="xml">&lt;aop:config&gt;    &lt;aop:aspect ref=&quot;audience&quot;&gt;        &lt;aop:pointcut            id=&quot;performance&quot;            expression=&quot;execution(** concert.Performance.perform(..))&quot; /&gt;        &lt;aop:around pointcut-ref=&quot;performance&quot; method=&quot;watchPerformance&quot;/&gt;    &lt;/aop:aspect&gt;&lt;/aop:config&gt;</code></pre><h2 id="为通知传递参数"><a href="#为通知传递参数" class="headerlink" title="为通知传递参数"></a>为通知传递参数</h2><pre><code class="java">// 移除掉 TrackCounter 上所有的 @AspectJ 注解public class TrackCounter {    private Map&lt;Integer, Integer&gt; trackCounts = new HashMap&lt;&gt;();    public void countTrack(int trackNumber) {        int currentCount = getPlayCount(trackNumber);        trackCounts.put(trackNumber, currentCount + 1);    }    public int getPlayCount(int trackNumber) {        return trackCounts.containsKey(trackNumber)                ? trackCounts.get(trackNumber) : 0;    }}</code></pre><pre><code class="xml">&lt;bean id=&quot;trackCounter&quot; class=&quot;soundsystem.TrackCounter&quot; /&gt;&lt;bean id=&quot;cd&quot; class=&quot;soundsystem.BlankDisc&quot;&gt;    &lt;property name=&quot;title&quot; value=&quot;Sgt. Pepper&#39;s Lonely Hearts Club Band&quot; /&gt;    &lt;property name=&quot;artist&quot; value=&quot;The Beatles&quot; /&gt;    &lt;property name=&quot;tracks&quot;&gt;        &lt;list&gt;            &lt;value&gt;Sgt. Pepper&#39;s Lonely Hearts Club Band&lt;/value&gt;            &lt;value&gt;With a Little Help from My Friends&lt;/value&gt;            &lt;value&gt;Lucy in the Sky with Diamonds&lt;/value&gt;            &lt;value&gt;Getting Better&lt;/value&gt;            &lt;value&gt;Fixing a Hole&lt;/value&gt;            &lt;!-- ...other tracks omitted for brevity... --&gt;        &lt;/list&gt;    &lt;/property&gt;&lt;/bean&gt;&lt;aop:config&gt;    &lt;aop:aspect ref=&quot;trackCounter&quot;&gt;        &lt;aop:pointcut id=&quot;trackPlayed&quot; expression=            &quot;execution(* soundsystem.CompactDisc.playTrack(int)) and args(trackNumber)&quot; /&gt;        &lt;aop:before pointcut-ref=&quot;trackPlayed&quot; method=&quot;countTrack&quot;/&gt;    &lt;/aop:aspect&gt;&lt;/aop:config&gt;</code></pre><p>我们使用了和前面相同的 aop 命名空间 XML 元素，它们会将 POJO 声明为切面。唯一明显的差别在于切点表达式中包含了一个参数，这个参数会传递到通知方法中。</p><h2 id="通过切面引入新的功能"><a href="#通过切面引入新的功能" class="headerlink" title="通过切面引入新的功能"></a>通过切面引入新的功能</h2><p>借助 <code>AspectJ</code> 的 <code>@DeclareParents</code> 注解为被通知的方法神奇地引入新的方法。但是 AOP 引入并不是 AspectJ 特有的。使用 Spring aop 命名空间中的 <code>&lt;aop:declare-parents&gt;</code> 元素，我们可以实现相同的功能。</p><pre><code class="xml">&lt;aop:aspect&gt;    &lt;aop:declare-parents        types-matching=&quot;concert.Performance+&quot;        implement-interface=&quot;concert.Encoreable&quot;        default-impl=&quot;concert.DefaultEncoreable&quot;        /&gt;&lt;/aop:aspect&gt;</code></pre><p>这里有两种方式标识所引入接口的实现。在本例中，我们使用 <code>default-impl</code> 属性用全限定类名来显式指定 <code>Encoreable</code> 的实现。或者，我们还可以使用 <code>delegate-ref</code> 属性来标识。</p><pre><code class="xml">&lt;bean id=&quot;encoreableDelegate&quot; class=&quot;concert.DefaultEncoreable&quot; /&gt;&lt;aop:aspect&gt;    &lt;aop:declare-parents        types-matching=&quot;concert.Performance+&quot;        implement-interface=&quot;concert.Encoreable&quot;        delegate-ref=&quot;encoreableDelegate&quot;        /&gt;&lt;/aop:aspect&gt;</code></pre><p>使用 <code>default-impl</code> 来直接标识委托和间接使用 <code>delegate-ref</code> 的区别在于后者是 Spring bean，它本身可以被注入、通知或使用其他的 Spring 配置。</p><h1 id="注入-AspectJ-切面"><a href="#注入-AspectJ-切面" class="headerlink" title="注入 AspectJ 切面"></a>注入 AspectJ 切面</h1><p>虽然 Spring AOP 能够满足许多应用的切面需求，但是与 <code>AspectJ</code> 相比，Spring AOP 是一个功能比较弱的 AOP 解决方案。<code>AspectJ</code> 提供了 Spring AOP 所不能支持的许多类型的切点。例如，构造器切点。</p><p>我们可以借助 Spring 的依赖注入把 bean 装配进 <code>AspectJ</code> 切面中。</p><p>我们为上面的演出创建一个新切面。具体来讲，我们以切面的方式创建一个评论员的角色，他会观看演出并且会在演出之后提供一些批评意见。下面的 <code>CriticAspect</code> 就是一个这样的切面。</p><pre><code class="java">// 使用 AspectJ 实现表演的评论员public aspect CriticAspect {    public CriticAspect() {}    pointcut performance() : execution(* perform(..));    afterReturning() : performance() {        System.out.println(criticismEngine.getCriticism());    }    private CriticismEngine criticismEngine;    public void setCriticismEngine(CriticismEngine criticismEngine) {        this.criticismEngine = criticismEngine;    }}</code></pre><p><code>CriticAspect</code> 的主要职责是在表演结束后为表演发表评论。程序中的 <code>performance()</code> 切点匹配 <code>perform()</code> 方法。当它与 <code>afterReturning()</code> 通知一起配合使用时，我们可以让该切面在表演结束时起作用。</p><p><code>CriticAspect</code> 与一个 <code>CriticismEngine</code> 对象相协作，在表演结束时，调用该对象的 <code>getCriticism()</code> 方法来发表一个苛刻的评论。下图展示了此关系。</p><p><img src="https://blog-1252208501.cos.ap-beijing.myqcloud.com/20190707172016.png" alt="切面也需要注入。像其他的 bean 一样，Spring 可以为 AspectJ 切面注入依赖"></p><pre><code class="java">public interface CriticismEngine {    public String getCriticism();}public class CriticismEngineImpl implements CriticismEngine {    public CriticismEngineImpl() {}    public String getCriticism() {        int i = (int) (Math.random() * criticismPool.length);        return criticismPool[i];    }    // injected    private String[] criticismPool;    public void setCriticismPool(String[] criticismPool) {        this.criticismPool = criticismPool;    }}</code></pre><p>CriticismEngineImpl 可以使用如下的 XML 声明为一个 Spring bean</p><pre><code class="xml">&lt;bean id=&quot;criticismEngine&quot;        class=&quot;com.springinaction.springidol.CriticismEngineImpl&quot;&gt;    &lt;property name=&quot;criticisms&quot;&gt;        &lt;list&gt;            &lt;value&gt;Worst performance ever!&lt;/value&gt;            &lt;value&gt;I laughed, I cried, then I realized I was at the wrong show.&lt;/value&gt;            &lt;value&gt;A must see show!&lt;/value&gt;        &lt;/list&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre><p>把 <code>criticismEngine bean</code> 注入到 <code>CriticAspect</code> 中：</p><pre><code class="xml">&lt;bean class=&quot;com.springinaction.springidol.CriticAspect&quot;        factory-method=&quot;aspectOf&quot;&gt;    &lt;property name=&quot;criticismEngine&quot; ref=&quot;criticismEngine&quot; /&gt;&lt;/bean&gt;</code></pre><p>使用了 <code>factory-method</code> 属性。通常情况下，<code>AspectJ</code> 切面是由 <code>AspectJ</code> 在运行期创建的。</p><p>Spring 不能负责创建 <code>CriticAspect</code>，但所有的 <code>AspectJ</code> 切面都提供了一个静态的 <strong><code>aspectOf()</code></strong> 方法，该方法返回切面的一个单例。所以为了获得切面的实例，我们必须使用 <code>factory-method</code> 来调用 <code>asepctOf()</code> 方法而不是调用 CriticAspect 的构造器方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在软件开发中，散布于应用中多处的功能被称为&lt;strong&gt;横切关注点&lt;/strong&gt;（cross-cutting concern）。通常来讲，这些横切关注点从概念上是与应用的业务逻辑相分离的（但是往往会直接嵌入到应用的业务逻辑之中）。&lt;strong&gt;把这些横切关注点与业务逻辑相分离正是面向切面编程（AOP）所要解决的问题&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在第2章，我们介绍了如何使用&lt;strong&gt;依赖注入&lt;/strong&gt;（DI）管理和配置我们的应用对象。DI 有助于应用对象之间的解耦，而 AOP 可以实现横切关注点与它们所影响的对象之间的解耦。&lt;/p&gt;
&lt;p&gt;日志是应用切面的常见范例，但它并不是切面适用的唯一场景。通览本书，我们还会看到切面所适用的多个场景，包括声明式事务、安全和缓存。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://coolview.github.io/categories/Java/"/>
    
    
      <category term="Spring" scheme="http://coolview.github.io/tags/Spring/"/>
    
  </entry>
  
</feed>
